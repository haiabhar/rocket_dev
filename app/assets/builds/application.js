(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/@rails/actioncable/src/adapters.js
  var adapters_default;
  var init_adapters = __esm({
    "node_modules/@rails/actioncable/src/adapters.js"() {
      adapters_default = {
        logger: self.console,
        WebSocket: self.WebSocket
      };
    }
  });

  // node_modules/@rails/actioncable/src/logger.js
  var logger_default;
  var init_logger = __esm({
    "node_modules/@rails/actioncable/src/logger.js"() {
      init_adapters();
      logger_default = {
        log(...messages) {
          if (this.enabled) {
            messages.push(Date.now());
            adapters_default.logger.log("[ActionCable]", ...messages);
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection_monitor.js
  var now, secondsSince, ConnectionMonitor, connection_monitor_default;
  var init_connection_monitor = __esm({
    "node_modules/@rails/actioncable/src/connection_monitor.js"() {
      init_logger();
      now = () => (/* @__PURE__ */ new Date()).getTime();
      secondsSince = (time) => (now() - time) / 1e3;
      ConnectionMonitor = class {
        constructor(connection) {
          this.visibilityDidChange = this.visibilityDidChange.bind(this);
          this.connection = connection;
          this.reconnectAttempts = 0;
        }
        start() {
          if (!this.isRunning()) {
            this.startedAt = now();
            delete this.stoppedAt;
            this.startPolling();
            addEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
          }
        }
        stop() {
          if (this.isRunning()) {
            this.stoppedAt = now();
            this.stopPolling();
            removeEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log("ConnectionMonitor stopped");
          }
        }
        isRunning() {
          return this.startedAt && !this.stoppedAt;
        }
        recordPing() {
          this.pingedAt = now();
        }
        recordConnect() {
          this.reconnectAttempts = 0;
          this.recordPing();
          delete this.disconnectedAt;
          logger_default.log("ConnectionMonitor recorded connect");
        }
        recordDisconnect() {
          this.disconnectedAt = now();
          logger_default.log("ConnectionMonitor recorded disconnect");
        }
        // Private
        startPolling() {
          this.stopPolling();
          this.poll();
        }
        stopPolling() {
          clearTimeout(this.pollTimeout);
        }
        poll() {
          this.pollTimeout = setTimeout(
            () => {
              this.reconnectIfStale();
              this.poll();
            },
            this.getPollInterval()
          );
        }
        getPollInterval() {
          const { staleThreshold, reconnectionBackoffRate } = this.constructor;
          const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
          const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
          const jitter = jitterMax * Math.random();
          return staleThreshold * 1e3 * backoff * (1 + jitter);
        }
        reconnectIfStale() {
          if (this.connectionIsStale()) {
            logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
            this.reconnectAttempts++;
            if (this.disconnectedRecently()) {
              logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
            } else {
              logger_default.log("ConnectionMonitor reopening");
              this.connection.reopen();
            }
          }
        }
        get refreshedAt() {
          return this.pingedAt ? this.pingedAt : this.startedAt;
        }
        connectionIsStale() {
          return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
        }
        disconnectedRecently() {
          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
        }
        visibilityDidChange() {
          if (document.visibilityState === "visible") {
            setTimeout(
              () => {
                if (this.connectionIsStale() || !this.connection.isOpen()) {
                  logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                  this.connection.reopen();
                }
              },
              200
            );
          }
        }
      };
      ConnectionMonitor.staleThreshold = 6;
      ConnectionMonitor.reconnectionBackoffRate = 0.15;
      connection_monitor_default = ConnectionMonitor;
    }
  });

  // node_modules/@rails/actioncable/src/internal.js
  var internal_default;
  var init_internal = __esm({
    "node_modules/@rails/actioncable/src/internal.js"() {
      internal_default = {
        "message_types": {
          "welcome": "welcome",
          "disconnect": "disconnect",
          "ping": "ping",
          "confirmation": "confirm_subscription",
          "rejection": "reject_subscription"
        },
        "disconnect_reasons": {
          "unauthorized": "unauthorized",
          "invalid_request": "invalid_request",
          "server_restart": "server_restart"
        },
        "default_mount_path": "/cable",
        "protocols": [
          "actioncable-v1-json",
          "actioncable-unsupported"
        ]
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection.js
  var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
  var init_connection = __esm({
    "node_modules/@rails/actioncable/src/connection.js"() {
      init_adapters();
      init_connection_monitor();
      init_internal();
      init_logger();
      ({ message_types, protocols } = internal_default);
      supportedProtocols = protocols.slice(0, protocols.length - 1);
      indexOf = [].indexOf;
      Connection = class {
        constructor(consumer2) {
          this.open = this.open.bind(this);
          this.consumer = consumer2;
          this.subscriptions = this.consumer.subscriptions;
          this.monitor = new connection_monitor_default(this);
          this.disconnected = true;
        }
        send(data) {
          if (this.isOpen()) {
            this.webSocket.send(JSON.stringify(data));
            return true;
          } else {
            return false;
          }
        }
        open() {
          if (this.isActive()) {
            logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
            return false;
          } else {
            logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`);
            if (this.webSocket) {
              this.uninstallEventHandlers();
            }
            this.webSocket = new adapters_default.WebSocket(this.consumer.url, protocols);
            this.installEventHandlers();
            this.monitor.start();
            return true;
          }
        }
        close({ allowReconnect } = { allowReconnect: true }) {
          if (!allowReconnect) {
            this.monitor.stop();
          }
          if (this.isOpen()) {
            return this.webSocket.close();
          }
        }
        reopen() {
          logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
          if (this.isActive()) {
            try {
              return this.close();
            } catch (error2) {
              logger_default.log("Failed to reopen WebSocket", error2);
            } finally {
              logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
              setTimeout(this.open, this.constructor.reopenDelay);
            }
          } else {
            return this.open();
          }
        }
        getProtocol() {
          if (this.webSocket) {
            return this.webSocket.protocol;
          }
        }
        isOpen() {
          return this.isState("open");
        }
        isActive() {
          return this.isState("open", "connecting");
        }
        // Private
        isProtocolSupported() {
          return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
        }
        isState(...states) {
          return indexOf.call(states, this.getState()) >= 0;
        }
        getState() {
          if (this.webSocket) {
            for (let state in adapters_default.WebSocket) {
              if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
                return state.toLowerCase();
              }
            }
          }
          return null;
        }
        installEventHandlers() {
          for (let eventName in this.events) {
            const handler = this.events[eventName].bind(this);
            this.webSocket[`on${eventName}`] = handler;
          }
        }
        uninstallEventHandlers() {
          for (let eventName in this.events) {
            this.webSocket[`on${eventName}`] = function() {
            };
          }
        }
      };
      Connection.reopenDelay = 500;
      Connection.prototype.events = {
        message(event) {
          if (!this.isProtocolSupported()) {
            return;
          }
          const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
          switch (type) {
            case message_types.welcome:
              this.monitor.recordConnect();
              return this.subscriptions.reload();
            case message_types.disconnect:
              logger_default.log(`Disconnecting. Reason: ${reason}`);
              return this.close({ allowReconnect: reconnect });
            case message_types.ping:
              return this.monitor.recordPing();
            case message_types.confirmation:
              this.subscriptions.confirmSubscription(identifier);
              return this.subscriptions.notify(identifier, "connected");
            case message_types.rejection:
              return this.subscriptions.reject(identifier);
            default:
              return this.subscriptions.notify(identifier, "received", message);
          }
        },
        open() {
          logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
          this.disconnected = false;
          if (!this.isProtocolSupported()) {
            logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
            return this.close({ allowReconnect: false });
          }
        },
        close(event) {
          logger_default.log("WebSocket onclose event");
          if (this.disconnected) {
            return;
          }
          this.disconnected = true;
          this.monitor.recordDisconnect();
          return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
        },
        error() {
          logger_default.log("WebSocket onerror event");
        }
      };
      connection_default = Connection;
    }
  });

  // node_modules/@rails/actioncable/src/subscription.js
  var extend, Subscription;
  var init_subscription = __esm({
    "node_modules/@rails/actioncable/src/subscription.js"() {
      extend = function(object, properties) {
        if (properties != null) {
          for (let key in properties) {
            const value = properties[key];
            object[key] = value;
          }
        }
        return object;
      };
      Subscription = class {
        constructor(consumer2, params = {}, mixin) {
          this.consumer = consumer2;
          this.identifier = JSON.stringify(params);
          extend(this, mixin);
        }
        // Perform a channel action with the optional data passed as an attribute
        perform(action, data = {}) {
          data.action = action;
          return this.send(data);
        }
        send(data) {
          return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
        }
        unsubscribe() {
          return this.consumer.subscriptions.remove(this);
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/subscription_guarantor.js
  var SubscriptionGuarantor, subscription_guarantor_default;
  var init_subscription_guarantor = __esm({
    "node_modules/@rails/actioncable/src/subscription_guarantor.js"() {
      init_logger();
      SubscriptionGuarantor = class {
        constructor(subscriptions) {
          this.subscriptions = subscriptions;
          this.pendingSubscriptions = [];
        }
        guarantee(subscription) {
          if (this.pendingSubscriptions.indexOf(subscription) == -1) {
            logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
            this.pendingSubscriptions.push(subscription);
          } else {
            logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
          }
          this.startGuaranteeing();
        }
        forget(subscription) {
          logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
          this.pendingSubscriptions = this.pendingSubscriptions.filter((s) => s !== subscription);
        }
        startGuaranteeing() {
          this.stopGuaranteeing();
          this.retrySubscribing();
        }
        stopGuaranteeing() {
          clearTimeout(this.retryTimeout);
        }
        retrySubscribing() {
          this.retryTimeout = setTimeout(
            () => {
              if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
                this.pendingSubscriptions.map((subscription) => {
                  logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
                  this.subscriptions.subscribe(subscription);
                });
              }
            },
            500
          );
        }
      };
      subscription_guarantor_default = SubscriptionGuarantor;
    }
  });

  // node_modules/@rails/actioncable/src/subscriptions.js
  var Subscriptions;
  var init_subscriptions = __esm({
    "node_modules/@rails/actioncable/src/subscriptions.js"() {
      init_subscription();
      init_subscription_guarantor();
      init_logger();
      Subscriptions = class {
        constructor(consumer2) {
          this.consumer = consumer2;
          this.guarantor = new subscription_guarantor_default(this);
          this.subscriptions = [];
        }
        create(channelName, mixin) {
          const channel = channelName;
          const params = typeof channel === "object" ? channel : { channel };
          const subscription = new Subscription(this.consumer, params, mixin);
          return this.add(subscription);
        }
        // Private
        add(subscription) {
          this.subscriptions.push(subscription);
          this.consumer.ensureActiveConnection();
          this.notify(subscription, "initialized");
          this.subscribe(subscription);
          return subscription;
        }
        remove(subscription) {
          this.forget(subscription);
          if (!this.findAll(subscription.identifier).length) {
            this.sendCommand(subscription, "unsubscribe");
          }
          return subscription;
        }
        reject(identifier) {
          return this.findAll(identifier).map((subscription) => {
            this.forget(subscription);
            this.notify(subscription, "rejected");
            return subscription;
          });
        }
        forget(subscription) {
          this.guarantor.forget(subscription);
          this.subscriptions = this.subscriptions.filter((s) => s !== subscription);
          return subscription;
        }
        findAll(identifier) {
          return this.subscriptions.filter((s) => s.identifier === identifier);
        }
        reload() {
          return this.subscriptions.map((subscription) => this.subscribe(subscription));
        }
        notifyAll(callbackName, ...args) {
          return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
        }
        notify(subscription, callbackName, ...args) {
          let subscriptions;
          if (typeof subscription === "string") {
            subscriptions = this.findAll(subscription);
          } else {
            subscriptions = [subscription];
          }
          return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
        }
        subscribe(subscription) {
          if (this.sendCommand(subscription, "subscribe")) {
            this.guarantor.guarantee(subscription);
          }
        }
        confirmSubscription(identifier) {
          logger_default.log(`Subscription confirmed ${identifier}`);
          this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
        }
        sendCommand(subscription, command) {
          const { identifier } = subscription;
          return this.consumer.send({ command, identifier });
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/consumer.js
  function createWebSocketURL(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a = document.createElement("a");
      a.href = url;
      a.href = a.href;
      a.protocol = a.protocol.replace("http", "ws");
      return a.href;
    } else {
      return url;
    }
  }
  var Consumer;
  var init_consumer = __esm({
    "node_modules/@rails/actioncable/src/consumer.js"() {
      init_connection();
      init_subscriptions();
      Consumer = class {
        constructor(url) {
          this._url = url;
          this.subscriptions = new Subscriptions(this);
          this.connection = new connection_default(this);
        }
        get url() {
          return createWebSocketURL(this._url);
        }
        send(data) {
          return this.connection.send(data);
        }
        connect() {
          return this.connection.open();
        }
        disconnect() {
          return this.connection.close({ allowReconnect: false });
        }
        ensureActiveConnection() {
          if (!this.connection.isActive()) {
            return this.connection.open();
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Connection: () => connection_default,
    ConnectionMonitor: () => connection_monitor_default,
    Consumer: () => Consumer,
    INTERNAL: () => internal_default,
    Subscription: () => Subscription,
    SubscriptionGuarantor: () => subscription_guarantor_default,
    Subscriptions: () => Subscriptions,
    adapters: () => adapters_default,
    createConsumer: () => createConsumer,
    createWebSocketURL: () => createWebSocketURL,
    getConfig: () => getConfig,
    logger: () => logger_default
  });
  function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
    return new Consumer(url);
  }
  function getConfig(name) {
    const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  var init_src = __esm({
    "node_modules/@rails/actioncable/src/index.js"() {
      init_connection();
      init_connection_monitor();
      init_consumer();
      init_internal();
      init_subscription();
      init_subscriptions();
      init_subscription_guarantor();
      init_adapters();
      init_logger();
    }
  });

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var ReactVersion = "18.2.0";
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactCurrentBatchConfig = {
            transition: null
          };
          var ReactCurrentActQueue = {
            current: null,
            // Used to reproduce behavior of `batchedUpdates` in legacy mode.
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false
          };
          var ReactCurrentOwner = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactDebugCurrentFrame = {};
          var currentExtraStackFrame = null;
          function setExtraStackFrame(stack) {
            {
              currentExtraStackFrame = stack;
            }
          }
          {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
              {
                currentExtraStackFrame = stack;
              }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack = "";
              if (currentExtraStackFrame) {
                stack += currentExtraStackFrame;
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack += impl() || "";
              }
              return stack;
            };
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner
          };
          {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
          }
          function warn(format4) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format4, args);
              }
            }
          }
          function error2(format4) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format4, args);
              }
            }
          }
          function printWarning(level, format4, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format4 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format4);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error2("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            /**
             * Checks whether or not this composite component is mounted.
             * @param {ReactClass} publicInstance The instance we want to test.
             * @return {boolean} True if mounted, false otherwise.
             * @protected
             * @final
             */
            isMounted: function(publicInstance) {
              return false;
            },
            /**
             * Forces an update. This should only be invoked when it is known with
             * certainty that we are **not** in a DOM transaction.
             *
             * You may want to call this when you know that some deeper aspect of the
             * component's state has changed but `setState` was not called.
             *
             * This will not invoke `shouldComponentUpdate`, but it will invoke
             * `componentWillUpdate` and `componentDidUpdate`.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            /**
             * Replaces all of the state. Always use this or `setState` to mutate state.
             * You should treat `this.state` as immutable.
             *
             * There is no guarantee that `this.state` will be immediately updated, so
             * accessing `this.state` after calling this method may return the old value.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} completeState Next state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            /**
             * Sets a subset of the state. This only exists because _pendingState is
             * internal. This provides a merging strategy that is not available to deep
             * properties which is confusing. TODO: Expose pendingState or don't use it
             * during the merge.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} partialState Next partial state to be merged with state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} Name of the calling function in the public API.
             * @internal
             */
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var assign = Object.assign;
          var emptyObject = {};
          {
            Object.freeze(emptyObject);
          }
          function Component9(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component9.prototype.isReactComponent = {};
          Component9.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
              throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component9.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component9.prototype, methodName, {
                get: function() {
                  warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component9.prototype;
          function PureComponent20(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent20.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent20;
          assign(pureComponentPrototype, Component9.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          var isArrayImpl = Array.isArray;
          function isArray(a) {
            return isArrayImpl(a);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config2) {
            {
              if (hasOwnProperty.call(config2, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.ref !== void 0;
          }
          function hasValidKey(config2) {
            {
              if (hasOwnProperty.call(config2, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config2) {
            {
              if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              // This tag allows us to uniquely identify this as a React Element
              $$typeof: REACT_ELEMENT_TYPE,
              // Built-in properties that belong on the element
              type,
              key,
              ref,
              props,
              // Record the component responsible for creating this element.
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement(type, config2, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self2 = null;
            var source = null;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref = config2.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config2);
                }
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key = "" + config2.key;
              }
              self2 = config2.__self === void 0 ? null : config2.__self;
              source = config2.__source === void 0 ? null : config2.__source;
              for (propName in config2) {
                if (hasOwnProperty.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config2[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type && type.defaultProps) {
              var defaultProps4 = type.defaultProps;
              for (propName in defaultProps4) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps4[propName];
                }
              }
            }
            {
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement5(element, config2, children) {
            if (element === null || element === void 0) {
              throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self2 = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref = config2.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key = "" + config2.key;
              }
              var defaultProps4;
              if (element.type && element.type.defaultProps) {
                defaultProps4 = element.type.defaultProps;
              }
              for (propName in config2) {
                if (hasOwnProperty.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  if (config2[propName] === void 0 && defaultProps4 !== void 0) {
                    props[propName] = defaultProps4[propName];
                  } else {
                    props[propName] = config2[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self2, source, owner, props);
          }
          function isValidElement4(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = key.replace(escapeRegex, function(match2) {
              return escaperLookup[match2];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, "$&/");
          }
          function getElementKey(element, index) {
            if (typeof element === "object" && element !== null && element.key != null) {
              {
                checkKeyStringCoercion(element.key);
              }
              return escape("" + element.key);
            }
            return index.toString(36);
          }
          function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === "undefined" || type === "boolean") {
              children = null;
            }
            var invokeCallback = false;
            if (children === null) {
              invokeCallback = true;
            } else {
              switch (type) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              var _child = children;
              var mappedChild = callback(_child);
              var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
              if (isArray(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) {
                  escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                }
                mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                  return c;
                });
              } else if (mappedChild != null) {
                if (isValidElement4(mappedChild)) {
                  {
                    if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                      checkKeyStringCoercion(mappedChild.key);
                    }
                  }
                  mappedChild = cloneAndReplaceKey(
                    mappedChild,
                    // Keep both the (mapped) and old keys if they differ, just as
                    // traverseAllChildren used to do for objects as children
                    escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                    (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                      // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                      // eslint-disable-next-line react-internal/safe-string-coercion
                      escapeUserProvidedKey("" + mappedChild.key) + "/"
                    ) : "") + childKey
                  );
                }
                array.push(mappedChild);
              }
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray(children)) {
              for (var i = 0; i < children.length; i++) {
                child = children[i];
                nextName = nextNamePrefix + getElementKey(child, i);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                {
                  if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) {
                      warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while (!(step = iterator.next()).done) {
                  child = step.value;
                  nextName = nextNamePrefix + getElementKey(child, ii++);
                  subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
              } else if (type === "object") {
                var childrenString = String(children);
                throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
              }
            }
            return subtreeCount;
          }
          function mapChildren(children, func, context) {
            if (children == null) {
              return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context, child, count++);
            });
            return result;
          }
          function countChildren(children) {
            var n = 0;
            mapChildren(children, function() {
              n++;
            });
            return n;
          }
          function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
              forEachFunc.apply(this, arguments);
            }, forEachContext);
          }
          function toArray(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          }
          function onlyChild(children) {
            if (!isValidElement4(children)) {
              throw new Error("React.Children.only expected to receive a single React element child.");
            }
            return children;
          }
          function createContext2(defaultValue6) {
            var context = {
              $$typeof: REACT_CONTEXT_TYPE,
              // As a workaround to support multiple concurrent renderers, we categorize
              // some renderers as primary and others as secondary. We only expect
              // there to be two concurrent renderers at most: React Native (primary) and
              // Fabric (secondary); React DOM (primary) and React ART (secondary).
              // Secondary renderers store their context values on separate fields.
              _currentValue: defaultValue6,
              _currentValue2: defaultValue6,
              // Used to track how many concurrent renderers this context currently
              // supports within in a single renderer. Such as parallel server rendering.
              _threadCount: 0,
              // These are circular
              Provider: null,
              Consumer: null,
              // Add these to use same hidden class in VM as ServerContext
              _defaultValue: null,
              _globalName: null
            };
            context.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
              var Consumer2 = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context
              };
              Object.defineProperties(Consumer2, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error2("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context.Provider;
                  },
                  set: function(_Provider) {
                    context.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context._currentValue;
                  },
                  set: function(_currentValue) {
                    context._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context._threadCount;
                  },
                  set: function(_threadCount) {
                    context._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error2("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context.Consumer;
                  }
                },
                displayName: {
                  get: function() {
                    return context.displayName;
                  },
                  set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                      warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                      hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                  }
                }
              });
              context.Consumer = Consumer2;
            }
            {
              context._currentRenderer = null;
              context._currentRenderer2 = null;
            }
            return context;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
              var ctor = payload._result;
              var thenable = ctor();
              thenable.then(function(moduleObject2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var resolved = payload;
                  resolved._status = Resolved;
                  resolved._result = moduleObject2;
                }
              }, function(error3) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var rejected = payload;
                  rejected._status = Rejected;
                  rejected._result = error3;
                }
              });
              if (payload._status === Uninitialized) {
                var pending = payload;
                pending._status = Pending;
                pending._result = thenable;
              }
            }
            if (payload._status === Resolved) {
              var moduleObject = payload._result;
              {
                if (moduleObject === void 0) {
                  error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
                }
              }
              {
                if (!("default" in moduleObject)) {
                  error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                }
              }
              return moduleObject.default;
            } else {
              throw payload._result;
            }
          }
          function lazy(ctor) {
            var payload = {
              // We use these fields to store the result.
              _status: Uninitialized,
              _result: ctor
            };
            var lazyType = {
              $$typeof: REACT_LAZY_TYPE,
              _payload: payload,
              _init: lazyInitializer
            };
            {
              var defaultProps4;
              var propTypes;
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps4;
                  },
                  set: function(newDefaultProps) {
                    error2("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps4 = newDefaultProps;
                    Object.defineProperty(lazyType, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes;
                  },
                  set: function(newPropTypes) {
                    error2("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes;
                    Object.defineProperty(lazyType, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType;
          }
          function forwardRef51(render) {
            {
              if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                error2("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render !== "function") {
                error2("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
              } else {
                if (render.length !== 0 && render.length !== 2) {
                  error2("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render != null) {
                if (render.defaultProps != null || render.propTypes != null) {
                  error2("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            var elementType2 = {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render
            };
            {
              var ownName;
              Object.defineProperty(elementType2, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!render.name && !render.displayName) {
                    render.displayName = name;
                  }
                }
              });
            }
            return elementType2;
          }
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType2(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
              // types supported by any Flight configuration anywhere since
              // we don't know which Flight build this will end up being used
              // with.
              type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function memo3(type, compare) {
            {
              if (!isValidElementType2(type)) {
                error2("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
              }
            }
            var elementType2 = {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare === void 0 ? null : compare
            };
            {
              var ownName;
              Object.defineProperty(elementType2, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!type.name && !type.displayName) {
                    type.displayName = name;
                  }
                }
              });
            }
            return elementType2;
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
              if (dispatcher === null) {
                error2("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext63(Context2) {
            var dispatcher = resolveDispatcher();
            {
              if (Context2._context !== void 0) {
                var realContext = Context2._context;
                if (realContext.Consumer === Context2) {
                  error2("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context2) {
                  error2("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context2);
          }
          function useState51(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
          }
          function useReducer3(reducer, initialArg, init) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init);
          }
          function useRef25(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect49(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create, deps);
          }
          function useInsertionEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create, deps);
          }
          function useLayoutEffect3(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create, deps);
          }
          function useCallback20(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
          }
          function useMemo25(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create, deps);
          }
          function useImperativeHandle2(ref, create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create, deps);
          }
          function useDebugValue2(value, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value, formatterFn);
            }
          }
          function useTransition() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
          }
          function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
          }
          function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
          }
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match2 = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match2 && match2[1] || "";
                }
              }
              return "\n" + prefix + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn2);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn2();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn2.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn2.displayName);
                          }
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher$1.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component10) {
            var prototype = Component10.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location2, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error2("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                setExtraStackFrame(stack);
              } else {
                setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
              setCurrentlyValidatingElement$1(element);
              error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement4(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement4(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement4(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
              // Inner props are checked in the reconciler.
              type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys5 = Object.keys(fragment.props);
              for (var i = 0; i < keys5.length; i++) {
                var key = keys5[i];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error2("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function createElementWithValidation(type, props, children) {
            var validType = isValidElementType2(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              {
                error2("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i = 2; i < arguments.length; i++) {
                validateChildKeys(arguments[i], type);
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type
                  });
                  return type;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement5.apply(this, arguments);
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          function startTransition(scope, options2) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
              ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              scope();
            } finally {
              ReactCurrentBatchConfig.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          var didWarnAboutMessageChannel = false;
          var enqueueTaskImpl = null;
          function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
              try {
                var requireString = ("require" + Math.random()).slice(0, 7);
                var nodeRequire = module && module[requireString];
                enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
              } catch (_err) {
                enqueueTaskImpl = function(callback) {
                  {
                    if (didWarnAboutMessageChannel === false) {
                      didWarnAboutMessageChannel = true;
                      if (typeof MessageChannel === "undefined") {
                        error2("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                      }
                    }
                  }
                  var channel = new MessageChannel();
                  channel.port1.onmessage = callback;
                  channel.port2.postMessage(void 0);
                };
              }
            }
            return enqueueTaskImpl(task);
          }
          var actScopeDepth = 0;
          var didWarnNoAwaitAct = false;
          function act(callback) {
            {
              var prevActScopeDepth = actScopeDepth;
              actScopeDepth++;
              if (ReactCurrentActQueue.current === null) {
                ReactCurrentActQueue.current = [];
              }
              var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
              var result;
              try {
                ReactCurrentActQueue.isBatchingLegacy = true;
                result = callback();
                if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                  var queue = ReactCurrentActQueue.current;
                  if (queue !== null) {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    flushActQueue(queue);
                  }
                }
              } catch (error3) {
                popActScope(prevActScopeDepth);
                throw error3;
              } finally {
                ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
              }
              if (result !== null && typeof result === "object" && typeof result.then === "function") {
                var thenableResult = result;
                var wasAwaited = false;
                var thenable = {
                  then: function(resolve, reject) {
                    wasAwaited = true;
                    thenableResult.then(function(returnValue2) {
                      popActScope(prevActScopeDepth);
                      if (actScopeDepth === 0) {
                        recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                      } else {
                        resolve(returnValue2);
                      }
                    }, function(error3) {
                      popActScope(prevActScopeDepth);
                      reject(error3);
                    });
                  }
                };
                {
                  if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                    Promise.resolve().then(function() {
                    }).then(function() {
                      if (!wasAwaited) {
                        didWarnNoAwaitAct = true;
                        error2("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                      }
                    });
                  }
                }
                return thenable;
              } else {
                var returnValue = result;
                popActScope(prevActScopeDepth);
                if (actScopeDepth === 0) {
                  var _queue = ReactCurrentActQueue.current;
                  if (_queue !== null) {
                    flushActQueue(_queue);
                    ReactCurrentActQueue.current = null;
                  }
                  var _thenable = {
                    then: function(resolve, reject) {
                      if (ReactCurrentActQueue.current === null) {
                        ReactCurrentActQueue.current = [];
                        recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                      } else {
                        resolve(returnValue);
                      }
                    }
                  };
                  return _thenable;
                } else {
                  var _thenable2 = {
                    then: function(resolve, reject) {
                      resolve(returnValue);
                    }
                  };
                  return _thenable2;
                }
              }
            }
          }
          function popActScope(prevActScopeDepth) {
            {
              if (prevActScopeDepth !== actScopeDepth - 1) {
                error2("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
              }
              actScopeDepth = prevActScopeDepth;
            }
          }
          function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            {
              var queue = ReactCurrentActQueue.current;
              if (queue !== null) {
                try {
                  flushActQueue(queue);
                  enqueueTask(function() {
                    if (queue.length === 0) {
                      ReactCurrentActQueue.current = null;
                      resolve(returnValue);
                    } else {
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    }
                  });
                } catch (error3) {
                  reject(error3);
                }
              } else {
                resolve(returnValue);
              }
            }
          }
          var isFlushing = false;
          function flushActQueue(queue) {
            {
              if (!isFlushing) {
                isFlushing = true;
                var i = 0;
                try {
                  for (; i < queue.length; i++) {
                    var callback = queue[i];
                    do {
                      callback = callback(true);
                    } while (callback !== null);
                  }
                  queue.length = 0;
                } catch (error3) {
                  queue = queue.slice(i + 1);
                  throw error3;
                } finally {
                  isFlushing = false;
                }
              }
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children8 = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray,
            only: onlyChild
          };
          exports.Children = Children8;
          exports.Component = Component9;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.Profiler = REACT_PROFILER_TYPE;
          exports.PureComponent = PureComponent20;
          exports.StrictMode = REACT_STRICT_MODE_TYPE;
          exports.Suspense = REACT_SUSPENSE_TYPE;
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports.cloneElement = cloneElement$1;
          exports.createContext = createContext2;
          exports.createElement = createElement$1;
          exports.createFactory = createFactory;
          exports.createRef = createRef;
          exports.forwardRef = forwardRef51;
          exports.isValidElement = isValidElement4;
          exports.lazy = lazy;
          exports.memo = memo3;
          exports.startTransition = startTransition;
          exports.unstable_act = act;
          exports.useCallback = useCallback20;
          exports.useContext = useContext63;
          exports.useDebugValue = useDebugValue2;
          exports.useDeferredValue = useDeferredValue;
          exports.useEffect = useEffect49;
          exports.useId = useId;
          exports.useImperativeHandle = useImperativeHandle2;
          exports.useInsertionEffect = useInsertionEffect;
          exports.useLayoutEffect = useLayoutEffect3;
          exports.useMemo = useMemo25;
          exports.useReducer = useReducer3;
          exports.useRef = useRef25;
          exports.useState = useState51;
          exports.useSyncExternalStore = useSyncExternalStore;
          exports.useTransition = useTransition;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var enableSchedulerDebugging = false;
          var enableProfiling = false;
          var frameYieldMs = 5;
          function push(heap, node) {
            var index = heap.length;
            heap.push(node);
            siftUp(heap, node, index);
          }
          function peek(heap) {
            return heap.length === 0 ? null : heap[0];
          }
          function pop(heap) {
            if (heap.length === 0) {
              return null;
            }
            var first = heap[0];
            var last5 = heap.pop();
            if (last5 !== first) {
              heap[0] = last5;
              siftDown(heap, last5, 0);
            }
            return first;
          }
          function siftUp(heap, node, i) {
            var index = i;
            while (index > 0) {
              var parentIndex = index - 1 >>> 1;
              var parent = heap[parentIndex];
              if (compare(parent, node) > 0) {
                heap[parentIndex] = node;
                heap[index] = parent;
                index = parentIndex;
              } else {
                return;
              }
            }
          }
          function siftDown(heap, node, i) {
            var index = i;
            var length = heap.length;
            var halfLength = length >>> 1;
            while (index < halfLength) {
              var leftIndex = (index + 1) * 2 - 1;
              var left2 = heap[leftIndex];
              var rightIndex = leftIndex + 1;
              var right2 = heap[rightIndex];
              if (compare(left2, node) < 0) {
                if (rightIndex < length && compare(right2, left2) < 0) {
                  heap[index] = right2;
                  heap[rightIndex] = node;
                  index = rightIndex;
                } else {
                  heap[index] = left2;
                  heap[leftIndex] = node;
                  index = leftIndex;
                }
              } else if (rightIndex < length && compare(right2, node) < 0) {
                heap[index] = right2;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                return;
              }
            }
          }
          function compare(a, b) {
            var diff = a.sortIndex - b.sortIndex;
            return diff !== 0 ? diff : a.id - b.id;
          }
          var ImmediatePriority = 1;
          var UserBlockingPriority = 2;
          var NormalPriority = 3;
          var LowPriority = 4;
          var IdlePriority = 5;
          function markTaskErrored(task, ms) {
          }
          var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
          if (hasPerformanceNow) {
            var localPerformance = performance;
            exports.unstable_now = function() {
              return localPerformance.now();
            };
          } else {
            var localDate = Date;
            var initialTime = localDate.now();
            exports.unstable_now = function() {
              return localDate.now() - initialTime;
            };
          }
          var maxSigned31BitInt = 1073741823;
          var IMMEDIATE_PRIORITY_TIMEOUT = -1;
          var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
          var NORMAL_PRIORITY_TIMEOUT = 5e3;
          var LOW_PRIORITY_TIMEOUT = 1e4;
          var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
          var taskQueue = [];
          var timerQueue = [];
          var taskIdCounter = 1;
          var currentTask = null;
          var currentPriorityLevel = NormalPriority;
          var isPerformingWork = false;
          var isHostCallbackScheduled = false;
          var isHostTimeoutScheduled = false;
          var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
          var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
          var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
          var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
          function advanceTimers(currentTime) {
            var timer = peek(timerQueue);
            while (timer !== null) {
              if (timer.callback === null) {
                pop(timerQueue);
              } else if (timer.startTime <= currentTime) {
                pop(timerQueue);
                timer.sortIndex = timer.expirationTime;
                push(taskQueue, timer);
              } else {
                return;
              }
              timer = peek(timerQueue);
            }
          }
          function handleTimeout(currentTime) {
            isHostTimeoutScheduled = false;
            advanceTimers(currentTime);
            if (!isHostCallbackScheduled) {
              if (peek(taskQueue) !== null) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              } else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) {
                  requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
              }
            }
          }
          function flushWork(hasTimeRemaining, initialTime2) {
            isHostCallbackScheduled = false;
            if (isHostTimeoutScheduled) {
              isHostTimeoutScheduled = false;
              cancelHostTimeout();
            }
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              if (enableProfiling) {
                try {
                  return workLoop(hasTimeRemaining, initialTime2);
                } catch (error2) {
                  if (currentTask !== null) {
                    var currentTime = exports.unstable_now();
                    markTaskErrored(currentTask, currentTime);
                    currentTask.isQueued = false;
                  }
                  throw error2;
                }
              } else {
                return workLoop(hasTimeRemaining, initialTime2);
              }
            } finally {
              currentTask = null;
              currentPriorityLevel = previousPriorityLevel;
              isPerformingWork = false;
            }
          }
          function workLoop(hasTimeRemaining, initialTime2) {
            var currentTime = initialTime2;
            advanceTimers(currentTime);
            currentTask = peek(taskQueue);
            while (currentTask !== null && !enableSchedulerDebugging) {
              if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
                break;
              }
              var callback = currentTask.callback;
              if (typeof callback === "function") {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                var continuationCallback = callback(didUserCallbackTimeout);
                currentTime = exports.unstable_now();
                if (typeof continuationCallback === "function") {
                  currentTask.callback = continuationCallback;
                } else {
                  if (currentTask === peek(taskQueue)) {
                    pop(taskQueue);
                  }
                }
                advanceTimers(currentTime);
              } else {
                pop(taskQueue);
              }
              currentTask = peek(taskQueue);
            }
            if (currentTask !== null) {
              return true;
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
              return false;
            }
          }
          function unstable_runWithPriority(priorityLevel, eventHandler) {
            switch (priorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
              case LowPriority:
              case IdlePriority:
                break;
              default:
                priorityLevel = NormalPriority;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_next(eventHandler) {
            var priorityLevel;
            switch (currentPriorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
                priorityLevel = NormalPriority;
                break;
              default:
                priorityLevel = currentPriorityLevel;
                break;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_wrapCallback(callback) {
            var parentPriorityLevel = currentPriorityLevel;
            return function() {
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = parentPriorityLevel;
              try {
                return callback.apply(this, arguments);
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
          }
          function unstable_scheduleCallback(priorityLevel, callback, options2) {
            var currentTime = exports.unstable_now();
            var startTime2;
            if (typeof options2 === "object" && options2 !== null) {
              var delay = options2.delay;
              if (typeof delay === "number" && delay > 0) {
                startTime2 = currentTime + delay;
              } else {
                startTime2 = currentTime;
              }
            } else {
              startTime2 = currentTime;
            }
            var timeout;
            switch (priorityLevel) {
              case ImmediatePriority:
                timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                break;
              case UserBlockingPriority:
                timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                break;
              case IdlePriority:
                timeout = IDLE_PRIORITY_TIMEOUT;
                break;
              case LowPriority:
                timeout = LOW_PRIORITY_TIMEOUT;
                break;
              case NormalPriority:
              default:
                timeout = NORMAL_PRIORITY_TIMEOUT;
                break;
            }
            var expirationTime = startTime2 + timeout;
            var newTask = {
              id: taskIdCounter++,
              callback,
              priorityLevel,
              startTime: startTime2,
              expirationTime,
              sortIndex: -1
            };
            if (startTime2 > currentTime) {
              newTask.sortIndex = startTime2;
              push(timerQueue, newTask);
              if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                if (isHostTimeoutScheduled) {
                  cancelHostTimeout();
                } else {
                  isHostTimeoutScheduled = true;
                }
                requestHostTimeout(handleTimeout, startTime2 - currentTime);
              }
            } else {
              newTask.sortIndex = expirationTime;
              push(taskQueue, newTask);
              if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              }
            }
            return newTask;
          }
          function unstable_pauseExecution() {
          }
          function unstable_continueExecution() {
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          function unstable_getFirstCallbackNode() {
            return peek(taskQueue);
          }
          function unstable_cancelCallback(task) {
            task.callback = null;
          }
          function unstable_getCurrentPriorityLevel() {
            return currentPriorityLevel;
          }
          var isMessageLoopRunning = false;
          var scheduledHostCallback = null;
          var taskTimeoutID = -1;
          var frameInterval = frameYieldMs;
          var startTime = -1;
          function shouldYieldToHost() {
            var timeElapsed = exports.unstable_now() - startTime;
            if (timeElapsed < frameInterval) {
              return false;
            }
            return true;
          }
          function requestPaint() {
          }
          function forceFrameRate(fps) {
            if (fps < 0 || fps > 125) {
              console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
              return;
            }
            if (fps > 0) {
              frameInterval = Math.floor(1e3 / fps);
            } else {
              frameInterval = frameYieldMs;
            }
          }
          var performWorkUntilDeadline = function() {
            if (scheduledHostCallback !== null) {
              var currentTime = exports.unstable_now();
              startTime = currentTime;
              var hasTimeRemaining = true;
              var hasMoreWork = true;
              try {
                hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
              } finally {
                if (hasMoreWork) {
                  schedulePerformWorkUntilDeadline();
                } else {
                  isMessageLoopRunning = false;
                  scheduledHostCallback = null;
                }
              }
            } else {
              isMessageLoopRunning = false;
            }
          };
          var schedulePerformWorkUntilDeadline;
          if (typeof localSetImmediate === "function") {
            schedulePerformWorkUntilDeadline = function() {
              localSetImmediate(performWorkUntilDeadline);
            };
          } else if (typeof MessageChannel !== "undefined") {
            var channel = new MessageChannel();
            var port = channel.port2;
            channel.port1.onmessage = performWorkUntilDeadline;
            schedulePerformWorkUntilDeadline = function() {
              port.postMessage(null);
            };
          } else {
            schedulePerformWorkUntilDeadline = function() {
              localSetTimeout(performWorkUntilDeadline, 0);
            };
          }
          function requestHostCallback(callback) {
            scheduledHostCallback = callback;
            if (!isMessageLoopRunning) {
              isMessageLoopRunning = true;
              schedulePerformWorkUntilDeadline();
            }
          }
          function requestHostTimeout(callback, ms) {
            taskTimeoutID = localSetTimeout(function() {
              callback(exports.unstable_now());
            }, ms);
          }
          function cancelHostTimeout() {
            localClearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
          }
          var unstable_requestPaint = requestPaint;
          var unstable_Profiling = null;
          exports.unstable_IdlePriority = IdlePriority;
          exports.unstable_ImmediatePriority = ImmediatePriority;
          exports.unstable_LowPriority = LowPriority;
          exports.unstable_NormalPriority = NormalPriority;
          exports.unstable_Profiling = unstable_Profiling;
          exports.unstable_UserBlockingPriority = UserBlockingPriority;
          exports.unstable_cancelCallback = unstable_cancelCallback;
          exports.unstable_continueExecution = unstable_continueExecution;
          exports.unstable_forceFrameRate = forceFrameRate;
          exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
          exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
          exports.unstable_next = unstable_next;
          exports.unstable_pauseExecution = unstable_pauseExecution;
          exports.unstable_requestPaint = unstable_requestPaint;
          exports.unstable_runWithPriority = unstable_runWithPriority;
          exports.unstable_scheduleCallback = unstable_scheduleCallback;
          exports.unstable_shouldYield = shouldYieldToHost;
          exports.unstable_wrapCallback = unstable_wrapCallback;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React159 = require_react();
          var Scheduler = require_scheduler();
          var ReactSharedInternals = React159.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          var suppressWarning = false;
          function setSuppressWarning(newSuppressWarning) {
            {
              suppressWarning = newSuppressWarning;
            }
          }
          function warn(format4) {
            {
              if (!suppressWarning) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format4, args);
              }
            }
          }
          function error2(format4) {
            {
              if (!suppressWarning) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format4, args);
              }
            }
          }
          function printWarning(level, format4, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format4 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format4);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var FunctionComponent = 0;
          var ClassComponent = 1;
          var IndeterminateComponent = 2;
          var HostRoot = 3;
          var HostPortal = 4;
          var HostComponent = 5;
          var HostText = 6;
          var Fragment2 = 7;
          var Mode = 8;
          var ContextConsumer = 9;
          var ContextProvider = 10;
          var ForwardRef = 11;
          var Profiler = 12;
          var SuspenseComponent = 13;
          var MemoComponent = 14;
          var SimpleMemoComponent = 15;
          var LazyComponent = 16;
          var IncompleteClassComponent = 17;
          var DehydratedFragment = 18;
          var SuspenseListComponent = 19;
          var ScopeComponent = 21;
          var OffscreenComponent = 22;
          var LegacyHiddenComponent = 23;
          var CacheComponent = 24;
          var TracingMarkerComponent = 25;
          var enableClientRenderFallbackOnTextMismatch = true;
          var enableNewReconciler = false;
          var enableLazyContextPropagation = false;
          var enableLegacyHidden = false;
          var enableSuspenseAvoidThisFallback = false;
          var disableCommentsAsDOMContainers = true;
          var enableCustomElementPropertySupport = false;
          var warnAboutStringRefs = false;
          var enableSchedulingProfiler = true;
          var enableProfilerTimer = true;
          var enableProfilerCommitHooks = true;
          var allNativeEvents = /* @__PURE__ */ new Set();
          var registrationNameDependencies = {};
          var possibleRegistrationNames = {};
          function registerTwoPhaseEvent(registrationName, dependencies) {
            registerDirectEvent(registrationName, dependencies);
            registerDirectEvent(registrationName + "Capture", dependencies);
          }
          function registerDirectEvent(registrationName, dependencies) {
            {
              if (registrationNameDependencies[registrationName]) {
                error2("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
              }
            }
            registrationNameDependencies[registrationName] = dependencies;
            {
              var lowerCasedName = registrationName.toLowerCase();
              possibleRegistrationNames[lowerCasedName] = registrationName;
              if (registrationName === "onDoubleClick") {
                possibleRegistrationNames.ondblclick = registrationName;
              }
            }
            for (var i = 0; i < dependencies.length; i++) {
              allNativeEvents.add(dependencies[i]);
            }
          }
          var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkAttributeStringCoercion(value, attributeName) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkPropStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkCSSPropertyStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkHtmlStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error2("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkFormFieldValueStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error2("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          var RESERVED = 0;
          var STRING = 1;
          var BOOLEANISH_STRING = 2;
          var BOOLEAN = 3;
          var OVERLOADED_BOOLEAN = 4;
          var NUMERIC = 5;
          var POSITIVE_NUMERIC = 6;
          var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
          var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
          var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var illegalAttributeNameCache = {};
          var validatedAttributeNameCache = {};
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
              return true;
            }
            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
              return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
              validatedAttributeNameCache[attributeName] = true;
              return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
              error2("Invalid attribute name: `%s`", attributeName);
            }
            return false;
          }
          function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null) {
              return propertyInfo.type === RESERVED;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
              return true;
            }
            return false;
          }
          function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
              return false;
            }
            switch (typeof value) {
              case "function":
              case "symbol":
                return true;
              case "boolean": {
                if (isCustomComponentTag) {
                  return false;
                }
                if (propertyInfo !== null) {
                  return !propertyInfo.acceptsBooleans;
                } else {
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  return prefix2 !== "data-" && prefix2 !== "aria-";
                }
              }
              default:
                return false;
            }
          }
          function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
            if (value === null || typeof value === "undefined") {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
              return true;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              switch (propertyInfo.type) {
                case BOOLEAN:
                  return !value;
                case OVERLOADED_BOOLEAN:
                  return value === false;
                case NUMERIC:
                  return isNaN(value);
                case POSITIVE_NUMERIC:
                  return isNaN(value) || value < 1;
              }
            }
            return false;
          }
          function getPropertyInfo(name) {
            return properties.hasOwnProperty(name) ? properties[name] : null;
          }
          function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name;
            this.type = type;
            this.sanitizeURL = sanitizeURL2;
            this.removeEmptyString = removeEmptyString;
          }
          var properties = {};
          var reservedProps = [
            "children",
            "dangerouslySetInnerHTML",
            // TODO: This prevents the assignment of defaultValue to regular
            // elements (not just inputs). Now that ReactDOMInput assigns to the
            // defaultValue property -- do we need this?
            "defaultValue",
            "defaultChecked",
            "innerHTML",
            "suppressContentEditableWarning",
            "suppressHydrationWarning",
            "style"
          ];
          reservedProps.forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              RESERVED,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
            var name = _ref[0], attributeName = _ref[1];
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEANISH_STRING,
              false,
              // mustUseProperty
              name.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEANISH_STRING,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "allowFullScreen",
            "async",
            // Note: there is a special case that prevents it from being written to the DOM
            // on the client side because the browsers are inconsistent. Instead we call focus().
            "autoFocus",
            "autoPlay",
            "controls",
            "default",
            "defer",
            "disabled",
            "disablePictureInPicture",
            "disableRemotePlayback",
            "formNoValidate",
            "hidden",
            "loop",
            "noModule",
            "noValidate",
            "open",
            "playsInline",
            "readOnly",
            "required",
            "reversed",
            "scoped",
            "seamless",
            // Microdata
            "itemScope"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEAN,
              false,
              // mustUseProperty
              name.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "checked",
            // Note: `option.selected` is not updated if `select.multiple` is
            // disabled with `removeAttribute`. We have special logic for handling this.
            "multiple",
            "muted",
            "selected"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEAN,
              true,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "capture",
            "download"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              OVERLOADED_BOOLEAN,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "cols",
            "rows",
            "size",
            "span"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              POSITIVE_NUMERIC,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          ["rowSpan", "start"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              NUMERIC,
              false,
              // mustUseProperty
              name.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          var CAMELIZE = /[\-\:]([a-z])/g;
          var capitalize2 = function(token) {
            return token[1].toUpperCase();
          };
          [
            "accent-height",
            "alignment-baseline",
            "arabic-form",
            "baseline-shift",
            "cap-height",
            "clip-path",
            "clip-rule",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "dominant-baseline",
            "enable-background",
            "fill-opacity",
            "fill-rule",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "glyph-name",
            "glyph-orientation-horizontal",
            "glyph-orientation-vertical",
            "horiz-adv-x",
            "horiz-origin-x",
            "image-rendering",
            "letter-spacing",
            "lighting-color",
            "marker-end",
            "marker-mid",
            "marker-start",
            "overline-position",
            "overline-thickness",
            "paint-order",
            "panose-1",
            "pointer-events",
            "rendering-intent",
            "shape-rendering",
            "stop-color",
            "stop-opacity",
            "strikethrough-position",
            "strikethrough-thickness",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "underline-position",
            "underline-thickness",
            "unicode-bidi",
            "unicode-range",
            "units-per-em",
            "v-alphabetic",
            "v-hanging",
            "v-ideographic",
            "v-mathematical",
            "vector-effect",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "word-spacing",
            "writing-mode",
            "xmlns:xlink",
            "x-height"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize2);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "xlink:actuate",
            "xlink:arcrole",
            "xlink:role",
            "xlink:show",
            "xlink:title",
            "xlink:type"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize2);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              "http://www.w3.org/1999/xlink",
              false,
              // sanitizeURL
              false
            );
          });
          [
            "xml:base",
            "xml:lang",
            "xml:space"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize2);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              "http://www.w3.org/XML/1998/namespace",
              false,
              // sanitizeURL
              false
            );
          });
          ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              // mustUseProperty
              attributeName.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          var xlinkHref = "xlinkHref";
          properties[xlinkHref] = new PropertyInfoRecord(
            "xlinkHref",
            STRING,
            false,
            // mustUseProperty
            "xlink:href",
            "http://www.w3.org/1999/xlink",
            true,
            // sanitizeURL
            false
          );
          ["src", "href", "action", "formAction"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              // mustUseProperty
              attributeName.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              true,
              // sanitizeURL
              true
            );
          });
          var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
          var didWarn = false;
          function sanitizeURL(url) {
            {
              if (!didWarn && isJavaScriptProtocol.test(url)) {
                didWarn = true;
                error2("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
              }
            }
          }
          function getValueForProperty(node, name, expected, propertyInfo) {
            {
              if (propertyInfo.mustUseProperty) {
                var propertyName = propertyInfo.propertyName;
                return node[propertyName];
              } else {
                {
                  checkAttributeStringCoercion(expected, name);
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL("" + expected);
                }
                var attributeName = propertyInfo.attributeName;
                var stringValue = null;
                if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                  if (node.hasAttribute(attributeName)) {
                    var value = node.getAttribute(attributeName);
                    if (value === "") {
                      return true;
                    }
                    if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                      return value;
                    }
                    if (value === "" + expected) {
                      return expected;
                    }
                    return value;
                  }
                } else if (node.hasAttribute(attributeName)) {
                  if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                    return node.getAttribute(attributeName);
                  }
                  if (propertyInfo.type === BOOLEAN) {
                    return expected;
                  }
                  stringValue = node.getAttribute(attributeName);
                }
                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                  return stringValue === null ? expected : stringValue;
                } else if (stringValue === "" + expected) {
                  return expected;
                } else {
                  return stringValue;
                }
              }
            }
          }
          function getValueForAttribute(node, name, expected, isCustomComponentTag) {
            {
              if (!isAttributeNameSafe(name)) {
                return;
              }
              if (!node.hasAttribute(name)) {
                return expected === void 0 ? void 0 : null;
              }
              var value = node.getAttribute(name);
              {
                checkAttributeStringCoercion(expected, name);
              }
              if (value === "" + expected) {
                return expected;
              }
              return value;
            }
          }
          function setValueForProperty(node, name, value, isCustomComponentTag) {
            var propertyInfo = getPropertyInfo(name);
            if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
              return;
            }
            if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
              value = null;
            }
            if (isCustomComponentTag || propertyInfo === null) {
              if (isAttributeNameSafe(name)) {
                var _attributeName = name;
                if (value === null) {
                  node.removeAttribute(_attributeName);
                } else {
                  {
                    checkAttributeStringCoercion(value, name);
                  }
                  node.setAttribute(_attributeName, "" + value);
                }
              }
              return;
            }
            var mustUseProperty = propertyInfo.mustUseProperty;
            if (mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              if (value === null) {
                var type = propertyInfo.type;
                node[propertyName] = type === BOOLEAN ? false : "";
              } else {
                node[propertyName] = value;
              }
              return;
            }
            var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
            if (value === null) {
              node.removeAttribute(attributeName);
            } else {
              var _type = propertyInfo.type;
              var attributeValue;
              if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
                attributeValue = "";
              } else {
                {
                  {
                    checkAttributeStringCoercion(value, attributeName);
                  }
                  attributeValue = "" + value;
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL(attributeValue.toString());
                }
              }
              if (attributeNamespace) {
                node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
              } else {
                node.setAttribute(attributeName, attributeValue);
              }
            }
          }
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_SCOPE_TYPE = Symbol.for("react.scope");
          var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
          var REACT_CACHE_TYPE = Symbol.for("react.cache");
          var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var assign = Object.assign;
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match2 = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match2 && match2[1] || "";
                }
              }
              return "\n" + prefix + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn2);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn2();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn2.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn2.displayName);
                          }
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeClassComponentFrame(ctor, source, ownerFn) {
            {
              return describeNativeComponentFrame(ctor, true);
            }
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component9) {
            var prototype = Component9.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          function describeFiber(fiber) {
            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
            var source = fiber._debugSource;
            switch (fiber.tag) {
              case HostComponent:
                return describeBuiltInComponentFrame(fiber.type);
              case LazyComponent:
                return describeBuiltInComponentFrame("Lazy");
              case SuspenseComponent:
                return describeBuiltInComponentFrame("Suspense");
              case SuspenseListComponent:
                return describeBuiltInComponentFrame("SuspenseList");
              case FunctionComponent:
              case IndeterminateComponent:
              case SimpleMemoComponent:
                return describeFunctionComponentFrame(fiber.type);
              case ForwardRef:
                return describeFunctionComponentFrame(fiber.type.render);
              case ClassComponent:
                return describeClassComponentFrame(fiber.type);
              default:
                return "";
            }
          }
          function getStackByFiberInDevAndProd(workInProgress2) {
            try {
              var info = "";
              var node = workInProgress2;
              do {
                info += describeFiber(node);
                node = node.return;
              } while (node);
              return info;
            } catch (x) {
              return "\nError generating stack: " + x.message + "\n" + x.stack;
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          function getWrappedName$1(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getContextName$1(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromFiber(fiber) {
            var tag = fiber.tag, type = fiber.type;
            switch (tag) {
              case CacheComponent:
                return "Cache";
              case ContextConsumer:
                var context = type;
                return getContextName$1(context) + ".Consumer";
              case ContextProvider:
                var provider = type;
                return getContextName$1(provider._context) + ".Provider";
              case DehydratedFragment:
                return "DehydratedFragment";
              case ForwardRef:
                return getWrappedName$1(type, type.render, "ForwardRef");
              case Fragment2:
                return "Fragment";
              case HostComponent:
                return type;
              case HostPortal:
                return "Portal";
              case HostRoot:
                return "Root";
              case HostText:
                return "Text";
              case LazyComponent:
                return getComponentNameFromType(type);
              case Mode:
                if (type === REACT_STRICT_MODE_TYPE) {
                  return "StrictMode";
                }
                return "Mode";
              case OffscreenComponent:
                return "Offscreen";
              case Profiler:
                return "Profiler";
              case ScopeComponent:
                return "Scope";
              case SuspenseComponent:
                return "Suspense";
              case SuspenseListComponent:
                return "SuspenseList";
              case TracingMarkerComponent:
                return "TracingMarker";
              case ClassComponent:
              case FunctionComponent:
              case IncompleteClassComponent:
              case IndeterminateComponent:
              case MemoComponent:
              case SimpleMemoComponent:
                if (typeof type === "function") {
                  return type.displayName || type.name || null;
                }
                if (typeof type === "string") {
                  return type;
                }
                break;
            }
            return null;
          }
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var current = null;
          var isRendering = false;
          function getCurrentFiberOwnerNameInDevOrNull() {
            {
              if (current === null) {
                return null;
              }
              var owner = current._debugOwner;
              if (owner !== null && typeof owner !== "undefined") {
                return getComponentNameFromFiber(owner);
              }
            }
            return null;
          }
          function getCurrentFiberStackInDev() {
            {
              if (current === null) {
                return "";
              }
              return getStackByFiberInDevAndProd(current);
            }
          }
          function resetCurrentFiber() {
            {
              ReactDebugCurrentFrame.getCurrentStack = null;
              current = null;
              isRendering = false;
            }
          }
          function setCurrentFiber(fiber) {
            {
              ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
              current = fiber;
              isRendering = false;
            }
          }
          function getCurrentFiber() {
            {
              return current;
            }
          }
          function setIsRendering(rendering) {
            {
              isRendering = rendering;
            }
          }
          function toString(value) {
            return "" + value;
          }
          function getToStringValue(value) {
            switch (typeof value) {
              case "boolean":
              case "number":
              case "string":
              case "undefined":
                return value;
              case "object":
                {
                  checkFormFieldValueStringCoercion(value);
                }
                return value;
              default:
                return "";
            }
          }
          var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
          };
          function checkControlledValueProps(tagName, props) {
            {
              if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                error2("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
              }
              if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                error2("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
              }
            }
          }
          function isCheckable(elem) {
            var type = elem.type;
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
          }
          function getTracker(node) {
            return node._valueTracker;
          }
          function detachTracker(node) {
            node._valueTracker = null;
          }
          function getValueFromNode(node) {
            var value = "";
            if (!node) {
              return value;
            }
            if (isCheckable(node)) {
              value = node.checked ? "true" : "false";
            } else {
              value = node.value;
            }
            return value;
          }
          function trackValueOnNode(node) {
            var valueField = isCheckable(node) ? "checked" : "value";
            var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
            {
              checkFormFieldValueStringCoercion(node[valueField]);
            }
            var currentValue = "" + node[valueField];
            if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
              return;
            }
            var get3 = descriptor.get, set4 = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get3.call(this);
              },
              set: function(value) {
                {
                  checkFormFieldValueStringCoercion(value);
                }
                currentValue = "" + value;
                set4.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            var tracker = {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                {
                  checkFormFieldValueStringCoercion(value);
                }
                currentValue = "" + value;
              },
              stopTracking: function() {
                detachTracker(node);
                delete node[valueField];
              }
            };
            return tracker;
          }
          function track(node) {
            if (getTracker(node)) {
              return;
            }
            node._valueTracker = trackValueOnNode(node);
          }
          function updateValueIfChanged(node) {
            if (!node) {
              return false;
            }
            var tracker = getTracker(node);
            if (!tracker) {
              return true;
            }
            var lastValue = tracker.getValue();
            var nextValue = getValueFromNode(node);
            if (nextValue !== lastValue) {
              tracker.setValue(nextValue);
              return true;
            }
            return false;
          }
          function getActiveElement(doc) {
            doc = doc || (typeof document !== "undefined" ? document : void 0);
            if (typeof doc === "undefined") {
              return null;
            }
            try {
              return doc.activeElement || doc.body;
            } catch (e) {
              return doc.body;
            }
          }
          var didWarnValueDefaultValue = false;
          var didWarnCheckedDefaultChecked = false;
          var didWarnControlledToUncontrolled = false;
          var didWarnUncontrolledToControlled = false;
          function isControlled(props) {
            var usesChecked = props.type === "checkbox" || props.type === "radio";
            return usesChecked ? props.checked != null : props.value != null;
          }
          function getHostProps(element, props) {
            var node = element;
            var checked = props.checked;
            var hostProps = assign({}, props, {
              defaultChecked: void 0,
              defaultValue: void 0,
              value: void 0,
              checked: checked != null ? checked : node._wrapperState.initialChecked
            });
            return hostProps;
          }
          function initWrapperState(element, props) {
            {
              checkControlledValueProps("input", props);
              if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
                error2("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnCheckedDefaultChecked = true;
              }
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
                error2("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnValueDefaultValue = true;
              }
            }
            var node = element;
            var defaultValue6 = props.defaultValue == null ? "" : props.defaultValue;
            node._wrapperState = {
              initialChecked: props.checked != null ? props.checked : props.defaultChecked,
              initialValue: getToStringValue(props.value != null ? props.value : defaultValue6),
              controlled: isControlled(props)
            };
          }
          function updateChecked(element, props) {
            var node = element;
            var checked = props.checked;
            if (checked != null) {
              setValueForProperty(node, "checked", checked, false);
            }
          }
          function updateWrapper(element, props) {
            var node = element;
            {
              var controlled = isControlled(props);
              if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
                error2("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnUncontrolledToControlled = true;
              }
              if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
                error2("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnControlledToUncontrolled = true;
              }
            }
            updateChecked(element, props);
            var value = getToStringValue(props.value);
            var type = props.type;
            if (value != null) {
              if (type === "number") {
                if (value === 0 && node.value === "" || // We explicitly want to coerce to number here if possible.
                // eslint-disable-next-line
                node.value != value) {
                  node.value = toString(value);
                }
              } else if (node.value !== toString(value)) {
                node.value = toString(value);
              }
            } else if (type === "submit" || type === "reset") {
              node.removeAttribute("value");
              return;
            }
            {
              if (props.hasOwnProperty("value")) {
                setDefaultValue(node, props.type, value);
              } else if (props.hasOwnProperty("defaultValue")) {
                setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
              }
            }
            {
              if (props.checked == null && props.defaultChecked != null) {
                node.defaultChecked = !!props.defaultChecked;
              }
            }
          }
          function postMountWrapper(element, props, isHydrating2) {
            var node = element;
            if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
              var type = props.type;
              var isButton = type === "submit" || type === "reset";
              if (isButton && (props.value === void 0 || props.value === null)) {
                return;
              }
              var initialValue = toString(node._wrapperState.initialValue);
              if (!isHydrating2) {
                {
                  if (initialValue !== node.value) {
                    node.value = initialValue;
                  }
                }
              }
              {
                node.defaultValue = initialValue;
              }
            }
            var name = node.name;
            if (name !== "") {
              node.name = "";
            }
            {
              node.defaultChecked = !node.defaultChecked;
              node.defaultChecked = !!node._wrapperState.initialChecked;
            }
            if (name !== "") {
              node.name = name;
            }
          }
          function restoreControlledState(element, props) {
            var node = element;
            updateWrapper(node, props);
            updateNamedCousins(node, props);
          }
          function updateNamedCousins(rootNode, props) {
            var name = props.name;
            if (props.type === "radio" && name != null) {
              var queryRoot = rootNode;
              while (queryRoot.parentNode) {
                queryRoot = queryRoot.parentNode;
              }
              {
                checkAttributeStringCoercion(name, "name");
              }
              var group3 = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
              for (var i = 0; i < group3.length; i++) {
                var otherNode = group3[i];
                if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                  continue;
                }
                var otherProps = getFiberCurrentPropsFromNode(otherNode);
                if (!otherProps) {
                  throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                }
                updateValueIfChanged(otherNode);
                updateWrapper(otherNode, otherProps);
              }
            }
          }
          function setDefaultValue(node, type, value) {
            if (
              // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
              type !== "number" || getActiveElement(node.ownerDocument) !== node
            ) {
              if (value == null) {
                node.defaultValue = toString(node._wrapperState.initialValue);
              } else if (node.defaultValue !== toString(value)) {
                node.defaultValue = toString(value);
              }
            }
          }
          var didWarnSelectedSetOnOption = false;
          var didWarnInvalidChild = false;
          var didWarnInvalidInnerHTML = false;
          function validateProps(element, props) {
            {
              if (props.value == null) {
                if (typeof props.children === "object" && props.children !== null) {
                  React159.Children.forEach(props.children, function(child) {
                    if (child == null) {
                      return;
                    }
                    if (typeof child === "string" || typeof child === "number") {
                      return;
                    }
                    if (!didWarnInvalidChild) {
                      didWarnInvalidChild = true;
                      error2("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                    }
                  });
                } else if (props.dangerouslySetInnerHTML != null) {
                  if (!didWarnInvalidInnerHTML) {
                    didWarnInvalidInnerHTML = true;
                    error2("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              if (props.selected != null && !didWarnSelectedSetOnOption) {
                error2("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                didWarnSelectedSetOnOption = true;
              }
            }
          }
          function postMountWrapper$1(element, props) {
            if (props.value != null) {
              element.setAttribute("value", toString(getToStringValue(props.value)));
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray(a) {
            return isArrayImpl(a);
          }
          var didWarnValueDefaultValue$1;
          {
            didWarnValueDefaultValue$1 = false;
          }
          function getDeclarationErrorAddendum() {
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              return "\n\nCheck the render method of `" + ownerName + "`.";
            }
            return "";
          }
          var valuePropNames = ["value", "defaultValue"];
          function checkSelectPropTypes(props) {
            {
              checkControlledValueProps("select", props);
              for (var i = 0; i < valuePropNames.length; i++) {
                var propName = valuePropNames[i];
                if (props[propName] == null) {
                  continue;
                }
                var propNameIsArray = isArray(props[propName]);
                if (props.multiple && !propNameIsArray) {
                  error2("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
                } else if (!props.multiple && propNameIsArray) {
                  error2("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
                }
              }
            }
          }
          function updateOptions(node, multiple, propValue, setDefaultSelected) {
            var options3 = node.options;
            if (multiple) {
              var selectedValues = propValue;
              var selectedValue = {};
              for (var i = 0; i < selectedValues.length; i++) {
                selectedValue["$" + selectedValues[i]] = true;
              }
              for (var _i = 0; _i < options3.length; _i++) {
                var selected = selectedValue.hasOwnProperty("$" + options3[_i].value);
                if (options3[_i].selected !== selected) {
                  options3[_i].selected = selected;
                }
                if (selected && setDefaultSelected) {
                  options3[_i].defaultSelected = true;
                }
              }
            } else {
              var _selectedValue = toString(getToStringValue(propValue));
              var defaultSelected = null;
              for (var _i2 = 0; _i2 < options3.length; _i2++) {
                if (options3[_i2].value === _selectedValue) {
                  options3[_i2].selected = true;
                  if (setDefaultSelected) {
                    options3[_i2].defaultSelected = true;
                  }
                  return;
                }
                if (defaultSelected === null && !options3[_i2].disabled) {
                  defaultSelected = options3[_i2];
                }
              }
              if (defaultSelected !== null) {
                defaultSelected.selected = true;
              }
            }
          }
          function getHostProps$1(element, props) {
            return assign({}, props, {
              value: void 0
            });
          }
          function initWrapperState$1(element, props) {
            var node = element;
            {
              checkSelectPropTypes(props);
            }
            node._wrapperState = {
              wasMultiple: !!props.multiple
            };
            {
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
                error2("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnValueDefaultValue$1 = true;
              }
            }
          }
          function postMountWrapper$2(element, props) {
            var node = element;
            node.multiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (props.defaultValue != null) {
              updateOptions(node, !!props.multiple, props.defaultValue, true);
            }
          }
          function postUpdateWrapper(element, props) {
            var node = element;
            var wasMultiple = node._wrapperState.wasMultiple;
            node._wrapperState.wasMultiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (wasMultiple !== !!props.multiple) {
              if (props.defaultValue != null) {
                updateOptions(node, !!props.multiple, props.defaultValue, true);
              } else {
                updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
              }
            }
          }
          function restoreControlledState$1(element, props) {
            var node = element;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            }
          }
          var didWarnValDefaultVal = false;
          function getHostProps$2(element, props) {
            var node = element;
            if (props.dangerouslySetInnerHTML != null) {
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            }
            var hostProps = assign({}, props, {
              value: void 0,
              defaultValue: void 0,
              children: toString(node._wrapperState.initialValue)
            });
            return hostProps;
          }
          function initWrapperState$2(element, props) {
            var node = element;
            {
              checkControlledValueProps("textarea", props);
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
                error2("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
                didWarnValDefaultVal = true;
              }
            }
            var initialValue = props.value;
            if (initialValue == null) {
              var children = props.children, defaultValue6 = props.defaultValue;
              if (children != null) {
                {
                  error2("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                }
                {
                  if (defaultValue6 != null) {
                    throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                  }
                  if (isArray(children)) {
                    if (children.length > 1) {
                      throw new Error("<textarea> can only have at most one child.");
                    }
                    children = children[0];
                  }
                  defaultValue6 = children;
                }
              }
              if (defaultValue6 == null) {
                defaultValue6 = "";
              }
              initialValue = defaultValue6;
            }
            node._wrapperState = {
              initialValue: getToStringValue(initialValue)
            };
          }
          function updateWrapper$1(element, props) {
            var node = element;
            var value = getToStringValue(props.value);
            var defaultValue6 = getToStringValue(props.defaultValue);
            if (value != null) {
              var newValue = toString(value);
              if (newValue !== node.value) {
                node.value = newValue;
              }
              if (props.defaultValue == null && node.defaultValue !== newValue) {
                node.defaultValue = newValue;
              }
            }
            if (defaultValue6 != null) {
              node.defaultValue = toString(defaultValue6);
            }
          }
          function postMountWrapper$3(element, props) {
            var node = element;
            var textContent = node.textContent;
            if (textContent === node._wrapperState.initialValue) {
              if (textContent !== "" && textContent !== null) {
                node.value = textContent;
              }
            }
          }
          function restoreControlledState$2(element, props) {
            updateWrapper$1(element, props);
          }
          var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          function getIntrinsicNamespace(type) {
            switch (type) {
              case "svg":
                return SVG_NAMESPACE;
              case "math":
                return MATH_NAMESPACE;
              default:
                return HTML_NAMESPACE;
            }
          }
          function getChildNamespace(parentNamespace, type) {
            if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
              return getIntrinsicNamespace(type);
            }
            if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
              return HTML_NAMESPACE;
            }
            return parentNamespace;
          }
          var createMicrosoftUnsafeLocalFunction = function(func) {
            if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
              return function(arg0, arg1, arg2, arg3) {
                MSApp.execUnsafeLocalFunction(function() {
                  return func(arg0, arg1, arg2, arg3);
                });
              };
            } else {
              return func;
            }
          };
          var reusableSVGContainer;
          var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
            if (node.namespaceURI === SVG_NAMESPACE) {
              if (!("innerHTML" in node)) {
                reusableSVGContainer = reusableSVGContainer || document.createElement("div");
                reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
                var svgNode = reusableSVGContainer.firstChild;
                while (node.firstChild) {
                  node.removeChild(node.firstChild);
                }
                while (svgNode.firstChild) {
                  node.appendChild(svgNode.firstChild);
                }
                return;
              }
            }
            node.innerHTML = html;
          });
          var ELEMENT_NODE = 1;
          var TEXT_NODE = 3;
          var COMMENT_NODE = 8;
          var DOCUMENT_NODE = 9;
          var DOCUMENT_FRAGMENT_NODE = 11;
          var setTextContent = function(node, text) {
            if (text) {
              var firstChild = node.firstChild;
              if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
                firstChild.nodeValue = text;
                return;
              }
            }
            node.textContent = text;
          };
          var shorthandToLonghand = {
            animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
            background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
            backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
            border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
            borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
            borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
            borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
            borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
            borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
            borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
            borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
            borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
            borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
            borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
            borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
            columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
            columns: ["columnCount", "columnWidth"],
            flex: ["flexBasis", "flexGrow", "flexShrink"],
            flexFlow: ["flexDirection", "flexWrap"],
            font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
            fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
            gap: ["columnGap", "rowGap"],
            grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
            gridColumn: ["gridColumnEnd", "gridColumnStart"],
            gridColumnGap: ["columnGap"],
            gridGap: ["columnGap", "rowGap"],
            gridRow: ["gridRowEnd", "gridRowStart"],
            gridRowGap: ["rowGap"],
            gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
            margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
            marker: ["markerEnd", "markerMid", "markerStart"],
            mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
            maskPosition: ["maskPositionX", "maskPositionY"],
            outline: ["outlineColor", "outlineStyle", "outlineWidth"],
            overflow: ["overflowX", "overflowY"],
            padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
            placeContent: ["alignContent", "justifyContent"],
            placeItems: ["alignItems", "justifyItems"],
            placeSelf: ["alignSelf", "justifySelf"],
            textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
            textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
            transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
            wordWrap: ["overflowWrap"]
          };
          var isUnitlessNumber = {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            // SVG-related properties
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function prefixKey(prefix2, key) {
            return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
          }
          var prefixes = ["Webkit", "ms", "Moz", "O"];
          Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes.forEach(function(prefix2) {
              isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
            });
          });
          function dangerousStyleValue(name, value, isCustomProperty) {
            var isEmpty = value == null || typeof value === "boolean" || value === "";
            if (isEmpty) {
              return "";
            }
            if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
              return value + "px";
            }
            {
              checkCSSPropertyStringCoercion(value, name);
            }
            return ("" + value).trim();
          }
          var uppercasePattern = /([A-Z])/g;
          var msPattern = /^ms-/;
          function hyphenateStyleName(name) {
            return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
          }
          var warnValidStyle = function() {
          };
          {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern$1 = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize2 = function(string) {
              return string.replace(hyphenPattern, function(_, character) {
                return character.toUpperCase();
              });
            };
            var warnHyphenatedStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error2(
                "Unsupported style property %s. Did you mean %s?",
                name,
                // As Andi Smith suggests
                // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
                // is converted to lowercase `ms`.
                camelize2(name.replace(msPattern$1, "ms-"))
              );
            };
            var warnBadVendoredStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error2("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
            };
            var warnStyleValueWithSemicolon = function(name, value) {
              if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                return;
              }
              warnedStyleValues[value] = true;
              error2(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
            };
            var warnStyleValueIsNaN = function(name, value) {
              if (warnedForNaNValue) {
                return;
              }
              warnedForNaNValue = true;
              error2("`NaN` is an invalid value for the `%s` css style property.", name);
            };
            var warnStyleValueIsInfinity = function(name, value) {
              if (warnedForInfinityValue) {
                return;
              }
              warnedForInfinityValue = true;
              error2("`Infinity` is an invalid value for the `%s` css style property.", name);
            };
            warnValidStyle = function(name, value) {
              if (name.indexOf("-") > -1) {
                warnHyphenatedStyleName(name);
              } else if (badVendoredStyleNamePattern.test(name)) {
                warnBadVendoredStyleName(name);
              } else if (badStyleValueWithSemicolonPattern.test(value)) {
                warnStyleValueWithSemicolon(name, value);
              }
              if (typeof value === "number") {
                if (isNaN(value)) {
                  warnStyleValueIsNaN(name, value);
                } else if (!isFinite(value)) {
                  warnStyleValueIsInfinity(name, value);
                }
              }
            };
          }
          var warnValidStyle$1 = warnValidStyle;
          function createDangerousStringForStyles(styles) {
            {
              var serialized = "";
              var delimiter = "";
              for (var styleName in styles) {
                if (!styles.hasOwnProperty(styleName)) {
                  continue;
                }
                var styleValue = styles[styleName];
                if (styleValue != null) {
                  var isCustomProperty = styleName.indexOf("--") === 0;
                  serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                  serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                  delimiter = ";";
                }
              }
              return serialized || null;
            }
          }
          function setValueForStyles(node, styles) {
            var style2 = node.style;
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var isCustomProperty = styleName.indexOf("--") === 0;
              {
                if (!isCustomProperty) {
                  warnValidStyle$1(styleName, styles[styleName]);
                }
              }
              var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
              if (styleName === "float") {
                styleName = "cssFloat";
              }
              if (isCustomProperty) {
                style2.setProperty(styleName, styleValue);
              } else {
                style2[styleName] = styleValue;
              }
            }
          }
          function isValueEmpty(value) {
            return value == null || typeof value === "boolean" || value === "";
          }
          function expandShorthandMap(styles) {
            var expanded = {};
            for (var key in styles) {
              var longhands = shorthandToLonghand[key] || [key];
              for (var i = 0; i < longhands.length; i++) {
                expanded[longhands[i]] = key;
              }
            }
            return expanded;
          }
          function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
            {
              if (!nextStyles) {
                return;
              }
              var expandedUpdates = expandShorthandMap(styleUpdates);
              var expandedStyles = expandShorthandMap(nextStyles);
              var warnedAbout = {};
              for (var key in expandedUpdates) {
                var originalKey = expandedUpdates[key];
                var correctOriginalKey = expandedStyles[key];
                if (correctOriginalKey && originalKey !== correctOriginalKey) {
                  var warningKey = originalKey + "," + correctOriginalKey;
                  if (warnedAbout[warningKey]) {
                    continue;
                  }
                  warnedAbout[warningKey] = true;
                  error2("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
                }
              }
            }
          }
          var omittedCloseTags = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
            // NOTE: menuitem's close tag should be omitted, but that causes problems.
          };
          var voidElementTags = assign({
            menuitem: true
          }, omittedCloseTags);
          var HTML = "__html";
          function assertValidProps(tag, props) {
            if (!props) {
              return;
            }
            if (voidElementTags[tag]) {
              if (props.children != null || props.dangerouslySetInnerHTML != null) {
                throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
            if (props.dangerouslySetInnerHTML != null) {
              if (props.children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
            {
              if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                error2("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
              }
            }
            if (props.style != null && typeof props.style !== "object") {
              throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
          function isCustomComponent(tagName, props) {
            if (tagName.indexOf("-") === -1) {
              return typeof props.is === "string";
            }
            switch (tagName) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var possibleStandardNames = {
            // HTML
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            imagesizes: "imageSizes",
            imagesrcset: "imageSrcSet",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            // SVG
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          };
          var ariaProperties = {
            "aria-current": 0,
            // state
            "aria-description": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            // state
            "aria-hidden": 0,
            // state
            "aria-invalid": 0,
            // state
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            // Widget Attributes
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            // Live Region Attributes
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            // Drag-and-Drop Attributes
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            // Relationship Attributes
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          };
          var warnedProperties = {};
          var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          function validateProperty(tagName, name) {
            {
              if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
                return true;
              }
              if (rARIACamel.test(name)) {
                var ariaName = "aria-" + name.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                if (correctName == null) {
                  error2("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                  warnedProperties[name] = true;
                  return true;
                }
                if (name !== correctName) {
                  error2("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
              if (rARIA.test(name)) {
                var lowerCasedName = name.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                if (standardName == null) {
                  warnedProperties[name] = true;
                  return false;
                }
                if (name !== standardName) {
                  error2("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
            }
            return true;
          }
          function warnInvalidARIAProps(type, props) {
            {
              var invalidProps = [];
              for (var key in props) {
                var isValid = validateProperty(type, key);
                if (!isValid) {
                  invalidProps.push(key);
                }
              }
              var unknownPropString = invalidProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (invalidProps.length === 1) {
                error2("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              } else if (invalidProps.length > 1) {
                error2("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              }
            }
          }
          function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnInvalidARIAProps(type, props);
          }
          var didWarnValueNull = false;
          function validateProperties$1(type, props) {
            {
              if (type !== "input" && type !== "textarea" && type !== "select") {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === "select" && props.multiple) {
                  error2("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
                } else {
                  error2("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
                }
              }
            }
          }
          var validateProperty$1 = function() {
          };
          {
            var warnedProperties$1 = {};
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
            var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
            validateProperty$1 = function(tagName, name, value, eventRegistry2) {
              if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
                return true;
              }
              var lowerCasedName = name.toLowerCase();
              if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                error2("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (eventRegistry2 != null) {
                var registrationNameDependencies2 = eventRegistry2.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry2.possibleRegistrationNames;
                if (registrationNameDependencies2.hasOwnProperty(name)) {
                  return true;
                }
                var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
                if (registrationName != null) {
                  error2("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                  warnedProperties$1[name] = true;
                  return true;
                }
                if (EVENT_NAME_REGEX.test(name)) {
                  error2("Unknown event handler property `%s`. It will be ignored.", name);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (EVENT_NAME_REGEX.test(name)) {
                if (INVALID_EVENT_NAME_REGEX.test(name)) {
                  error2("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
                return true;
              }
              if (lowerCasedName === "innerhtml") {
                error2("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "aria") {
                error2("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
                error2("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "number" && isNaN(value)) {
                error2("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
                warnedProperties$1[name] = true;
                return true;
              }
              var propertyInfo = getPropertyInfo(name);
              var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
              if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                var standardName = possibleStandardNames[lowerCasedName];
                if (standardName !== name) {
                  error2("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (!isReserved && name !== lowerCasedName) {
                error2("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                if (value) {
                  error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
                } else {
                  error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (isReserved) {
                return true;
              }
              if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                warnedProperties$1[name] = true;
                return false;
              }
              if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                error2("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
                warnedProperties$1[name] = true;
                return true;
              }
              return true;
            };
          }
          var warnUnknownProperties = function(type, props, eventRegistry2) {
            {
              var unknownProps = [];
              for (var key in props) {
                var isValid = validateProperty$1(type, key, props[key], eventRegistry2);
                if (!isValid) {
                  unknownProps.push(key);
                }
              }
              var unknownPropString = unknownProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (unknownProps.length === 1) {
                error2("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              } else if (unknownProps.length > 1) {
                error2("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              }
            }
          };
          function validateProperties$2(type, props, eventRegistry2) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnUnknownProperties(type, props, eventRegistry2);
          }
          var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
          var IS_NON_DELEGATED = 1 << 1;
          var IS_CAPTURE_PHASE = 1 << 2;
          var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
          var currentReplayingEvent = null;
          function setReplayingEvent(event) {
            {
              if (currentReplayingEvent !== null) {
                error2("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = event;
          }
          function resetReplayingEvent() {
            {
              if (currentReplayingEvent === null) {
                error2("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = null;
          }
          function isReplayingEvent(event) {
            return event === currentReplayingEvent;
          }
          function getEventTarget(nativeEvent) {
            var target = nativeEvent.target || nativeEvent.srcElement || window;
            if (target.correspondingUseElement) {
              target = target.correspondingUseElement;
            }
            return target.nodeType === TEXT_NODE ? target.parentNode : target;
          }
          var restoreImpl = null;
          var restoreTarget = null;
          var restoreQueue = null;
          function restoreStateOfTarget(target) {
            var internalInstance = getInstanceFromNode(target);
            if (!internalInstance) {
              return;
            }
            if (typeof restoreImpl !== "function") {
              throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
            }
            var stateNode = internalInstance.stateNode;
            if (stateNode) {
              var _props = getFiberCurrentPropsFromNode(stateNode);
              restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
            }
          }
          function setRestoreImplementation(impl) {
            restoreImpl = impl;
          }
          function enqueueStateRestore(target) {
            if (restoreTarget) {
              if (restoreQueue) {
                restoreQueue.push(target);
              } else {
                restoreQueue = [target];
              }
            } else {
              restoreTarget = target;
            }
          }
          function needsStateRestore() {
            return restoreTarget !== null || restoreQueue !== null;
          }
          function restoreStateIfNeeded() {
            if (!restoreTarget) {
              return;
            }
            var target = restoreTarget;
            var queuedTargets = restoreQueue;
            restoreTarget = null;
            restoreQueue = null;
            restoreStateOfTarget(target);
            if (queuedTargets) {
              for (var i = 0; i < queuedTargets.length; i++) {
                restoreStateOfTarget(queuedTargets[i]);
              }
            }
          }
          var batchedUpdatesImpl = function(fn2, bookkeeping) {
            return fn2(bookkeeping);
          };
          var flushSyncImpl = function() {
          };
          var isInsideEventHandler = false;
          function finishEventHandler() {
            var controlledComponentsHavePendingUpdates = needsStateRestore();
            if (controlledComponentsHavePendingUpdates) {
              flushSyncImpl();
              restoreStateIfNeeded();
            }
          }
          function batchedUpdates(fn2, a, b) {
            if (isInsideEventHandler) {
              return fn2(a, b);
            }
            isInsideEventHandler = true;
            try {
              return batchedUpdatesImpl(fn2, a, b);
            } finally {
              isInsideEventHandler = false;
              finishEventHandler();
            }
          }
          function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
            batchedUpdatesImpl = _batchedUpdatesImpl;
            flushSyncImpl = _flushSyncImpl;
          }
          function isInteractive(tag) {
            return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
          }
          function shouldPreventMouseEvent(name, type, props) {
            switch (name) {
              case "onClick":
              case "onClickCapture":
              case "onDoubleClick":
              case "onDoubleClickCapture":
              case "onMouseDown":
              case "onMouseDownCapture":
              case "onMouseMove":
              case "onMouseMoveCapture":
              case "onMouseUp":
              case "onMouseUpCapture":
              case "onMouseEnter":
                return !!(props.disabled && isInteractive(type));
              default:
                return false;
            }
          }
          function getListener(inst, registrationName) {
            var stateNode = inst.stateNode;
            if (stateNode === null) {
              return null;
            }
            var props = getFiberCurrentPropsFromNode(stateNode);
            if (props === null) {
              return null;
            }
            var listener = props[registrationName];
            if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
              return null;
            }
            if (listener && typeof listener !== "function") {
              throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
            }
            return listener;
          }
          var passiveBrowserEventsSupported = false;
          if (canUseDOM) {
            try {
              var options2 = {};
              Object.defineProperty(options2, "passive", {
                get: function() {
                  passiveBrowserEventsSupported = true;
                }
              });
              window.addEventListener("test", options2, options2);
              window.removeEventListener("test", options2, options2);
            } catch (e) {
              passiveBrowserEventsSupported = false;
            }
          }
          function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            try {
              func.apply(context, funcArgs);
            } catch (error3) {
              this.onError(error3);
            }
          }
          var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
          {
            if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
              var fakeNode = document.createElement("react");
              invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
                if (typeof document === "undefined" || document === null) {
                  throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
                }
                var evt = document.createEvent("Event");
                var didCall = false;
                var didError = true;
                var windowEvent = window.event;
                var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
                function restoreAfterDispatch() {
                  fakeNode.removeEventListener(evtType, callCallback2, false);
                  if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                    window.event = windowEvent;
                  }
                }
                var funcArgs = Array.prototype.slice.call(arguments, 3);
                function callCallback2() {
                  didCall = true;
                  restoreAfterDispatch();
                  func.apply(context, funcArgs);
                  didError = false;
                }
                var error3;
                var didSetError = false;
                var isCrossOriginError = false;
                function handleWindowError(event) {
                  error3 = event.error;
                  didSetError = true;
                  if (error3 === null && event.colno === 0 && event.lineno === 0) {
                    isCrossOriginError = true;
                  }
                  if (event.defaultPrevented) {
                    if (error3 != null && typeof error3 === "object") {
                      try {
                        error3._suppressLogging = true;
                      } catch (inner) {
                      }
                    }
                  }
                }
                var evtType = "react-" + (name ? name : "invokeguardedcallback");
                window.addEventListener("error", handleWindowError);
                fakeNode.addEventListener(evtType, callCallback2, false);
                evt.initEvent(evtType, false, false);
                fakeNode.dispatchEvent(evt);
                if (windowEventDescriptor) {
                  Object.defineProperty(window, "event", windowEventDescriptor);
                }
                if (didCall && didError) {
                  if (!didSetError) {
                    error3 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                  } else if (isCrossOriginError) {
                    error3 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                  }
                  this.onError(error3);
                }
                window.removeEventListener("error", handleWindowError);
                if (!didCall) {
                  restoreAfterDispatch();
                  return invokeGuardedCallbackProd.apply(this, arguments);
                }
              };
            }
          }
          var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
          var hasError = false;
          var caughtError = null;
          var hasRethrowError = false;
          var rethrowError = null;
          var reporter = {
            onError: function(error3) {
              hasError = true;
              caughtError = error3;
            }
          };
          function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
            hasError = false;
            caughtError = null;
            invokeGuardedCallbackImpl$1.apply(reporter, arguments);
          }
          function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
            invokeGuardedCallback.apply(this, arguments);
            if (hasError) {
              var error3 = clearCaughtError();
              if (!hasRethrowError) {
                hasRethrowError = true;
                rethrowError = error3;
              }
            }
          }
          function rethrowCaughtError() {
            if (hasRethrowError) {
              var error3 = rethrowError;
              hasRethrowError = false;
              rethrowError = null;
              throw error3;
            }
          }
          function hasCaughtError() {
            return hasError;
          }
          function clearCaughtError() {
            if (hasError) {
              var error3 = caughtError;
              hasError = false;
              caughtError = null;
              return error3;
            } else {
              throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function get2(key) {
            return key._reactInternals;
          }
          function has(key) {
            return key._reactInternals !== void 0;
          }
          function set3(key, value) {
            key._reactInternals = value;
          }
          var NoFlags = (
            /*                      */
            0
          );
          var PerformedWork = (
            /*                */
            1
          );
          var Placement = (
            /*                    */
            2
          );
          var Update = (
            /*                       */
            4
          );
          var ChildDeletion = (
            /*                */
            16
          );
          var ContentReset = (
            /*                 */
            32
          );
          var Callback = (
            /*                     */
            64
          );
          var DidCapture = (
            /*                   */
            128
          );
          var ForceClientRender = (
            /*            */
            256
          );
          var Ref = (
            /*                          */
            512
          );
          var Snapshot2 = (
            /*                     */
            1024
          );
          var Passive = (
            /*                      */
            2048
          );
          var Hydrating = (
            /*                    */
            4096
          );
          var Visibility = (
            /*                   */
            8192
          );
          var StoreConsistency = (
            /*             */
            16384
          );
          var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot2 | StoreConsistency;
          var HostEffectMask = (
            /*               */
            32767
          );
          var Incomplete = (
            /*                   */
            32768
          );
          var ShouldCapture = (
            /*                */
            65536
          );
          var ForceUpdateForLegacySuspense = (
            /* */
            131072
          );
          var Forked = (
            /*                       */
            1048576
          );
          var RefStatic = (
            /*                    */
            2097152
          );
          var LayoutStatic = (
            /*                 */
            4194304
          );
          var PassiveStatic = (
            /*                */
            8388608
          );
          var MountLayoutDev = (
            /*               */
            16777216
          );
          var MountPassiveDev = (
            /*              */
            33554432
          );
          var BeforeMutationMask = (
            // TODO: Remove Update flag from before mutation phase by re-landing Visibility
            // flag logic (see #20043)
            Update | Snapshot2 | 0
          );
          var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
          var LayoutMask = Update | Callback | Ref | Visibility;
          var PassiveMask = Passive | ChildDeletion;
          var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
              var nextNode = node;
              do {
                node = nextNode;
                if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                  nearestMounted = node.return;
                }
                nextNode = node.return;
              } while (nextNode);
            } else {
              while (node.return) {
                node = node.return;
              }
            }
            if (node.tag === HostRoot) {
              return nearestMounted;
            }
            return null;
          }
          function getSuspenseInstanceFromFiber(fiber) {
            if (fiber.tag === SuspenseComponent) {
              var suspenseState = fiber.memoizedState;
              if (suspenseState === null) {
                var current2 = fiber.alternate;
                if (current2 !== null) {
                  suspenseState = current2.memoizedState;
                }
              }
              if (suspenseState !== null) {
                return suspenseState.dehydrated;
              }
            }
            return null;
          }
          function getContainerFromFiber(fiber) {
            return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
          }
          function isFiberMounted(fiber) {
            return getNearestMountedFiber(fiber) === fiber;
          }
          function isMounted(component) {
            {
              var owner = ReactCurrentOwner.current;
              if (owner !== null && owner.tag === ClassComponent) {
                var ownerFiber = owner;
                var instance = ownerFiber.stateNode;
                if (!instance._warnedAboutRefsInRender) {
                  error2("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
                }
                instance._warnedAboutRefsInRender = true;
              }
            }
            var fiber = get2(component);
            if (!fiber) {
              return false;
            }
            return getNearestMountedFiber(fiber) === fiber;
          }
          function assertIsMounted(fiber) {
            if (getNearestMountedFiber(fiber) !== fiber) {
              throw new Error("Unable to find node on an unmounted component.");
            }
          }
          function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
              var nearestMounted = getNearestMountedFiber(fiber);
              if (nearestMounted === null) {
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (nearestMounted !== fiber) {
                return null;
              }
              return fiber;
            }
            var a = fiber;
            var b = alternate;
            while (true) {
              var parentA = a.return;
              if (parentA === null) {
                break;
              }
              var parentB = parentA.alternate;
              if (parentB === null) {
                var nextParent = parentA.return;
                if (nextParent !== null) {
                  a = b = nextParent;
                  continue;
                }
                break;
              }
              if (parentA.child === parentB.child) {
                var child = parentA.child;
                while (child) {
                  if (child === a) {
                    assertIsMounted(parentA);
                    return fiber;
                  }
                  if (child === b) {
                    assertIsMounted(parentA);
                    return alternate;
                  }
                  child = child.sibling;
                }
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (a.return !== b.return) {
                a = parentA;
                b = parentB;
              } else {
                var didFindChild = false;
                var _child = parentA.child;
                while (_child) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentA;
                    b = parentB;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentA;
                    a = parentB;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  _child = parentB.child;
                  while (_child) {
                    if (_child === a) {
                      didFindChild = true;
                      a = parentB;
                      b = parentA;
                      break;
                    }
                    if (_child === b) {
                      didFindChild = true;
                      b = parentB;
                      a = parentA;
                      break;
                    }
                    _child = _child.sibling;
                  }
                  if (!didFindChild) {
                    throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                  }
                }
              }
              if (a.alternate !== b) {
                throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (a.tag !== HostRoot) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a.stateNode.current === a) {
              return fiber;
            }
            return alternate;
          }
          function findCurrentHostFiber(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
          }
          function findCurrentHostFiberImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
              return node;
            }
            var child = node.child;
            while (child !== null) {
              var match2 = findCurrentHostFiberImpl(child);
              if (match2 !== null) {
                return match2;
              }
              child = child.sibling;
            }
            return null;
          }
          function findCurrentHostFiberWithNoPortals(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
          }
          function findCurrentHostFiberWithNoPortalsImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
              return node;
            }
            var child = node.child;
            while (child !== null) {
              if (child.tag !== HostPortal) {
                var match2 = findCurrentHostFiberWithNoPortalsImpl(child);
                if (match2 !== null) {
                  return match2;
                }
              }
              child = child.sibling;
            }
            return null;
          }
          var scheduleCallback = Scheduler.unstable_scheduleCallback;
          var cancelCallback = Scheduler.unstable_cancelCallback;
          var shouldYield = Scheduler.unstable_shouldYield;
          var requestPaint = Scheduler.unstable_requestPaint;
          var now2 = Scheduler.unstable_now;
          var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
          var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
          var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
          var NormalPriority = Scheduler.unstable_NormalPriority;
          var LowPriority = Scheduler.unstable_LowPriority;
          var IdlePriority = Scheduler.unstable_IdlePriority;
          var unstable_yieldValue = Scheduler.unstable_yieldValue;
          var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
          var rendererID = null;
          var injectedHook = null;
          var injectedProfilingHooks = null;
          var hasLoggedError = false;
          var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
          function injectInternals(internals) {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
              return false;
            }
            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (hook.isDisabled) {
              return true;
            }
            if (!hook.supportsFiber) {
              {
                error2("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
              }
              return true;
            }
            try {
              if (enableSchedulingProfiler) {
                internals = assign({}, internals, {
                  getLaneLabelMap,
                  injectProfilingHooks
                });
              }
              rendererID = hook.inject(internals);
              injectedHook = hook;
            } catch (err) {
              {
                error2("React instrumentation encountered an error: %s.", err);
              }
            }
            if (hook.checkDCE) {
              return true;
            } else {
              return false;
            }
          }
          function onScheduleRoot(root2, children) {
            {
              if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
                try {
                  injectedHook.onScheduleFiberRoot(rendererID, root2, children);
                } catch (err) {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitRoot(root2, eventPriority) {
            if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
              try {
                var didError = (root2.current.flags & DidCapture) === DidCapture;
                if (enableProfilerTimer) {
                  var schedulerPriority;
                  switch (eventPriority) {
                    case DiscreteEventPriority:
                      schedulerPriority = ImmediatePriority;
                      break;
                    case ContinuousEventPriority:
                      schedulerPriority = UserBlockingPriority;
                      break;
                    case DefaultEventPriority:
                      schedulerPriority = NormalPriority;
                      break;
                    case IdleEventPriority:
                      schedulerPriority = IdlePriority;
                      break;
                    default:
                      schedulerPriority = NormalPriority;
                      break;
                  }
                  injectedHook.onCommitFiberRoot(rendererID, root2, schedulerPriority, didError);
                } else {
                  injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);
                }
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onPostCommitRoot(root2) {
            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, root2);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitUnmount(fiber) {
            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
              try {
                injectedHook.onCommitFiberUnmount(rendererID, fiber);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function setIsStrictModeForDevtools(newIsStrictMode) {
            {
              if (typeof unstable_yieldValue === "function") {
                unstable_setDisableYieldValue(newIsStrictMode);
                setSuppressWarning(newIsStrictMode);
              }
              if (injectedHook && typeof injectedHook.setStrictMode === "function") {
                try {
                  injectedHook.setStrictMode(rendererID, newIsStrictMode);
                } catch (err) {
                  {
                    if (!hasLoggedError) {
                      hasLoggedError = true;
                      error2("React instrumentation encountered an error: %s", err);
                    }
                  }
                }
              }
            }
          }
          function injectProfilingHooks(profilingHooks) {
            injectedProfilingHooks = profilingHooks;
          }
          function getLaneLabelMap() {
            {
              var map = /* @__PURE__ */ new Map();
              var lane = 1;
              for (var index2 = 0; index2 < TotalLanes; index2++) {
                var label = getLabelForLane(lane);
                map.set(lane, label);
                lane *= 2;
              }
              return map;
            }
          }
          function markCommitStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
                injectedProfilingHooks.markCommitStarted(lanes);
              }
            }
          }
          function markCommitStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
                injectedProfilingHooks.markCommitStopped();
              }
            }
          }
          function markComponentRenderStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
                injectedProfilingHooks.markComponentRenderStarted(fiber);
              }
            }
          }
          function markComponentRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
                injectedProfilingHooks.markComponentRenderStopped();
              }
            }
          }
          function markComponentPassiveEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStopped();
              }
            }
          }
          function markComponentPassiveEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
              }
            }
          }
          function markComponentLayoutEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStopped();
              }
            }
          }
          function markComponentLayoutEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
              }
            }
          }
          function markComponentErrored(fiber, thrownValue, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
                injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
              }
            }
          }
          function markComponentSuspended(fiber, wakeable, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
                injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
              }
            }
          }
          function markLayoutEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
                injectedProfilingHooks.markLayoutEffectsStarted(lanes);
              }
            }
          }
          function markLayoutEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
                injectedProfilingHooks.markLayoutEffectsStopped();
              }
            }
          }
          function markPassiveEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
                injectedProfilingHooks.markPassiveEffectsStarted(lanes);
              }
            }
          }
          function markPassiveEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
                injectedProfilingHooks.markPassiveEffectsStopped();
              }
            }
          }
          function markRenderStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
                injectedProfilingHooks.markRenderStarted(lanes);
              }
            }
          }
          function markRenderYielded() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
                injectedProfilingHooks.markRenderYielded();
              }
            }
          }
          function markRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
                injectedProfilingHooks.markRenderStopped();
              }
            }
          }
          function markRenderScheduled(lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
                injectedProfilingHooks.markRenderScheduled(lane);
              }
            }
          }
          function markForceUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
                injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
              }
            }
          }
          function markStateUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
                injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
              }
            }
          }
          var NoMode = (
            /*                         */
            0
          );
          var ConcurrentMode = (
            /*                 */
            1
          );
          var ProfileMode = (
            /*                    */
            2
          );
          var StrictLegacyMode = (
            /*               */
            8
          );
          var StrictEffectsMode = (
            /*              */
            16
          );
          var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
          var log = Math.log;
          var LN2 = Math.LN2;
          function clz32Fallback(x) {
            var asUint = x >>> 0;
            if (asUint === 0) {
              return 32;
            }
            return 31 - (log(asUint) / LN2 | 0) | 0;
          }
          var TotalLanes = 31;
          var NoLanes = (
            /*                        */
            0
          );
          var NoLane = (
            /*                          */
            0
          );
          var SyncLane = (
            /*                        */
            1
          );
          var InputContinuousHydrationLane = (
            /*    */
            2
          );
          var InputContinuousLane = (
            /*             */
            4
          );
          var DefaultHydrationLane = (
            /*            */
            8
          );
          var DefaultLane = (
            /*                     */
            16
          );
          var TransitionHydrationLane = (
            /*                */
            32
          );
          var TransitionLanes = (
            /*                       */
            4194240
          );
          var TransitionLane1 = (
            /*                        */
            64
          );
          var TransitionLane2 = (
            /*                        */
            128
          );
          var TransitionLane3 = (
            /*                        */
            256
          );
          var TransitionLane4 = (
            /*                        */
            512
          );
          var TransitionLane5 = (
            /*                        */
            1024
          );
          var TransitionLane6 = (
            /*                        */
            2048
          );
          var TransitionLane7 = (
            /*                        */
            4096
          );
          var TransitionLane8 = (
            /*                        */
            8192
          );
          var TransitionLane9 = (
            /*                        */
            16384
          );
          var TransitionLane10 = (
            /*                       */
            32768
          );
          var TransitionLane11 = (
            /*                       */
            65536
          );
          var TransitionLane12 = (
            /*                       */
            131072
          );
          var TransitionLane13 = (
            /*                       */
            262144
          );
          var TransitionLane14 = (
            /*                       */
            524288
          );
          var TransitionLane15 = (
            /*                       */
            1048576
          );
          var TransitionLane16 = (
            /*                       */
            2097152
          );
          var RetryLanes = (
            /*                            */
            130023424
          );
          var RetryLane1 = (
            /*                             */
            4194304
          );
          var RetryLane2 = (
            /*                             */
            8388608
          );
          var RetryLane3 = (
            /*                             */
            16777216
          );
          var RetryLane4 = (
            /*                             */
            33554432
          );
          var RetryLane5 = (
            /*                             */
            67108864
          );
          var SomeRetryLane = RetryLane1;
          var SelectiveHydrationLane = (
            /*          */
            134217728
          );
          var NonIdleLanes = (
            /*                          */
            268435455
          );
          var IdleHydrationLane = (
            /*               */
            268435456
          );
          var IdleLane = (
            /*                        */
            536870912
          );
          var OffscreenLane = (
            /*                   */
            1073741824
          );
          function getLabelForLane(lane) {
            {
              if (lane & SyncLane) {
                return "Sync";
              }
              if (lane & InputContinuousHydrationLane) {
                return "InputContinuousHydration";
              }
              if (lane & InputContinuousLane) {
                return "InputContinuous";
              }
              if (lane & DefaultHydrationLane) {
                return "DefaultHydration";
              }
              if (lane & DefaultLane) {
                return "Default";
              }
              if (lane & TransitionHydrationLane) {
                return "TransitionHydration";
              }
              if (lane & TransitionLanes) {
                return "Transition";
              }
              if (lane & RetryLanes) {
                return "Retry";
              }
              if (lane & SelectiveHydrationLane) {
                return "SelectiveHydration";
              }
              if (lane & IdleHydrationLane) {
                return "IdleHydration";
              }
              if (lane & IdleLane) {
                return "Idle";
              }
              if (lane & OffscreenLane) {
                return "Offscreen";
              }
            }
          }
          var NoTimestamp = -1;
          var nextTransitionLane = TransitionLane1;
          var nextRetryLane = RetryLane1;
          function getHighestPriorityLanes(lanes) {
            switch (getHighestPriorityLane(lanes)) {
              case SyncLane:
                return SyncLane;
              case InputContinuousHydrationLane:
                return InputContinuousHydrationLane;
              case InputContinuousLane:
                return InputContinuousLane;
              case DefaultHydrationLane:
                return DefaultHydrationLane;
              case DefaultLane:
                return DefaultLane;
              case TransitionHydrationLane:
                return TransitionHydrationLane;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return lanes & TransitionLanes;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return lanes & RetryLanes;
              case SelectiveHydrationLane:
                return SelectiveHydrationLane;
              case IdleHydrationLane:
                return IdleHydrationLane;
              case IdleLane:
                return IdleLane;
              case OffscreenLane:
                return OffscreenLane;
              default:
                {
                  error2("Should have found matching lanes. This is a bug in React.");
                }
                return lanes;
            }
          }
          function getNextLanes(root2, wipLanes) {
            var pendingLanes = root2.pendingLanes;
            if (pendingLanes === NoLanes) {
              return NoLanes;
            }
            var nextLanes = NoLanes;
            var suspendedLanes = root2.suspendedLanes;
            var pingedLanes = root2.pingedLanes;
            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
            if (nonIdlePendingLanes !== NoLanes) {
              var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
              if (nonIdleUnblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
              } else {
                var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                if (nonIdlePingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                }
              }
            } else {
              var unblockedLanes = pendingLanes & ~suspendedLanes;
              if (unblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(unblockedLanes);
              } else {
                if (pingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(pingedLanes);
                }
              }
            }
            if (nextLanes === NoLanes) {
              return NoLanes;
            }
            if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
            // bother waiting until the root is complete.
            (wipLanes & suspendedLanes) === NoLanes) {
              var nextLane = getHighestPriorityLane(nextLanes);
              var wipLane = getHighestPriorityLane(wipLanes);
              if (
                // Tests whether the next lane is equal or lower priority than the wip
                // one. This works because the bits decrease in priority as you go left.
                nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
                // only difference between default updates and transition updates is that
                // default updates do not support refresh transitions.
                nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
              ) {
                return wipLanes;
              }
            }
            if ((nextLanes & InputContinuousLane) !== NoLanes) {
              nextLanes |= pendingLanes & DefaultLane;
            }
            var entangledLanes = root2.entangledLanes;
            if (entangledLanes !== NoLanes) {
              var entanglements = root2.entanglements;
              var lanes = nextLanes & entangledLanes;
              while (lanes > 0) {
                var index2 = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index2;
                nextLanes |= entanglements[index2];
                lanes &= ~lane;
              }
            }
            return nextLanes;
          }
          function getMostRecentEventTime(root2, lanes) {
            var eventTimes = root2.eventTimes;
            var mostRecentEventTime = NoTimestamp;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              var eventTime = eventTimes[index2];
              if (eventTime > mostRecentEventTime) {
                mostRecentEventTime = eventTime;
              }
              lanes &= ~lane;
            }
            return mostRecentEventTime;
          }
          function computeExpirationTime(lane, currentTime) {
            switch (lane) {
              case SyncLane:
              case InputContinuousHydrationLane:
              case InputContinuousLane:
                return currentTime + 250;
              case DefaultHydrationLane:
              case DefaultLane:
              case TransitionHydrationLane:
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return currentTime + 5e3;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return NoTimestamp;
              case SelectiveHydrationLane:
              case IdleHydrationLane:
              case IdleLane:
              case OffscreenLane:
                return NoTimestamp;
              default:
                {
                  error2("Should have found matching lanes. This is a bug in React.");
                }
                return NoTimestamp;
            }
          }
          function markStarvedLanesAsExpired(root2, currentTime) {
            var pendingLanes = root2.pendingLanes;
            var suspendedLanes = root2.suspendedLanes;
            var pingedLanes = root2.pingedLanes;
            var expirationTimes = root2.expirationTimes;
            var lanes = pendingLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              var expirationTime = expirationTimes[index2];
              if (expirationTime === NoTimestamp) {
                if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                  expirationTimes[index2] = computeExpirationTime(lane, currentTime);
                }
              } else if (expirationTime <= currentTime) {
                root2.expiredLanes |= lane;
              }
              lanes &= ~lane;
            }
          }
          function getHighestPriorityPendingLanes(root2) {
            return getHighestPriorityLanes(root2.pendingLanes);
          }
          function getLanesToRetrySynchronouslyOnError(root2) {
            var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
            if (everythingButOffscreen !== NoLanes) {
              return everythingButOffscreen;
            }
            if (everythingButOffscreen & OffscreenLane) {
              return OffscreenLane;
            }
            return NoLanes;
          }
          function includesSyncLane(lanes) {
            return (lanes & SyncLane) !== NoLanes;
          }
          function includesNonIdleWork(lanes) {
            return (lanes & NonIdleLanes) !== NoLanes;
          }
          function includesOnlyRetries(lanes) {
            return (lanes & RetryLanes) === lanes;
          }
          function includesOnlyNonUrgentLanes(lanes) {
            var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
            return (lanes & UrgentLanes) === NoLanes;
          }
          function includesOnlyTransitions(lanes) {
            return (lanes & TransitionLanes) === lanes;
          }
          function includesBlockingLane(root2, lanes) {
            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
            return (lanes & SyncDefaultLanes) !== NoLanes;
          }
          function includesExpiredLane(root2, lanes) {
            return (lanes & root2.expiredLanes) !== NoLanes;
          }
          function isTransitionLane(lane) {
            return (lane & TransitionLanes) !== NoLanes;
          }
          function claimNextTransitionLane() {
            var lane = nextTransitionLane;
            nextTransitionLane <<= 1;
            if ((nextTransitionLane & TransitionLanes) === NoLanes) {
              nextTransitionLane = TransitionLane1;
            }
            return lane;
          }
          function claimNextRetryLane() {
            var lane = nextRetryLane;
            nextRetryLane <<= 1;
            if ((nextRetryLane & RetryLanes) === NoLanes) {
              nextRetryLane = RetryLane1;
            }
            return lane;
          }
          function getHighestPriorityLane(lanes) {
            return lanes & -lanes;
          }
          function pickArbitraryLane(lanes) {
            return getHighestPriorityLane(lanes);
          }
          function pickArbitraryLaneIndex(lanes) {
            return 31 - clz32(lanes);
          }
          function laneToIndex(lane) {
            return pickArbitraryLaneIndex(lane);
          }
          function includesSomeLane(a, b) {
            return (a & b) !== NoLanes;
          }
          function isSubsetOfLanes(set4, subset) {
            return (set4 & subset) === subset;
          }
          function mergeLanes(a, b) {
            return a | b;
          }
          function removeLanes(set4, subset) {
            return set4 & ~subset;
          }
          function intersectLanes(a, b) {
            return a & b;
          }
          function laneToLanes(lane) {
            return lane;
          }
          function higherPriorityLane(a, b) {
            return a !== NoLane && a < b ? a : b;
          }
          function createLaneMap(initial) {
            var laneMap = [];
            for (var i = 0; i < TotalLanes; i++) {
              laneMap.push(initial);
            }
            return laneMap;
          }
          function markRootUpdated(root2, updateLane, eventTime) {
            root2.pendingLanes |= updateLane;
            if (updateLane !== IdleLane) {
              root2.suspendedLanes = NoLanes;
              root2.pingedLanes = NoLanes;
            }
            var eventTimes = root2.eventTimes;
            var index2 = laneToIndex(updateLane);
            eventTimes[index2] = eventTime;
          }
          function markRootSuspended(root2, suspendedLanes) {
            root2.suspendedLanes |= suspendedLanes;
            root2.pingedLanes &= ~suspendedLanes;
            var expirationTimes = root2.expirationTimes;
            var lanes = suspendedLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              expirationTimes[index2] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootPinged(root2, pingedLanes, eventTime) {
            root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
          }
          function markRootFinished(root2, remainingLanes) {
            var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
            root2.pendingLanes = remainingLanes;
            root2.suspendedLanes = NoLanes;
            root2.pingedLanes = NoLanes;
            root2.expiredLanes &= remainingLanes;
            root2.mutableReadLanes &= remainingLanes;
            root2.entangledLanes &= remainingLanes;
            var entanglements = root2.entanglements;
            var eventTimes = root2.eventTimes;
            var expirationTimes = root2.expirationTimes;
            var lanes = noLongerPendingLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              entanglements[index2] = NoLanes;
              eventTimes[index2] = NoTimestamp;
              expirationTimes[index2] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootEntangled(root2, entangledLanes) {
            var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
            var entanglements = root2.entanglements;
            var lanes = rootEntangledLanes;
            while (lanes) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              if (
                // Is this one of the newly entangled lanes?
                lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
                entanglements[index2] & entangledLanes
              ) {
                entanglements[index2] |= entangledLanes;
              }
              lanes &= ~lane;
            }
          }
          function getBumpedLaneForHydration(root2, renderLanes2) {
            var renderLane = getHighestPriorityLane(renderLanes2);
            var lane;
            switch (renderLane) {
              case InputContinuousLane:
                lane = InputContinuousHydrationLane;
                break;
              case DefaultLane:
                lane = DefaultHydrationLane;
                break;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                lane = TransitionHydrationLane;
                break;
              case IdleLane:
                lane = IdleHydrationLane;
                break;
              default:
                lane = NoLane;
                break;
            }
            if ((lane & (root2.suspendedLanes | renderLanes2)) !== NoLane) {
              return NoLane;
            }
            return lane;
          }
          function addFiberToLanesMap(root2, fiber, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
            while (lanes > 0) {
              var index2 = laneToIndex(lanes);
              var lane = 1 << index2;
              var updaters = pendingUpdatersLaneMap[index2];
              updaters.add(fiber);
              lanes &= ~lane;
            }
          }
          function movePendingFibersToMemoized(root2, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
            var memoizedUpdaters = root2.memoizedUpdaters;
            while (lanes > 0) {
              var index2 = laneToIndex(lanes);
              var lane = 1 << index2;
              var updaters = pendingUpdatersLaneMap[index2];
              if (updaters.size > 0) {
                updaters.forEach(function(fiber) {
                  var alternate = fiber.alternate;
                  if (alternate === null || !memoizedUpdaters.has(alternate)) {
                    memoizedUpdaters.add(fiber);
                  }
                });
                updaters.clear();
              }
              lanes &= ~lane;
            }
          }
          function getTransitionsForLanes(root2, lanes) {
            {
              return null;
            }
          }
          var DiscreteEventPriority = SyncLane;
          var ContinuousEventPriority = InputContinuousLane;
          var DefaultEventPriority = DefaultLane;
          var IdleEventPriority = IdleLane;
          var currentUpdatePriority = NoLane;
          function getCurrentUpdatePriority() {
            return currentUpdatePriority;
          }
          function setCurrentUpdatePriority(newPriority) {
            currentUpdatePriority = newPriority;
          }
          function runWithPriority(priority, fn2) {
            var previousPriority = currentUpdatePriority;
            try {
              currentUpdatePriority = priority;
              return fn2();
            } finally {
              currentUpdatePriority = previousPriority;
            }
          }
          function higherEventPriority(a, b) {
            return a !== 0 && a < b ? a : b;
          }
          function lowerEventPriority(a, b) {
            return a === 0 || a > b ? a : b;
          }
          function isHigherEventPriority(a, b) {
            return a !== 0 && a < b;
          }
          function lanesToEventPriority(lanes) {
            var lane = getHighestPriorityLane(lanes);
            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
              return DiscreteEventPriority;
            }
            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
              return ContinuousEventPriority;
            }
            if (includesNonIdleWork(lane)) {
              return DefaultEventPriority;
            }
            return IdleEventPriority;
          }
          function isRootDehydrated(root2) {
            var currentState = root2.current.memoizedState;
            return currentState.isDehydrated;
          }
          var _attemptSynchronousHydration;
          function setAttemptSynchronousHydration(fn2) {
            _attemptSynchronousHydration = fn2;
          }
          function attemptSynchronousHydration(fiber) {
            _attemptSynchronousHydration(fiber);
          }
          var attemptContinuousHydration;
          function setAttemptContinuousHydration(fn2) {
            attemptContinuousHydration = fn2;
          }
          var attemptHydrationAtCurrentPriority;
          function setAttemptHydrationAtCurrentPriority(fn2) {
            attemptHydrationAtCurrentPriority = fn2;
          }
          var getCurrentUpdatePriority$1;
          function setGetCurrentUpdatePriority(fn2) {
            getCurrentUpdatePriority$1 = fn2;
          }
          var attemptHydrationAtPriority;
          function setAttemptHydrationAtPriority(fn2) {
            attemptHydrationAtPriority = fn2;
          }
          var hasScheduledReplayAttempt = false;
          var queuedDiscreteEvents = [];
          var queuedFocus = null;
          var queuedDrag = null;
          var queuedMouse = null;
          var queuedPointers = /* @__PURE__ */ new Map();
          var queuedPointerCaptures = /* @__PURE__ */ new Map();
          var queuedExplicitHydrationTargets = [];
          var discreteReplayableEvents = [
            "mousedown",
            "mouseup",
            "touchcancel",
            "touchend",
            "touchstart",
            "auxclick",
            "dblclick",
            "pointercancel",
            "pointerdown",
            "pointerup",
            "dragend",
            "dragstart",
            "drop",
            "compositionend",
            "compositionstart",
            "keydown",
            "keypress",
            "keyup",
            "input",
            "textInput",
            // Intentionally camelCase
            "copy",
            "cut",
            "paste",
            "click",
            "change",
            "contextmenu",
            "reset",
            "submit"
          ];
          function isDiscreteEventThatRequiresHydration(eventType) {
            return discreteReplayableEvents.indexOf(eventType) > -1;
          }
          function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            };
          }
          function clearIfContinuousEvent(domEventName, nativeEvent) {
            switch (domEventName) {
              case "focusin":
              case "focusout":
                queuedFocus = null;
                break;
              case "dragenter":
              case "dragleave":
                queuedDrag = null;
                break;
              case "mouseover":
              case "mouseout":
                queuedMouse = null;
                break;
              case "pointerover":
              case "pointerout": {
                var pointerId = nativeEvent.pointerId;
                queuedPointers.delete(pointerId);
                break;
              }
              case "gotpointercapture":
              case "lostpointercapture": {
                var _pointerId = nativeEvent.pointerId;
                queuedPointerCaptures.delete(_pointerId);
                break;
              }
            }
          }
          function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
              var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (blockedOn !== null) {
                var _fiber2 = getInstanceFromNode(blockedOn);
                if (_fiber2 !== null) {
                  attemptContinuousHydration(_fiber2);
                }
              }
              return queuedEvent;
            }
            existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
            var targetContainers = existingQueuedEvent.targetContainers;
            if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
              targetContainers.push(targetContainer);
            }
            return existingQueuedEvent;
          }
          function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            switch (domEventName) {
              case "focusin": {
                var focusEvent = nativeEvent;
                queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
                return true;
              }
              case "dragenter": {
                var dragEvent = nativeEvent;
                queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
                return true;
              }
              case "mouseover": {
                var mouseEvent = nativeEvent;
                queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
                return true;
              }
              case "pointerover": {
                var pointerEvent = nativeEvent;
                var pointerId = pointerEvent.pointerId;
                queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
                return true;
              }
              case "gotpointercapture": {
                var _pointerEvent = nativeEvent;
                var _pointerId2 = _pointerEvent.pointerId;
                queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
                return true;
              }
            }
            return false;
          }
          function attemptExplicitHydrationTarget(queuedTarget) {
            var targetInst = getClosestInstanceFromNode(queuedTarget.target);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted !== null) {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    queuedTarget.blockedOn = instance;
                    attemptHydrationAtPriority(queuedTarget.priority, function() {
                      attemptHydrationAtCurrentPriority(nearestMounted);
                    });
                    return;
                  }
                } else if (tag === HostRoot) {
                  var root2 = nearestMounted.stateNode;
                  if (isRootDehydrated(root2)) {
                    queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                    return;
                  }
                }
              }
            }
            queuedTarget.blockedOn = null;
          }
          function queueExplicitHydrationTarget(target) {
            var updatePriority = getCurrentUpdatePriority$1();
            var queuedTarget = {
              blockedOn: null,
              target,
              priority: updatePriority
            };
            var i = 0;
            for (; i < queuedExplicitHydrationTargets.length; i++) {
              if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority)) {
                break;
              }
            }
            queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);
            if (i === 0) {
              attemptExplicitHydrationTarget(queuedTarget);
            }
          }
          function attemptReplayContinuousQueuedEvent(queuedEvent) {
            if (queuedEvent.blockedOn !== null) {
              return false;
            }
            var targetContainers = queuedEvent.targetContainers;
            while (targetContainers.length > 0) {
              var targetContainer = targetContainers[0];
              var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
              if (nextBlockedOn === null) {
                {
                  var nativeEvent = queuedEvent.nativeEvent;
                  var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                  setReplayingEvent(nativeEventClone);
                  nativeEvent.target.dispatchEvent(nativeEventClone);
                  resetReplayingEvent();
                }
              } else {
                var _fiber3 = getInstanceFromNode(nextBlockedOn);
                if (_fiber3 !== null) {
                  attemptContinuousHydration(_fiber3);
                }
                queuedEvent.blockedOn = nextBlockedOn;
                return false;
              }
              targetContainers.shift();
            }
            return true;
          }
          function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
            if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
              map.delete(key);
            }
          }
          function replayUnblockedEvents() {
            hasScheduledReplayAttempt = false;
            if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
              queuedFocus = null;
            }
            if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
              queuedDrag = null;
            }
            if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
              queuedMouse = null;
            }
            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
          }
          function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
            if (queuedEvent.blockedOn === unblocked) {
              queuedEvent.blockedOn = null;
              if (!hasScheduledReplayAttempt) {
                hasScheduledReplayAttempt = true;
                Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
              }
            }
          }
          function retryIfBlockedOn(unblocked) {
            if (queuedDiscreteEvents.length > 0) {
              scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
              for (var i = 1; i < queuedDiscreteEvents.length; i++) {
                var queuedEvent = queuedDiscreteEvents[i];
                if (queuedEvent.blockedOn === unblocked) {
                  queuedEvent.blockedOn = null;
                }
              }
            }
            if (queuedFocus !== null) {
              scheduleCallbackIfUnblocked(queuedFocus, unblocked);
            }
            if (queuedDrag !== null) {
              scheduleCallbackIfUnblocked(queuedDrag, unblocked);
            }
            if (queuedMouse !== null) {
              scheduleCallbackIfUnblocked(queuedMouse, unblocked);
            }
            var unblock = function(queuedEvent2) {
              return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
            };
            queuedPointers.forEach(unblock);
            queuedPointerCaptures.forEach(unblock);
            for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
              var queuedTarget = queuedExplicitHydrationTargets[_i];
              if (queuedTarget.blockedOn === unblocked) {
                queuedTarget.blockedOn = null;
              }
            }
            while (queuedExplicitHydrationTargets.length > 0) {
              var nextExplicitTarget = queuedExplicitHydrationTargets[0];
              if (nextExplicitTarget.blockedOn !== null) {
                break;
              } else {
                attemptExplicitHydrationTarget(nextExplicitTarget);
                if (nextExplicitTarget.blockedOn === null) {
                  queuedExplicitHydrationTargets.shift();
                }
              }
            }
          }
          var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
          var _enabled = true;
          function setEnabled(enabled) {
            _enabled = !!enabled;
          }
          function isEnabled() {
            return _enabled;
          }
          function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
            var eventPriority = getEventPriority(domEventName);
            var listenerWrapper;
            switch (eventPriority) {
              case DiscreteEventPriority:
                listenerWrapper = dispatchDiscreteEvent;
                break;
              case ContinuousEventPriority:
                listenerWrapper = dispatchContinuousEvent;
                break;
              case DefaultEventPriority:
              default:
                listenerWrapper = dispatchEvent2;
                break;
            }
            return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
          }
          function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(DiscreteEventPriority);
              dispatchEvent2(domEventName, eventSystemFlags, container, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(ContinuousEventPriority);
              dispatchEvent2(domEventName, eventSystemFlags, container, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchEvent2(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (!_enabled) {
              return;
            }
            {
              dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            }
          }
          function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn === null) {
              dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
              clearIfContinuousEvent(domEventName, nativeEvent);
              return;
            }
            if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
              nativeEvent.stopPropagation();
              return;
            }
            clearIfContinuousEvent(domEventName, nativeEvent);
            if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
              while (blockedOn !== null) {
                var fiber = getInstanceFromNode(blockedOn);
                if (fiber !== null) {
                  attemptSynchronousHydration(fiber);
                }
                var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
                if (nextBlockedOn === null) {
                  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
                }
                if (nextBlockedOn === blockedOn) {
                  break;
                }
                blockedOn = nextBlockedOn;
              }
              if (blockedOn !== null) {
                nativeEvent.stopPropagation();
              }
              return;
            }
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
          }
          var return_targetInst = null;
          function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return_targetInst = null;
            var nativeEventTarget = getEventTarget(nativeEvent);
            var targetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted === null) {
                targetInst = null;
              } else {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    return instance;
                  }
                  targetInst = null;
                } else if (tag === HostRoot) {
                  var root2 = nearestMounted.stateNode;
                  if (isRootDehydrated(root2)) {
                    return getContainerFromFiber(nearestMounted);
                  }
                  targetInst = null;
                } else if (nearestMounted !== targetInst) {
                  targetInst = null;
                }
              }
            }
            return_targetInst = targetInst;
            return null;
          }
          function getEventPriority(domEventName) {
            switch (domEventName) {
              case "cancel":
              case "click":
              case "close":
              case "contextmenu":
              case "copy":
              case "cut":
              case "auxclick":
              case "dblclick":
              case "dragend":
              case "dragstart":
              case "drop":
              case "focusin":
              case "focusout":
              case "input":
              case "invalid":
              case "keydown":
              case "keypress":
              case "keyup":
              case "mousedown":
              case "mouseup":
              case "paste":
              case "pause":
              case "play":
              case "pointercancel":
              case "pointerdown":
              case "pointerup":
              case "ratechange":
              case "reset":
              case "resize":
              case "seeked":
              case "submit":
              case "touchcancel":
              case "touchend":
              case "touchstart":
              case "volumechange":
              case "change":
              case "selectionchange":
              case "textInput":
              case "compositionstart":
              case "compositionend":
              case "compositionupdate":
              case "beforeblur":
              case "afterblur":
              case "beforeinput":
              case "blur":
              case "fullscreenchange":
              case "focus":
              case "hashchange":
              case "popstate":
              case "select":
              case "selectstart":
                return DiscreteEventPriority;
              case "drag":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "mousemove":
              case "mouseout":
              case "mouseover":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "scroll":
              case "toggle":
              case "touchmove":
              case "wheel":
              case "mouseenter":
              case "mouseleave":
              case "pointerenter":
              case "pointerleave":
                return ContinuousEventPriority;
              case "message": {
                var schedulerPriority = getCurrentPriorityLevel();
                switch (schedulerPriority) {
                  case ImmediatePriority:
                    return DiscreteEventPriority;
                  case UserBlockingPriority:
                    return ContinuousEventPriority;
                  case NormalPriority:
                  case LowPriority:
                    return DefaultEventPriority;
                  case IdlePriority:
                    return IdleEventPriority;
                  default:
                    return DefaultEventPriority;
                }
              }
              default:
                return DefaultEventPriority;
            }
          }
          function addEventBubbleListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, false);
            return listener;
          }
          function addEventCaptureListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, true);
            return listener;
          }
          function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive2) {
            target.addEventListener(eventType, listener, {
              capture: true,
              passive: passive2
            });
            return listener;
          }
          function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive2) {
            target.addEventListener(eventType, listener, {
              passive: passive2
            });
            return listener;
          }
          var root = null;
          var startText = null;
          var fallbackText = null;
          function initialize(nativeEventTarget) {
            root = nativeEventTarget;
            startText = getText();
            return true;
          }
          function reset() {
            root = null;
            startText = null;
            fallbackText = null;
          }
          function getData() {
            if (fallbackText) {
              return fallbackText;
            }
            var start3;
            var startValue = startText;
            var startLength = startValue.length;
            var end2;
            var endValue = getText();
            var endLength = endValue.length;
            for (start3 = 0; start3 < startLength; start3++) {
              if (startValue[start3] !== endValue[start3]) {
                break;
              }
            }
            var minEnd = startLength - start3;
            for (end2 = 1; end2 <= minEnd; end2++) {
              if (startValue[startLength - end2] !== endValue[endLength - end2]) {
                break;
              }
            }
            var sliceTail = end2 > 1 ? 1 - end2 : void 0;
            fallbackText = endValue.slice(start3, sliceTail);
            return fallbackText;
          }
          function getText() {
            if ("value" in root) {
              return root.value;
            }
            return root.textContent;
          }
          function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;
            if ("charCode" in nativeEvent) {
              charCode = nativeEvent.charCode;
              if (charCode === 0 && keyCode === 13) {
                charCode = 13;
              }
            } else {
              charCode = keyCode;
            }
            if (charCode === 10) {
              charCode = 13;
            }
            if (charCode >= 32 || charCode === 13) {
              return charCode;
            }
            return 0;
          }
          function functionThatReturnsTrue() {
            return true;
          }
          function functionThatReturnsFalse() {
            return false;
          }
          function createSyntheticEvent(Interface) {
            function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
              this._reactName = reactName;
              this._targetInst = targetInst;
              this.type = reactEventType;
              this.nativeEvent = nativeEvent;
              this.target = nativeEventTarget;
              this.currentTarget = null;
              for (var _propName in Interface) {
                if (!Interface.hasOwnProperty(_propName)) {
                  continue;
                }
                var normalize = Interface[_propName];
                if (normalize) {
                  this[_propName] = normalize(nativeEvent);
                } else {
                  this[_propName] = nativeEvent[_propName];
                }
              }
              var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
              if (defaultPrevented) {
                this.isDefaultPrevented = functionThatReturnsTrue;
              } else {
                this.isDefaultPrevented = functionThatReturnsFalse;
              }
              this.isPropagationStopped = functionThatReturnsFalse;
              return this;
            }
            assign(SyntheticBaseEvent.prototype, {
              preventDefault: function() {
                this.defaultPrevented = true;
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.preventDefault) {
                  event.preventDefault();
                } else if (typeof event.returnValue !== "unknown") {
                  event.returnValue = false;
                }
                this.isDefaultPrevented = functionThatReturnsTrue;
              },
              stopPropagation: function() {
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.stopPropagation) {
                  event.stopPropagation();
                } else if (typeof event.cancelBubble !== "unknown") {
                  event.cancelBubble = true;
                }
                this.isPropagationStopped = functionThatReturnsTrue;
              },
              /**
               * We release all dispatched `SyntheticEvent`s after each event loop, adding
               * them back into the pool. This allows a way to hold onto a reference that
               * won't be added back into the pool.
               */
              persist: function() {
              },
              /**
               * Checks if this event should be released back into the pool.
               *
               * @return {boolean} True if this should not be released, false otherwise.
               */
              isPersistent: functionThatReturnsTrue
            });
            return SyntheticBaseEvent;
          }
          var EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(event) {
              return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
          };
          var SyntheticEvent = createSyntheticEvent(EventInterface);
          var UIEventInterface = assign({}, EventInterface, {
            view: 0,
            detail: 0
          });
          var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
          var lastMovementX;
          var lastMovementY;
          var lastMouseEvent;
          function updateMouseMovementPolyfillState(event) {
            if (event !== lastMouseEvent) {
              if (lastMouseEvent && event.type === "mousemove") {
                lastMovementX = event.screenX - lastMouseEvent.screenX;
                lastMovementY = event.screenY - lastMouseEvent.screenY;
              } else {
                lastMovementX = 0;
                lastMovementY = 0;
              }
              lastMouseEvent = event;
            }
          }
          var MouseEventInterface = assign({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function(event) {
              if (event.relatedTarget === void 0)
                return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
              return event.relatedTarget;
            },
            movementX: function(event) {
              if ("movementX" in event) {
                return event.movementX;
              }
              updateMouseMovementPolyfillState(event);
              return lastMovementX;
            },
            movementY: function(event) {
              if ("movementY" in event) {
                return event.movementY;
              }
              return lastMovementY;
            }
          });
          var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
          var DragEventInterface = assign({}, MouseEventInterface, {
            dataTransfer: 0
          });
          var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
          var FocusEventInterface = assign({}, UIEventInterface, {
            relatedTarget: 0
          });
          var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
          var AnimationEventInterface = assign({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
          var ClipboardEventInterface = assign({}, EventInterface, {
            clipboardData: function(event) {
              return "clipboardData" in event ? event.clipboardData : window.clipboardData;
            }
          });
          var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
          var CompositionEventInterface = assign({}, EventInterface, {
            data: 0
          });
          var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
          var SyntheticInputEvent = SyntheticCompositionEvent;
          var normalizeKey = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          };
          var translateToKey = {
            "8": "Backspace",
            "9": "Tab",
            "12": "Clear",
            "13": "Enter",
            "16": "Shift",
            "17": "Control",
            "18": "Alt",
            "19": "Pause",
            "20": "CapsLock",
            "27": "Escape",
            "32": " ",
            "33": "PageUp",
            "34": "PageDown",
            "35": "End",
            "36": "Home",
            "37": "ArrowLeft",
            "38": "ArrowUp",
            "39": "ArrowRight",
            "40": "ArrowDown",
            "45": "Insert",
            "46": "Delete",
            "112": "F1",
            "113": "F2",
            "114": "F3",
            "115": "F4",
            "116": "F5",
            "117": "F6",
            "118": "F7",
            "119": "F8",
            "120": "F9",
            "121": "F10",
            "122": "F11",
            "123": "F12",
            "144": "NumLock",
            "145": "ScrollLock",
            "224": "Meta"
          };
          function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if (key !== "Unidentified") {
                return key;
              }
            }
            if (nativeEvent.type === "keypress") {
              var charCode = getEventCharCode(nativeEvent);
              return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
              return translateToKey[nativeEvent.keyCode] || "Unidentified";
            }
            return "";
          }
          var modifierKeyToProp = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          };
          function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
              return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
          }
          function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
          }
          var KeyboardEventInterface = assign({}, UIEventInterface, {
            key: getEventKey,
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            // Legacy Interface
            charCode: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              return 0;
            },
            keyCode: function(event) {
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            },
            which: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            }
          });
          var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
          var PointerEventInterface = assign({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
          });
          var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
          var TouchEventInterface = assign({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState
          });
          var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
          var TransitionEventInterface = assign({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
          var WheelEventInterface = assign({}, MouseEventInterface, {
            deltaX: function(event) {
              return "deltaX" in event ? event.deltaX : (
                // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
                "wheelDeltaX" in event ? -event.wheelDeltaX : 0
              );
            },
            deltaY: function(event) {
              return "deltaY" in event ? event.deltaY : (
                // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
                "wheelDeltaY" in event ? -event.wheelDeltaY : (
                  // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
                  "wheelDelta" in event ? -event.wheelDelta : 0
                )
              );
            },
            deltaZ: 0,
            // Browsers without "deltaMode" is reporting in raw wheel delta where one
            // notch on the scroll is always +/- 120, roughly equivalent to pixels.
            // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
            // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
            deltaMode: 0
          });
          var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
          var END_KEYCODES = [9, 13, 27, 32];
          var START_KEYCODE = 229;
          var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
          var documentMode = null;
          if (canUseDOM && "documentMode" in document) {
            documentMode = document.documentMode;
          }
          var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
          var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
          var SPACEBAR_CODE = 32;
          var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
          function registerEvents() {
            registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
            registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          }
          var hasSpaceKeypress = false;
          function isKeypressCommand(nativeEvent) {
            return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
            !(nativeEvent.ctrlKey && nativeEvent.altKey);
          }
          function getCompositionEventType(domEventName) {
            switch (domEventName) {
              case "compositionstart":
                return "onCompositionStart";
              case "compositionend":
                return "onCompositionEnd";
              case "compositionupdate":
                return "onCompositionUpdate";
            }
          }
          function isFallbackCompositionStart(domEventName, nativeEvent) {
            return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
          }
          function isFallbackCompositionEnd(domEventName, nativeEvent) {
            switch (domEventName) {
              case "keyup":
                return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
              case "keydown":
                return nativeEvent.keyCode !== START_KEYCODE;
              case "keypress":
              case "mousedown":
              case "focusout":
                return true;
              default:
                return false;
            }
          }
          function getDataFromCustomEvent(nativeEvent) {
            var detail = nativeEvent.detail;
            if (typeof detail === "object" && "data" in detail) {
              return detail.data;
            }
            return null;
          }
          function isUsingKoreanIME(nativeEvent) {
            return nativeEvent.locale === "ko";
          }
          var isComposing = false;
          function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var eventType;
            var fallbackData;
            if (canUseCompositionEvent) {
              eventType = getCompositionEventType(domEventName);
            } else if (!isComposing) {
              if (isFallbackCompositionStart(domEventName, nativeEvent)) {
                eventType = "onCompositionStart";
              }
            } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
              eventType = "onCompositionEnd";
            }
            if (!eventType) {
              return null;
            }
            if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
              if (!isComposing && eventType === "onCompositionStart") {
                isComposing = initialize(nativeEventTarget);
              } else if (eventType === "onCompositionEnd") {
                if (isComposing) {
                  fallbackData = getData();
                }
              }
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
            if (listeners.length > 0) {
              var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              if (fallbackData) {
                event.data = fallbackData;
              } else {
                var customData = getDataFromCustomEvent(nativeEvent);
                if (customData !== null) {
                  event.data = customData;
                }
              }
            }
          }
          function getNativeBeforeInputChars(domEventName, nativeEvent) {
            switch (domEventName) {
              case "compositionend":
                return getDataFromCustomEvent(nativeEvent);
              case "keypress":
                var which = nativeEvent.which;
                if (which !== SPACEBAR_CODE) {
                  return null;
                }
                hasSpaceKeypress = true;
                return SPACEBAR_CHAR;
              case "textInput":
                var chars = nativeEvent.data;
                if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                  return null;
                }
                return chars;
              default:
                return null;
            }
          }
          function getFallbackBeforeInputChars(domEventName, nativeEvent) {
            if (isComposing) {
              if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
                var chars = getData();
                reset();
                isComposing = false;
                return chars;
              }
              return null;
            }
            switch (domEventName) {
              case "paste":
                return null;
              case "keypress":
                if (!isKeypressCommand(nativeEvent)) {
                  if (nativeEvent.char && nativeEvent.char.length > 1) {
                    return nativeEvent.char;
                  } else if (nativeEvent.which) {
                    return String.fromCharCode(nativeEvent.which);
                  }
                }
                return null;
              case "compositionend":
                return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
              default:
                return null;
            }
          }
          function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var chars;
            if (canUseTextInputEvent) {
              chars = getNativeBeforeInputChars(domEventName, nativeEvent);
            } else {
              chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
            }
            if (!chars) {
              return null;
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
            if (listeners.length > 0) {
              var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.data = chars;
            }
          }
          function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
          var supportedInputTypes = {
            color: true,
            date: true,
            datetime: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
          };
          function isTextInputElement(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            if (nodeName === "input") {
              return !!supportedInputTypes[elem.type];
            }
            if (nodeName === "textarea") {
              return true;
            }
            return false;
          }
          function isEventSupported(eventNameSuffix) {
            if (!canUseDOM) {
              return false;
            }
            var eventName = "on" + eventNameSuffix;
            var isSupported = eventName in document;
            if (!isSupported) {
              var element = document.createElement("div");
              element.setAttribute(eventName, "return;");
              isSupported = typeof element[eventName] === "function";
            }
            return isSupported;
          }
          function registerEvents$1() {
            registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
          }
          function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
            enqueueStateRestore(target);
            var listeners = accumulateTwoPhaseListeners(inst, "onChange");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          var activeElement = null;
          var activeElementInst = null;
          function shouldUseChangeEvent(elem) {
            var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName === "select" || nodeName === "input" && elem.type === "file";
          }
          function manualDispatchChangeEvent(nativeEvent) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
            batchedUpdates(runEventInBatch, dispatchQueue);
          }
          function runEventInBatch(dispatchQueue) {
            processDispatchQueue(dispatchQueue, 0);
          }
          function getInstIfValueChanged(targetInst) {
            var targetNode = getNodeFromInstance(targetInst);
            if (updateValueIfChanged(targetNode)) {
              return targetInst;
            }
          }
          function getTargetInstForChangeEvent(domEventName, targetInst) {
            if (domEventName === "change") {
              return targetInst;
            }
          }
          var isInputEventSupported = false;
          if (canUseDOM) {
            isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
          }
          function startWatchingForValueChange(target, targetInst) {
            activeElement = target;
            activeElementInst = targetInst;
            activeElement.attachEvent("onpropertychange", handlePropertyChange);
          }
          function stopWatchingForValueChange() {
            if (!activeElement) {
              return;
            }
            activeElement.detachEvent("onpropertychange", handlePropertyChange);
            activeElement = null;
            activeElementInst = null;
          }
          function handlePropertyChange(nativeEvent) {
            if (nativeEvent.propertyName !== "value") {
              return;
            }
            if (getInstIfValueChanged(activeElementInst)) {
              manualDispatchChangeEvent(nativeEvent);
            }
          }
          function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
            if (domEventName === "focusin") {
              stopWatchingForValueChange();
              startWatchingForValueChange(target, targetInst);
            } else if (domEventName === "focusout") {
              stopWatchingForValueChange();
            }
          }
          function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
            if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
              return getInstIfValueChanged(activeElementInst);
            }
          }
          function shouldUseClickEvent(elem) {
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
          }
          function getTargetInstForClickEvent(domEventName, targetInst) {
            if (domEventName === "click") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
            if (domEventName === "input" || domEventName === "change") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function handleControlledInputBlur(node) {
            var state = node._wrapperState;
            if (!state || !state.controlled || node.type !== "number") {
              return;
            }
            {
              setDefaultValue(node, "number", node.value);
            }
          }
          function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            var getTargetInstFunc, handleEventFunc;
            if (shouldUseChangeEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForChangeEvent;
            } else if (isTextInputElement(targetNode)) {
              if (isInputEventSupported) {
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              } else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                handleEventFunc = handleEventsForInputEventPolyfill;
              }
            } else if (shouldUseClickEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForClickEvent;
            }
            if (getTargetInstFunc) {
              var inst = getTargetInstFunc(domEventName, targetInst);
              if (inst) {
                createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
                return;
              }
            }
            if (handleEventFunc) {
              handleEventFunc(domEventName, targetNode, targetInst);
            }
            if (domEventName === "focusout") {
              handleControlledInputBlur(targetNode);
            }
          }
          function registerEvents$2() {
            registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
            registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
            registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
            registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
          }
          function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
            var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
            if (isOverEvent && !isReplayingEvent(nativeEvent)) {
              var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
              if (related) {
                if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                  return;
                }
              }
            }
            if (!isOutEvent && !isOverEvent) {
              return;
            }
            var win;
            if (nativeEventTarget.window === nativeEventTarget) {
              win = nativeEventTarget;
            } else {
              var doc = nativeEventTarget.ownerDocument;
              if (doc) {
                win = doc.defaultView || doc.parentWindow;
              } else {
                win = window;
              }
            }
            var from;
            var to;
            if (isOutEvent) {
              var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
              from = targetInst;
              to = _related ? getClosestInstanceFromNode(_related) : null;
              if (to !== null) {
                var nearestMounted = getNearestMountedFiber(to);
                if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
                  to = null;
                }
              }
            } else {
              from = null;
              to = targetInst;
            }
            if (from === to) {
              return;
            }
            var SyntheticEventCtor = SyntheticMouseEvent;
            var leaveEventType = "onMouseLeave";
            var enterEventType = "onMouseEnter";
            var eventTypePrefix = "mouse";
            if (domEventName === "pointerout" || domEventName === "pointerover") {
              SyntheticEventCtor = SyntheticPointerEvent;
              leaveEventType = "onPointerLeave";
              enterEventType = "onPointerEnter";
              eventTypePrefix = "pointer";
            }
            var fromNode = from == null ? win : getNodeFromInstance(from);
            var toNode = to == null ? win : getNodeFromInstance(to);
            var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from, nativeEvent, nativeEventTarget);
            leave.target = fromNode;
            leave.relatedTarget = toNode;
            var enter = null;
            var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (nativeTargetInst === targetInst) {
              var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
              enterEvent.target = toNode;
              enterEvent.relatedTarget = fromNode;
              enter = enterEvent;
            }
            accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
          }
          function is2(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is2;
          function shallowEqual5(objA, objB) {
            if (objectIs(objA, objB)) {
              return true;
            }
            if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
              return false;
            }
            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) {
              return false;
            }
            for (var i = 0; i < keysA.length; i++) {
              var currentKey = keysA[i];
              if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
                return false;
              }
            }
            return true;
          }
          function getLeafNode(node) {
            while (node && node.firstChild) {
              node = node.firstChild;
            }
            return node;
          }
          function getSiblingNode(node) {
            while (node) {
              if (node.nextSibling) {
                return node.nextSibling;
              }
              node = node.parentNode;
            }
          }
          function getNodeForCharacterOffset(root2, offset2) {
            var node = getLeafNode(root2);
            var nodeStart = 0;
            var nodeEnd = 0;
            while (node) {
              if (node.nodeType === TEXT_NODE) {
                nodeEnd = nodeStart + node.textContent.length;
                if (nodeStart <= offset2 && nodeEnd >= offset2) {
                  return {
                    node,
                    offset: offset2 - nodeStart
                  };
                }
                nodeStart = nodeEnd;
              }
              node = getLeafNode(getSiblingNode(node));
            }
          }
          function getOffsets(outerNode) {
            var ownerDocument = outerNode.ownerDocument;
            var win = ownerDocument && ownerDocument.defaultView || window;
            var selection = win.getSelection && win.getSelection();
            if (!selection || selection.rangeCount === 0) {
              return null;
            }
            var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
            try {
              anchorNode.nodeType;
              focusNode.nodeType;
            } catch (e) {
              return null;
            }
            return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
          }
          function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
            var length = 0;
            var start3 = -1;
            var end2 = -1;
            var indexWithinAnchor = 0;
            var indexWithinFocus = 0;
            var node = outerNode;
            var parentNode = null;
            outer:
              while (true) {
                var next = null;
                while (true) {
                  if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                    start3 = length + anchorOffset;
                  }
                  if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                    end2 = length + focusOffset;
                  }
                  if (node.nodeType === TEXT_NODE) {
                    length += node.nodeValue.length;
                  }
                  if ((next = node.firstChild) === null) {
                    break;
                  }
                  parentNode = node;
                  node = next;
                }
                while (true) {
                  if (node === outerNode) {
                    break outer;
                  }
                  if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                    start3 = length;
                  }
                  if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                    end2 = length;
                  }
                  if ((next = node.nextSibling) !== null) {
                    break;
                  }
                  node = parentNode;
                  parentNode = node.parentNode;
                }
                node = next;
              }
            if (start3 === -1 || end2 === -1) {
              return null;
            }
            return {
              start: start3,
              end: end2
            };
          }
          function setOffsets(node, offsets) {
            var doc = node.ownerDocument || document;
            var win = doc && doc.defaultView || window;
            if (!win.getSelection) {
              return;
            }
            var selection = win.getSelection();
            var length = node.textContent.length;
            var start3 = Math.min(offsets.start, length);
            var end2 = offsets.end === void 0 ? start3 : Math.min(offsets.end, length);
            if (!selection.extend && start3 > end2) {
              var temp = end2;
              end2 = start3;
              start3 = temp;
            }
            var startMarker = getNodeForCharacterOffset(node, start3);
            var endMarker = getNodeForCharacterOffset(node, end2);
            if (startMarker && endMarker) {
              if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
                return;
              }
              var range3 = doc.createRange();
              range3.setStart(startMarker.node, startMarker.offset);
              selection.removeAllRanges();
              if (start3 > end2) {
                selection.addRange(range3);
                selection.extend(endMarker.node, endMarker.offset);
              } else {
                range3.setEnd(endMarker.node, endMarker.offset);
                selection.addRange(range3);
              }
            }
          }
          function isTextNode(node) {
            return node && node.nodeType === TEXT_NODE;
          }
          function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
              return false;
            } else if (outerNode === innerNode) {
              return true;
            } else if (isTextNode(outerNode)) {
              return false;
            } else if (isTextNode(innerNode)) {
              return containsNode(outerNode, innerNode.parentNode);
            } else if ("contains" in outerNode) {
              return outerNode.contains(innerNode);
            } else if (outerNode.compareDocumentPosition) {
              return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            } else {
              return false;
            }
          }
          function isInDocument(node) {
            return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
          }
          function isSameOriginFrame(iframe) {
            try {
              return typeof iframe.contentWindow.location.href === "string";
            } catch (err) {
              return false;
            }
          }
          function getActiveElementDeep() {
            var win = window;
            var element = getActiveElement();
            while (element instanceof win.HTMLIFrameElement) {
              if (isSameOriginFrame(element)) {
                win = element.contentWindow;
              } else {
                return element;
              }
              element = getActiveElement(win.document);
            }
            return element;
          }
          function hasSelectionCapabilities(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
          }
          function getSelectionInformation() {
            var focusedElem = getActiveElementDeep();
            return {
              focusedElem,
              selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
            };
          }
          function restoreSelection(priorSelectionInformation) {
            var curFocusedElem = getActiveElementDeep();
            var priorFocusedElem = priorSelectionInformation.focusedElem;
            var priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
              if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
                setSelection(priorFocusedElem, priorSelectionRange);
              }
              var ancestors = [];
              var ancestor = priorFocusedElem;
              while (ancestor = ancestor.parentNode) {
                if (ancestor.nodeType === ELEMENT_NODE) {
                  ancestors.push({
                    element: ancestor,
                    left: ancestor.scrollLeft,
                    top: ancestor.scrollTop
                  });
                }
              }
              if (typeof priorFocusedElem.focus === "function") {
                priorFocusedElem.focus();
              }
              for (var i = 0; i < ancestors.length; i++) {
                var info = ancestors[i];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
          }
          function getSelection(input) {
            var selection;
            if ("selectionStart" in input) {
              selection = {
                start: input.selectionStart,
                end: input.selectionEnd
              };
            } else {
              selection = getOffsets(input);
            }
            return selection || {
              start: 0,
              end: 0
            };
          }
          function setSelection(input, offsets) {
            var start3 = offsets.start;
            var end2 = offsets.end;
            if (end2 === void 0) {
              end2 = start3;
            }
            if ("selectionStart" in input) {
              input.selectionStart = start3;
              input.selectionEnd = Math.min(end2, input.value.length);
            } else {
              setOffsets(input, offsets);
            }
          }
          var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
          function registerEvents$3() {
            registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
          }
          var activeElement$1 = null;
          var activeElementInst$1 = null;
          var lastSelection = null;
          var mouseDown = false;
          function getSelection$1(node) {
            if ("selectionStart" in node && hasSelectionCapabilities(node)) {
              return {
                start: node.selectionStart,
                end: node.selectionEnd
              };
            } else {
              var win = node.ownerDocument && node.ownerDocument.defaultView || window;
              var selection = win.getSelection();
              return {
                anchorNode: selection.anchorNode,
                anchorOffset: selection.anchorOffset,
                focusNode: selection.focusNode,
                focusOffset: selection.focusOffset
              };
            }
          }
          function getEventTargetDocument(eventTarget) {
            return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
          }
          function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
            var doc = getEventTargetDocument(nativeEventTarget);
            if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
              return;
            }
            var currentSelection = getSelection$1(activeElement$1);
            if (!lastSelection || !shallowEqual5(lastSelection, currentSelection)) {
              lastSelection = currentSelection;
              var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
              if (listeners.length > 0) {
                var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event,
                  listeners
                });
                event.target = activeElement$1;
              }
            }
          }
          function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                  activeElement$1 = targetNode;
                  activeElementInst$1 = targetInst;
                  lastSelection = null;
                }
                break;
              case "focusout":
                activeElement$1 = null;
                activeElementInst$1 = null;
                lastSelection = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) {
                  break;
                }
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
          }
          function makePrefixMap(styleProp, eventName) {
            var prefixes2 = {};
            prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
            prefixes2["Webkit" + styleProp] = "webkit" + eventName;
            prefixes2["Moz" + styleProp] = "moz" + eventName;
            return prefixes2;
          }
          var vendorPrefixes = {
            animationend: makePrefixMap("Animation", "AnimationEnd"),
            animationiteration: makePrefixMap("Animation", "AnimationIteration"),
            animationstart: makePrefixMap("Animation", "AnimationStart"),
            transitionend: makePrefixMap("Transition", "TransitionEnd")
          };
          var prefixedEventNames = {};
          var style = {};
          if (canUseDOM) {
            style = document.createElement("div").style;
            if (!("AnimationEvent" in window)) {
              delete vendorPrefixes.animationend.animation;
              delete vendorPrefixes.animationiteration.animation;
              delete vendorPrefixes.animationstart.animation;
            }
            if (!("TransitionEvent" in window)) {
              delete vendorPrefixes.transitionend.transition;
            }
          }
          function getVendorPrefixedEventName(eventName) {
            if (prefixedEventNames[eventName]) {
              return prefixedEventNames[eventName];
            } else if (!vendorPrefixes[eventName]) {
              return eventName;
            }
            var prefixMap = vendorPrefixes[eventName];
            for (var styleProp in prefixMap) {
              if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
                return prefixedEventNames[eventName] = prefixMap[styleProp];
              }
            }
            return eventName;
          }
          var ANIMATION_END = getVendorPrefixedEventName("animationend");
          var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
          var ANIMATION_START = getVendorPrefixedEventName("animationstart");
          var TRANSITION_END2 = getVendorPrefixedEventName("transitionend");
          var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
          var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
          function registerSimpleEvent(domEventName, reactName) {
            topLevelEventsToReactNames.set(domEventName, reactName);
            registerTwoPhaseEvent(reactName, [domEventName]);
          }
          function registerSimpleEvents() {
            for (var i = 0; i < simpleEventPluginEvents.length; i++) {
              var eventName = simpleEventPluginEvents[i];
              var domEventName = eventName.toLowerCase();
              var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
              registerSimpleEvent(domEventName, "on" + capitalizedEvent);
            }
            registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
            registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
            registerSimpleEvent(ANIMATION_START, "onAnimationStart");
            registerSimpleEvent("dblclick", "onDoubleClick");
            registerSimpleEvent("focusin", "onFocus");
            registerSimpleEvent("focusout", "onBlur");
            registerSimpleEvent(TRANSITION_END2, "onTransitionEnd");
          }
          function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (reactName === void 0) {
              return;
            }
            var SyntheticEventCtor = SyntheticEvent;
            var reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (getEventCharCode(nativeEvent) === 0) {
                  return;
                }
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (nativeEvent.button === 2) {
                  return;
                }
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END2:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
            }
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            {
              var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
              // nonDelegatedEvents list in DOMPluginEventSystem.
              // Then we can remove this special list.
              // This is a breaking change that can wait until React 18.
              domEventName === "scroll";
              var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
              if (_listeners.length > 0) {
                var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event: _event,
                  listeners: _listeners
                });
              }
            }
          }
          registerSimpleEvents();
          registerEvents$2();
          registerEvents$1();
          registerEvents$3();
          registerEvents();
          function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
            if (shouldProcessPolyfillPlugins) {
              extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            }
          }
          var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
          var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
          function executeDispatch(event, listener, currentTarget) {
            var type = event.type || "unknown-event";
            event.currentTarget = currentTarget;
            invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
            event.currentTarget = null;
          }
          function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
            var previousInstance;
            if (inCapturePhase) {
              for (var i = dispatchListeners.length - 1; i >= 0; i--) {
                var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, listener, currentTarget);
                previousInstance = instance;
              }
            } else {
              for (var _i = 0; _i < dispatchListeners.length; _i++) {
                var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
                if (_instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, _listener, _currentTarget);
                previousInstance = _instance;
              }
            }
          }
          function processDispatchQueue(dispatchQueue, eventSystemFlags) {
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            for (var i = 0; i < dispatchQueue.length; i++) {
              var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
              processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
            }
            rethrowCaughtError();
          }
          function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var nativeEventTarget = getEventTarget(nativeEvent);
            var dispatchQueue = [];
            extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          }
          function listenToNonDelegatedEvent(domEventName, targetElement) {
            {
              if (!nonDelegatedEvents.has(domEventName)) {
                error2('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var isCapturePhaseListener = false;
            var listenerSet = getEventListenerSet(targetElement);
            var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
            if (!listenerSet.has(listenerSetKey)) {
              addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
              listenerSet.add(listenerSetKey);
            }
          }
          function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
            {
              if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
                error2('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var eventSystemFlags = 0;
            if (isCapturePhaseListener) {
              eventSystemFlags |= IS_CAPTURE_PHASE;
            }
            addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
          }
          var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
          function listenToAllSupportedEvents(rootContainerElement) {
            if (!rootContainerElement[listeningMarker]) {
              rootContainerElement[listeningMarker] = true;
              allNativeEvents.forEach(function(domEventName) {
                if (domEventName !== "selectionchange") {
                  if (!nonDelegatedEvents.has(domEventName)) {
                    listenToNativeEvent(domEventName, false, rootContainerElement);
                  }
                  listenToNativeEvent(domEventName, true, rootContainerElement);
                }
              });
              var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
              if (ownerDocument !== null) {
                if (!ownerDocument[listeningMarker]) {
                  ownerDocument[listeningMarker] = true;
                  listenToNativeEvent("selectionchange", false, ownerDocument);
                }
              }
            }
          }
          function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
            var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
            var isPassiveListener = void 0;
            if (passiveBrowserEventsSupported) {
              if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
                isPassiveListener = true;
              }
            }
            targetContainer = targetContainer;
            var unsubscribeListener;
            if (isCapturePhaseListener) {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
              }
            } else {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
              }
            }
          }
          function isMatchingRootContainer(grandContainer, targetContainer) {
            return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
          }
          function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var ancestorInst = targetInst;
            if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
              var targetContainerNode = targetContainer;
              if (targetInst !== null) {
                var node = targetInst;
                mainLoop:
                  while (true) {
                    if (node === null) {
                      return;
                    }
                    var nodeTag = node.tag;
                    if (nodeTag === HostRoot || nodeTag === HostPortal) {
                      var container = node.stateNode.containerInfo;
                      if (isMatchingRootContainer(container, targetContainerNode)) {
                        break;
                      }
                      if (nodeTag === HostPortal) {
                        var grandNode = node.return;
                        while (grandNode !== null) {
                          var grandTag = grandNode.tag;
                          if (grandTag === HostRoot || grandTag === HostPortal) {
                            var grandContainer = grandNode.stateNode.containerInfo;
                            if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                              return;
                            }
                          }
                          grandNode = grandNode.return;
                        }
                      }
                      while (container !== null) {
                        var parentNode = getClosestInstanceFromNode(container);
                        if (parentNode === null) {
                          return;
                        }
                        var parentTag = parentNode.tag;
                        if (parentTag === HostComponent || parentTag === HostText) {
                          node = ancestorInst = parentNode;
                          continue mainLoop;
                        }
                        container = container.parentNode;
                      }
                    }
                    node = node.return;
                  }
              }
            }
            batchedUpdates(function() {
              return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
            });
          }
          function createDispatchListener(instance, listener, currentTarget) {
            return {
              instance,
              listener,
              currentTarget
            };
          }
          function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
            var captureName = reactName !== null ? reactName + "Capture" : null;
            var reactEventName = inCapturePhase ? captureName : reactName;
            var listeners = [];
            var instance = targetFiber;
            var lastHostComponent = null;
            while (instance !== null) {
              var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
              if (tag === HostComponent && stateNode !== null) {
                lastHostComponent = stateNode;
                if (reactEventName !== null) {
                  var listener = getListener(instance, reactEventName);
                  if (listener != null) {
                    listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                  }
                }
              }
              if (accumulateTargetOnly) {
                break;
              }
              instance = instance.return;
            }
            return listeners;
          }
          function accumulateTwoPhaseListeners(targetFiber, reactName) {
            var captureName = reactName + "Capture";
            var listeners = [];
            var instance = targetFiber;
            while (instance !== null) {
              var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                var captureListener = getListener(instance, captureName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
                var bubbleListener = getListener(instance, reactName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
              instance = instance.return;
            }
            return listeners;
          }
          function getParent(inst) {
            if (inst === null) {
              return null;
            }
            do {
              inst = inst.return;
            } while (inst && inst.tag !== HostComponent);
            if (inst) {
              return inst;
            }
            return null;
          }
          function getLowestCommonAncestor(instA, instB) {
            var nodeA = instA;
            var nodeB = instB;
            var depthA = 0;
            for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
              depthA++;
            }
            var depthB = 0;
            for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
              depthB++;
            }
            while (depthA - depthB > 0) {
              nodeA = getParent(nodeA);
              depthA--;
            }
            while (depthB - depthA > 0) {
              nodeB = getParent(nodeB);
              depthB--;
            }
            var depth = depthA;
            while (depth--) {
              if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
                return nodeA;
              }
              nodeA = getParent(nodeA);
              nodeB = getParent(nodeB);
            }
            return null;
          }
          function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
            var registrationName = event._reactName;
            var listeners = [];
            var instance = target;
            while (instance !== null) {
              if (instance === common) {
                break;
              }
              var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
              if (alternate !== null && alternate === common) {
                break;
              }
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                if (inCapturePhase) {
                  var captureListener = getListener(instance, registrationName);
                  if (captureListener != null) {
                    listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                  }
                } else if (!inCapturePhase) {
                  var bubbleListener = getListener(instance, registrationName);
                  if (bubbleListener != null) {
                    listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                  }
                }
              }
              instance = instance.return;
            }
            if (listeners.length !== 0) {
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
            var common = from && to ? getLowestCommonAncestor(from, to) : null;
            if (from !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
            }
            if (to !== null && enterEvent !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
            }
          }
          function getListenerSetKey(domEventName, capture) {
            return domEventName + "__" + (capture ? "capture" : "bubble");
          }
          var didWarnInvalidHydration = false;
          var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
          var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
          var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
          var AUTOFOCUS = "autoFocus";
          var CHILDREN = "children";
          var STYLE = "style";
          var HTML$1 = "__html";
          var warnedUnknownTags;
          var validatePropertiesInDevelopment;
          var warnForPropDifference;
          var warnForExtraAttributes;
          var warnForInvalidEventListener;
          var canDiffStyleForHydrationWarning;
          var normalizeHTML;
          {
            warnedUnknownTags = {
              // There are working polyfills for <dialog>. Let people use it.
              dialog: true,
              // Electron ships a custom <webview> tag to display external web content in
              // an isolated frame and process.
              // This tag is not present in non Electron environments such as JSDom which
              // is often used for testing purposes.
              // @see https://electronjs.org/docs/api/webview-tag
              webview: true
            };
            validatePropertiesInDevelopment = function(type, props) {
              validateProperties(type, props);
              validateProperties$1(type, props);
              validateProperties$2(type, props, {
                registrationNameDependencies,
                possibleRegistrationNames
              });
            };
            canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
            warnForPropDifference = function(propName, serverValue, clientValue) {
              if (didWarnInvalidHydration) {
                return;
              }
              var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
              var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
              if (normalizedServerValue === normalizedClientValue) {
                return;
              }
              didWarnInvalidHydration = true;
              error2("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
            };
            warnForExtraAttributes = function(attributeNames) {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              var names = [];
              attributeNames.forEach(function(name) {
                names.push(name);
              });
              error2("Extra attributes from the server: %s", names);
            };
            warnForInvalidEventListener = function(registrationName, listener) {
              if (listener === false) {
                error2("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
              } else {
                error2("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
              }
            };
            normalizeHTML = function(parent, html) {
              var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
              testElement.innerHTML = html;
              return testElement.innerHTML;
            };
          }
          var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
          var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
          function normalizeMarkupForTextOrAttribute(markup) {
            {
              checkHtmlStringCoercion(markup);
            }
            var markupString = typeof markup === "string" ? markup : "" + markup;
            return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
          }
          function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
            var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
            var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
            if (normalizedServerText === normalizedClientText) {
              return;
            }
            if (shouldWarnDev) {
              {
                if (!didWarnInvalidHydration) {
                  didWarnInvalidHydration = true;
                  error2('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
                }
              }
            }
            if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
              throw new Error("Text content does not match server-rendered HTML.");
            }
          }
          function getOwnerDocumentFromRootContainer(rootContainerElement) {
            return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
          }
          function noop2() {
          }
          function trapClickOnNonInteractiveElement(node) {
            node.onclick = noop2;
          }
          function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
            for (var propKey in nextProps) {
              if (!nextProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = nextProps[propKey];
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                setValueForStyles(domElement, nextProp);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  setInnerHTML(domElement, nextHtml);
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  var canSetTextContent = tag !== "textarea" || nextProp !== "";
                  if (canSetTextContent) {
                    setTextContent(domElement, nextProp);
                  }
                } else if (typeof nextProp === "number") {
                  setTextContent(domElement, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (nextProp != null) {
                setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
              }
            }
          }
          function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
            for (var i = 0; i < updatePayload.length; i += 2) {
              var propKey = updatePayload[i];
              var propValue = updatePayload[i + 1];
              if (propKey === STYLE) {
                setValueForStyles(domElement, propValue);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                setInnerHTML(domElement, propValue);
              } else if (propKey === CHILDREN) {
                setTextContent(domElement, propValue);
              } else {
                setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
              }
            }
          }
          function createElement(type, props, rootContainerElement, parentNamespace) {
            var isCustomComponentTag;
            var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
            var domElement;
            var namespaceURI = parentNamespace;
            if (namespaceURI === HTML_NAMESPACE) {
              namespaceURI = getIntrinsicNamespace(type);
            }
            if (namespaceURI === HTML_NAMESPACE) {
              {
                isCustomComponentTag = isCustomComponent(type, props);
                if (!isCustomComponentTag && type !== type.toLowerCase()) {
                  error2("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
                }
              }
              if (type === "script") {
                var div = ownerDocument.createElement("div");
                div.innerHTML = "<script><\/script>";
                var firstChild = div.firstChild;
                domElement = div.removeChild(firstChild);
              } else if (typeof props.is === "string") {
                domElement = ownerDocument.createElement(type, {
                  is: props.is
                });
              } else {
                domElement = ownerDocument.createElement(type);
                if (type === "select") {
                  var node = domElement;
                  if (props.multiple) {
                    node.multiple = true;
                  } else if (props.size) {
                    node.size = props.size;
                  }
                }
              }
            } else {
              domElement = ownerDocument.createElementNS(namespaceURI, type);
            }
            {
              if (namespaceURI === HTML_NAMESPACE) {
                if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty.call(warnedUnknownTags, type)) {
                  warnedUnknownTags[type] = true;
                  error2("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
                }
              }
            }
            return domElement;
          }
          function createTextNode(text, rootContainerElement) {
            return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
          }
          function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
            var isCustomComponentTag = isCustomComponent(tag, rawProps);
            {
              validatePropertiesInDevelopment(tag, rawProps);
            }
            var props;
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                props = rawProps;
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "video":
              case "audio":
                for (var i = 0; i < mediaEventTypes.length; i++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                }
                props = rawProps;
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                props = rawProps;
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                props = rawProps;
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                props = getHostProps(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                props = rawProps;
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                props = getHostProps$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                props = getHostProps$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              default:
                props = rawProps;
            }
            assertValidProps(tag, props);
            setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, false);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "option":
                postMountWrapper$1(domElement, rawProps);
                break;
              case "select":
                postMountWrapper$2(domElement, rawProps);
                break;
              default:
                if (typeof props.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
          }
          function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
            {
              validatePropertiesInDevelopment(tag, nextRawProps);
            }
            var updatePayload = null;
            var lastProps;
            var nextProps;
            switch (tag) {
              case "input":
                lastProps = getHostProps(domElement, lastRawProps);
                nextProps = getHostProps(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "select":
                lastProps = getHostProps$1(domElement, lastRawProps);
                nextProps = getHostProps$1(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "textarea":
                lastProps = getHostProps$2(domElement, lastRawProps);
                nextProps = getHostProps$2(domElement, nextRawProps);
                updatePayload = [];
                break;
              default:
                lastProps = lastRawProps;
                nextProps = nextRawProps;
                if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            assertValidProps(tag, nextProps);
            var propKey;
            var styleName;
            var styleUpdates = null;
            for (propKey in lastProps) {
              if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
                continue;
              }
              if (propKey === STYLE) {
                var lastStyle = lastProps[propKey];
                for (styleName in lastStyle) {
                  if (lastStyle.hasOwnProperty(styleName)) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
                ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (!updatePayload) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, null);
              }
            }
            for (propKey in nextProps) {
              var nextProp = nextProps[propKey];
              var lastProp = lastProps != null ? lastProps[propKey] : void 0;
              if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
                continue;
              }
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                if (lastProp) {
                  for (styleName in lastProp) {
                    if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = "";
                    }
                  }
                  for (styleName in nextProp) {
                    if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = nextProp[styleName];
                    }
                  }
                } else {
                  if (!styleUpdates) {
                    if (!updatePayload) {
                      updatePayload = [];
                    }
                    updatePayload.push(propKey, styleUpdates);
                  }
                  styleUpdates = nextProp;
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  if (lastHtml !== nextHtml) {
                    (updatePayload = updatePayload || []).push(propKey, nextHtml);
                  }
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string" || typeof nextProp === "number") {
                  (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
                if (!updatePayload && lastProp !== nextProp) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, nextProp);
              }
            }
            if (styleUpdates) {
              {
                validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
              }
              (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
            }
            return updatePayload;
          }
          function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
            if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
              updateChecked(domElement, nextRawProps);
            }
            var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
            var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
            updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
            switch (tag) {
              case "input":
                updateWrapper(domElement, nextRawProps);
                break;
              case "textarea":
                updateWrapper$1(domElement, nextRawProps);
                break;
              case "select":
                postUpdateWrapper(domElement, nextRawProps);
                break;
            }
          }
          function getPossibleStandardName(propName) {
            {
              var lowerCasedName = propName.toLowerCase();
              if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                return null;
              }
              return possibleStandardNames[lowerCasedName] || null;
            }
          }
          function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
            var isCustomComponentTag;
            var extraAttributeNames;
            {
              isCustomComponentTag = isCustomComponent(tag, rawProps);
              validatePropertiesInDevelopment(tag, rawProps);
            }
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "video":
              case "audio":
                for (var i = 0; i < mediaEventTypes.length; i++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                }
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
            }
            assertValidProps(tag, rawProps);
            {
              extraAttributeNames = /* @__PURE__ */ new Set();
              var attributes = domElement.attributes;
              for (var _i = 0; _i < attributes.length; _i++) {
                var name = attributes[_i].name.toLowerCase();
                switch (name) {
                  case "value":
                    break;
                  case "checked":
                    break;
                  case "selected":
                    break;
                  default:
                    extraAttributeNames.add(attributes[_i].name);
                }
              }
            }
            var updatePayload = null;
            for (var propKey in rawProps) {
              if (!rawProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = rawProps[propKey];
              if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  if (domElement.textContent !== nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, nextProp];
                  }
                } else if (typeof nextProp === "number") {
                  if (domElement.textContent !== "" + nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, "" + nextProp];
                  }
                }
              } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (shouldWarnDev && true && // Convince Flow we've calculated it (it's DEV-only in this method.)
              typeof isCustomComponentTag === "boolean") {
                var serverValue = void 0;
                var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
                if (rawProps[SUPPRESS_HYDRATION_WARNING] === true)
                  ;
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
                // TODO: Only ignore them on controlled tags.
                propKey === "value" || propKey === "checked" || propKey === "selected")
                  ;
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                  var serverHTML = domElement.innerHTML;
                  var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                  if (nextHtml != null) {
                    var expectedHTML = normalizeHTML(domElement, nextHtml);
                    if (expectedHTML !== serverHTML) {
                      warnForPropDifference(propKey, serverHTML, expectedHTML);
                    }
                  }
                } else if (propKey === STYLE) {
                  extraAttributeNames.delete(propKey);
                  if (canDiffStyleForHydrationWarning) {
                    var expectedStyle = createDangerousStringForStyles(nextProp);
                    serverValue = domElement.getAttribute("style");
                    if (expectedStyle !== serverValue) {
                      warnForPropDifference(propKey, serverValue, expectedStyle);
                    }
                  }
                } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                  extraAttributeNames.delete(propKey.toLowerCase());
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  if (nextProp !== serverValue) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                  var isMismatchDueToBadCasing = false;
                  if (propertyInfo !== null) {
                    extraAttributeNames.delete(propertyInfo.attributeName);
                    serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                  } else {
                    var ownNamespace = parentNamespace;
                    if (ownNamespace === HTML_NAMESPACE) {
                      ownNamespace = getIntrinsicNamespace(tag);
                    }
                    if (ownNamespace === HTML_NAMESPACE) {
                      extraAttributeNames.delete(propKey.toLowerCase());
                    } else {
                      var standardName = getPossibleStandardName(propKey);
                      if (standardName !== null && standardName !== propKey) {
                        isMismatchDueToBadCasing = true;
                        extraAttributeNames.delete(standardName);
                      }
                      extraAttributeNames.delete(propKey);
                    }
                    serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  }
                  var dontWarnCustomElement = enableCustomElementPropertySupport;
                  if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                }
              }
            }
            {
              if (shouldWarnDev) {
                if (
                  // $FlowFixMe - Should be inferred as not undefined.
                  extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true
                ) {
                  warnForExtraAttributes(extraAttributeNames);
                }
              }
            }
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, true);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "select":
              case "option":
                break;
              default:
                if (typeof rawProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            return updatePayload;
          }
          function diffHydratedText(textNode, text, isConcurrentMode) {
            var isDifferent = textNode.nodeValue !== text;
            return isDifferent;
          }
          function warnForDeletedHydratableElement(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error2("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
            }
          }
          function warnForDeletedHydratableText(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error2('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedElement(parentNode, tag, props) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error2("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedText(parentNode, text) {
            {
              if (text === "") {
                return;
              }
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error2('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
            }
          }
          function restoreControlledState$3(domElement, tag, props) {
            switch (tag) {
              case "input":
                restoreControlledState(domElement, props);
                return;
              case "textarea":
                restoreControlledState$2(domElement, props);
                return;
              case "select":
                restoreControlledState$1(domElement, props);
                return;
            }
          }
          var validateDOMNesting = function() {
          };
          var updatedAncestorInfo = function() {
          };
          {
            var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
            var inScopeTags = [
              "applet",
              "caption",
              "html",
              "table",
              "td",
              "th",
              "marquee",
              "object",
              "template",
              // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
              // TODO: Distinguish by namespace here -- for <title>, including it here
              // errs on the side of fewer warnings
              "foreignObject",
              "desc",
              "title"
            ];
            var buttonScopeTags = inScopeTags.concat(["button"]);
            var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
            var emptyAncestorInfo = {
              current: null,
              formTag: null,
              aTagInScope: null,
              buttonTagInScope: null,
              nobrTagInScope: null,
              pTagInButtonScope: null,
              listItemTagAutoclosing: null,
              dlItemTagAutoclosing: null
            };
            updatedAncestorInfo = function(oldInfo, tag) {
              var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
              var info = {
                tag
              };
              if (inScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.aTagInScope = null;
                ancestorInfo.buttonTagInScope = null;
                ancestorInfo.nobrTagInScope = null;
              }
              if (buttonScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.pTagInButtonScope = null;
              }
              if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
                ancestorInfo.listItemTagAutoclosing = null;
                ancestorInfo.dlItemTagAutoclosing = null;
              }
              ancestorInfo.current = info;
              if (tag === "form") {
                ancestorInfo.formTag = info;
              }
              if (tag === "a") {
                ancestorInfo.aTagInScope = info;
              }
              if (tag === "button") {
                ancestorInfo.buttonTagInScope = info;
              }
              if (tag === "nobr") {
                ancestorInfo.nobrTagInScope = info;
              }
              if (tag === "p") {
                ancestorInfo.pTagInButtonScope = info;
              }
              if (tag === "li") {
                ancestorInfo.listItemTagAutoclosing = info;
              }
              if (tag === "dd" || tag === "dt") {
                ancestorInfo.dlItemTagAutoclosing = info;
              }
              return ancestorInfo;
            };
            var isTagValidWithParent = function(tag, parentTag) {
              switch (parentTag) {
                case "select":
                  return tag === "option" || tag === "optgroup" || tag === "#text";
                case "optgroup":
                  return tag === "option" || tag === "#text";
                case "option":
                  return tag === "#text";
                case "tr":
                  return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
                case "tbody":
                case "thead":
                case "tfoot":
                  return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
                case "colgroup":
                  return tag === "col" || tag === "template";
                case "table":
                  return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
                case "head":
                  return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
                case "html":
                  return tag === "head" || tag === "body" || tag === "frameset";
                case "frameset":
                  return tag === "frame";
                case "#document":
                  return tag === "html";
              }
              switch (tag) {
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
                case "rp":
                case "rt":
                  return impliedEndTags.indexOf(parentTag) === -1;
                case "body":
                case "caption":
                case "col":
                case "colgroup":
                case "frameset":
                case "frame":
                case "head":
                case "html":
                case "tbody":
                case "td":
                case "tfoot":
                case "th":
                case "thead":
                case "tr":
                  return parentTag == null;
              }
              return true;
            };
            var findInvalidAncestorForTag = function(tag, ancestorInfo) {
              switch (tag) {
                case "address":
                case "article":
                case "aside":
                case "blockquote":
                case "center":
                case "details":
                case "dialog":
                case "dir":
                case "div":
                case "dl":
                case "fieldset":
                case "figcaption":
                case "figure":
                case "footer":
                case "header":
                case "hgroup":
                case "main":
                case "menu":
                case "nav":
                case "ol":
                case "p":
                case "section":
                case "summary":
                case "ul":
                case "pre":
                case "listing":
                case "table":
                case "hr":
                case "xmp":
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return ancestorInfo.pTagInButtonScope;
                case "form":
                  return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
                case "li":
                  return ancestorInfo.listItemTagAutoclosing;
                case "dd":
                case "dt":
                  return ancestorInfo.dlItemTagAutoclosing;
                case "button":
                  return ancestorInfo.buttonTagInScope;
                case "a":
                  return ancestorInfo.aTagInScope;
                case "nobr":
                  return ancestorInfo.nobrTagInScope;
              }
              return null;
            };
            var didWarn$1 = {};
            validateDOMNesting = function(childTag, childText, ancestorInfo) {
              ancestorInfo = ancestorInfo || emptyAncestorInfo;
              var parentInfo = ancestorInfo.current;
              var parentTag = parentInfo && parentInfo.tag;
              if (childText != null) {
                if (childTag != null) {
                  error2("validateDOMNesting: when childText is passed, childTag should be null");
                }
                childTag = "#text";
              }
              var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
              var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
              var invalidParentOrAncestor = invalidParent || invalidAncestor;
              if (!invalidParentOrAncestor) {
                return;
              }
              var ancestorTag = invalidParentOrAncestor.tag;
              var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
              if (didWarn$1[warnKey]) {
                return;
              }
              didWarn$1[warnKey] = true;
              var tagDisplayName = childTag;
              var whitespaceInfo = "";
              if (childTag === "#text") {
                if (/\S/.test(childText)) {
                  tagDisplayName = "Text nodes";
                } else {
                  tagDisplayName = "Whitespace text nodes";
                  whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
                }
              } else {
                tagDisplayName = "<" + childTag + ">";
              }
              if (invalidParent) {
                var info = "";
                if (ancestorTag === "table" && childTag === "tr") {
                  info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
                }
                error2("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
              } else {
                error2("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
              }
            };
          }
          var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
          var SUSPENSE_START_DATA = "$";
          var SUSPENSE_END_DATA = "/$";
          var SUSPENSE_PENDING_START_DATA = "$?";
          var SUSPENSE_FALLBACK_START_DATA = "$!";
          var STYLE$1 = "style";
          var eventsEnabled = null;
          var selectionInformation = null;
          function getRootHostContext(rootContainerInstance) {
            var type;
            var namespace;
            var nodeType = rootContainerInstance.nodeType;
            switch (nodeType) {
              case DOCUMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE: {
                type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
                var root2 = rootContainerInstance.documentElement;
                namespace = root2 ? root2.namespaceURI : getChildNamespace(null, "");
                break;
              }
              default: {
                var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
                var ownNamespace = container.namespaceURI || null;
                type = container.tagName;
                namespace = getChildNamespace(ownNamespace, type);
                break;
              }
            }
            {
              var validatedTag = type.toLowerCase();
              var ancestorInfo = updatedAncestorInfo(null, validatedTag);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getChildHostContext(parentHostContext, type, rootContainerInstance) {
            {
              var parentHostContextDev = parentHostContext;
              var namespace = getChildNamespace(parentHostContextDev.namespace, type);
              var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getPublicInstance(instance) {
            return instance;
          }
          function prepareForCommit(containerInfo) {
            eventsEnabled = isEnabled();
            selectionInformation = getSelectionInformation();
            var activeInstance = null;
            setEnabled(false);
            return activeInstance;
          }
          function resetAfterCommit(containerInfo) {
            restoreSelection(selectionInformation);
            setEnabled(eventsEnabled);
            eventsEnabled = null;
            selectionInformation = null;
          }
          function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              validateDOMNesting(type, null, hostContextDev.ancestorInfo);
              if (typeof props.children === "string" || typeof props.children === "number") {
                var string = "" + props.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string, ownAncestorInfo);
              }
              parentNamespace = hostContextDev.namespace;
            }
            var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
            precacheFiberNode(internalInstanceHandle, domElement);
            updateFiberProps(domElement, props);
            return domElement;
          }
          function appendInitialChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
            setInitialProperties(domElement, type, props, rootContainerInstance);
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                return !!props.autoFocus;
              case "img":
                return true;
              default:
                return false;
            }
          }
          function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
            {
              var hostContextDev = hostContext;
              if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
                var string = "" + newProps.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string, ownAncestorInfo);
              }
            }
            return diffProperties(domElement, type, oldProps, newProps);
          }
          function shouldSetTextContent(type, props) {
            return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
          }
          function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
            {
              var hostContextDev = hostContext;
              validateDOMNesting(null, text, hostContextDev.ancestorInfo);
            }
            var textNode = createTextNode(text, rootContainerInstance);
            precacheFiberNode(internalInstanceHandle, textNode);
            return textNode;
          }
          function getCurrentEventPriority() {
            var currentEvent = window.event;
            if (currentEvent === void 0) {
              return DefaultEventPriority;
            }
            return getEventPriority(currentEvent.type);
          }
          var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
          var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
          var noTimeout = -1;
          var localPromise = typeof Promise === "function" ? Promise : void 0;
          var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
            return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
          } : scheduleTimeout;
          function handleErrorInNextTick(error3) {
            setTimeout(function() {
              throw error3;
            });
          }
          function commitMount(domElement, type, newProps, internalInstanceHandle) {
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                if (newProps.autoFocus) {
                  domElement.focus();
                }
                return;
              case "img": {
                if (newProps.src) {
                  domElement.src = newProps.src;
                }
                return;
              }
            }
          }
          function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
            updateProperties(domElement, updatePayload, type, oldProps, newProps);
            updateFiberProps(domElement, newProps);
          }
          function resetTextContent(domElement) {
            setTextContent(domElement, "");
          }
          function commitTextUpdate(textInstance, oldText, newText) {
            textInstance.nodeValue = newText;
          }
          function appendChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function appendChildToContainer(container, child) {
            var parentNode;
            if (container.nodeType === COMMENT_NODE) {
              parentNode = container.parentNode;
              parentNode.insertBefore(child, container);
            } else {
              parentNode = container;
              parentNode.appendChild(child);
            }
            var reactRootContainer = container._reactRootContainer;
            if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
              trapClickOnNonInteractiveElement(parentNode);
            }
          }
          function insertBefore(parentInstance, child, beforeChild) {
            parentInstance.insertBefore(child, beforeChild);
          }
          function insertInContainerBefore(container, child, beforeChild) {
            if (container.nodeType === COMMENT_NODE) {
              container.parentNode.insertBefore(child, beforeChild);
            } else {
              container.insertBefore(child, beforeChild);
            }
          }
          function removeChild(parentInstance, child) {
            parentInstance.removeChild(child);
          }
          function removeChildFromContainer(container, child) {
            if (container.nodeType === COMMENT_NODE) {
              container.parentNode.removeChild(child);
            } else {
              container.removeChild(child);
            }
          }
          function clearSuspenseBoundary(parentInstance, suspenseInstance) {
            var node = suspenseInstance;
            var depth = 0;
            do {
              var nextNode = node.nextSibling;
              parentInstance.removeChild(node);
              if (nextNode && nextNode.nodeType === COMMENT_NODE) {
                var data = nextNode.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    parentInstance.removeChild(nextNode);
                    retryIfBlockedOn(suspenseInstance);
                    return;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
                  depth++;
                }
              }
              node = nextNode;
            } while (node);
            retryIfBlockedOn(suspenseInstance);
          }
          function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
            if (container.nodeType === COMMENT_NODE) {
              clearSuspenseBoundary(container.parentNode, suspenseInstance);
            } else if (container.nodeType === ELEMENT_NODE) {
              clearSuspenseBoundary(container, suspenseInstance);
            }
            retryIfBlockedOn(container);
          }
          function hideInstance(instance) {
            instance = instance;
            var style2 = instance.style;
            if (typeof style2.setProperty === "function") {
              style2.setProperty("display", "none", "important");
            } else {
              style2.display = "none";
            }
          }
          function hideTextInstance(textInstance) {
            textInstance.nodeValue = "";
          }
          function unhideInstance(instance, props) {
            instance = instance;
            var styleProp = props[STYLE$1];
            var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
            instance.style.display = dangerousStyleValue("display", display);
          }
          function unhideTextInstance(textInstance, text) {
            textInstance.nodeValue = text;
          }
          function clearContainer(container) {
            if (container.nodeType === ELEMENT_NODE) {
              container.textContent = "";
            } else if (container.nodeType === DOCUMENT_NODE) {
              if (container.documentElement) {
                container.removeChild(container.documentElement);
              }
            }
          }
          function canHydrateInstance(instance, type, props) {
            if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
              return null;
            }
            return instance;
          }
          function canHydrateTextInstance(instance, text) {
            if (text === "" || instance.nodeType !== TEXT_NODE) {
              return null;
            }
            return instance;
          }
          function canHydrateSuspenseInstance(instance) {
            if (instance.nodeType !== COMMENT_NODE) {
              return null;
            }
            return instance;
          }
          function isSuspenseInstancePending(instance) {
            return instance.data === SUSPENSE_PENDING_START_DATA;
          }
          function isSuspenseInstanceFallback(instance) {
            return instance.data === SUSPENSE_FALLBACK_START_DATA;
          }
          function getSuspenseInstanceFallbackErrorDetails(instance) {
            var dataset = instance.nextSibling && instance.nextSibling.dataset;
            var digest, message, stack;
            if (dataset) {
              digest = dataset.dgst;
              {
                message = dataset.msg;
                stack = dataset.stck;
              }
            }
            {
              return {
                message,
                digest,
                stack
              };
            }
          }
          function registerSuspenseInstanceRetry(instance, callback) {
            instance._reactRetry = callback;
          }
          function getNextHydratable(node) {
            for (; node != null; node = node.nextSibling) {
              var nodeType = node.nodeType;
              if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
                break;
              }
              if (nodeType === COMMENT_NODE) {
                var nodeData = node.data;
                if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                  break;
                }
                if (nodeData === SUSPENSE_END_DATA) {
                  return null;
                }
              }
            }
            return node;
          }
          function getNextHydratableSibling(instance) {
            return getNextHydratable(instance.nextSibling);
          }
          function getFirstHydratableChild(parentInstance) {
            return getNextHydratable(parentInstance.firstChild);
          }
          function getFirstHydratableChildWithinContainer(parentContainer) {
            return getNextHydratable(parentContainer.firstChild);
          }
          function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
            return getNextHydratable(parentInstance.nextSibling);
          }
          function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, instance);
            updateFiberProps(instance, props);
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              parentNamespace = hostContextDev.namespace;
            }
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
          }
          function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, textInstance);
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedText(textInstance, text);
          }
          function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
            precacheFiberNode(internalInstanceHandle, suspenseInstance);
          }
          function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
            var node = suspenseInstance.nextSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    return getNextHydratableSibling(node);
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  depth++;
                }
              }
              node = node.nextSibling;
            }
            return null;
          }
          function getParentSuspenseInstance(targetInstance) {
            var node = targetInstance.previousSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  if (depth === 0) {
                    return node;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_END_DATA) {
                  depth++;
                }
              }
              node = node.previousSibling;
            }
            return null;
          }
          function commitHydratedContainer(container) {
            retryIfBlockedOn(container);
          }
          function commitHydratedSuspenseInstance(suspenseInstance) {
            retryIfBlockedOn(suspenseInstance);
          }
          function shouldDeleteUnhydratedTailInstances(parentType) {
            return parentType !== "head" && parentType !== "body";
          }
          function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
          }
          function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              var shouldWarnDev = true;
              checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
            }
          }
          function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
            {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentContainer, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentContainer, instance);
              }
            }
          }
          function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null) {
                if (instance.nodeType === ELEMENT_NODE) {
                  warnForDeletedHydratableElement(parentNode, instance);
                } else if (instance.nodeType === COMMENT_NODE)
                  ;
                else {
                  warnForDeletedHydratableText(parentNode, instance);
                }
              }
            }
          }
          function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                if (instance.nodeType === ELEMENT_NODE) {
                  warnForDeletedHydratableElement(parentInstance, instance);
                } else if (instance.nodeType === COMMENT_NODE)
                  ;
                else {
                  warnForDeletedHydratableText(parentInstance, instance);
                }
              }
            }
          }
          function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
            {
              warnForInsertedHydratedElement(parentContainer, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
            {
              warnForInsertedHydratedText(parentContainer, text);
            }
          }
          function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null)
                warnForInsertedHydratedElement(parentNode, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null)
                warnForInsertedHydratedText(parentNode, text);
            }
          }
          function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedElement(parentInstance, type);
              }
            }
          }
          function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedText(parentInstance, text);
              }
            }
          }
          function errorHydratingContainer(parentContainer) {
            {
              error2("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
            }
          }
          function preparePortalMount(portalInstance) {
            listenToAllSupportedEvents(portalInstance);
          }
          var randomKey = Math.random().toString(36).slice(2);
          var internalInstanceKey = "__reactFiber$" + randomKey;
          var internalPropsKey = "__reactProps$" + randomKey;
          var internalContainerInstanceKey = "__reactContainer$" + randomKey;
          var internalEventHandlersKey = "__reactEvents$" + randomKey;
          var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
          var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
          function detachDeletedInstance(node) {
            delete node[internalInstanceKey];
            delete node[internalPropsKey];
            delete node[internalEventHandlersKey];
            delete node[internalEventHandlerListenersKey];
            delete node[internalEventHandlesSetKey];
          }
          function precacheFiberNode(hostInst, node) {
            node[internalInstanceKey] = hostInst;
          }
          function markContainerAsRoot(hostRoot, node) {
            node[internalContainerInstanceKey] = hostRoot;
          }
          function unmarkContainerAsRoot(node) {
            node[internalContainerInstanceKey] = null;
          }
          function isContainerMarkedAsRoot(node) {
            return !!node[internalContainerInstanceKey];
          }
          function getClosestInstanceFromNode(targetNode) {
            var targetInst = targetNode[internalInstanceKey];
            if (targetInst) {
              return targetInst;
            }
            var parentNode = targetNode.parentNode;
            while (parentNode) {
              targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
              if (targetInst) {
                var alternate = targetInst.alternate;
                if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                  var suspenseInstance = getParentSuspenseInstance(targetNode);
                  while (suspenseInstance !== null) {
                    var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                    if (targetSuspenseInst) {
                      return targetSuspenseInst;
                    }
                    suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                  }
                }
                return targetInst;
              }
              targetNode = parentNode;
              parentNode = targetNode.parentNode;
            }
            return null;
          }
          function getInstanceFromNode(node) {
            var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
            if (inst) {
              if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
                return inst;
              } else {
                return null;
              }
            }
            return null;
          }
          function getNodeFromInstance(inst) {
            if (inst.tag === HostComponent || inst.tag === HostText) {
              return inst.stateNode;
            }
            throw new Error("getNodeFromInstance: Invalid argument.");
          }
          function getFiberCurrentPropsFromNode(node) {
            return node[internalPropsKey] || null;
          }
          function updateFiberProps(node, props) {
            node[internalPropsKey] = props;
          }
          function getEventListenerSet(node) {
            var elementListenerSet = node[internalEventHandlersKey];
            if (elementListenerSet === void 0) {
              elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
            }
            return elementListenerSet;
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location2, componentName, element) {
            {
              var has2 = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has2(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error2("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var valueStack = [];
          var fiberStack;
          {
            fiberStack = [];
          }
          var index = -1;
          function createCursor(defaultValue6) {
            return {
              current: defaultValue6
            };
          }
          function pop(cursor, fiber) {
            if (index < 0) {
              {
                error2("Unexpected pop.");
              }
              return;
            }
            {
              if (fiber !== fiberStack[index]) {
                error2("Unexpected Fiber popped.");
              }
            }
            cursor.current = valueStack[index];
            valueStack[index] = null;
            {
              fiberStack[index] = null;
            }
            index--;
          }
          function push(cursor, value, fiber) {
            index++;
            valueStack[index] = cursor.current;
            {
              fiberStack[index] = fiber;
            }
            cursor.current = value;
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          var contextStackCursor = createCursor(emptyContextObject);
          var didPerformWorkStackCursor = createCursor(false);
          var previousContext = emptyContextObject;
          function getUnmaskedContext(workInProgress2, Component9, didPushOwnContextIfProvider) {
            {
              if (didPushOwnContextIfProvider && isContextProvider(Component9)) {
                return previousContext;
              }
              return contextStackCursor.current;
            }
          }
          function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
            {
              var instance = workInProgress2.stateNode;
              instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
              instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
            }
          }
          function getMaskedContext(workInProgress2, unmaskedContext) {
            {
              var type = workInProgress2.type;
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var instance = workInProgress2.stateNode;
              if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                return instance.__reactInternalMemoizedMaskedChildContext;
              }
              var context = {};
              for (var key in contextTypes) {
                context[key] = unmaskedContext[key];
              }
              {
                var name = getComponentNameFromFiber(workInProgress2) || "Unknown";
                checkPropTypes(contextTypes, context, "context", name);
              }
              if (instance) {
                cacheContext(workInProgress2, unmaskedContext, context);
              }
              return context;
            }
          }
          function hasContextChanged() {
            {
              return didPerformWorkStackCursor.current;
            }
          }
          function isContextProvider(type) {
            {
              var childContextTypes = type.childContextTypes;
              return childContextTypes !== null && childContextTypes !== void 0;
            }
          }
          function popContext(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function popTopLevelContextObject(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function pushTopLevelContextObject(fiber, context, didChange) {
            {
              if (contextStackCursor.current !== emptyContextObject) {
                throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
              }
              push(contextStackCursor, context, fiber);
              push(didPerformWorkStackCursor, didChange, fiber);
            }
          }
          function processChildContext(fiber, type, parentContext) {
            {
              var instance = fiber.stateNode;
              var childContextTypes = type.childContextTypes;
              if (typeof instance.getChildContext !== "function") {
                {
                  var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error2("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext = instance.getChildContext();
              for (var contextKey in childContext) {
                if (!(contextKey in childContextTypes)) {
                  throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                }
              }
              {
                var name = getComponentNameFromFiber(fiber) || "Unknown";
                checkPropTypes(childContextTypes, childContext, "child context", name);
              }
              return assign({}, parentContext, childContext);
            }
          }
          function pushContextProvider(workInProgress2) {
            {
              var instance = workInProgress2.stateNode;
              var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
              previousContext = contextStackCursor.current;
              push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
              push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
              return true;
            }
          }
          function invalidateContextProvider(workInProgress2, type, didChange) {
            {
              var instance = workInProgress2.stateNode;
              if (!instance) {
                throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
              }
              if (didChange) {
                var mergedContext = processChildContext(workInProgress2, type, previousContext);
                instance.__reactInternalMemoizedMergedChildContext = mergedContext;
                pop(didPerformWorkStackCursor, workInProgress2);
                pop(contextStackCursor, workInProgress2);
                push(contextStackCursor, mergedContext, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              } else {
                pop(didPerformWorkStackCursor, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              }
            }
          }
          function findCurrentUnmaskedContext(fiber) {
            {
              if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
                throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
              }
              var node = fiber;
              do {
                switch (node.tag) {
                  case HostRoot:
                    return node.stateNode.context;
                  case ClassComponent: {
                    var Component9 = node.type;
                    if (isContextProvider(Component9)) {
                      return node.stateNode.__reactInternalMemoizedMergedChildContext;
                    }
                    break;
                  }
                }
                node = node.return;
              } while (node !== null);
              throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          var LegacyRoot = 0;
          var ConcurrentRoot = 1;
          var syncQueue = null;
          var includesLegacySyncCallbacks = false;
          var isFlushingSyncQueue = false;
          function scheduleSyncCallback(callback) {
            if (syncQueue === null) {
              syncQueue = [callback];
            } else {
              syncQueue.push(callback);
            }
          }
          function scheduleLegacySyncCallback(callback) {
            includesLegacySyncCallbacks = true;
            scheduleSyncCallback(callback);
          }
          function flushSyncCallbacksOnlyInLegacyMode() {
            if (includesLegacySyncCallbacks) {
              flushSyncCallbacks();
            }
          }
          function flushSyncCallbacks() {
            if (!isFlushingSyncQueue && syncQueue !== null) {
              isFlushingSyncQueue = true;
              var i = 0;
              var previousUpdatePriority = getCurrentUpdatePriority();
              try {
                var isSync = true;
                var queue = syncQueue;
                setCurrentUpdatePriority(DiscreteEventPriority);
                for (; i < queue.length; i++) {
                  var callback = queue[i];
                  do {
                    callback = callback(isSync);
                  } while (callback !== null);
                }
                syncQueue = null;
                includesLegacySyncCallbacks = false;
              } catch (error3) {
                if (syncQueue !== null) {
                  syncQueue = syncQueue.slice(i + 1);
                }
                scheduleCallback(ImmediatePriority, flushSyncCallbacks);
                throw error3;
              } finally {
                setCurrentUpdatePriority(previousUpdatePriority);
                isFlushingSyncQueue = false;
              }
            }
            return null;
          }
          var forkStack = [];
          var forkStackIndex = 0;
          var treeForkProvider = null;
          var treeForkCount = 0;
          var idStack = [];
          var idStackIndex = 0;
          var treeContextProvider = null;
          var treeContextId = 1;
          var treeContextOverflow = "";
          function isForkedChild(workInProgress2) {
            warnIfNotHydrating();
            return (workInProgress2.flags & Forked) !== NoFlags;
          }
          function getForksAtLevel(workInProgress2) {
            warnIfNotHydrating();
            return treeForkCount;
          }
          function getTreeId() {
            var overflow = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
            return id.toString(32) + overflow;
          }
          function pushTreeFork(workInProgress2, totalChildren) {
            warnIfNotHydrating();
            forkStack[forkStackIndex++] = treeForkCount;
            forkStack[forkStackIndex++] = treeForkProvider;
            treeForkProvider = workInProgress2;
            treeForkCount = totalChildren;
          }
          function pushTreeId(workInProgress2, totalChildren, index2) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextProvider = workInProgress2;
            var baseIdWithLeadingBit = treeContextId;
            var baseOverflow = treeContextOverflow;
            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
            var slot = index2 + 1;
            var length = getBitLength(totalChildren) + baseLength;
            if (length > 30) {
              var numberOfOverflowBits = baseLength - baseLength % 5;
              var newOverflowBits = (1 << numberOfOverflowBits) - 1;
              var newOverflow = (baseId & newOverflowBits).toString(32);
              var restOfBaseId = baseId >> numberOfOverflowBits;
              var restOfBaseLength = baseLength - numberOfOverflowBits;
              var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
              var restOfNewBits = slot << restOfBaseLength;
              var id = restOfNewBits | restOfBaseId;
              var overflow = newOverflow + baseOverflow;
              treeContextId = 1 << restOfLength | id;
              treeContextOverflow = overflow;
            } else {
              var newBits = slot << baseLength;
              var _id = newBits | baseId;
              var _overflow = baseOverflow;
              treeContextId = 1 << length | _id;
              treeContextOverflow = _overflow;
            }
          }
          function pushMaterializedTreeId(workInProgress2) {
            warnIfNotHydrating();
            var returnFiber = workInProgress2.return;
            if (returnFiber !== null) {
              var numberOfForks = 1;
              var slotIndex = 0;
              pushTreeFork(workInProgress2, numberOfForks);
              pushTreeId(workInProgress2, numberOfForks, slotIndex);
            }
          }
          function getBitLength(number) {
            return 32 - clz32(number);
          }
          function getLeadingBit(id) {
            return 1 << getBitLength(id) - 1;
          }
          function popTreeContext(workInProgress2) {
            while (workInProgress2 === treeForkProvider) {
              treeForkProvider = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
              treeForkCount = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
            }
            while (workInProgress2 === treeContextProvider) {
              treeContextProvider = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextOverflow = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextId = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
            }
          }
          function getSuspendedTreeContext() {
            warnIfNotHydrating();
            if (treeContextProvider !== null) {
              return {
                id: treeContextId,
                overflow: treeContextOverflow
              };
            } else {
              return null;
            }
          }
          function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextId = suspendedContext.id;
            treeContextOverflow = suspendedContext.overflow;
            treeContextProvider = workInProgress2;
          }
          function warnIfNotHydrating() {
            {
              if (!getIsHydrating()) {
                error2("Expected to be hydrating. This is a bug in React. Please file an issue.");
              }
            }
          }
          var hydrationParentFiber = null;
          var nextHydratableInstance = null;
          var isHydrating = false;
          var didSuspendOrErrorDEV = false;
          var hydrationErrors = null;
          function warnIfHydrating() {
            {
              if (isHydrating) {
                error2("We should not be hydrating here. This is a bug in React. Please file a bug.");
              }
            }
          }
          function markDidThrowWhileHydratingDEV() {
            {
              didSuspendOrErrorDEV = true;
            }
          }
          function didSuspendOrErrorWhileHydratingDEV() {
            {
              return didSuspendOrErrorDEV;
            }
          }
          function enterHydrationState(fiber) {
            var parentInstance = fiber.stateNode.containerInfo;
            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            return true;
          }
          function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            if (treeContext !== null) {
              restoreSuspendedTreeContext(fiber, treeContext);
            }
            return true;
          }
          function warnUnhydratedInstance(returnFiber, instance) {
            {
              switch (returnFiber.tag) {
                case HostRoot: {
                  didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                  break;
                }
                case HostComponent: {
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotHydrateInstance(
                    returnFiber.type,
                    returnFiber.memoizedProps,
                    returnFiber.stateNode,
                    instance,
                    // TODO: Delete this argument when we remove the legacy root API.
                    isConcurrentMode
                  );
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  if (suspenseState.dehydrated !== null)
                    didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                  break;
                }
              }
            }
          }
          function deleteHydratableInstance(returnFiber, instance) {
            warnUnhydratedInstance(returnFiber, instance);
            var childToDelete = createFiberFromHostInstanceForDeletion();
            childToDelete.stateNode = instance;
            childToDelete.return = returnFiber;
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(childToDelete);
            }
          }
          function warnNonhydratedInstance(returnFiber, fiber) {
            {
              if (didSuspendOrErrorDEV) {
                return;
              }
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  switch (fiber.tag) {
                    case HostComponent:
                      var type = fiber.type;
                      var props = fiber.pendingProps;
                      didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                      break;
                    case HostText:
                      var text = fiber.pendingProps;
                      didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                      break;
                  }
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  switch (fiber.tag) {
                    case HostComponent: {
                      var _type = fiber.type;
                      var _props = fiber.pendingProps;
                      var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _type,
                        _props,
                        // TODO: Delete this argument when we remove the legacy root API.
                        isConcurrentMode
                      );
                      break;
                    }
                    case HostText: {
                      var _text = fiber.pendingProps;
                      var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableTextInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _text,
                        // TODO: Delete this argument when we remove the legacy root API.
                        _isConcurrentMode
                      );
                      break;
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  var _parentInstance = suspenseState.dehydrated;
                  if (_parentInstance !== null)
                    switch (fiber.tag) {
                      case HostComponent:
                        var _type2 = fiber.type;
                        var _props2 = fiber.pendingProps;
                        didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                        break;
                      case HostText:
                        var _text2 = fiber.pendingProps;
                        didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                        break;
                    }
                  break;
                }
                default:
                  return;
              }
            }
          }
          function insertNonHydratedInstance(returnFiber, fiber) {
            fiber.flags = fiber.flags & ~Hydrating | Placement;
            warnNonhydratedInstance(returnFiber, fiber);
          }
          function tryHydrate(fiber, nextInstance) {
            switch (fiber.tag) {
              case HostComponent: {
                var type = fiber.type;
                var props = fiber.pendingProps;
                var instance = canHydrateInstance(nextInstance, type);
                if (instance !== null) {
                  fiber.stateNode = instance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = getFirstHydratableChild(instance);
                  return true;
                }
                return false;
              }
              case HostText: {
                var text = fiber.pendingProps;
                var textInstance = canHydrateTextInstance(nextInstance, text);
                if (textInstance !== null) {
                  fiber.stateNode = textInstance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              case SuspenseComponent: {
                var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
                if (suspenseInstance !== null) {
                  var suspenseState = {
                    dehydrated: suspenseInstance,
                    treeContext: getSuspendedTreeContext(),
                    retryLane: OffscreenLane
                  };
                  fiber.memoizedState = suspenseState;
                  var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                  dehydratedFragment.return = fiber;
                  fiber.child = dehydratedFragment;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              default:
                return false;
            }
          }
          function shouldClientRenderOnMismatch(fiber) {
            return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
          }
          function throwOnHydrationMismatch(fiber) {
            throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
          }
          function tryToClaimNextHydratableInstance(fiber) {
            if (!isHydrating) {
              return;
            }
            var nextInstance = nextHydratableInstance;
            if (!nextInstance) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrate(fiber, nextInstance)) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              nextInstance = getNextHydratableSibling(firstAttemptedInstance);
              var prevHydrationParentFiber = hydrationParentFiber;
              if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating = false;
                hydrationParentFiber = fiber;
                return;
              }
              deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
            }
          }
          function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
            var instance = fiber.stateNode;
            var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
            fiber.updateQueue = updatePayload;
            if (updatePayload !== null) {
              return true;
            }
            return false;
          }
          function prepareToHydrateHostTextInstance(fiber) {
            var textInstance = fiber.stateNode;
            var textContent = fiber.memoizedProps;
            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
            if (shouldUpdate) {
              var returnFiber = hydrationParentFiber;
              if (returnFiber !== null) {
                switch (returnFiber.tag) {
                  case HostRoot: {
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedContainerTextInstance(
                      parentContainer,
                      textInstance,
                      textContent,
                      // TODO: Delete this argument when we remove the legacy root API.
                      isConcurrentMode
                    );
                    break;
                  }
                  case HostComponent: {
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedTextInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      textInstance,
                      textContent,
                      // TODO: Delete this argument when we remove the legacy root API.
                      _isConcurrentMode2
                    );
                    break;
                  }
                }
              }
            }
            return shouldUpdate;
          }
          function prepareToHydrateHostSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            hydrateSuspenseInstance(suspenseInstance, fiber);
          }
          function skipPastDehydratedSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
          }
          function popToNextHostParent(fiber) {
            var parent = fiber.return;
            while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
              parent = parent.return;
            }
            hydrationParentFiber = parent;
          }
          function popHydrationState(fiber) {
            if (fiber !== hydrationParentFiber) {
              return false;
            }
            if (!isHydrating) {
              popToNextHostParent(fiber);
              isHydrating = true;
              return false;
            }
            if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
              var nextInstance = nextHydratableInstance;
              if (nextInstance) {
                if (shouldClientRenderOnMismatch(fiber)) {
                  warnIfUnhydratedTailNodes(fiber);
                  throwOnHydrationMismatch();
                } else {
                  while (nextInstance) {
                    deleteHydratableInstance(fiber, nextInstance);
                    nextInstance = getNextHydratableSibling(nextInstance);
                  }
                }
              }
            }
            popToNextHostParent(fiber);
            if (fiber.tag === SuspenseComponent) {
              nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
            } else {
              nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
            }
            return true;
          }
          function hasUnhydratedTailNodes() {
            return isHydrating && nextHydratableInstance !== null;
          }
          function warnIfUnhydratedTailNodes(fiber) {
            var nextInstance = nextHydratableInstance;
            while (nextInstance) {
              warnUnhydratedInstance(fiber, nextInstance);
              nextInstance = getNextHydratableSibling(nextInstance);
            }
          }
          function resetHydrationState() {
            hydrationParentFiber = null;
            nextHydratableInstance = null;
            isHydrating = false;
            didSuspendOrErrorDEV = false;
          }
          function upgradeHydrationErrorsToRecoverable() {
            if (hydrationErrors !== null) {
              queueRecoverableErrors(hydrationErrors);
              hydrationErrors = null;
            }
          }
          function getIsHydrating() {
            return isHydrating;
          }
          function queueHydrationError(error3) {
            if (hydrationErrors === null) {
              hydrationErrors = [error3];
            } else {
              hydrationErrors.push(error3);
            }
          }
          var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
          var NoTransition = null;
          function requestCurrentTransition() {
            return ReactCurrentBatchConfig$1.transition;
          }
          var ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function(fiber, instance) {
            },
            flushPendingUnsafeLifecycleWarnings: function() {
            },
            recordLegacyContextWarning: function(fiber, instance) {
            },
            flushLegacyContextWarning: function() {
            },
            discardPendingWarnings: function() {
            }
          };
          {
            var findStrictRoot = function(fiber) {
              var maybeStrictRoot = null;
              var node = fiber;
              while (node !== null) {
                if (node.mode & StrictLegacyMode) {
                  maybeStrictRoot = node;
                }
                node = node.return;
              }
              return maybeStrictRoot;
            };
            var setToSortedString = function(set4) {
              var array = [];
              set4.forEach(function(value) {
                array.push(value);
              });
              return array.sort().join(", ");
            };
            var pendingComponentWillMountWarnings = [];
            var pendingUNSAFE_ComponentWillMountWarnings = [];
            var pendingComponentWillReceivePropsWarnings = [];
            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            var pendingComponentWillUpdateWarnings = [];
            var pendingUNSAFE_ComponentWillUpdateWarnings = [];
            var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
              if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                return;
              }
              if (typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
              instance.componentWillMount.__suppressDeprecationWarning !== true) {
                pendingComponentWillMountWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
                pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                pendingComponentWillReceivePropsWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                pendingComponentWillUpdateWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
                pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
              var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillMountWarnings.length > 0) {
                pendingComponentWillMountWarnings.forEach(function(fiber) {
                  componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillMountWarnings = [];
              }
              var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillMountWarnings = [];
              }
              var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillReceivePropsWarnings.length > 0) {
                pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillReceivePropsWarnings = [];
              }
              var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              }
              var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillUpdateWarnings.length > 0) {
                pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                  componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillUpdateWarnings = [];
              }
              var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillUpdateWarnings = [];
              }
              if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                error2("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
              }
              if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                error2("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
              }
              if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                error2("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
              }
              if (componentWillMountUniqueNames.size > 0) {
                var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
              }
              if (componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
              }
              if (componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
              }
            };
            var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
              var strictRoot = findStrictRoot(fiber);
              if (strictRoot === null) {
                error2("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
                return;
              }
              if (didWarnAboutLegacyContext.has(fiber.type)) {
                return;
              }
              var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
              if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
                if (warningsForRoot === void 0) {
                  warningsForRoot = [];
                  pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                }
                warningsForRoot.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushLegacyContextWarning = function() {
              pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
                if (fiberArray.length === 0) {
                  return;
                }
                var firstFiber = fiberArray[0];
                var uniqueNames = /* @__PURE__ */ new Set();
                fiberArray.forEach(function(fiber) {
                  uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutLegacyContext.add(fiber.type);
                });
                var sortedNames = setToSortedString(uniqueNames);
                try {
                  setCurrentFiber(firstFiber);
                  error2("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
                } finally {
                  resetCurrentFiber();
                }
              });
            };
            ReactStrictModeWarnings.discardPendingWarnings = function() {
              pendingComponentWillMountWarnings = [];
              pendingUNSAFE_ComponentWillMountWarnings = [];
              pendingComponentWillReceivePropsWarnings = [];
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              pendingComponentWillUpdateWarnings = [];
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
              pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            };
          }
          function resolveDefaultProps(Component9, baseProps) {
            if (Component9 && Component9.defaultProps) {
              var props = assign({}, baseProps);
              var defaultProps4 = Component9.defaultProps;
              for (var propName in defaultProps4) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps4[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          var valueCursor = createCursor(null);
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var currentlyRenderingFiber = null;
          var lastContextDependency = null;
          var lastFullyObservedContext = null;
          var isDisallowedContextReadInDEV = false;
          function resetContextDependencies() {
            currentlyRenderingFiber = null;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function enterDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = true;
            }
          }
          function exitDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function pushProvider(providerFiber, context, nextValue) {
            {
              push(valueCursor, context._currentValue, providerFiber);
              context._currentValue = nextValue;
              {
                if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                  error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer = rendererSigil;
              }
            }
          }
          function popProvider(context, providerFiber) {
            var currentValue = valueCursor.current;
            pop(valueCursor, providerFiber);
            {
              {
                context._currentValue = currentValue;
              }
            }
          }
          function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
            var node = parent;
            while (node !== null) {
              var alternate = node.alternate;
              if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
                node.childLanes = mergeLanes(node.childLanes, renderLanes2);
                if (alternate !== null) {
                  alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
                }
              } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
              if (node === propagationRoot) {
                break;
              }
              node = node.return;
            }
            {
              if (node !== propagationRoot) {
                error2("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function propagateContextChange(workInProgress2, context, renderLanes2) {
            {
              propagateContextChange_eager(workInProgress2, context, renderLanes2);
            }
          }
          function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
            var fiber = workInProgress2.child;
            if (fiber !== null) {
              fiber.return = workInProgress2;
            }
            while (fiber !== null) {
              var nextFiber = void 0;
              var list = fiber.dependencies;
              if (list !== null) {
                nextFiber = fiber.child;
                var dependency = list.firstContext;
                while (dependency !== null) {
                  if (dependency.context === context) {
                    if (fiber.tag === ClassComponent) {
                      var lane = pickArbitraryLane(renderLanes2);
                      var update = createUpdate(NoTimestamp, lane);
                      update.tag = ForceUpdate;
                      var updateQueue = fiber.updateQueue;
                      if (updateQueue === null)
                        ;
                      else {
                        var sharedQueue = updateQueue.shared;
                        var pending = sharedQueue.pending;
                        if (pending === null) {
                          update.next = update;
                        } else {
                          update.next = pending.next;
                          pending.next = update;
                        }
                        sharedQueue.pending = update;
                      }
                    }
                    fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                    var alternate = fiber.alternate;
                    if (alternate !== null) {
                      alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                    }
                    scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                    list.lanes = mergeLanes(list.lanes, renderLanes2);
                    break;
                  }
                  dependency = dependency.next;
                }
              } else if (fiber.tag === ContextProvider) {
                nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
              } else if (fiber.tag === DehydratedFragment) {
                var parentSuspense = fiber.return;
                if (parentSuspense === null) {
                  throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
                }
                parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
                var _alternate = parentSuspense.alternate;
                if (_alternate !== null) {
                  _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
                }
                scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
                nextFiber = fiber.sibling;
              } else {
                nextFiber = fiber.child;
              }
              if (nextFiber !== null) {
                nextFiber.return = fiber;
              } else {
                nextFiber = fiber;
                while (nextFiber !== null) {
                  if (nextFiber === workInProgress2) {
                    nextFiber = null;
                    break;
                  }
                  var sibling = nextFiber.sibling;
                  if (sibling !== null) {
                    sibling.return = nextFiber.return;
                    nextFiber = sibling;
                    break;
                  }
                  nextFiber = nextFiber.return;
                }
              }
              fiber = nextFiber;
            }
          }
          function prepareToReadContext(workInProgress2, renderLanes2) {
            currentlyRenderingFiber = workInProgress2;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            var dependencies = workInProgress2.dependencies;
            if (dependencies !== null) {
              {
                var firstContext = dependencies.firstContext;
                if (firstContext !== null) {
                  if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                    markWorkInProgressReceivedUpdate();
                  }
                  dependencies.firstContext = null;
                }
              }
            }
          }
          function readContext(context) {
            {
              if (isDisallowedContextReadInDEV) {
                error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            var value = context._currentValue;
            if (lastFullyObservedContext === context)
              ;
            else {
              var contextItem = {
                context,
                memoizedValue: value,
                next: null
              };
              if (lastContextDependency === null) {
                if (currentlyRenderingFiber === null) {
                  throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                }
                lastContextDependency = contextItem;
                currentlyRenderingFiber.dependencies = {
                  lanes: NoLanes,
                  firstContext: contextItem
                };
              } else {
                lastContextDependency = lastContextDependency.next = contextItem;
              }
            }
            return value;
          }
          var concurrentQueues = null;
          function pushConcurrentUpdateQueue(queue) {
            if (concurrentQueues === null) {
              concurrentQueues = [queue];
            } else {
              concurrentQueues.push(queue);
            }
          }
          function finishQueueingConcurrentUpdates() {
            if (concurrentQueues !== null) {
              for (var i = 0; i < concurrentQueues.length; i++) {
                var queue = concurrentQueues[i];
                var lastInterleavedUpdate = queue.interleaved;
                if (lastInterleavedUpdate !== null) {
                  queue.interleaved = null;
                  var firstInterleavedUpdate = lastInterleavedUpdate.next;
                  var lastPendingUpdate = queue.pending;
                  if (lastPendingUpdate !== null) {
                    var firstPendingUpdate = lastPendingUpdate.next;
                    lastPendingUpdate.next = firstInterleavedUpdate;
                    lastInterleavedUpdate.next = firstPendingUpdate;
                  }
                  queue.pending = lastInterleavedUpdate;
                }
              }
              concurrentQueues = null;
            }
          }
          function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
          }
          function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentRenderForLane(fiber, lane) {
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
          function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
            var alternate = sourceFiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, lane);
            }
            {
              if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
              }
            }
            var node = sourceFiber;
            var parent = sourceFiber.return;
            while (parent !== null) {
              parent.childLanes = mergeLanes(parent.childLanes, lane);
              alternate = parent.alternate;
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, lane);
              } else {
                {
                  if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                  }
                }
              }
              node = parent;
              parent = parent.return;
            }
            if (node.tag === HostRoot) {
              var root2 = node.stateNode;
              return root2;
            } else {
              return null;
            }
          }
          var UpdateState = 0;
          var ReplaceState = 1;
          var ForceUpdate = 2;
          var CaptureUpdate = 3;
          var hasForceUpdate = false;
          var didWarnUpdateInsideUpdate;
          var currentlyProcessingQueue;
          {
            didWarnUpdateInsideUpdate = false;
            currentlyProcessingQueue = null;
          }
          function initializeUpdateQueue(fiber) {
            var queue = {
              baseState: fiber.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: {
                pending: null,
                interleaved: null,
                lanes: NoLanes
              },
              effects: null
            };
            fiber.updateQueue = queue;
          }
          function cloneUpdateQueue(current2, workInProgress2) {
            var queue = workInProgress2.updateQueue;
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var clone5 = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: currentQueue.firstBaseUpdate,
                lastBaseUpdate: currentQueue.lastBaseUpdate,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = clone5;
            }
          }
          function createUpdate(eventTime, lane) {
            var update = {
              eventTime,
              lane,
              tag: UpdateState,
              payload: null,
              callback: null,
              next: null
            };
            return update;
          }
          function enqueueUpdate(fiber, update, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return null;
            }
            var sharedQueue = updateQueue.shared;
            {
              if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                error2("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
                didWarnUpdateInsideUpdate = true;
              }
            }
            if (isUnsafeClassRenderPhaseUpdate()) {
              var pending = sharedQueue.pending;
              if (pending === null) {
                update.next = update;
              } else {
                update.next = pending.next;
                pending.next = update;
              }
              sharedQueue.pending = update;
              return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
            } else {
              return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
            }
          }
          function entangleTransitions(root2, fiber, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return;
            }
            var sharedQueue = updateQueue.shared;
            if (isTransitionLane(lane)) {
              var queueLanes = sharedQueue.lanes;
              queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              sharedQueue.lanes = newQueueLanes;
              markRootEntangled(root2, newQueueLanes);
            }
          }
          function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
            var queue = workInProgress2.updateQueue;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue = current2.updateQueue;
              if (queue === currentQueue) {
                var newFirst = null;
                var newLast = null;
                var firstBaseUpdate = queue.firstBaseUpdate;
                if (firstBaseUpdate !== null) {
                  var update = firstBaseUpdate;
                  do {
                    var clone5 = {
                      eventTime: update.eventTime,
                      lane: update.lane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    if (newLast === null) {
                      newFirst = newLast = clone5;
                    } else {
                      newLast.next = clone5;
                      newLast = clone5;
                    }
                    update = update.next;
                  } while (update !== null);
                  if (newLast === null) {
                    newFirst = newLast = capturedUpdate;
                  } else {
                    newLast.next = capturedUpdate;
                    newLast = capturedUpdate;
                  }
                } else {
                  newFirst = newLast = capturedUpdate;
                }
                queue = {
                  baseState: currentQueue.baseState,
                  firstBaseUpdate: newFirst,
                  lastBaseUpdate: newLast,
                  shared: currentQueue.shared,
                  effects: currentQueue.effects
                };
                workInProgress2.updateQueue = queue;
                return;
              }
            }
            var lastBaseUpdate = queue.lastBaseUpdate;
            if (lastBaseUpdate === null) {
              queue.firstBaseUpdate = capturedUpdate;
            } else {
              lastBaseUpdate.next = capturedUpdate;
            }
            queue.lastBaseUpdate = capturedUpdate;
          }
          function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
            switch (update.tag) {
              case ReplaceState: {
                var payload = update.payload;
                if (typeof payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  var nextState = payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                  return nextState;
                }
                return payload;
              }
              case CaptureUpdate: {
                workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
              }
              case UpdateState: {
                var _payload = update.payload;
                var partialState;
                if (typeof _payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  partialState = _payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        _payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                } else {
                  partialState = _payload;
                }
                if (partialState === null || partialState === void 0) {
                  return prevState;
                }
                return assign({}, prevState, partialState);
              }
              case ForceUpdate: {
                hasForceUpdate = true;
                return prevState;
              }
            }
            return prevState;
          }
          function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
            var queue = workInProgress2.updateQueue;
            hasForceUpdate = false;
            {
              currentlyProcessingQueue = queue.shared;
            }
            var firstBaseUpdate = queue.firstBaseUpdate;
            var lastBaseUpdate = queue.lastBaseUpdate;
            var pendingQueue = queue.shared.pending;
            if (pendingQueue !== null) {
              queue.shared.pending = null;
              var lastPendingUpdate = pendingQueue;
              var firstPendingUpdate = lastPendingUpdate.next;
              lastPendingUpdate.next = null;
              if (lastBaseUpdate === null) {
                firstBaseUpdate = firstPendingUpdate;
              } else {
                lastBaseUpdate.next = firstPendingUpdate;
              }
              lastBaseUpdate = lastPendingUpdate;
              var current2 = workInProgress2.alternate;
              if (current2 !== null) {
                var currentQueue = current2.updateQueue;
                var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                if (currentLastBaseUpdate !== lastBaseUpdate) {
                  if (currentLastBaseUpdate === null) {
                    currentQueue.firstBaseUpdate = firstPendingUpdate;
                  } else {
                    currentLastBaseUpdate.next = firstPendingUpdate;
                  }
                  currentQueue.lastBaseUpdate = lastPendingUpdate;
                }
              }
            }
            if (firstBaseUpdate !== null) {
              var newState = queue.baseState;
              var newLanes = NoLanes;
              var newBaseState = null;
              var newFirstBaseUpdate = null;
              var newLastBaseUpdate = null;
              var update = firstBaseUpdate;
              do {
                var updateLane = update.lane;
                var updateEventTime = update.eventTime;
                if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                  var clone5 = {
                    eventTime: updateEventTime,
                    lane: updateLane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  if (newLastBaseUpdate === null) {
                    newFirstBaseUpdate = newLastBaseUpdate = clone5;
                    newBaseState = newState;
                  } else {
                    newLastBaseUpdate = newLastBaseUpdate.next = clone5;
                  }
                  newLanes = mergeLanes(newLanes, updateLane);
                } else {
                  if (newLastBaseUpdate !== null) {
                    var _clone = {
                      eventTime: updateEventTime,
                      // This update is going to be committed so we never want uncommit
                      // it. Using NoLane works because 0 is a subset of all bitmasks, so
                      // this will never be skipped by the check above.
                      lane: NoLane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                  }
                  newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
                  var callback = update.callback;
                  if (callback !== null && // If the update was already committed, we should not queue its
                  // callback again.
                  update.lane !== NoLane) {
                    workInProgress2.flags |= Callback;
                    var effects = queue.effects;
                    if (effects === null) {
                      queue.effects = [update];
                    } else {
                      effects.push(update);
                    }
                  }
                }
                update = update.next;
                if (update === null) {
                  pendingQueue = queue.shared.pending;
                  if (pendingQueue === null) {
                    break;
                  } else {
                    var _lastPendingUpdate = pendingQueue;
                    var _firstPendingUpdate = _lastPendingUpdate.next;
                    _lastPendingUpdate.next = null;
                    update = _firstPendingUpdate;
                    queue.lastBaseUpdate = _lastPendingUpdate;
                    queue.shared.pending = null;
                  }
                }
              } while (true);
              if (newLastBaseUpdate === null) {
                newBaseState = newState;
              }
              queue.baseState = newBaseState;
              queue.firstBaseUpdate = newFirstBaseUpdate;
              queue.lastBaseUpdate = newLastBaseUpdate;
              var lastInterleaved = queue.shared.interleaved;
              if (lastInterleaved !== null) {
                var interleaved = lastInterleaved;
                do {
                  newLanes = mergeLanes(newLanes, interleaved.lane);
                  interleaved = interleaved.next;
                } while (interleaved !== lastInterleaved);
              } else if (firstBaseUpdate === null) {
                queue.shared.lanes = NoLanes;
              }
              markSkippedUpdateLanes(newLanes);
              workInProgress2.lanes = newLanes;
              workInProgress2.memoizedState = newState;
            }
            {
              currentlyProcessingQueue = null;
            }
          }
          function callCallback(callback, context) {
            if (typeof callback !== "function") {
              throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
            }
            callback.call(context);
          }
          function resetHasForceUpdateBeforeProcessing() {
            hasForceUpdate = false;
          }
          function checkHasForceUpdateAfterProcessing() {
            return hasForceUpdate;
          }
          function commitUpdateQueue(finishedWork, finishedQueue, instance) {
            var effects = finishedQueue.effects;
            finishedQueue.effects = null;
            if (effects !== null) {
              for (var i = 0; i < effects.length; i++) {
                var effect4 = effects[i];
                var callback = effect4.callback;
                if (callback !== null) {
                  effect4.callback = null;
                  callCallback(callback, instance);
                }
              }
            }
          }
          var fakeInternalInstance = {};
          var emptyRefsObject = new React159.Component().refs;
          var didWarnAboutStateAssignmentForComponent;
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          {
            didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
            didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
            didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
            didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
            var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
            warnOnInvalidCallback = function(callback, callerName) {
              if (callback === null || typeof callback === "function") {
                return;
              }
              var key = callerName + "_" + callback;
              if (!didWarnOnInvalidCallback.has(key)) {
                didWarnOnInvalidCallback.add(key);
                error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            };
            warnOnUndefinedDerivedState = function(type, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentNameFromType(type) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error2("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
            Object.defineProperty(fakeInternalInstance, "_processChildContext", {
              enumerable: false,
              value: function() {
                throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
              }
            });
            Object.freeze(fakeInternalInstance);
          }
          function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
            var prevState = workInProgress2.memoizedState;
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  partialState = getDerivedStateFromProps(nextProps, prevState);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var memoizedState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
            workInProgress2.memoizedState = memoizedState;
            if (workInProgress2.lanes === NoLanes) {
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = memoizedState;
            }
          }
          var classComponentUpdater = {
            isMounted,
            enqueueSetState: function(inst, payload, callback) {
              var fiber = get2(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "setState");
                }
                update.callback = callback;
              }
              var root2 = enqueueUpdate(fiber, update, lane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitions(root2, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueReplaceState: function(inst, payload, callback) {
              var fiber = get2(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ReplaceState;
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "replaceState");
                }
                update.callback = callback;
              }
              var root2 = enqueueUpdate(fiber, update, lane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitions(root2, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueForceUpdate: function(inst, callback) {
              var fiber = get2(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ForceUpdate;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "forceUpdate");
                }
                update.callback = callback;
              }
              var root2 = enqueueUpdate(fiber, update, lane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitions(root2, fiber, lane);
              }
              {
                markForceUpdateScheduled(fiber, lane);
              }
            }
          };
          function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
            var instance = workInProgress2.stateNode;
            if (typeof instance.shouldComponentUpdate === "function") {
              var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                if (shouldUpdate === void 0) {
                  error2("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
                }
              }
              return shouldUpdate;
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent) {
              return !shallowEqual5(oldProps, newProps) || !shallowEqual5(oldState, newState);
            }
            return true;
          }
          function checkClassInstance(workInProgress2, ctor, newProps) {
            var instance = workInProgress2.stateNode;
            {
              var name = getComponentNameFromType(ctor) || "Component";
              var renderPresent = instance.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error2("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
                } else {
                  error2("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
                }
              }
              if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                error2("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
              }
              if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                error2("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
              }
              if (instance.propTypes) {
                error2("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
              }
              if (instance.contextType) {
                error2("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
              }
              {
                if (instance.contextTypes) {
                  error2("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error2("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
                }
              }
              if (typeof instance.componentShouldUpdate === "function") {
                error2("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                error2("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
              }
              if (typeof instance.componentDidUnmount === "function") {
                error2("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
              }
              if (typeof instance.componentDidReceiveProps === "function") {
                error2("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
              }
              if (typeof instance.componentWillRecieveProps === "function") {
                error2("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
              }
              if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                error2("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
              }
              var hasMutatedProps = instance.props !== newProps;
              if (instance.props !== void 0 && hasMutatedProps) {
                error2("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
              }
              if (instance.defaultProps) {
                error2("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error2("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
              }
              if (typeof instance.getDerivedStateFromProps === "function") {
                error2("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof instance.getDerivedStateFromError === "function") {
                error2("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error2("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
              }
              var _state = instance.state;
              if (_state && (typeof _state !== "object" || isArray(_state))) {
                error2("%s.state: must be set to an object or null", name);
              }
              if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error2("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
              }
            }
          }
          function adoptClassInstance(workInProgress2, instance) {
            instance.updater = classComponentUpdater;
            workInProgress2.stateNode = instance;
            set3(instance, workInProgress2);
            {
              instance._reactInternalInstance = fakeInternalInstance;
            }
          }
          function constructClassInstance(workInProgress2, ctor, props) {
            var isLegacyContextConsumer = false;
            var unmaskedContext = emptyContextObject;
            var context = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid = (
                  // Allow null for conditional declaration
                  contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
                );
                if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error2("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context = readContext(contextType);
            } else {
              unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              var contextTypes = ctor.contextTypes;
              isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
              context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
            }
            var instance = new ctor(props, context);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  instance = new ctor(props, context);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
            adoptClassInstance(workInProgress2, instance);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error2("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentNameFromType(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error2("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            if (isLegacyContextConsumer) {
              cacheContext(workInProgress2, unmaskedContext, context);
            }
            return instance;
          }
          function callComponentWillMount(workInProgress2, instance) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
            if (oldState !== instance.state) {
              {
                error2("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
            var oldState = instance.state;
            if (typeof instance.componentWillReceiveProps === "function") {
              instance.componentWillReceiveProps(newProps, nextContext);
            }
            if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
            }
            if (instance.state !== oldState) {
              {
                var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
                if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                  didWarnAboutStateAssignmentForComponent.add(componentName);
                  error2("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
                }
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            {
              checkClassInstance(workInProgress2, ctor, newProps);
            }
            var instance = workInProgress2.stateNode;
            instance.props = newProps;
            instance.state = workInProgress2.memoizedState;
            instance.refs = emptyRefsObject;
            initializeUpdateQueue(workInProgress2);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance.context = readContext(contextType);
            } else {
              var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              instance.context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            {
              if (instance.state === newProps) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error2("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
              }
              {
                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
              }
            }
            instance.state = workInProgress2.memoizedState;
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              callComponentWillMount(workInProgress2, instance);
              processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof instance.componentDidMount === "function") {
              var fiberFlags = Update;
              {
                fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= fiberFlags;
            }
          }
          function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            var oldProps = workInProgress2.memoizedProps;
            instance.props = oldProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (oldProps !== newProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance.componentDidMount === "function") {
                var fiberFlags = Update;
                {
                  fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= fiberFlags;
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
                if (typeof instance.componentWillMount === "function") {
                  instance.componentWillMount();
                }
                if (typeof instance.UNSAFE_componentWillMount === "function") {
                  instance.UNSAFE_componentWillMount();
                }
              }
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags = Update;
                {
                  _fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags;
              }
            } else {
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags2 = Update;
                {
                  _fiberFlags2 |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags2 |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags2;
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            var unresolvedOldProps = workInProgress2.memoizedProps;
            var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
            instance.props = oldProps;
            var unresolvedNewProps = workInProgress2.pendingProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot2;
                }
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
            // both before and after `shouldComponentUpdate` has been called. Not ideal,
            // but I'm loath to refactor this function. This only happens for memoized
            // components so it's not that common.
            enableLazyContextPropagation;
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
                if (typeof instance.componentWillUpdate === "function") {
                  instance.componentWillUpdate(newProps, newState, nextContext);
                }
                if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
                }
              }
              if (typeof instance.componentDidUpdate === "function") {
                workInProgress2.flags |= Update;
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                workInProgress2.flags |= Snapshot2;
              }
            } else {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot2;
                }
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          var didWarnAboutMaps;
          var didWarnAboutGenerators;
          var didWarnAboutStringRefs;
          var ownerHasKeyUseWarning;
          var ownerHasFunctionTypeWarning;
          var warnForMissingKey = function(child, returnFiber) {
          };
          {
            didWarnAboutMaps = false;
            didWarnAboutGenerators = false;
            didWarnAboutStringRefs = {};
            ownerHasKeyUseWarning = {};
            ownerHasFunctionTypeWarning = {};
            warnForMissingKey = function(child, returnFiber) {
              if (child === null || typeof child !== "object") {
                return;
              }
              if (!child._store || child._store.validated || child.key != null) {
                return;
              }
              if (typeof child._store !== "object") {
                throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
              }
              child._store.validated = true;
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasKeyUseWarning[componentName]) {
                return;
              }
              ownerHasKeyUseWarning[componentName] = true;
              error2('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
            };
          }
          function coerceRef(returnFiber, current2, element) {
            var mixedRef = element.ref;
            if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
              {
                if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
                // because these cannot be automatically converted to an arrow function
                // using a codemod. Therefore, we don't have to warn about string refs again.
                !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                  var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                  if (!didWarnAboutStringRefs[componentName]) {
                    {
                      error2('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);
                    }
                    didWarnAboutStringRefs[componentName] = true;
                  }
                }
              }
              if (element._owner) {
                var owner = element._owner;
                var inst;
                if (owner) {
                  var ownerFiber = owner;
                  if (ownerFiber.tag !== ClassComponent) {
                    throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                  }
                  inst = ownerFiber.stateNode;
                }
                if (!inst) {
                  throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                }
                var resolvedInst = inst;
                {
                  checkPropStringCoercion(mixedRef, "ref");
                }
                var stringRef = "" + mixedRef;
                if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                  return current2.ref;
                }
                var ref = function(value) {
                  var refs = resolvedInst.refs;
                  if (refs === emptyRefsObject) {
                    refs = resolvedInst.refs = {};
                  }
                  if (value === null) {
                    delete refs[stringRef];
                  } else {
                    refs[stringRef] = value;
                  }
                };
                ref._stringRef = stringRef;
                return ref;
              } else {
                if (typeof mixedRef !== "string") {
                  throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                }
                if (!element._owner) {
                  throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
                }
              }
            }
            return mixedRef;
          }
          function throwOnInvalidObjectType(returnFiber, newChild) {
            var childString = Object.prototype.toString.call(newChild);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          function warnOnFunctionType(returnFiber) {
            {
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasFunctionTypeWarning[componentName]) {
                return;
              }
              ownerHasFunctionTypeWarning[componentName] = true;
              error2("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
          function resolveLazy(lazyType) {
            var payload = lazyType._payload;
            var init = lazyType._init;
            return init(payload);
          }
          function ChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
              if (!shouldTrackSideEffects) {
                return;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [childToDelete];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(childToDelete);
              }
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
              if (!shouldTrackSideEffects) {
                return null;
              }
              var childToDelete = currentFirstChild;
              while (childToDelete !== null) {
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
              }
              return null;
            }
            function mapRemainingChildren(returnFiber, currentFirstChild) {
              var existingChildren = /* @__PURE__ */ new Map();
              var existingChild = currentFirstChild;
              while (existingChild !== null) {
                if (existingChild.key !== null) {
                  existingChildren.set(existingChild.key, existingChild);
                } else {
                  existingChildren.set(existingChild.index, existingChild);
                }
                existingChild = existingChild.sibling;
              }
              return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
              var clone5 = createWorkInProgress(fiber, pendingProps);
              clone5.index = 0;
              clone5.sibling = null;
              return clone5;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
              newFiber.index = newIndex;
              if (!shouldTrackSideEffects) {
                newFiber.flags |= Forked;
                return lastPlacedIndex;
              }
              var current2 = newFiber.alternate;
              if (current2 !== null) {
                var oldIndex = current2.index;
                if (oldIndex < lastPlacedIndex) {
                  newFiber.flags |= Placement;
                  return lastPlacedIndex;
                } else {
                  return oldIndex;
                }
              } else {
                newFiber.flags |= Placement;
                return lastPlacedIndex;
              }
            }
            function placeSingleChild(newFiber) {
              if (shouldTrackSideEffects && newFiber.alternate === null) {
                newFiber.flags |= Placement;
              }
              return newFiber;
            }
            function updateTextNode(returnFiber, current2, textContent, lanes) {
              if (current2 === null || current2.tag !== HostText) {
                var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, textContent);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateElement(returnFiber, current2, element, lanes) {
              var elementType2 = element.type;
              if (elementType2 === REACT_FRAGMENT_TYPE) {
                return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
              }
              if (current2 !== null) {
                if (current2.elementType === elementType2 || // Keep this check inline so it only runs on the false path:
                isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.
                // We need to do this after the Hot Reloading check above,
                // because hot reloading has different semantics than prod because
                // it doesn't resuspend. So we can't let the call below suspend.
                typeof elementType2 === "object" && elementType2 !== null && elementType2.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType2) === current2.type) {
                  var existing = useFiber(current2, element.props);
                  existing.ref = coerceRef(returnFiber, current2, element);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              }
              var created = createFiberFromElement(element, returnFiber.mode, lanes);
              created.ref = coerceRef(returnFiber, current2, element);
              created.return = returnFiber;
              return created;
            }
            function updatePortal(returnFiber, current2, portal, lanes) {
              if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, portal.children || []);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateFragment2(returnFiber, current2, fragment, lanes, key) {
              if (current2 === null || current2.tag !== Fragment2) {
                var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, fragment);
                existing.return = returnFiber;
                return existing;
              }
            }
            function createChild(returnFiber, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                    _created.ref = coerceRef(returnFiber, null, newChild);
                    _created.return = returnFiber;
                    return _created;
                  }
                  case REACT_PORTAL_TYPE: {
                    var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                    _created2.return = returnFiber;
                    return _created2;
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return createChild(returnFiber, init(payload), lanes);
                  }
                }
                if (isArray(newChild) || getIteratorFn(newChild)) {
                  var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                  _created3.return = returnFiber;
                  return _created3;
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, lanes) {
              var key = oldFiber !== null ? oldFiber.key : null;
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                if (key !== null) {
                  return null;
                }
                return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    if (newChild.key === key) {
                      return updateElement(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_PORTAL_TYPE: {
                    if (newChild.key === key) {
                      return updatePortal(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return updateSlot(returnFiber, oldFiber, init(payload), lanes);
                  }
                }
                if (isArray(newChild) || getIteratorFn(newChild)) {
                  if (key !== null) {
                    return null;
                  }
                  return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var matchedFiber = existingChildren.get(newIdx) || null;
                return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                  }
                  case REACT_PORTAL_TYPE: {
                    var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                  }
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
                }
                if (isArray(newChild) || getIteratorFn(newChild)) {
                  var _matchedFiber3 = existingChildren.get(newIdx) || null;
                  return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function warnOnInvalidKey(child, knownKeys, returnFiber) {
              {
                if (typeof child !== "object" || child === null) {
                  return knownKeys;
                }
                switch (child.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    warnForMissingKey(child, returnFiber);
                    var key = child.key;
                    if (typeof key !== "string") {
                      break;
                    }
                    if (knownKeys === null) {
                      knownKeys = /* @__PURE__ */ new Set();
                      knownKeys.add(key);
                      break;
                    }
                    if (!knownKeys.has(key)) {
                      knownKeys.add(key);
                      break;
                    }
                    error2("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                    break;
                  case REACT_LAZY_TYPE:
                    var payload = child._payload;
                    var init = child._init;
                    warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                    break;
                }
              }
              return knownKeys;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
              {
                var knownKeys = null;
                for (var i = 0; i < newChildren.length; i++) {
                  var child = newChildren[i];
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (newIdx === newChildren.length) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; newIdx < newChildren.length; newIdx++) {
                  var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                  if (_newFiber === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber;
                  } else {
                    previousNewFiber.sibling = _newFiber;
                  }
                  previousNewFiber = _newFiber;
                }
                if (getIsHydrating()) {
                  var _numberOfForks = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                if (_newFiber2 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber2.alternate !== null) {
                      existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber2;
                  } else {
                    previousNewFiber.sibling = _newFiber2;
                  }
                  previousNewFiber = _newFiber2;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks2 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks2);
              }
              return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
              var iteratorFn = getIteratorFn(newChildrenIterable);
              if (typeof iteratorFn !== "function") {
                throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
              }
              {
                if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
                newChildrenIterable[Symbol.toStringTag] === "Generator") {
                  if (!didWarnAboutGenerators) {
                    error2("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                  }
                  didWarnAboutGenerators = true;
                }
                if (newChildrenIterable.entries === iteratorFn) {
                  if (!didWarnAboutMaps) {
                    error2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
                var _newChildren = iteratorFn.call(newChildrenIterable);
                if (_newChildren) {
                  var knownKeys = null;
                  var _step = _newChildren.next();
                  for (; !_step.done; _step = _newChildren.next()) {
                    var child = _step.value;
                    knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                  }
                }
              }
              var newChildren = iteratorFn.call(newChildrenIterable);
              if (newChildren == null) {
                throw new Error("An iterable object provided no iterator.");
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              var step = newChildren.next();
              for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (step.done) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; !step.done; newIdx++, step = newChildren.next()) {
                  var _newFiber3 = createChild(returnFiber, step.value, lanes);
                  if (_newFiber3 === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber3;
                  } else {
                    previousNewFiber.sibling = _newFiber3;
                  }
                  previousNewFiber = _newFiber3;
                }
                if (getIsHydrating()) {
                  var _numberOfForks3 = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks3);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
                if (_newFiber4 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber4.alternate !== null) {
                      existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber4;
                  } else {
                    previousNewFiber.sibling = _newFiber4;
                  }
                  previousNewFiber = _newFiber4;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks4 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks4);
              }
              return resultingFirstChild;
            }
            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
              if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                var existing = useFiber(currentFirstChild, textContent);
                existing.return = returnFiber;
                return existing;
              }
              deleteRemainingChildren(returnFiber, currentFirstChild);
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
              var key = element.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  var elementType2 = element.type;
                  if (elementType2 === REACT_FRAGMENT_TYPE) {
                    if (child.tag === Fragment2) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var existing = useFiber(child, element.props.children);
                      existing.return = returnFiber;
                      {
                        existing._debugSource = element._source;
                        existing._debugOwner = element._owner;
                      }
                      return existing;
                    }
                  } else {
                    if (child.elementType === elementType2 || // Keep this check inline so it only runs on the false path:
                    isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                    // We need to do this after the Hot Reloading check above,
                    // because hot reloading has different semantics than prod because
                    // it doesn't resuspend. So we can't let the call below suspend.
                    typeof elementType2 === "object" && elementType2 !== null && elementType2.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType2) === child.type) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var _existing = useFiber(child, element.props);
                      _existing.ref = coerceRef(returnFiber, child, element);
                      _existing.return = returnFiber;
                      {
                        _existing._debugSource = element._source;
                        _existing._debugOwner = element._owner;
                      }
                      return _existing;
                    }
                  }
                  deleteRemainingChildren(returnFiber, child);
                  break;
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              if (element.type === REACT_FRAGMENT_TYPE) {
                var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                created.return = returnFiber;
                return created;
              } else {
                var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                _created4.return = returnFiber;
                return _created4;
              }
            }
            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
              var key = portal.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, portal.children || []);
                    existing.return = returnFiber;
                    return existing;
                  } else {
                    deleteRemainingChildren(returnFiber, child);
                    break;
                  }
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
              var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
              if (isUnkeyedTopLevelFragment) {
                newChild = newChild.props.children;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_PORTAL_TYPE:
                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);
                }
                if (isArray(newChild)) {
                  return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
                }
                if (getIteratorFn(newChild)) {
                  return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            return reconcileChildFibers2;
          }
          var reconcileChildFibers = ChildReconciler(true);
          var mountChildFibers = ChildReconciler(false);
          function cloneChildFibers(current2, workInProgress2) {
            if (current2 !== null && workInProgress2.child !== current2.child) {
              throw new Error("Resuming work not yet implemented.");
            }
            if (workInProgress2.child === null) {
              return;
            }
            var currentChild = workInProgress2.child;
            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
            workInProgress2.child = newChild;
            newChild.return = workInProgress2;
            while (currentChild.sibling !== null) {
              currentChild = currentChild.sibling;
              newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
              newChild.return = workInProgress2;
            }
            newChild.sibling = null;
          }
          function resetChildFibers(workInProgress2, lanes) {
            var child = workInProgress2.child;
            while (child !== null) {
              resetWorkInProgress(child, lanes);
              child = child.sibling;
            }
          }
          var NO_CONTEXT = {};
          var contextStackCursor$1 = createCursor(NO_CONTEXT);
          var contextFiberStackCursor = createCursor(NO_CONTEXT);
          var rootInstanceStackCursor = createCursor(NO_CONTEXT);
          function requiredContext(c) {
            if (c === NO_CONTEXT) {
              throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
            }
            return c;
          }
          function getRootHostContainer() {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            return rootInstance;
          }
          function pushHostContainer(fiber, nextRootInstance) {
            push(rootInstanceStackCursor, nextRootInstance, fiber);
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, NO_CONTEXT, fiber);
            var nextRootContext = getRootHostContext(nextRootInstance);
            pop(contextStackCursor$1, fiber);
            push(contextStackCursor$1, nextRootContext, fiber);
          }
          function popHostContainer(fiber) {
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
            pop(rootInstanceStackCursor, fiber);
          }
          function getHostContext() {
            var context = requiredContext(contextStackCursor$1.current);
            return context;
          }
          function pushHostContext(fiber) {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            var context = requiredContext(contextStackCursor$1.current);
            var nextContext = getChildHostContext(context, fiber.type);
            if (context === nextContext) {
              return;
            }
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, nextContext, fiber);
          }
          function popHostContext(fiber) {
            if (contextFiberStackCursor.current !== fiber) {
              return;
            }
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
          }
          var DefaultSuspenseContext = 0;
          var SubtreeSuspenseContextMask = 1;
          var InvisibleParentSuspenseContext = 1;
          var ForceSuspenseFallback = 2;
          var suspenseStackCursor = createCursor(DefaultSuspenseContext);
          function hasSuspenseContext(parentContext, flag) {
            return (parentContext & flag) !== 0;
          }
          function setDefaultShallowSuspenseContext(parentContext) {
            return parentContext & SubtreeSuspenseContextMask;
          }
          function setShallowSuspenseContext(parentContext, shallowContext) {
            return parentContext & SubtreeSuspenseContextMask | shallowContext;
          }
          function addSubtreeSuspenseContext(parentContext, subtreeContext) {
            return parentContext | subtreeContext;
          }
          function pushSuspenseContext(fiber, newContext) {
            push(suspenseStackCursor, newContext, fiber);
          }
          function popSuspenseContext(fiber) {
            pop(suspenseStackCursor, fiber);
          }
          function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
            var nextState = workInProgress2.memoizedState;
            if (nextState !== null) {
              if (nextState.dehydrated !== null) {
                return true;
              }
              return false;
            }
            var props = workInProgress2.memoizedProps;
            {
              return true;
            }
          }
          function findFirstSuspended(row) {
            var node = row;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  var dehydrated = state.dehydrated;
                  if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                    return node;
                  }
                }
              } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
              // keep track of whether it suspended or not.
              node.memoizedProps.revealOrder !== void 0) {
                var didSuspend = (node.flags & DidCapture) !== NoFlags;
                if (didSuspend) {
                  return node;
                }
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === row) {
                return null;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === row) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          var NoFlags$1 = (
            /*   */
            0
          );
          var HasEffect = (
            /* */
            1
          );
          var Insertion = (
            /*  */
            2
          );
          var Layout = (
            /*    */
            4
          );
          var Passive$1 = (
            /*   */
            8
          );
          var workInProgressSources = [];
          function resetWorkInProgressVersions() {
            for (var i = 0; i < workInProgressSources.length; i++) {
              var mutableSource = workInProgressSources[i];
              {
                mutableSource._workInProgressVersionPrimary = null;
              }
            }
            workInProgressSources.length = 0;
          }
          function registerMutableSourceForHydration(root2, mutableSource) {
            var getVersion = mutableSource._getVersion;
            var version = getVersion(mutableSource._source);
            if (root2.mutableSourceEagerHydrationData == null) {
              root2.mutableSourceEagerHydrationData = [mutableSource, version];
            } else {
              root2.mutableSourceEagerHydrationData.push(mutableSource, version);
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
          var didWarnAboutMismatchedHooksForComponent;
          var didWarnUncachedGetSnapshot;
          {
            didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
          }
          var renderLanes = NoLanes;
          var currentlyRenderingFiber$1 = null;
          var currentHook = null;
          var workInProgressHook = null;
          var didScheduleRenderPhaseUpdate = false;
          var didScheduleRenderPhaseUpdateDuringThisPass = false;
          var localIdCounter = 0;
          var globalClientIdCounter = 0;
          var RE_RENDER_LIMIT = 25;
          var currentHookNameInDev = null;
          var hookTypesDev = null;
          var hookTypesUpdateIndexDev = -1;
          var ignorePreviousDependencies = false;
          function mountHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev === null) {
                hookTypesDev = [hookName];
              } else {
                hookTypesDev.push(hookName);
              }
            }
          }
          function updateHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev !== null) {
                hookTypesUpdateIndexDev++;
                if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                  warnOnHookMismatchInDev(hookName);
                }
              }
            }
          }
          function checkDepsAreArrayDev(deps) {
            {
              if (deps !== void 0 && deps !== null && !isArray(deps)) {
                error2("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
              }
            }
          }
          function warnOnHookMismatchInDev(currentHookName) {
            {
              var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
              if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                didWarnAboutMismatchedHooksForComponent.add(componentName);
                if (hookTypesDev !== null) {
                  var table = "";
                  var secondColumnStart = 30;
                  for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
                    var oldHookName = hookTypesDev[i];
                    var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                    var row = i + 1 + ". " + oldHookName;
                    while (row.length < secondColumnStart) {
                      row += " ";
                    }
                    row += newHookName + "\n";
                    table += row;
                  }
                  error2("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
                }
              }
            }
          }
          function throwInvalidHookError() {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            {
              if (ignorePreviousDependencies) {
                return false;
              }
            }
            if (prevDeps === null) {
              {
                error2("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error2("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
              }
            }
            for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
              if (objectIs(nextDeps[i], prevDeps[i])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function renderWithHooks(current2, workInProgress2, Component9, props, secondArg, nextRenderLanes) {
            renderLanes = nextRenderLanes;
            currentlyRenderingFiber$1 = workInProgress2;
            {
              hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
              hookTypesUpdateIndexDev = -1;
              ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
            }
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.lanes = NoLanes;
            {
              if (current2 !== null && current2.memoizedState !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
              } else if (hookTypesDev !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
              } else {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
              }
            }
            var children = Component9(props, secondArg);
            if (didScheduleRenderPhaseUpdateDuringThisPass) {
              var numberOfReRenders = 0;
              do {
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                localIdCounter = 0;
                if (numberOfReRenders >= RE_RENDER_LIMIT) {
                  throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                }
                numberOfReRenders += 1;
                {
                  ignorePreviousDependencies = false;
                }
                currentHook = null;
                workInProgressHook = null;
                workInProgress2.updateQueue = null;
                {
                  hookTypesUpdateIndexDev = -1;
                }
                ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                children = Component9(props, secondArg);
              } while (didScheduleRenderPhaseUpdateDuringThisPass);
            }
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            {
              workInProgress2._debugHookTypes = hookTypesDev;
            }
            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              currentHookNameInDev = null;
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
              // and creates false positives. To make this work in legacy mode, we'd
              // need to mark fibers that commit in an incomplete state, somehow. For
              // now I'll disable the warning that most of the bugs that would trigger
              // it are either exclusive to concurrent mode or exist in both.
              (current2.mode & ConcurrentMode) !== NoMode) {
                error2("Internal React error: Expected static flag was missing. Please notify the React team.");
              }
            }
            didScheduleRenderPhaseUpdate = false;
            if (didRenderTooFewHooks) {
              throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
            }
            return children;
          }
          function checkDidRenderIdHook() {
            var didRenderIdHook = localIdCounter !== 0;
            localIdCounter = 0;
            return didRenderIdHook;
          }
          function bailoutHooks(current2, workInProgress2, lanes) {
            workInProgress2.updateQueue = current2.updateQueue;
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
            } else {
              workInProgress2.flags &= ~(Passive | Update);
            }
            current2.lanes = removeLanes(current2.lanes, lanes);
          }
          function resetHooksAfterThrow() {
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            if (didScheduleRenderPhaseUpdate) {
              var hook = currentlyRenderingFiber$1.memoizedState;
              while (hook !== null) {
                var queue = hook.queue;
                if (queue !== null) {
                  queue.pending = null;
                }
                hook = hook.next;
              }
              didScheduleRenderPhaseUpdate = false;
            }
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              currentHookNameInDev = null;
              isUpdatingOpaqueValueInRenderPhase = false;
            }
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            localIdCounter = 0;
          }
          function mountWorkInProgressHook() {
            var hook = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
            } else {
              workInProgressHook = workInProgressHook.next = hook;
            }
            return workInProgressHook;
          }
          function updateWorkInProgressHook() {
            var nextCurrentHook;
            if (currentHook === null) {
              var current2 = currentlyRenderingFiber$1.alternate;
              if (current2 !== null) {
                nextCurrentHook = current2.memoizedState;
              } else {
                nextCurrentHook = null;
              }
            } else {
              nextCurrentHook = currentHook.next;
            }
            var nextWorkInProgressHook;
            if (workInProgressHook === null) {
              nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
            } else {
              nextWorkInProgressHook = workInProgressHook.next;
            }
            if (nextWorkInProgressHook !== null) {
              workInProgressHook = nextWorkInProgressHook;
              nextWorkInProgressHook = workInProgressHook.next;
              currentHook = nextCurrentHook;
            } else {
              if (nextCurrentHook === null) {
                throw new Error("Rendered more hooks than during the previous render.");
              }
              currentHook = nextCurrentHook;
              var newHook = {
                memoizedState: currentHook.memoizedState,
                baseState: currentHook.baseState,
                baseQueue: currentHook.baseQueue,
                queue: currentHook.queue,
                next: null
              };
              if (workInProgressHook === null) {
                currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
              } else {
                workInProgressHook = workInProgressHook.next = newHook;
              }
            }
            return workInProgressHook;
          }
          function createFunctionComponentUpdateQueue() {
            return {
              lastEffect: null,
              stores: null
            };
          }
          function basicStateReducer(state, action) {
            return typeof action === "function" ? action(state) : action;
          }
          function mountReducer(reducer, initialArg, init) {
            var hook = mountWorkInProgressHook();
            var initialState;
            if (init !== void 0) {
              initialState = init(initialArg);
            } else {
              initialState = initialArg;
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: reducer,
              lastRenderedState: initialState
            };
            hook.queue = queue;
            var dispatch2 = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch2];
          }
          function updateReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var current2 = currentHook;
            var baseQueue = current2.baseQueue;
            var pendingQueue = queue.pending;
            if (pendingQueue !== null) {
              if (baseQueue !== null) {
                var baseFirst = baseQueue.next;
                var pendingFirst = pendingQueue.next;
                baseQueue.next = pendingFirst;
                pendingQueue.next = baseFirst;
              }
              {
                if (current2.baseQueue !== baseQueue) {
                  error2("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
                }
              }
              current2.baseQueue = baseQueue = pendingQueue;
              queue.pending = null;
            }
            if (baseQueue !== null) {
              var first = baseQueue.next;
              var newState = current2.baseState;
              var newBaseState = null;
              var newBaseQueueFirst = null;
              var newBaseQueueLast = null;
              var update = first;
              do {
                var updateLane = update.lane;
                if (!isSubsetOfLanes(renderLanes, updateLane)) {
                  var clone5 = {
                    lane: updateLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  };
                  if (newBaseQueueLast === null) {
                    newBaseQueueFirst = newBaseQueueLast = clone5;
                    newBaseState = newState;
                  } else {
                    newBaseQueueLast = newBaseQueueLast.next = clone5;
                  }
                  currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                  markSkippedUpdateLanes(updateLane);
                } else {
                  if (newBaseQueueLast !== null) {
                    var _clone = {
                      // This update is going to be committed so we never want uncommit
                      // it. Using NoLane works because 0 is a subset of all bitmasks, so
                      // this will never be skipped by the check above.
                      lane: NoLane,
                      action: update.action,
                      hasEagerState: update.hasEagerState,
                      eagerState: update.eagerState,
                      next: null
                    };
                    newBaseQueueLast = newBaseQueueLast.next = _clone;
                  }
                  if (update.hasEagerState) {
                    newState = update.eagerState;
                  } else {
                    var action = update.action;
                    newState = reducer(newState, action);
                  }
                }
                update = update.next;
              } while (update !== null && update !== first);
              if (newBaseQueueLast === null) {
                newBaseState = newState;
              } else {
                newBaseQueueLast.next = newBaseQueueFirst;
              }
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              hook.baseState = newBaseState;
              hook.baseQueue = newBaseQueueLast;
              queue.lastRenderedState = newState;
            }
            var lastInterleaved = queue.interleaved;
            if (lastInterleaved !== null) {
              var interleaved = lastInterleaved;
              do {
                var interleavedLane = interleaved.lane;
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
                markSkippedUpdateLanes(interleavedLane);
                interleaved = interleaved.next;
              } while (interleaved !== lastInterleaved);
            } else if (baseQueue === null) {
              queue.lanes = NoLanes;
            }
            var dispatch2 = queue.dispatch;
            return [hook.memoizedState, dispatch2];
          }
          function rerenderReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var dispatch2 = queue.dispatch;
            var lastRenderPhaseUpdate = queue.pending;
            var newState = hook.memoizedState;
            if (lastRenderPhaseUpdate !== null) {
              queue.pending = null;
              var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                newState = reducer(newState, action);
                update = update.next;
              } while (update !== firstRenderPhaseUpdate);
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              if (hook.baseQueue === null) {
                hook.baseState = newState;
              }
              queue.lastRenderedState = newState;
            }
            return [newState, dispatch2];
          }
          function mountMutableSource(source, getSnapshot, subscribe) {
            {
              return void 0;
            }
          }
          function updateMutableSource(source, getSnapshot, subscribe) {
            {
              return void 0;
            }
          }
          function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = mountWorkInProgressHook();
            var nextSnapshot;
            var isHydrating2 = getIsHydrating();
            if (isHydrating2) {
              if (getServerSnapshot === void 0) {
                throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
              }
              nextSnapshot = getServerSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  if (nextSnapshot !== getServerSnapshot()) {
                    error2("The result of getServerSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
            } else {
              nextSnapshot = getSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  var cachedSnapshot = getSnapshot();
                  if (!objectIs(nextSnapshot, cachedSnapshot)) {
                    error2("The result of getSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
              var root2 = getWorkInProgressRoot();
              if (root2 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root2, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            hook.memoizedState = nextSnapshot;
            var inst = {
              value: nextSnapshot,
              getSnapshot
            };
            hook.queue = inst;
            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
            return nextSnapshot;
          }
          function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = updateWorkInProgressHook();
            var nextSnapshot = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedSnapshot = getSnapshot();
                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                  error2("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var prevSnapshot = hook.memoizedState;
            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
            if (snapshotChanged) {
              hook.memoizedState = nextSnapshot;
              markWorkInProgressReceivedUpdate();
            }
            var inst = hook.queue;
            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
            // checking whether we scheduled a subscription effect above.
            workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
              fiber.flags |= Passive;
              pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
              var root2 = getWorkInProgressRoot();
              if (root2 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root2, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            return nextSnapshot;
          }
          function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
            fiber.flags |= StoreConsistency;
            var check = {
              getSnapshot,
              value: renderedSnapshot
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.stores = [check];
            } else {
              var stores = componentUpdateQueue.stores;
              if (stores === null) {
                componentUpdateQueue.stores = [check];
              } else {
                stores.push(check);
              }
            }
          }
          function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
            inst.value = nextSnapshot;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceStoreRerender(fiber);
            }
          }
          function subscribeToStore(fiber, inst, subscribe) {
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceStoreRerender(fiber);
              }
            };
            return subscribe(handleStoreChange);
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(prevValue, nextValue);
            } catch (error3) {
              return true;
            }
          }
          function forceStoreRerender(fiber) {
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          }
          function mountState(initialState) {
            var hook = mountWorkInProgressHook();
            if (typeof initialState === "function") {
              initialState = initialState();
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialState
            };
            hook.queue = queue;
            var dispatch2 = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch2];
          }
          function updateState(initialState) {
            return updateReducer(basicStateReducer);
          }
          function rerenderState(initialState) {
            return rerenderReducer(basicStateReducer);
          }
          function pushEffect(tag, create, destroy, deps) {
            var effect4 = {
              tag,
              create,
              destroy,
              deps,
              // Circular
              next: null
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.lastEffect = effect4.next = effect4;
            } else {
              var lastEffect = componentUpdateQueue.lastEffect;
              if (lastEffect === null) {
                componentUpdateQueue.lastEffect = effect4.next = effect4;
              } else {
                var firstEffect = lastEffect.next;
                lastEffect.next = effect4;
                effect4.next = firstEffect;
                componentUpdateQueue.lastEffect = effect4;
              }
            }
            return effect4;
          }
          function mountRef(initialValue) {
            var hook = mountWorkInProgressHook();
            {
              var _ref2 = {
                current: initialValue
              };
              hook.memoizedState = _ref2;
              return _ref2;
            }
          }
          function updateRef(initialValue) {
            var hook = updateWorkInProgressHook();
            return hook.memoizedState;
          }
          function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);
          }
          function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var destroy = void 0;
            if (currentHook !== null) {
              var prevEffect = currentHook.memoizedState;
              destroy = prevEffect.destroy;
              if (nextDeps !== null) {
                var prevDeps = prevEffect.deps;
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
                  return;
                }
              }
            }
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
          }
          function mountEffect(create, deps) {
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);
            } else {
              return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
            }
          }
          function updateEffect(create, deps) {
            return updateEffectImpl(Passive, Passive$1, create, deps);
          }
          function mountInsertionEffect(create, deps) {
            return mountEffectImpl(Update, Insertion, create, deps);
          }
          function updateInsertionEffect(create, deps) {
            return updateEffectImpl(Update, Insertion, create, deps);
          }
          function mountLayoutEffect(create, deps) {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, create, deps);
          }
          function updateLayoutEffect(create, deps) {
            return updateEffectImpl(Update, Layout, create, deps);
          }
          function imperativeHandleEffect(create, ref) {
            if (typeof ref === "function") {
              var refCallback = ref;
              var _inst = create();
              refCallback(_inst);
              return function() {
                refCallback(null);
              };
            } else if (ref !== null && ref !== void 0) {
              var refObject = ref;
              {
                if (!refObject.hasOwnProperty("current")) {
                  error2("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
                }
              }
              var _inst2 = create();
              refObject.current = _inst2;
              return function() {
                refObject.current = null;
              };
            }
          }
          function mountImperativeHandle(ref, create, deps) {
            {
              if (typeof create !== "function") {
                error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
          }
          function updateImperativeHandle(ref, create, deps) {
            {
              if (typeof create !== "function") {
                error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
          }
          function mountDebugValue(value, formatterFn) {
          }
          var updateDebugValue = mountDebugValue;
          function mountCallback(callback, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function updateCallback(callback, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function mountMemo(nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function mountDeferredValue(value) {
            var hook = mountWorkInProgressHook();
            hook.memoizedState = value;
            return value;
          }
          function updateDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            var resolvedCurrentHook = currentHook;
            var prevValue = resolvedCurrentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value);
          }
          function rerenderDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            if (currentHook === null) {
              hook.memoizedState = value;
              return value;
            } else {
              var prevValue = currentHook.memoizedState;
              return updateDeferredValueImpl(hook, prevValue, value);
            }
          }
          function updateDeferredValueImpl(hook, prevValue, value) {
            var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
            if (shouldDeferValue) {
              if (!objectIs(value, prevValue)) {
                var deferredLane = claimNextTransitionLane();
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
                markSkippedUpdateLanes(deferredLane);
                hook.baseState = true;
              }
              return prevValue;
            } else {
              if (hook.baseState) {
                hook.baseState = false;
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = value;
              return value;
            }
          }
          function startTransition(setPending, callback, options3) {
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
            setPending(true);
            var prevTransition = ReactCurrentBatchConfig$2.transition;
            ReactCurrentBatchConfig$2.transition = {};
            var currentTransition = ReactCurrentBatchConfig$2.transition;
            {
              ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              setPending(false);
              callback();
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$2.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          function mountTransition() {
            var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
            var start3 = startTransition.bind(null, setPending);
            var hook = mountWorkInProgressHook();
            hook.memoizedState = start3;
            return [isPending, start3];
          }
          function updateTransition() {
            var _updateState = updateState(), isPending = _updateState[0];
            var hook = updateWorkInProgressHook();
            var start3 = hook.memoizedState;
            return [isPending, start3];
          }
          function rerenderTransition() {
            var _rerenderState = rerenderState(), isPending = _rerenderState[0];
            var hook = updateWorkInProgressHook();
            var start3 = hook.memoizedState;
            return [isPending, start3];
          }
          var isUpdatingOpaqueValueInRenderPhase = false;
          function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
            {
              return isUpdatingOpaqueValueInRenderPhase;
            }
          }
          function mountId() {
            var hook = mountWorkInProgressHook();
            var root2 = getWorkInProgressRoot();
            var identifierPrefix = root2.identifierPrefix;
            var id;
            if (getIsHydrating()) {
              var treeId = getTreeId();
              id = ":" + identifierPrefix + "R" + treeId;
              var localId = localIdCounter++;
              if (localId > 0) {
                id += "H" + localId.toString(32);
              }
              id += ":";
            } else {
              var globalClientId = globalClientIdCounter++;
              id = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
            }
            hook.memoizedState = id;
            return id;
          }
          function updateId() {
            var hook = updateWorkInProgressHook();
            var id = hook.memoizedState;
            return id;
          }
          function dispatchReducerAction(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update);
            } else {
              var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
              if (root2 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitionUpdate(root2, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function dispatchSetState(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update);
            } else {
              var alternate = fiber.alternate;
              if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                var lastRenderedReducer = queue.lastRenderedReducer;
                if (lastRenderedReducer !== null) {
                  var prevDispatcher;
                  {
                    prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                  }
                  try {
                    var currentState = queue.lastRenderedState;
                    var eagerState = lastRenderedReducer(currentState, action);
                    update.hasEagerState = true;
                    update.eagerState = eagerState;
                    if (objectIs(eagerState, currentState)) {
                      enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                      return;
                    }
                  } catch (error3) {
                  } finally {
                    {
                      ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                  }
                }
              }
              var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
              if (root2 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitionUpdate(root2, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function isRenderPhaseUpdate(fiber) {
            var alternate = fiber.alternate;
            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
          }
          function enqueueRenderPhaseUpdate(queue, update) {
            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
            var pending = queue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            queue.pending = update;
          }
          function entangleTransitionUpdate(root2, queue, lane) {
            if (isTransitionLane(lane)) {
              var queueLanes = queue.lanes;
              queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              queue.lanes = newQueueLanes;
              markRootEntangled(root2, newQueueLanes);
            }
          }
          function markUpdateInDevTools(fiber, lane, action) {
            {
              markStateUpdateScheduled(fiber, lane);
            }
          }
          var ContextOnlyDispatcher = {
            readContext,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useInsertionEffect: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
            useMutableSource: throwInvalidHookError,
            useSyncExternalStore: throwInvalidHookError,
            useId: throwInvalidHookError,
            unstable_isNewReconciler: enableNewReconciler
          };
          var HooksDispatcherOnMountInDEV = null;
          var HooksDispatcherOnMountWithHookTypesInDEV = null;
          var HooksDispatcherOnUpdateInDEV = null;
          var HooksDispatcherOnRerenderInDEV = null;
          var InvalidNestedHooksDispatcherOnMountInDEV = null;
          var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
          var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
          {
            var warnInvalidContextAccess = function() {
              error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            };
            var warnInvalidHookAccess = function() {
              error2("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            };
            HooksDispatcherOnMountInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                mountHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnMountWithHookTypesInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return mountImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return mountInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnUpdateInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnRerenderInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnMountInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnUpdateInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnRerenderInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
          }
          var now$1 = Scheduler.unstable_now;
          var commitTime = 0;
          var layoutEffectStartTime = -1;
          var profilerStartTime = -1;
          var passiveEffectStartTime = -1;
          var currentUpdateIsNested = false;
          var nestedUpdateScheduled = false;
          function isCurrentUpdateNested() {
            return currentUpdateIsNested;
          }
          function markNestedUpdateScheduled() {
            {
              nestedUpdateScheduled = true;
            }
          }
          function resetNestedUpdateFlag() {
            {
              currentUpdateIsNested = false;
              nestedUpdateScheduled = false;
            }
          }
          function syncNestedUpdateFlag() {
            {
              currentUpdateIsNested = nestedUpdateScheduled;
              nestedUpdateScheduled = false;
            }
          }
          function getCommitTime() {
            return commitTime;
          }
          function recordCommitTime() {
            commitTime = now$1();
          }
          function startProfilerTimer(fiber) {
            profilerStartTime = now$1();
            if (fiber.actualStartTime < 0) {
              fiber.actualStartTime = now$1();
            }
          }
          function stopProfilerTimerIfRunning(fiber) {
            profilerStartTime = -1;
          }
          function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
            if (profilerStartTime >= 0) {
              var elapsedTime = now$1() - profilerStartTime;
              fiber.actualDuration += elapsedTime;
              if (overrideBaseTime) {
                fiber.selfBaseDuration = elapsedTime;
              }
              profilerStartTime = -1;
            }
          }
          function recordLayoutEffectDuration(fiber) {
            if (layoutEffectStartTime >= 0) {
              var elapsedTime = now$1() - layoutEffectStartTime;
              layoutEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root2 = parentFiber.stateNode;
                    root2.effectDuration += elapsedTime;
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    parentStateNode.effectDuration += elapsedTime;
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function recordPassiveEffectDuration(fiber) {
            if (passiveEffectStartTime >= 0) {
              var elapsedTime = now$1() - passiveEffectStartTime;
              passiveEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root2 = parentFiber.stateNode;
                    if (root2 !== null) {
                      root2.passiveEffectDuration += elapsedTime;
                    }
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    if (parentStateNode !== null) {
                      parentStateNode.passiveEffectDuration += elapsedTime;
                    }
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function startLayoutEffectTimer() {
            layoutEffectStartTime = now$1();
          }
          function startPassiveEffectTimer() {
            passiveEffectStartTime = now$1();
          }
          function transferActualDuration(fiber) {
            var child = fiber.child;
            while (child) {
              fiber.actualDuration += child.actualDuration;
              child = child.sibling;
            }
          }
          function createCapturedValueAtFiber(value, source) {
            return {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source),
              digest: null
            };
          }
          function createCapturedValue(value, digest, stack) {
            return {
              value,
              source: null,
              stack: stack != null ? stack : null,
              digest: digest != null ? digest : null
            };
          }
          function showErrorDialog(boundary, errorInfo) {
            return true;
          }
          function logCapturedError(boundary, errorInfo) {
            try {
              var logError = showErrorDialog(boundary, errorInfo);
              if (logError === false) {
                return;
              }
              var error3 = errorInfo.value;
              if (true) {
                var source = errorInfo.source;
                var stack = errorInfo.stack;
                var componentStack = stack !== null ? stack : "";
                if (error3 != null && error3._suppressLogging) {
                  if (boundary.tag === ClassComponent) {
                    return;
                  }
                  console["error"](error3);
                }
                var componentName = source ? getComponentNameFromFiber(source) : null;
                var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
                var errorBoundaryMessage;
                if (boundary.tag === HostRoot) {
                  errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
                } else {
                  var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                  errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                }
                var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
                console["error"](combinedMessage);
              } else {
                console["error"](error3);
              }
            } catch (e) {
              setTimeout(function() {
                throw e;
              });
            }
          }
          var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
          function createRootErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            update.payload = {
              element: null
            };
            var error3 = errorInfo.value;
            update.callback = function() {
              onUncaughtError(error3);
              logCapturedError(fiber, errorInfo);
            };
            return update;
          }
          function createClassErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
            if (typeof getDerivedStateFromError === "function") {
              var error$1 = errorInfo.value;
              update.payload = function() {
                return getDerivedStateFromError(error$1);
              };
              update.callback = function() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
              };
            }
            var inst = fiber.stateNode;
            if (inst !== null && typeof inst.componentDidCatch === "function") {
              update.callback = function callback() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
                if (typeof getDerivedStateFromError !== "function") {
                  markLegacyErrorBoundaryAsFailed(this);
                }
                var error$12 = errorInfo.value;
                var stack = errorInfo.stack;
                this.componentDidCatch(error$12, {
                  componentStack: stack !== null ? stack : ""
                });
                {
                  if (typeof getDerivedStateFromError !== "function") {
                    if (!includesSomeLane(fiber.lanes, SyncLane)) {
                      error2("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                    }
                  }
                }
              };
            }
            return update;
          }
          function attachPingListener(root2, wakeable, lanes) {
            var pingCache = root2.pingCache;
            var threadIDs;
            if (pingCache === null) {
              pingCache = root2.pingCache = new PossiblyWeakMap$1();
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            } else {
              threadIDs = pingCache.get(wakeable);
              if (threadIDs === void 0) {
                threadIDs = /* @__PURE__ */ new Set();
                pingCache.set(wakeable, threadIDs);
              }
            }
            if (!threadIDs.has(lanes)) {
              threadIDs.add(lanes);
              var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
              {
                if (isDevToolsPresent) {
                  restorePendingUpdaters(root2, lanes);
                }
              }
              wakeable.then(ping, ping);
            }
          }
          function attachRetryListener(suspenseBoundary, root2, wakeable, lanes) {
            var wakeables = suspenseBoundary.updateQueue;
            if (wakeables === null) {
              var updateQueue = /* @__PURE__ */ new Set();
              updateQueue.add(wakeable);
              suspenseBoundary.updateQueue = updateQueue;
            } else {
              wakeables.add(wakeable);
            }
          }
          function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
            var tag = sourceFiber.tag;
            if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
              var currentSource = sourceFiber.alternate;
              if (currentSource) {
                sourceFiber.updateQueue = currentSource.updateQueue;
                sourceFiber.memoizedState = currentSource.memoizedState;
                sourceFiber.lanes = currentSource.lanes;
              } else {
                sourceFiber.updateQueue = null;
                sourceFiber.memoizedState = null;
              }
            }
          }
          function getNearestSuspenseBoundaryToCapture(returnFiber) {
            var node = returnFiber;
            do {
              if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
                return node;
              }
              node = node.return;
            } while (node !== null);
            return null;
          }
          function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes) {
            if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
              if (suspenseBoundary === returnFiber) {
                suspenseBoundary.flags |= ShouldCapture;
              } else {
                suspenseBoundary.flags |= DidCapture;
                sourceFiber.flags |= ForceUpdateForLegacySuspense;
                sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                if (sourceFiber.tag === ClassComponent) {
                  var currentSourceFiber = sourceFiber.alternate;
                  if (currentSourceFiber === null) {
                    sourceFiber.tag = IncompleteClassComponent;
                  } else {
                    var update = createUpdate(NoTimestamp, SyncLane);
                    update.tag = ForceUpdate;
                    enqueueUpdate(sourceFiber, update, SyncLane);
                  }
                }
                sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
              }
              return suspenseBoundary;
            }
            suspenseBoundary.flags |= ShouldCapture;
            suspenseBoundary.lanes = rootRenderLanes;
            return suspenseBoundary;
          }
          function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
            sourceFiber.flags |= Incomplete;
            {
              if (isDevToolsPresent) {
                restorePendingUpdaters(root2, rootRenderLanes);
              }
            }
            if (value !== null && typeof value === "object" && typeof value.then === "function") {
              var wakeable = value;
              resetSuspendedComponent(sourceFiber);
              {
                if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                  markDidThrowWhileHydratingDEV();
                }
              }
              var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
              if (suspenseBoundary !== null) {
                suspenseBoundary.flags &= ~ForceClientRender;
                markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
                if (suspenseBoundary.mode & ConcurrentMode) {
                  attachPingListener(root2, wakeable, rootRenderLanes);
                }
                attachRetryListener(suspenseBoundary, root2, wakeable);
                return;
              } else {
                if (!includesSyncLane(rootRenderLanes)) {
                  attachPingListener(root2, wakeable, rootRenderLanes);
                  renderDidSuspendDelayIfPossible();
                  return;
                }
                var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
                value = uncaughtSuspenseError;
              }
            } else {
              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                markDidThrowWhileHydratingDEV();
                var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
                if (_suspenseBoundary !== null) {
                  if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                    _suspenseBoundary.flags |= ForceClientRender;
                  }
                  markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
                  queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
                  return;
                }
              }
            }
            value = createCapturedValueAtFiber(value, sourceFiber);
            renderDidError(value);
            var workInProgress2 = returnFiber;
            do {
              switch (workInProgress2.tag) {
                case HostRoot: {
                  var _errorInfo = value;
                  workInProgress2.flags |= ShouldCapture;
                  var lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                  enqueueCapturedUpdate(workInProgress2, update);
                  return;
                }
                case ClassComponent:
                  var errorInfo = value;
                  var ctor = workInProgress2.type;
                  var instance = workInProgress2.stateNode;
                  if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                    workInProgress2.flags |= ShouldCapture;
                    var _lane = pickArbitraryLane(rootRenderLanes);
                    workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                    var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                    enqueueCapturedUpdate(workInProgress2, _update);
                    return;
                  }
                  break;
              }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2 !== null);
          }
          function getSuspendedCache() {
            {
              return null;
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var didReceiveUpdate = false;
          var didWarnAboutBadClass;
          var didWarnAboutModulePatternComponent;
          var didWarnAboutContextTypeOnFunctionComponent;
          var didWarnAboutGetDerivedStateOnFunctionComponent;
          var didWarnAboutFunctionRefs;
          var didWarnAboutReassigningProps;
          var didWarnAboutRevealOrder;
          var didWarnAboutTailOptions;
          {
            didWarnAboutBadClass = {};
            didWarnAboutModulePatternComponent = {};
            didWarnAboutContextTypeOnFunctionComponent = {};
            didWarnAboutGetDerivedStateOnFunctionComponent = {};
            didWarnAboutFunctionRefs = {};
            didWarnAboutReassigningProps = false;
            didWarnAboutRevealOrder = {};
            didWarnAboutTailOptions = {};
          }
          function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
            if (current2 === null) {
              workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
            }
          }
          function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          }
          function updateForwardRef(current2, workInProgress2, Component9, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component9.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(Component9)
                  );
                }
              }
            }
            var render2 = Component9.render;
            var ref = workInProgress2.ref;
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMemoComponent(current2, workInProgress2, Component9, nextProps, renderLanes2) {
            if (current2 === null) {
              var type = Component9.type;
              if (isSimpleFunctionComponent(type) && Component9.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
              Component9.defaultProps === void 0) {
                var resolvedType = type;
                {
                  resolvedType = resolveFunctionForHotReloading(type);
                }
                workInProgress2.tag = SimpleMemoComponent;
                workInProgress2.type = resolvedType;
                {
                  validateFunctionComponentInDev(workInProgress2, type);
                }
                return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
              }
              {
                var innerPropTypes = type.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(type)
                  );
                }
              }
              var child = createFiberFromTypeAndProps(Component9.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
              child.ref = workInProgress2.ref;
              child.return = workInProgress2;
              workInProgress2.child = child;
              return child;
            }
            {
              var _type = Component9.type;
              var _innerPropTypes = _type.propTypes;
              if (_innerPropTypes) {
                checkPropTypes(
                  _innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(_type)
                );
              }
            }
            var currentChild = current2.child;
            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
            if (!hasScheduledUpdateOrContext) {
              var prevProps = currentChild.memoizedProps;
              var compare = Component9.compare;
              compare = compare !== null ? compare : shallowEqual5;
              if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
            }
            workInProgress2.flags |= PerformedWork;
            var newChild = createWorkInProgress(currentChild, nextProps);
            newChild.ref = workInProgress2.ref;
            newChild.return = workInProgress2;
            workInProgress2.child = newChild;
            return newChild;
          }
          function updateSimpleMemoComponent(current2, workInProgress2, Component9, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerMemoType = workInProgress2.elementType;
                if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                  var lazyComponent = outerMemoType;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    outerMemoType = init(payload);
                  } catch (x) {
                    outerMemoType = null;
                  }
                  var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      nextProps,
                      // Resolved (SimpleMemoComponent has no defaultProps)
                      "prop",
                      getComponentNameFromType(outerMemoType)
                    );
                  }
                }
              }
            }
            if (current2 !== null) {
              var prevProps = current2.memoizedProps;
              if (shallowEqual5(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
              workInProgress2.type === current2.type) {
                didReceiveUpdate = false;
                workInProgress2.pendingProps = nextProps = prevProps;
                if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
                  workInProgress2.lanes = current2.lanes;
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                }
              }
            }
            return updateFunctionComponent(current2, workInProgress2, Component9, nextProps, renderLanes2);
          }
          function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            var prevState = current2 !== null ? current2.memoizedState : null;
            if (nextProps.mode === "hidden" || enableLegacyHidden) {
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                var nextState = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = nextState;
                pushRenderLanes(workInProgress2, renderLanes2);
              } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
                var spawnedCachePool = null;
                var nextBaseLanes;
                if (prevState !== null) {
                  var prevBaseLanes = prevState.baseLanes;
                  nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
                } else {
                  nextBaseLanes = renderLanes2;
                }
                workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
                var _nextState = {
                  baseLanes: nextBaseLanes,
                  cachePool: spawnedCachePool,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState;
                workInProgress2.updateQueue = null;
                pushRenderLanes(workInProgress2, nextBaseLanes);
                return null;
              } else {
                var _nextState2 = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState2;
                var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
                pushRenderLanes(workInProgress2, subtreeRenderLanes2);
              }
            } else {
              var _subtreeRenderLanes;
              if (prevState !== null) {
                _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
                workInProgress2.memoizedState = null;
              } else {
                _subtreeRenderLanes = renderLanes2;
              }
              pushRenderLanes(workInProgress2, _subtreeRenderLanes);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateFragment(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMode(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateProfiler(current2, workInProgress2, renderLanes2) {
            {
              workInProgress2.flags |= Update;
              {
                var stateNode = workInProgress2.stateNode;
                stateNode.effectDuration = 0;
                stateNode.passiveEffectDuration = 0;
              }
            }
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markRef(current2, workInProgress2) {
            var ref = workInProgress2.ref;
            if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
              workInProgress2.flags |= Ref;
              {
                workInProgress2.flags |= RefStatic;
              }
            }
          }
          function updateFunctionComponent(current2, workInProgress2, Component9, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component9.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(Component9)
                  );
                }
              }
            }
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component9, true);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, Component9, nextProps, context, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, Component9, nextProps, context, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateClassComponent(current2, workInProgress2, Component9, nextProps, renderLanes2) {
            {
              switch (shouldError(workInProgress2)) {
                case false: {
                  var _instance = workInProgress2.stateNode;
                  var ctor = workInProgress2.type;
                  var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                  var state = tempInstance.state;
                  _instance.updater.enqueueSetState(_instance, state, null);
                  break;
                }
                case true: {
                  workInProgress2.flags |= DidCapture;
                  workInProgress2.flags |= ShouldCapture;
                  var error$1 = new Error("Simulated error coming from DevTools");
                  var lane = pickArbitraryLane(renderLanes2);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
                  enqueueCapturedUpdate(workInProgress2, update);
                  break;
                }
              }
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component9.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(Component9)
                  );
                }
              }
            }
            var hasContext;
            if (isContextProvider(Component9)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var instance = workInProgress2.stateNode;
            var shouldUpdate;
            if (instance === null) {
              resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
              constructClassInstance(workInProgress2, Component9, nextProps);
              mountClassInstance(workInProgress2, Component9, nextProps, renderLanes2);
              shouldUpdate = true;
            } else if (current2 === null) {
              shouldUpdate = resumeMountClassInstance(workInProgress2, Component9, nextProps, renderLanes2);
            } else {
              shouldUpdate = updateClassInstance(current2, workInProgress2, Component9, nextProps, renderLanes2);
            }
            var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component9, shouldUpdate, hasContext, renderLanes2);
            {
              var inst = workInProgress2.stateNode;
              if (shouldUpdate && inst.props !== nextProps) {
                if (!didWarnAboutReassigningProps) {
                  error2("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            return nextUnitOfWork;
          }
          function finishClassComponent(current2, workInProgress2, Component9, shouldUpdate, hasContext, renderLanes2) {
            markRef(current2, workInProgress2);
            var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (!shouldUpdate && !didCaptureError) {
              if (hasContext) {
                invalidateContextProvider(workInProgress2, Component9, false);
              }
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            var instance = workInProgress2.stateNode;
            ReactCurrentOwner$1.current = workInProgress2;
            var nextChildren;
            if (didCaptureError && typeof Component9.getDerivedStateFromError !== "function") {
              nextChildren = null;
              {
                stopProfilerTimerIfRunning();
              }
            } else {
              {
                markComponentRenderStarted(workInProgress2);
              }
              {
                setIsRendering(true);
                nextChildren = instance.render();
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    instance.render();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                setIsRendering(false);
              }
              {
                markComponentRenderStopped();
              }
            }
            workInProgress2.flags |= PerformedWork;
            if (current2 !== null && didCaptureError) {
              forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            workInProgress2.memoizedState = instance.state;
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component9, true);
            }
            return workInProgress2.child;
          }
          function pushHostRootContext(workInProgress2) {
            var root2 = workInProgress2.stateNode;
            if (root2.pendingContext) {
              pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);
            } else if (root2.context) {
              pushTopLevelContextObject(workInProgress2, root2.context, false);
            }
            pushHostContainer(workInProgress2, root2.containerInfo);
          }
          function updateHostRoot(current2, workInProgress2, renderLanes2) {
            pushHostRootContext(workInProgress2);
            if (current2 === null) {
              throw new Error("Should have a current fiber. This is a bug in React.");
            }
            var nextProps = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            var prevChildren = prevState.element;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            var root2 = workInProgress2.stateNode;
            var nextChildren = nextState.element;
            if (prevState.isDehydrated) {
              var overrideState = {
                element: nextChildren,
                isDehydrated: false,
                cache: nextState.cache,
                pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
                transitions: nextState.transitions
              };
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = overrideState;
              workInProgress2.memoizedState = overrideState;
              if (workInProgress2.flags & ForceClientRender) {
                var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
              } else if (nextChildren !== prevChildren) {
                var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
              } else {
                enterHydrationState(workInProgress2);
                var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
                workInProgress2.child = child;
                var node = child;
                while (node) {
                  node.flags = node.flags & ~Placement | Hydrating;
                  node = node.sibling;
                }
              }
            } else {
              resetHydrationState();
              if (nextChildren === prevChildren) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
            resetHydrationState();
            queueHydrationError(recoverableError);
            workInProgress2.flags |= ForceClientRender;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostComponent(current2, workInProgress2, renderLanes2) {
            pushHostContext(workInProgress2);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            var type = workInProgress2.type;
            var nextProps = workInProgress2.pendingProps;
            var prevProps = current2 !== null ? current2.memoizedProps : null;
            var nextChildren = nextProps.children;
            var isDirectTextChild = shouldSetTextContent(type, nextProps);
            if (isDirectTextChild) {
              nextChildren = null;
            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
              workInProgress2.flags |= ContentReset;
            }
            markRef(current2, workInProgress2);
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostText(current2, workInProgress2) {
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            return null;
          }
          function mountLazyComponent(_current, workInProgress2, elementType2, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var lazyComponent = elementType2;
            var payload = lazyComponent._payload;
            var init = lazyComponent._init;
            var Component9 = init(payload);
            workInProgress2.type = Component9;
            var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component9);
            var resolvedProps = resolveDefaultProps(Component9, props);
            var child;
            switch (resolvedTag) {
              case FunctionComponent: {
                {
                  validateFunctionComponentInDev(workInProgress2, Component9);
                  workInProgress2.type = Component9 = resolveFunctionForHotReloading(Component9);
                }
                child = updateFunctionComponent(null, workInProgress2, Component9, resolvedProps, renderLanes2);
                return child;
              }
              case ClassComponent: {
                {
                  workInProgress2.type = Component9 = resolveClassForHotReloading(Component9);
                }
                child = updateClassComponent(null, workInProgress2, Component9, resolvedProps, renderLanes2);
                return child;
              }
              case ForwardRef: {
                {
                  workInProgress2.type = Component9 = resolveForwardRefForHotReloading(Component9);
                }
                child = updateForwardRef(null, workInProgress2, Component9, resolvedProps, renderLanes2);
                return child;
              }
              case MemoComponent: {
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = Component9.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        resolvedProps,
                        // Resolved for outer only
                        "prop",
                        getComponentNameFromType(Component9)
                      );
                    }
                  }
                }
                child = updateMemoComponent(
                  null,
                  workInProgress2,
                  Component9,
                  resolveDefaultProps(Component9.type, resolvedProps),
                  // The inner type can have defaults too
                  renderLanes2
                );
                return child;
              }
            }
            var hint = "";
            {
              if (Component9 !== null && typeof Component9 === "object" && Component9.$$typeof === REACT_LAZY_TYPE) {
                hint = " Did you wrap a component in React.lazy() more than once?";
              }
            }
            throw new Error("Element type is invalid. Received a promise that resolves to: " + Component9 + ". " + ("Lazy element type must resolve to a class or function." + hint));
          }
          function mountIncompleteClassComponent(_current, workInProgress2, Component9, nextProps, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            workInProgress2.tag = ClassComponent;
            var hasContext;
            if (isContextProvider(Component9)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            constructClassInstance(workInProgress2, Component9, nextProps);
            mountClassInstance(workInProgress2, Component9, nextProps, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component9, true, hasContext, renderLanes2);
          }
          function mountIndeterminateComponent(_current, workInProgress2, Component9, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component9, false);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var value;
            var hasId;
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              if (Component9.prototype && typeof Component9.prototype.render === "function") {
                var componentName = getComponentNameFromType(Component9) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error2("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
              }
              setIsRendering(true);
              ReactCurrentOwner$1.current = workInProgress2;
              value = renderWithHooks(null, workInProgress2, Component9, props, context, renderLanes2);
              hasId = checkDidRenderIdHook();
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            {
              if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
                var _componentName = getComponentNameFromType(Component9) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
            }
            if (
              // Run these checks in production only if the flag is off.
              // Eventually we'll delete this branch altogether.
              typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
            ) {
              {
                var _componentName2 = getComponentNameFromType(Component9) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName2]) {
                  error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                  didWarnAboutModulePatternComponent[_componentName2] = true;
                }
              }
              workInProgress2.tag = ClassComponent;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              var hasContext = false;
              if (isContextProvider(Component9)) {
                hasContext = true;
                pushContextProvider(workInProgress2);
              } else {
                hasContext = false;
              }
              workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
              initializeUpdateQueue(workInProgress2);
              adoptClassInstance(workInProgress2, value);
              mountClassInstance(workInProgress2, Component9, props, renderLanes2);
              return finishClassComponent(null, workInProgress2, Component9, true, hasContext, renderLanes2);
            } else {
              workInProgress2.tag = FunctionComponent;
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    value = renderWithHooks(null, workInProgress2, Component9, props, context, renderLanes2);
                    hasId = checkDidRenderIdHook();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
              }
              if (getIsHydrating() && hasId) {
                pushMaterializedTreeId(workInProgress2);
              }
              reconcileChildren(null, workInProgress2, value, renderLanes2);
              {
                validateFunctionComponentInDev(workInProgress2, Component9);
              }
              return workInProgress2.child;
            }
          }
          function validateFunctionComponentInDev(workInProgress2, Component9) {
            {
              if (Component9) {
                if (Component9.childContextTypes) {
                  error2("%s(...): childContextTypes cannot be defined on a function component.", Component9.displayName || Component9.name || "Component");
                }
              }
              if (workInProgress2.ref !== null) {
                var info = "";
                var ownerName = getCurrentFiberOwnerNameInDevOrNull();
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
                var warningKey = ownerName || "";
                var debugSource = workInProgress2._debugSource;
                if (debugSource) {
                  warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
                }
                if (!didWarnAboutFunctionRefs[warningKey]) {
                  didWarnAboutFunctionRefs[warningKey] = true;
                  error2("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
                }
              }
              if (typeof Component9.getDerivedStateFromProps === "function") {
                var _componentName3 = getComponentNameFromType(Component9) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                  error2("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                }
              }
              if (typeof Component9.contextType === "object" && Component9.contextType !== null) {
                var _componentName4 = getComponentNameFromType(Component9) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                  error2("%s: Function components do not support contextType.", _componentName4);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                }
              }
            }
          }
          var SUSPENDED_MARKER = {
            dehydrated: null,
            treeContext: null,
            retryLane: NoLane
          };
          function mountSuspenseOffscreenState(renderLanes2) {
            return {
              baseLanes: renderLanes2,
              cachePool: getSuspendedCache(),
              transitions: null
            };
          }
          function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
            var cachePool = null;
            return {
              baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
              cachePool,
              transitions: prevOffscreenState.transitions
            };
          }
          function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              var suspenseState = current2.memoizedState;
              if (suspenseState === null) {
                return false;
              }
            }
            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          }
          function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
            return removeLanes(current2.childLanes, renderLanes2);
          }
          function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            {
              if (shouldSuspend(workInProgress2)) {
                workInProgress2.flags |= DidCapture;
              }
            }
            var suspenseContext = suspenseStackCursor.current;
            var showFallback = false;
            var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
              showFallback = true;
              workInProgress2.flags &= ~DidCapture;
            } else {
              if (current2 === null || current2.memoizedState !== null) {
                {
                  suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
                }
              }
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            pushSuspenseContext(workInProgress2, suspenseContext);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
              var suspenseState = workInProgress2.memoizedState;
              if (suspenseState !== null) {
                var dehydrated = suspenseState.dehydrated;
                if (dehydrated !== null) {
                  return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
                }
              }
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              if (showFallback) {
                var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var primaryChildFragment = workInProgress2.child;
                primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackFragment;
              } else {
                return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
              }
            } else {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var _dehydrated = prevState.dehydrated;
                if (_dehydrated !== null) {
                  return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
                }
              }
              if (showFallback) {
                var _nextFallbackChildren = nextProps.fallback;
                var _nextPrimaryChildren = nextProps.children;
                var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
                var _primaryChildFragment2 = workInProgress2.child;
                var prevOffscreenState = current2.child.memoizedState;
                _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
                _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              } else {
                var _nextPrimaryChildren2 = nextProps.children;
                var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
                workInProgress2.memoizedState = null;
                return _primaryChildFragment3;
              }
            }
          }
          function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
            primaryChildFragment.return = workInProgress2;
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var progressedPrimaryFragment = workInProgress2.child;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            var fallbackChildFragment;
            if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = 0;
                primaryChildFragment.treeBaseDuration = 0;
              }
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            } else {
              primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            }
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
            return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
          }
          function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
            return createWorkInProgress(current2, offscreenProps);
          }
          function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
              mode: "visible",
              children: primaryChildren
            });
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              primaryChildFragment.lanes = renderLanes2;
            }
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = null;
            if (currentFallbackChildFragment !== null) {
              var deletions = workInProgress2.deletions;
              if (deletions === null) {
                workInProgress2.deletions = [currentFallbackChildFragment];
                workInProgress2.flags |= ChildDeletion;
              } else {
                deletions.push(currentFallbackChildFragment);
              }
            }
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            if (
              // In legacy mode, we commit the primary tree as if it successfully
              // completed, even though it's in an inconsistent state.
              (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
              // already cloned. In legacy mode, the only case where this isn't true is
              // when DevTools forces us to display a fallback; we skip the first render
              // pass entirely and go straight to rendering the fallback. (In Concurrent
              // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
              // only codepath.)
              workInProgress2.child !== currentPrimaryChildFragment
            ) {
              var progressedPrimaryFragment = workInProgress2.child;
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
              }
              workInProgress2.deletions = null;
            } else {
              primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
              primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
            }
            var fallbackChildFragment;
            if (currentFallbackChildFragment !== null) {
              fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
            } else {
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
              fallbackChildFragment.flags |= Placement;
            }
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
            if (recoverableError !== null) {
              queueHydrationError(recoverableError);
            }
            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            var nextProps = workInProgress2.pendingProps;
            var primaryChildren = nextProps.children;
            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
            primaryChildFragment.flags |= Placement;
            workInProgress2.memoizedState = null;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var fiberMode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
              reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            }
            return fallbackChildFragment;
          }
          function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              {
                error2("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
              }
              workInProgress2.lanes = laneToLanes(SyncLane);
            } else if (isSuspenseInstanceFallback(suspenseInstance)) {
              workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
            } else {
              workInProgress2.lanes = laneToLanes(OffscreenLane);
            }
            return null;
          }
          function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
            if (!didSuspend) {
              warnIfHydrating();
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                return retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2,
                  // TODO: When we delete legacy mode, we should make this error argument
                  // required — every concurrent mode path that causes hydration to
                  // de-opt to client rendering should have an error message.
                  null
                );
              }
              if (isSuspenseInstanceFallback(suspenseInstance)) {
                var digest, message, stack;
                {
                  var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                  digest = _getSuspenseInstanceF.digest;
                  message = _getSuspenseInstanceF.message;
                  stack = _getSuspenseInstanceF.stack;
                }
                var error3;
                if (message) {
                  error3 = new Error(message);
                } else {
                  error3 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
                }
                var capturedValue = createCapturedValue(error3, digest, stack);
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
              }
              var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
              if (didReceiveUpdate || hasContextChanged2) {
                var root2 = getWorkInProgressRoot();
                if (root2 !== null) {
                  var attemptHydrationAtLane = getBumpedLaneForHydration(root2, renderLanes2);
                  if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                    suspenseState.retryLane = attemptHydrationAtLane;
                    var eventTime = NoTimestamp;
                    enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                    scheduleUpdateOnFiber(root2, current2, attemptHydrationAtLane, eventTime);
                  }
                }
                renderDidSuspendDelayIfPossible();
                var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
              } else if (isSuspenseInstancePending(suspenseInstance)) {
                workInProgress2.flags |= DidCapture;
                workInProgress2.child = current2.child;
                var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
                registerSuspenseInstanceRetry(suspenseInstance, retry);
                return null;
              } else {
                reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
                var primaryChildren = nextProps.children;
                var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
                primaryChildFragment.flags |= Hydrating;
                return primaryChildFragment;
              }
            } else {
              if (workInProgress2.flags & ForceClientRender) {
                workInProgress2.flags &= ~ForceClientRender;
                var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
              } else if (workInProgress2.memoizedState !== null) {
                workInProgress2.child = current2.child;
                workInProgress2.flags |= DidCapture;
                return null;
              } else {
                var nextPrimaryChildren = nextProps.children;
                var nextFallbackChildren = nextProps.fallback;
                var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var _primaryChildFragment4 = workInProgress2.child;
                _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              }
            }
          }
          function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
            fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
            }
            scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
          }
          function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
            var node = firstChild;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
                }
              } else if (node.tag === SuspenseListComponent) {
                scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function findLastContentRow(firstChild) {
            var row = firstChild;
            var lastContentRow = null;
            while (row !== null) {
              var currentRow = row.alternate;
              if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                lastContentRow = row;
              }
              row = row.sibling;
            }
            return lastContentRow;
          }
          function validateRevealOrder(revealOrder) {
            {
              if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
                didWarnAboutRevealOrder[revealOrder] = true;
                if (typeof revealOrder === "string") {
                  switch (revealOrder.toLowerCase()) {
                    case "together":
                    case "forwards":
                    case "backwards": {
                      error2('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    case "forward":
                    case "backward": {
                      error2('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    default:
                      error2('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                      break;
                  }
                } else {
                  error2('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                }
              }
            }
          }
          function validateTailOptions(tailMode, revealOrder) {
            {
              if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
                if (tailMode !== "collapsed" && tailMode !== "hidden") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error2('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
                } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error2('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
                }
              }
            }
          }
          function validateSuspenseListNestedChild(childSlot, index2) {
            {
              var isAnArray = isArray(childSlot);
              var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
              if (isAnArray || isIterable) {
                var type = isAnArray ? "array" : "iterable";
                error2("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index2, type);
                return false;
              }
            }
            return true;
          }
          function validateSuspenseListChildren(children, revealOrder) {
            {
              if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
                if (isArray(children)) {
                  for (var i = 0; i < children.length; i++) {
                    if (!validateSuspenseListNestedChild(children[i], i)) {
                      return;
                    }
                  }
                } else {
                  var iteratorFn = getIteratorFn(children);
                  if (typeof iteratorFn === "function") {
                    var childrenIterator = iteratorFn.call(children);
                    if (childrenIterator) {
                      var step = childrenIterator.next();
                      var _i = 0;
                      for (; !step.done; step = childrenIterator.next()) {
                        if (!validateSuspenseListNestedChild(step.value, _i)) {
                          return;
                        }
                        _i++;
                      }
                    }
                  } else {
                    error2('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                  }
                }
              }
            }
          }
          function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              workInProgress2.memoizedState = {
                isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail,
                tailMode
              };
            } else {
              renderState.isBackwards = isBackwards;
              renderState.rendering = null;
              renderState.renderingStartTime = 0;
              renderState.last = lastContentRow;
              renderState.tail = tail;
              renderState.tailMode = tailMode;
            }
          }
          function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var revealOrder = nextProps.revealOrder;
            var tailMode = nextProps.tail;
            var newChildren = nextProps.children;
            validateRevealOrder(revealOrder);
            validateTailOptions(tailMode, revealOrder);
            validateSuspenseListChildren(newChildren, revealOrder);
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            var suspenseContext = suspenseStackCursor.current;
            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
            if (shouldForceFallback) {
              suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              workInProgress2.flags |= DidCapture;
            } else {
              var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
              if (didSuspendBefore) {
                propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
              }
              suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            }
            pushSuspenseContext(workInProgress2, suspenseContext);
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              workInProgress2.memoizedState = null;
            } else {
              switch (revealOrder) {
                case "forwards": {
                  var lastContentRow = findLastContentRow(workInProgress2.child);
                  var tail;
                  if (lastContentRow === null) {
                    tail = workInProgress2.child;
                    workInProgress2.child = null;
                  } else {
                    tail = lastContentRow.sibling;
                    lastContentRow.sibling = null;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    // isBackwards
                    tail,
                    lastContentRow,
                    tailMode
                  );
                  break;
                }
                case "backwards": {
                  var _tail = null;
                  var row = workInProgress2.child;
                  workInProgress2.child = null;
                  while (row !== null) {
                    var currentRow = row.alternate;
                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                      workInProgress2.child = row;
                      break;
                    }
                    var nextRow = row.sibling;
                    row.sibling = _tail;
                    _tail = row;
                    row = nextRow;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    true,
                    // isBackwards
                    _tail,
                    null,
                    // last
                    tailMode
                  );
                  break;
                }
                case "together": {
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    // isBackwards
                    null,
                    // tail
                    null,
                    // last
                    void 0
                  );
                  break;
                }
                default: {
                  workInProgress2.memoizedState = null;
                }
              }
            }
            return workInProgress2.child;
          }
          function updatePortalComponent(current2, workInProgress2, renderLanes2) {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            var nextChildren = workInProgress2.pendingProps;
            if (current2 === null) {
              workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
          function updateContextProvider(current2, workInProgress2, renderLanes2) {
            var providerType = workInProgress2.type;
            var context = providerType._context;
            var newProps = workInProgress2.pendingProps;
            var oldProps = workInProgress2.memoizedProps;
            var newValue = newProps.value;
            {
              if (!("value" in newProps)) {
                if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                  hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                  error2("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
                }
              }
              var providerPropTypes = workInProgress2.type.propTypes;
              if (providerPropTypes) {
                checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
              }
            }
            pushProvider(workInProgress2, context, newValue);
            {
              if (oldProps !== null) {
                var oldValue = oldProps.value;
                if (objectIs(oldValue, newValue)) {
                  if (oldProps.children === newProps.children && !hasContextChanged()) {
                    return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                  }
                } else {
                  propagateContextChange(workInProgress2, context, renderLanes2);
                }
              }
            }
            var newChildren = newProps.children;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingContextAsConsumer = false;
          function updateContextConsumer(current2, workInProgress2, renderLanes2) {
            var context = workInProgress2.type;
            {
              if (context._context === void 0) {
                if (context !== context.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error2("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context = context._context;
              }
            }
            var newProps = workInProgress2.pendingProps;
            var render2 = newProps.children;
            {
              if (typeof render2 !== "function") {
                error2("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var newValue = readContext(context);
            {
              markComponentRenderStarted(workInProgress2);
            }
            var newChildren;
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              newChildren = render2(newValue);
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markWorkInProgressReceivedUpdate() {
            didReceiveUpdate = true;
          }
          function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              if (current2 !== null) {
                current2.alternate = null;
                workInProgress2.alternate = null;
                workInProgress2.flags |= Placement;
              }
            }
          }
          function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              workInProgress2.dependencies = current2.dependencies;
            }
            {
              stopProfilerTimerIfRunning();
            }
            markSkippedUpdateLanes(workInProgress2.lanes);
            if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
              {
                return null;
              }
            }
            cloneChildFibers(current2, workInProgress2);
            return workInProgress2.child;
          }
          function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
            {
              var returnFiber = oldWorkInProgress.return;
              if (returnFiber === null) {
                throw new Error("Cannot swap the root fiber.");
              }
              current2.alternate = null;
              oldWorkInProgress.alternate = null;
              newWorkInProgress.index = oldWorkInProgress.index;
              newWorkInProgress.sibling = oldWorkInProgress.sibling;
              newWorkInProgress.return = oldWorkInProgress.return;
              newWorkInProgress.ref = oldWorkInProgress.ref;
              if (oldWorkInProgress === returnFiber.child) {
                returnFiber.child = newWorkInProgress;
              } else {
                var prevSibling = returnFiber.child;
                if (prevSibling === null) {
                  throw new Error("Expected parent to have a child.");
                }
                while (prevSibling.sibling !== oldWorkInProgress) {
                  prevSibling = prevSibling.sibling;
                  if (prevSibling === null) {
                    throw new Error("Expected to find the previous sibling.");
                  }
                }
                prevSibling.sibling = newWorkInProgress;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [current2];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(current2);
              }
              newWorkInProgress.flags |= Placement;
              return newWorkInProgress;
            }
          }
          function checkScheduledUpdateOrContext(current2, renderLanes2) {
            var updateLanes = current2.lanes;
            if (includesSomeLane(updateLanes, renderLanes2)) {
              return true;
            }
            return false;
          }
          function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
            switch (workInProgress2.tag) {
              case HostRoot:
                pushHostRootContext(workInProgress2);
                var root2 = workInProgress2.stateNode;
                resetHydrationState();
                break;
              case HostComponent:
                pushHostContext(workInProgress2);
                break;
              case ClassComponent: {
                var Component9 = workInProgress2.type;
                if (isContextProvider(Component9)) {
                  pushContextProvider(workInProgress2);
                }
                break;
              }
              case HostPortal:
                pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                break;
              case ContextProvider: {
                var newValue = workInProgress2.memoizedProps.value;
                var context = workInProgress2.type._context;
                pushProvider(workInProgress2, context, newValue);
                break;
              }
              case Profiler:
                {
                  var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                  if (hasChildWork) {
                    workInProgress2.flags |= Update;
                  }
                  {
                    var stateNode = workInProgress2.stateNode;
                    stateNode.effectDuration = 0;
                    stateNode.passiveEffectDuration = 0;
                  }
                }
                break;
              case SuspenseComponent: {
                var state = workInProgress2.memoizedState;
                if (state !== null) {
                  if (state.dehydrated !== null) {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    workInProgress2.flags |= DidCapture;
                    return null;
                  }
                  var primaryChildFragment = workInProgress2.child;
                  var primaryChildLanes = primaryChildFragment.childLanes;
                  if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                    return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                  } else {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                    if (child !== null) {
                      return child.sibling;
                    } else {
                      return null;
                    }
                  }
                } else {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                }
                break;
              }
              case SuspenseListComponent: {
                var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
                var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (didSuspendBefore) {
                  if (_hasChildWork) {
                    return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                  }
                  workInProgress2.flags |= DidCapture;
                }
                var renderState = workInProgress2.memoizedState;
                if (renderState !== null) {
                  renderState.rendering = null;
                  renderState.tail = null;
                  renderState.lastEffect = null;
                }
                pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
                if (_hasChildWork) {
                  break;
                } else {
                  return null;
                }
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                workInProgress2.lanes = NoLanes;
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          function beginWork(current2, workInProgress2, renderLanes2) {
            {
              if (workInProgress2._debugNeedsRemount && current2 !== null) {
                return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
              }
            }
            if (current2 !== null) {
              var oldProps = current2.memoizedProps;
              var newProps = workInProgress2.pendingProps;
              if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
              workInProgress2.type !== current2.type) {
                didReceiveUpdate = true;
              } else {
                var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
                if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
                // may not be work scheduled on `current`, so we check for this flag.
                (workInProgress2.flags & DidCapture) === NoFlags) {
                  didReceiveUpdate = false;
                  return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
                }
                if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                } else {
                  didReceiveUpdate = false;
                }
              }
            } else {
              didReceiveUpdate = false;
              if (getIsHydrating() && isForkedChild(workInProgress2)) {
                var slotIndex = workInProgress2.index;
                var numberOfForks = getForksAtLevel();
                pushTreeId(workInProgress2, numberOfForks, slotIndex);
              }
            }
            workInProgress2.lanes = NoLanes;
            switch (workInProgress2.tag) {
              case IndeterminateComponent: {
                return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
              }
              case LazyComponent: {
                var elementType2 = workInProgress2.elementType;
                return mountLazyComponent(current2, workInProgress2, elementType2, renderLanes2);
              }
              case FunctionComponent: {
                var Component9 = workInProgress2.type;
                var unresolvedProps = workInProgress2.pendingProps;
                var resolvedProps = workInProgress2.elementType === Component9 ? unresolvedProps : resolveDefaultProps(Component9, unresolvedProps);
                return updateFunctionComponent(current2, workInProgress2, Component9, resolvedProps, renderLanes2);
              }
              case ClassComponent: {
                var _Component = workInProgress2.type;
                var _unresolvedProps = workInProgress2.pendingProps;
                var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
                return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
              }
              case HostRoot:
                return updateHostRoot(current2, workInProgress2, renderLanes2);
              case HostComponent:
                return updateHostComponent(current2, workInProgress2, renderLanes2);
              case HostText:
                return updateHostText(current2, workInProgress2);
              case SuspenseComponent:
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              case HostPortal:
                return updatePortalComponent(current2, workInProgress2, renderLanes2);
              case ForwardRef: {
                var type = workInProgress2.type;
                var _unresolvedProps2 = workInProgress2.pendingProps;
                var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
              }
              case Fragment2:
                return updateFragment(current2, workInProgress2, renderLanes2);
              case Mode:
                return updateMode(current2, workInProgress2, renderLanes2);
              case Profiler:
                return updateProfiler(current2, workInProgress2, renderLanes2);
              case ContextProvider:
                return updateContextProvider(current2, workInProgress2, renderLanes2);
              case ContextConsumer:
                return updateContextConsumer(current2, workInProgress2, renderLanes2);
              case MemoComponent: {
                var _type2 = workInProgress2.type;
                var _unresolvedProps3 = workInProgress2.pendingProps;
                var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = _type2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        _resolvedProps3,
                        // Resolved for outer only
                        "prop",
                        getComponentNameFromType(_type2)
                      );
                    }
                  }
                }
                _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
              }
              case SimpleMemoComponent: {
                return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
              }
              case IncompleteClassComponent: {
                var _Component2 = workInProgress2.type;
                var _unresolvedProps4 = workInProgress2.pendingProps;
                var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
                return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
              }
              case SuspenseListComponent: {
                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent: {
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function markUpdate(workInProgress2) {
            workInProgress2.flags |= Update;
          }
          function markRef$1(workInProgress2) {
            workInProgress2.flags |= Ref;
            {
              workInProgress2.flags |= RefStatic;
            }
          }
          var appendAllChildren;
          var updateHostContainer;
          var updateHostComponent$1;
          var updateHostText$1;
          {
            appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
              var node = workInProgress2.child;
              while (node !== null) {
                if (node.tag === HostComponent || node.tag === HostText) {
                  appendInitialChild(parent, node.stateNode);
                } else if (node.tag === HostPortal)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === workInProgress2) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === workInProgress2) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            };
            updateHostContainer = function(current2, workInProgress2) {
            };
            updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
              var oldProps = current2.memoizedProps;
              if (oldProps === newProps) {
                return;
              }
              var instance = workInProgress2.stateNode;
              var currentHostContext = getHostContext();
              var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
              workInProgress2.updateQueue = updatePayload;
              if (updatePayload) {
                markUpdate(workInProgress2);
              }
            };
            updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
              if (oldText !== newText) {
                markUpdate(workInProgress2);
              }
            };
          }
          function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
            if (getIsHydrating()) {
              return;
            }
            switch (renderState.tailMode) {
              case "hidden": {
                var tailNode = renderState.tail;
                var lastTailNode = null;
                while (tailNode !== null) {
                  if (tailNode.alternate !== null) {
                    lastTailNode = tailNode;
                  }
                  tailNode = tailNode.sibling;
                }
                if (lastTailNode === null) {
                  renderState.tail = null;
                } else {
                  lastTailNode.sibling = null;
                }
                break;
              }
              case "collapsed": {
                var _tailNode = renderState.tail;
                var _lastTailNode = null;
                while (_tailNode !== null) {
                  if (_tailNode.alternate !== null) {
                    _lastTailNode = _tailNode;
                  }
                  _tailNode = _tailNode.sibling;
                }
                if (_lastTailNode === null) {
                  if (!hasRenderedATailFallback && renderState.tail !== null) {
                    renderState.tail.sibling = null;
                  } else {
                    renderState.tail = null;
                  }
                } else {
                  _lastTailNode.sibling = null;
                }
                break;
              }
            }
          }
          function bubbleProperties(completedWork) {
            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
            var newChildLanes = NoLanes;
            var subtreeFlags = NoFlags;
            if (!didBailout) {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var actualDuration = completedWork.actualDuration;
                var treeBaseDuration = completedWork.selfBaseDuration;
                var child = completedWork.child;
                while (child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                  subtreeFlags |= child.subtreeFlags;
                  subtreeFlags |= child.flags;
                  actualDuration += child.actualDuration;
                  treeBaseDuration += child.treeBaseDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
                completedWork.treeBaseDuration = treeBaseDuration;
              } else {
                var _child = completedWork.child;
                while (_child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                  subtreeFlags |= _child.subtreeFlags;
                  subtreeFlags |= _child.flags;
                  _child.return = completedWork;
                  _child = _child.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            } else {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var _treeBaseDuration = completedWork.selfBaseDuration;
                var _child2 = completedWork.child;
                while (_child2 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                  subtreeFlags |= _child2.subtreeFlags & StaticMask;
                  subtreeFlags |= _child2.flags & StaticMask;
                  _treeBaseDuration += _child2.treeBaseDuration;
                  _child2 = _child2.sibling;
                }
                completedWork.treeBaseDuration = _treeBaseDuration;
              } else {
                var _child3 = completedWork.child;
                while (_child3 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                  subtreeFlags |= _child3.subtreeFlags & StaticMask;
                  subtreeFlags |= _child3.flags & StaticMask;
                  _child3.return = completedWork;
                  _child3 = _child3.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            }
            completedWork.childLanes = newChildLanes;
            return didBailout;
          }
          function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
            if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
              warnIfUnhydratedTailNodes(workInProgress2);
              resetHydrationState();
              workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
              return false;
            }
            var wasHydrated = popHydrationState(workInProgress2);
            if (nextState !== null && nextState.dehydrated !== null) {
              if (current2 === null) {
                if (!wasHydrated) {
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                }
                prepareToHydrateHostSuspenseInstance(workInProgress2);
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var isTimedOutSuspense = nextState !== null;
                    if (isTimedOutSuspense) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              } else {
                resetHydrationState();
                if ((workInProgress2.flags & DidCapture) === NoFlags) {
                  workInProgress2.memoizedState = null;
                }
                workInProgress2.flags |= Update;
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var _isTimedOutSuspense = nextState !== null;
                    if (_isTimedOutSuspense) {
                      var _primaryChildFragment = workInProgress2.child;
                      if (_primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              }
            } else {
              upgradeHydrationErrorsToRecoverable();
              return true;
            }
          }
          function completeWork(current2, workInProgress2, renderLanes2) {
            var newProps = workInProgress2.pendingProps;
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case LazyComponent:
              case SimpleMemoComponent:
              case FunctionComponent:
              case ForwardRef:
              case Fragment2:
              case Mode:
              case Profiler:
              case ContextConsumer:
              case MemoComponent:
                bubbleProperties(workInProgress2);
                return null;
              case ClassComponent: {
                var Component9 = workInProgress2.type;
                if (isContextProvider(Component9)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostRoot: {
                var fiberRoot = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                if (fiberRoot.pendingContext) {
                  fiberRoot.context = fiberRoot.pendingContext;
                  fiberRoot.pendingContext = null;
                }
                if (current2 === null || current2.child === null) {
                  var wasHydrated = popHydrationState(workInProgress2);
                  if (wasHydrated) {
                    markUpdate(workInProgress2);
                  } else {
                    if (current2 !== null) {
                      var prevState = current2.memoizedState;
                      if (
                        // Check if this is a client root
                        !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                        (workInProgress2.flags & ForceClientRender) !== NoFlags
                      ) {
                        workInProgress2.flags |= Snapshot2;
                        upgradeHydrationErrorsToRecoverable();
                      }
                    }
                  }
                }
                updateHostContainer(current2, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                var rootContainerInstance = getRootHostContainer();
                var type = workInProgress2.type;
                if (current2 !== null && workInProgress2.stateNode != null) {
                  updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
                  if (current2.ref !== workInProgress2.ref) {
                    markRef$1(workInProgress2);
                  }
                } else {
                  if (!newProps) {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    bubbleProperties(workInProgress2);
                    return null;
                  }
                  var currentHostContext = getHostContext();
                  var _wasHydrated = popHydrationState(workInProgress2);
                  if (_wasHydrated) {
                    if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                    appendAllChildren(instance, workInProgress2, false, false);
                    workInProgress2.stateNode = instance;
                    if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                      markUpdate(workInProgress2);
                    }
                  }
                  if (workInProgress2.ref !== null) {
                    markRef$1(workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostText: {
                var newText = newProps;
                if (current2 && workInProgress2.stateNode != null) {
                  var oldText = current2.memoizedProps;
                  updateHostText$1(current2, workInProgress2, oldText, newText);
                } else {
                  if (typeof newText !== "string") {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                  }
                  var _rootContainerInstance = getRootHostContainer();
                  var _currentHostContext = getHostContext();
                  var _wasHydrated2 = popHydrationState(workInProgress2);
                  if (_wasHydrated2) {
                    if (prepareToHydrateHostTextInstance(workInProgress2)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var nextState = workInProgress2.memoizedState;
                if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
                  var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
                  if (!fallthroughToNormalSuspensePath) {
                    if (workInProgress2.flags & ShouldCapture) {
                      return workInProgress2;
                    } else {
                      return null;
                    }
                  }
                }
                if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                  workInProgress2.lanes = renderLanes2;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                var nextDidTimeout = nextState !== null;
                var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
                if (nextDidTimeout !== prevDidTimeout) {
                  if (nextDidTimeout) {
                    var _offscreenFiber2 = workInProgress2.child;
                    _offscreenFiber2.flags |= Visibility;
                    if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                      var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                      if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                        renderDidSuspend();
                      } else {
                        renderDidSuspendDelayIfPossible();
                      }
                    }
                  }
                }
                var wakeables = workInProgress2.updateQueue;
                if (wakeables !== null) {
                  workInProgress2.flags |= Update;
                }
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    if (nextDidTimeout) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                updateHostContainer(current2, workInProgress2);
                if (current2 === null) {
                  preparePortalMount(workInProgress2.stateNode.containerInfo);
                }
                bubbleProperties(workInProgress2);
                return null;
              case ContextProvider:
                var context = workInProgress2.type._context;
                popProvider(context, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              case IncompleteClassComponent: {
                var _Component = workInProgress2.type;
                if (isContextProvider(_Component)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                var renderState = workInProgress2.memoizedState;
                if (renderState === null) {
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
                var renderedTail = renderState.rendering;
                if (renderedTail === null) {
                  if (!didSuspendAlready) {
                    var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                    if (!cannotBeSuspended) {
                      var row = workInProgress2.child;
                      while (row !== null) {
                        var suspended = findFirstSuspended(row);
                        if (suspended !== null) {
                          didSuspendAlready = true;
                          workInProgress2.flags |= DidCapture;
                          cutOffTailIfNeeded(renderState, false);
                          var newThenables = suspended.updateQueue;
                          if (newThenables !== null) {
                            workInProgress2.updateQueue = newThenables;
                            workInProgress2.flags |= Update;
                          }
                          workInProgress2.subtreeFlags = NoFlags;
                          resetChildFibers(workInProgress2, renderLanes2);
                          pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                          return workInProgress2.child;
                        }
                        row = row.sibling;
                      }
                    }
                    if (renderState.tail !== null && now2() > getRenderTargetTime()) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  } else {
                    cutOffTailIfNeeded(renderState, false);
                  }
                } else {
                  if (!didSuspendAlready) {
                    var _suspended = findFirstSuspended(renderedTail);
                    if (_suspended !== null) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      var _newThenables = _suspended.updateQueue;
                      if (_newThenables !== null) {
                        workInProgress2.updateQueue = _newThenables;
                        workInProgress2.flags |= Update;
                      }
                      cutOffTailIfNeeded(renderState, true);
                      if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                        bubbleProperties(workInProgress2);
                        return null;
                      }
                    } else if (
                      // The time it took to render last row is greater than the remaining
                      // time we have to render. So rendering one more row would likely
                      // exceed it.
                      now2() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane
                    ) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  }
                  if (renderState.isBackwards) {
                    renderedTail.sibling = workInProgress2.child;
                    workInProgress2.child = renderedTail;
                  } else {
                    var previousSibling = renderState.last;
                    if (previousSibling !== null) {
                      previousSibling.sibling = renderedTail;
                    } else {
                      workInProgress2.child = renderedTail;
                    }
                    renderState.last = renderedTail;
                  }
                }
                if (renderState.tail !== null) {
                  var next = renderState.tail;
                  renderState.rendering = next;
                  renderState.tail = next.sibling;
                  renderState.renderingStartTime = now2();
                  next.sibling = null;
                  var suspenseContext = suspenseStackCursor.current;
                  if (didSuspendAlready) {
                    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                  } else {
                    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                  }
                  pushSuspenseContext(workInProgress2, suspenseContext);
                  return next;
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                popRenderLanes(workInProgress2);
                var _nextState = workInProgress2.memoizedState;
                var nextIsHidden = _nextState !== null;
                if (current2 !== null) {
                  var _prevState = current2.memoizedState;
                  var prevIsHidden = _prevState !== null;
                  if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding — it only pre-renders.
                  !enableLegacyHidden) {
                    workInProgress2.flags |= Visibility;
                  }
                }
                if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                  bubbleProperties(workInProgress2);
                } else {
                  if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                    bubbleProperties(workInProgress2);
                    {
                      if (workInProgress2.subtreeFlags & (Placement | Update)) {
                        workInProgress2.flags |= Visibility;
                      }
                    }
                  }
                }
                return null;
              }
              case CacheComponent: {
                return null;
              }
              case TracingMarkerComponent: {
                return null;
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function unwindWork(current2, workInProgress2, renderLanes2) {
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case ClassComponent: {
                var Component9 = workInProgress2.type;
                if (isContextProvider(Component9)) {
                  popContext(workInProgress2);
                }
                var flags = workInProgress2.flags;
                if (flags & ShouldCapture) {
                  workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case HostRoot: {
                var root2 = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                var _flags = workInProgress2.flags;
                if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                  workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                  return workInProgress2;
                }
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var suspenseState = workInProgress2.memoizedState;
                if (suspenseState !== null && suspenseState.dehydrated !== null) {
                  if (workInProgress2.alternate === null) {
                    throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                  }
                  resetHydrationState();
                }
                var _flags2 = workInProgress2.flags;
                if (_flags2 & ShouldCapture) {
                  workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                return null;
              case ContextProvider:
                var context = workInProgress2.type._context;
                popProvider(context, workInProgress2);
                return null;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(workInProgress2);
                return null;
              case CacheComponent:
                return null;
              default:
                return null;
            }
          }
          function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
            popTreeContext(interruptedWork);
            switch (interruptedWork.tag) {
              case ClassComponent: {
                var childContextTypes = interruptedWork.type.childContextTypes;
                if (childContextTypes !== null && childContextTypes !== void 0) {
                  popContext(interruptedWork);
                }
                break;
              }
              case HostRoot: {
                var root2 = interruptedWork.stateNode;
                popHostContainer(interruptedWork);
                popTopLevelContextObject(interruptedWork);
                resetWorkInProgressVersions();
                break;
              }
              case HostComponent: {
                popHostContext(interruptedWork);
                break;
              }
              case HostPortal:
                popHostContainer(interruptedWork);
                break;
              case SuspenseComponent:
                popSuspenseContext(interruptedWork);
                break;
              case SuspenseListComponent:
                popSuspenseContext(interruptedWork);
                break;
              case ContextProvider:
                var context = interruptedWork.type._context;
                popProvider(context, interruptedWork);
                break;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(interruptedWork);
                break;
            }
          }
          var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
          {
            didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
          }
          var offscreenSubtreeIsHidden = false;
          var offscreenSubtreeWasHidden = false;
          var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
          var nextEffect = null;
          var inProgressLanes = null;
          var inProgressRoot = null;
          function reportUncaughtErrorInDEV(error3) {
            {
              invokeGuardedCallback(null, function() {
                throw error3;
              });
              clearCaughtError();
            }
          }
          var callComponentWillUnmountWithTimer = function(current2, instance) {
            instance.props = current2.memoizedProps;
            instance.state = current2.memoizedState;
            if (current2.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                instance.componentWillUnmount();
              } finally {
                recordLayoutEffectDuration(current2);
              }
            } else {
              instance.componentWillUnmount();
            }
          };
          function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
            try {
              commitHookEffectListMount(Layout, current2);
            } catch (error3) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error3);
            }
          }
          function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
            try {
              callComponentWillUnmountWithTimer(current2, instance);
            } catch (error3) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error3);
            }
          }
          function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentDidMount();
            } catch (error3) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error3);
            }
          }
          function safelyAttachRef(current2, nearestMountedAncestor) {
            try {
              commitAttachRef(current2);
            } catch (error3) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error3);
            }
          }
          function safelyDetachRef(current2, nearestMountedAncestor) {
            var ref = current2.ref;
            if (ref !== null) {
              if (typeof ref === "function") {
                var retVal;
                try {
                  if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      retVal = ref(null);
                    } finally {
                      recordLayoutEffectDuration(current2);
                    }
                  } else {
                    retVal = ref(null);
                  }
                } catch (error3) {
                  captureCommitPhaseError(current2, nearestMountedAncestor, error3);
                }
                {
                  if (typeof retVal === "function") {
                    error2("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
                  }
                }
              } else {
                ref.current = null;
              }
            }
          }
          function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error3) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error3);
            }
          }
          var focusedInstanceHandle = null;
          var shouldFireAfterActiveInstanceBlur = false;
          function commitBeforeMutationEffects(root2, firstChild) {
            focusedInstanceHandle = prepareForCommit(root2.containerInfo);
            nextEffect = firstChild;
            commitBeforeMutationEffects_begin();
            var shouldFire = shouldFireAfterActiveInstanceBlur;
            shouldFireAfterActiveInstanceBlur = false;
            focusedInstanceHandle = null;
            return shouldFire;
          }
          function commitBeforeMutationEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitBeforeMutationEffects_complete();
              }
            }
          }
          function commitBeforeMutationEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                commitBeforeMutationEffectsOnFiber(fiber);
              } catch (error3) {
                captureCommitPhaseError(fiber, fiber.return, error3);
              }
              resetCurrentFiber();
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitBeforeMutationEffectsOnFiber(finishedWork) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            if ((flags & Snapshot2) !== NoFlags) {
              setCurrentFiber(finishedWork);
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  break;
                }
                case ClassComponent: {
                  if (current2 !== null) {
                    var prevProps = current2.memoizedProps;
                    var prevState = current2.memoizedState;
                    var instance = finishedWork.stateNode;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error2("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error2("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                    {
                      var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                      if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                        didWarnSet.add(finishedWork.type);
                        error2("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                      }
                    }
                    instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                  }
                  break;
                }
                case HostRoot: {
                  {
                    var root2 = finishedWork.stateNode;
                    clearContainer(root2.containerInfo);
                  }
                  break;
                }
                case HostComponent:
                case HostText:
                case HostPortal:
                case IncompleteClassComponent:
                  break;
                default: {
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              resetCurrentFiber();
            }
          }
          function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect4 = firstEffect;
              do {
                if ((effect4.tag & flags) === flags) {
                  var destroy = effect4.destroy;
                  effect4.destroy = void 0;
                  if (destroy !== void 0) {
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStarted(finishedWork);
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStarted(finishedWork);
                      }
                    }
                    {
                      if ((flags & Insertion) !== NoFlags$1) {
                        setIsRunningInsertionEffect(true);
                      }
                    }
                    safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                    {
                      if ((flags & Insertion) !== NoFlags$1) {
                        setIsRunningInsertionEffect(false);
                      }
                    }
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStopped();
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStopped();
                      }
                    }
                  }
                }
                effect4 = effect4.next;
              } while (effect4 !== firstEffect);
            }
          }
          function commitHookEffectListMount(flags, finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect4 = firstEffect;
              do {
                if ((effect4.tag & flags) === flags) {
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStarted(finishedWork);
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStarted(finishedWork);
                    }
                  }
                  var create = effect4.create;
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(true);
                    }
                  }
                  effect4.destroy = create();
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(false);
                    }
                  }
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStopped();
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStopped();
                    }
                  }
                  {
                    var destroy = effect4.destroy;
                    if (destroy !== void 0 && typeof destroy !== "function") {
                      var hookName = void 0;
                      if ((effect4.tag & Layout) !== NoFlags) {
                        hookName = "useLayoutEffect";
                      } else if ((effect4.tag & Insertion) !== NoFlags) {
                        hookName = "useInsertionEffect";
                      } else {
                        hookName = "useEffect";
                      }
                      var addendum = void 0;
                      if (destroy === null) {
                        addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                      } else if (typeof destroy.then === "function") {
                        addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                      } else {
                        addendum = " You returned: " + destroy;
                      }
                      error2("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                    }
                  }
                }
                effect4 = effect4.next;
              } while (effect4 !== firstEffect);
            }
          }
          function commitPassiveEffectDurations(finishedRoot, finishedWork) {
            {
              if ((finishedWork.flags & Update) !== NoFlags) {
                switch (finishedWork.tag) {
                  case Profiler: {
                    var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                    var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                    var commitTime2 = getCommitTime();
                    var phase = finishedWork.alternate === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onPostCommit === "function") {
                      onPostCommit(id, phase, passiveEffectDuration, commitTime2);
                    }
                    var parentFiber = finishedWork.return;
                    outer:
                      while (parentFiber !== null) {
                        switch (parentFiber.tag) {
                          case HostRoot:
                            var root2 = parentFiber.stateNode;
                            root2.passiveEffectDuration += passiveEffectDuration;
                            break outer;
                          case Profiler:
                            var parentStateNode = parentFiber.stateNode;
                            parentStateNode.passiveEffectDuration += passiveEffectDuration;
                            break outer;
                        }
                        parentFiber = parentFiber.return;
                      }
                    break;
                  }
                }
              }
            }
          }
          function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
            if ((finishedWork.flags & LayoutMask) !== NoFlags) {
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  if (!offscreenSubtreeWasHidden) {
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        commitHookEffectListMount(Layout | HasEffect, finishedWork);
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      commitHookEffectListMount(Layout | HasEffect, finishedWork);
                    }
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = finishedWork.stateNode;
                  if (finishedWork.flags & Update) {
                    if (!offscreenSubtreeWasHidden) {
                      if (current2 === null) {
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error2("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error2("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidMount();
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidMount();
                        }
                      } else {
                        var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                        var prevState = current2.memoizedState;
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error2("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error2("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                        }
                      }
                    }
                  }
                  var updateQueue = finishedWork.updateQueue;
                  if (updateQueue !== null) {
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error2("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error2("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    commitUpdateQueue(finishedWork, updateQueue, instance);
                  }
                  break;
                }
                case HostRoot: {
                  var _updateQueue = finishedWork.updateQueue;
                  if (_updateQueue !== null) {
                    var _instance = null;
                    if (finishedWork.child !== null) {
                      switch (finishedWork.child.tag) {
                        case HostComponent:
                          _instance = getPublicInstance(finishedWork.child.stateNode);
                          break;
                        case ClassComponent:
                          _instance = finishedWork.child.stateNode;
                          break;
                      }
                    }
                    commitUpdateQueue(finishedWork, _updateQueue, _instance);
                  }
                  break;
                }
                case HostComponent: {
                  var _instance2 = finishedWork.stateNode;
                  if (current2 === null && finishedWork.flags & Update) {
                    var type = finishedWork.type;
                    var props = finishedWork.memoizedProps;
                    commitMount(_instance2, type, props);
                  }
                  break;
                }
                case HostText: {
                  break;
                }
                case HostPortal: {
                  break;
                }
                case Profiler: {
                  {
                    var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                    var effectDuration = finishedWork.stateNode.effectDuration;
                    var commitTime2 = getCommitTime();
                    var phase = current2 === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onRender === "function") {
                      onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                    }
                    {
                      if (typeof onCommit === "function") {
                        onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                      }
                      enqueuePendingPassiveProfilerEffect(finishedWork);
                      var parentFiber = finishedWork.return;
                      outer:
                        while (parentFiber !== null) {
                          switch (parentFiber.tag) {
                            case HostRoot:
                              var root2 = parentFiber.stateNode;
                              root2.effectDuration += effectDuration;
                              break outer;
                            case Profiler:
                              var parentStateNode = parentFiber.stateNode;
                              parentStateNode.effectDuration += effectDuration;
                              break outer;
                          }
                          parentFiber = parentFiber.return;
                        }
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                  break;
                }
                case SuspenseListComponent:
                case IncompleteClassComponent:
                case ScopeComponent:
                case OffscreenComponent:
                case LegacyHiddenComponent:
                case TracingMarkerComponent: {
                  break;
                }
                default:
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (!offscreenSubtreeWasHidden) {
              {
                if (finishedWork.flags & Ref) {
                  commitAttachRef(finishedWork);
                }
              }
            }
          }
          function reappearLayoutEffectsOnFiber(node) {
            switch (node.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (node.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    safelyCallCommitHookLayoutEffectListMount(node, node.return);
                  } finally {
                    recordLayoutEffectDuration(node);
                  }
                } else {
                  safelyCallCommitHookLayoutEffectListMount(node, node.return);
                }
                break;
              }
              case ClassComponent: {
                var instance = node.stateNode;
                if (typeof instance.componentDidMount === "function") {
                  safelyCallComponentDidMount(node, node.return, instance);
                }
                safelyAttachRef(node, node.return);
                break;
              }
              case HostComponent: {
                safelyAttachRef(node, node.return);
                break;
              }
            }
          }
          function hideOrUnhideAllChildren(finishedWork, isHidden) {
            var hostSubtreeRoot = null;
            {
              var node = finishedWork;
              while (true) {
                if (node.tag === HostComponent) {
                  if (hostSubtreeRoot === null) {
                    hostSubtreeRoot = node;
                    try {
                      var instance = node.stateNode;
                      if (isHidden) {
                        hideInstance(instance);
                      } else {
                        unhideInstance(node.stateNode, node.memoizedProps);
                      }
                    } catch (error3) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                    }
                  }
                } else if (node.tag === HostText) {
                  if (hostSubtreeRoot === null) {
                    try {
                      var _instance3 = node.stateNode;
                      if (isHidden) {
                        hideTextInstance(_instance3);
                      } else {
                        unhideTextInstance(_instance3, node.memoizedProps);
                      }
                    } catch (error3) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                    }
                  }
                } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === finishedWork) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === finishedWork) {
                    return;
                  }
                  if (hostSubtreeRoot === node) {
                    hostSubtreeRoot = null;
                  }
                  node = node.return;
                }
                if (hostSubtreeRoot === node) {
                  hostSubtreeRoot = null;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
          }
          function commitAttachRef(finishedWork) {
            var ref = finishedWork.ref;
            if (ref !== null) {
              var instance = finishedWork.stateNode;
              var instanceToUse;
              switch (finishedWork.tag) {
                case HostComponent:
                  instanceToUse = getPublicInstance(instance);
                  break;
                default:
                  instanceToUse = instance;
              }
              if (typeof ref === "function") {
                var retVal;
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    retVal = ref(instanceToUse);
                  } finally {
                    recordLayoutEffectDuration(finishedWork);
                  }
                } else {
                  retVal = ref(instanceToUse);
                }
                {
                  if (typeof retVal === "function") {
                    error2("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                  }
                }
              } else {
                {
                  if (!ref.hasOwnProperty("current")) {
                    error2("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                  }
                }
                ref.current = instanceToUse;
              }
            }
          }
          function detachFiberMutation(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.return = null;
            }
            fiber.return = null;
          }
          function detachFiberAfterEffects(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              fiber.alternate = null;
              detachFiberAfterEffects(alternate);
            }
            {
              fiber.child = null;
              fiber.deletions = null;
              fiber.sibling = null;
              if (fiber.tag === HostComponent) {
                var hostInstance = fiber.stateNode;
                if (hostInstance !== null) {
                  detachDeletedInstance(hostInstance);
                }
              }
              fiber.stateNode = null;
              {
                fiber._debugOwner = null;
              }
              {
                fiber.return = null;
                fiber.dependencies = null;
                fiber.memoizedProps = null;
                fiber.memoizedState = null;
                fiber.pendingProps = null;
                fiber.stateNode = null;
                fiber.updateQueue = null;
              }
            }
          }
          function getHostParentFiber(fiber) {
            var parent = fiber.return;
            while (parent !== null) {
              if (isHostParent(parent)) {
                return parent;
              }
              parent = parent.return;
            }
            throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          }
          function isHostParent(fiber) {
            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
          }
          function getHostSibling(fiber) {
            var node = fiber;
            siblings:
              while (true) {
                while (node.sibling === null) {
                  if (node.return === null || isHostParent(node.return)) {
                    return null;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
                while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                  if (node.flags & Placement) {
                    continue siblings;
                  }
                  if (node.child === null || node.tag === HostPortal) {
                    continue siblings;
                  } else {
                    node.child.return = node;
                    node = node.child;
                  }
                }
                if (!(node.flags & Placement)) {
                  return node.stateNode;
                }
              }
          }
          function commitPlacement(finishedWork) {
            var parentFiber = getHostParentFiber(finishedWork);
            switch (parentFiber.tag) {
              case HostComponent: {
                var parent = parentFiber.stateNode;
                if (parentFiber.flags & ContentReset) {
                  resetTextContent(parent);
                  parentFiber.flags &= ~ContentReset;
                }
                var before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              }
              case HostRoot:
              case HostPortal: {
                var _parent = parentFiber.stateNode.containerInfo;
                var _before = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
                break;
              }
              default:
                throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
              var stateNode = node.stateNode;
              if (before) {
                insertInContainerBefore(parent, stateNode, before);
              } else {
                appendChildToContainer(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function insertOrAppendPlacementNode(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
              var stateNode = node.stateNode;
              if (before) {
                insertBefore(parent, stateNode, before);
              } else {
                appendChild(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNode(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNode(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          var hostParent = null;
          var hostParentIsContainer = false;
          function commitDeletionEffects(root2, returnFiber, deletedFiber) {
            {
              var parent = returnFiber;
              findParent:
                while (parent !== null) {
                  switch (parent.tag) {
                    case HostComponent: {
                      hostParent = parent.stateNode;
                      hostParentIsContainer = false;
                      break findParent;
                    }
                    case HostRoot: {
                      hostParent = parent.stateNode.containerInfo;
                      hostParentIsContainer = true;
                      break findParent;
                    }
                    case HostPortal: {
                      hostParent = parent.stateNode.containerInfo;
                      hostParentIsContainer = true;
                      break findParent;
                    }
                  }
                  parent = parent.return;
                }
              if (hostParent === null) {
                throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              }
              commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
            }
            detachFiberMutation(deletedFiber);
          }
          function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
            var child = parent.child;
            while (child !== null) {
              commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
              child = child.sibling;
            }
          }
          function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
            onCommitUnmount(deletedFiber);
            switch (deletedFiber.tag) {
              case HostComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                }
              }
              case HostText: {
                {
                  var prevHostParent = hostParent;
                  var prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = prevHostParent;
                  hostParentIsContainer = prevHostParentIsContainer;
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      removeChildFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      removeChild(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case DehydratedFragment: {
                {
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                {
                  var _prevHostParent = hostParent;
                  var _prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = deletedFiber.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = _prevHostParent;
                  hostParentIsContainer = _prevHostParentIsContainer;
                }
                return;
              }
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                if (!offscreenSubtreeWasHidden) {
                  var updateQueue = deletedFiber.updateQueue;
                  if (updateQueue !== null) {
                    var lastEffect = updateQueue.lastEffect;
                    if (lastEffect !== null) {
                      var firstEffect = lastEffect.next;
                      var effect4 = firstEffect;
                      do {
                        var _effect = effect4, destroy = _effect.destroy, tag = _effect.tag;
                        if (destroy !== void 0) {
                          if ((tag & Insertion) !== NoFlags$1) {
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          } else if ((tag & Layout) !== NoFlags$1) {
                            {
                              markComponentLayoutEffectUnmountStarted(deletedFiber);
                            }
                            if (deletedFiber.mode & ProfileMode) {
                              startLayoutEffectTimer();
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                              recordLayoutEffectDuration(deletedFiber);
                            } else {
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                            }
                            {
                              markComponentLayoutEffectUnmountStopped();
                            }
                          }
                        }
                        effect4 = effect4.next;
                      } while (effect4 !== firstEffect);
                    }
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ClassComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                  var instance = deletedFiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ScopeComponent: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case OffscreenComponent: {
                if (
                  // TODO: Remove this dead flag
                  deletedFiber.mode & ConcurrentMode
                ) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                }
                break;
              }
              default: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
            }
          }
          function commitSuspenseCallback(finishedWork) {
            var newState = finishedWork.memoizedState;
          }
          function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
            var newState = finishedWork.memoizedState;
            if (newState === null) {
              var current2 = finishedWork.alternate;
              if (current2 !== null) {
                var prevState = current2.memoizedState;
                if (prevState !== null) {
                  var suspenseInstance = prevState.dehydrated;
                  if (suspenseInstance !== null) {
                    commitHydratedSuspenseInstance(suspenseInstance);
                  }
                }
              }
            }
          }
          function attachSuspenseRetryListeners(finishedWork) {
            var wakeables = finishedWork.updateQueue;
            if (wakeables !== null) {
              finishedWork.updateQueue = null;
              var retryCache = finishedWork.stateNode;
              if (retryCache === null) {
                retryCache = finishedWork.stateNode = new PossiblyWeakSet();
              }
              wakeables.forEach(function(wakeable) {
                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                if (!retryCache.has(wakeable)) {
                  retryCache.add(wakeable);
                  {
                    if (isDevToolsPresent) {
                      if (inProgressLanes !== null && inProgressRoot !== null) {
                        restorePendingUpdaters(inProgressRoot, inProgressLanes);
                      } else {
                        throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                      }
                    }
                  }
                  wakeable.then(retry, retry);
                }
              });
            }
          }
          function commitMutationEffects(root2, finishedWork, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root2;
            setCurrentFiber(finishedWork);
            commitMutationEffectsOnFiber(finishedWork, root2);
            setCurrentFiber(finishedWork);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function recursivelyTraverseMutationEffects(root2, parentFiber, lanes) {
            var deletions = parentFiber.deletions;
            if (deletions !== null) {
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i];
                try {
                  commitDeletionEffects(root2, parentFiber, childToDelete);
                } catch (error3) {
                  captureCommitPhaseError(childToDelete, parentFiber, error3);
                }
              }
            }
            var prevDebugFiber = getCurrentFiber();
            if (parentFiber.subtreeFlags & MutationMask) {
              var child = parentFiber.child;
              while (child !== null) {
                setCurrentFiber(child);
                commitMutationEffectsOnFiber(child, root2);
                child = child.sibling;
              }
            }
            setCurrentFiber(prevDebugFiber);
          }
          function commitMutationEffectsOnFiber(finishedWork, root2, lanes) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  try {
                    commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                    commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                  if (finishedWork.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error3) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                    }
                    recordLayoutEffectDuration(finishedWork);
                  } else {
                    try {
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error3) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                    }
                  }
                }
                return;
              }
              case ClassComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                return;
              }
              case HostComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                {
                  if (finishedWork.flags & ContentReset) {
                    var instance = finishedWork.stateNode;
                    try {
                      resetTextContent(instance);
                    } catch (error3) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                    }
                  }
                  if (flags & Update) {
                    var _instance4 = finishedWork.stateNode;
                    if (_instance4 != null) {
                      var newProps = finishedWork.memoizedProps;
                      var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                      var type = finishedWork.type;
                      var updatePayload = finishedWork.updateQueue;
                      finishedWork.updateQueue = null;
                      if (updatePayload !== null) {
                        try {
                          commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                        } catch (error3) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostText: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (finishedWork.stateNode === null) {
                      throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    var textInstance = finishedWork.stateNode;
                    var newText = finishedWork.memoizedProps;
                    var oldText = current2 !== null ? current2.memoizedProps : newText;
                    try {
                      commitTextUpdate(textInstance, oldText, newText);
                    } catch (error3) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                    }
                  }
                }
                return;
              }
              case HostRoot: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (current2 !== null) {
                      var prevRootState = current2.memoizedState;
                      if (prevRootState.isDehydrated) {
                        try {
                          commitHydratedContainer(root2.containerInfo);
                        } catch (error3) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
              case SuspenseComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                var offscreenFiber = finishedWork.child;
                if (offscreenFiber.flags & Visibility) {
                  var offscreenInstance = offscreenFiber.stateNode;
                  var newState = offscreenFiber.memoizedState;
                  var isHidden = newState !== null;
                  offscreenInstance.isHidden = isHidden;
                  if (isHidden) {
                    var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                    if (!wasHidden) {
                      markCommitTimeOfFallback();
                    }
                  }
                }
                if (flags & Update) {
                  try {
                    commitSuspenseCallback(finishedWork);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case OffscreenComponent: {
                var _wasHidden = current2 !== null && current2.memoizedState !== null;
                if (
                  // TODO: Remove this dead flag
                  finishedWork.mode & ConcurrentMode
                ) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                }
                commitReconciliationEffects(finishedWork);
                if (flags & Visibility) {
                  var _offscreenInstance = finishedWork.stateNode;
                  var _newState = finishedWork.memoizedState;
                  var _isHidden = _newState !== null;
                  var offscreenBoundary = finishedWork;
                  _offscreenInstance.isHidden = _isHidden;
                  {
                    if (_isHidden) {
                      if (!_wasHidden) {
                        if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                          nextEffect = offscreenBoundary;
                          var offscreenChild = offscreenBoundary.child;
                          while (offscreenChild !== null) {
                            nextEffect = offscreenChild;
                            disappearLayoutEffects_begin(offscreenChild);
                            offscreenChild = offscreenChild.sibling;
                          }
                        }
                      }
                    }
                  }
                  {
                    hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                  }
                }
                return;
              }
              case SuspenseListComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case ScopeComponent: {
                return;
              }
              default: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
            }
          }
          function commitReconciliationEffects(finishedWork) {
            var flags = finishedWork.flags;
            if (flags & Placement) {
              try {
                commitPlacement(finishedWork);
              } catch (error3) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error3);
              }
              finishedWork.flags &= ~Placement;
            }
            if (flags & Hydrating) {
              finishedWork.flags &= ~Hydrating;
            }
          }
          function commitLayoutEffects(finishedWork, root2, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root2;
            nextEffect = finishedWork;
            commitLayoutEffects_begin(finishedWork, root2, committedLanes);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function commitLayoutEffects_begin(subtreeRoot, root2, committedLanes) {
            var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent && isModernRoot) {
                var isHidden = fiber.memoizedState !== null;
                var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
                if (newOffscreenSubtreeIsHidden) {
                  commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                  continue;
                } else {
                  var current2 = fiber.alternate;
                  var wasHidden = current2 !== null && current2.memoizedState !== null;
                  var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                  var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                  if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                    nextEffect = fiber;
                    reappearLayoutEffects_begin(fiber);
                  }
                  var child = firstChild;
                  while (child !== null) {
                    nextEffect = child;
                    commitLayoutEffects_begin(
                      child,
                      // New root; bubble back up to here and stop.
                      root2,
                      committedLanes
                    );
                    child = child.sibling;
                  }
                  nextEffect = fiber;
                  offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                  commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                  continue;
                }
              }
              if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
              }
            }
          }
          function commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & LayoutMask) !== NoFlags) {
                var current2 = fiber.alternate;
                setCurrentFiber(fiber);
                try {
                  commitLayoutEffectOnFiber(root2, current2, fiber, committedLanes);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function disappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case MemoComponent:
                case SimpleMemoComponent: {
                  if (fiber.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout, fiber, fiber.return);
                    } finally {
                      recordLayoutEffectDuration(fiber);
                    }
                  } else {
                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                  }
                  break;
                }
                case ClassComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
                case HostComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  break;
                }
                case OffscreenComponent: {
                  var isHidden = fiber.memoizedState !== null;
                  if (isHidden) {
                    disappearLayoutEffects_complete(subtreeRoot);
                    continue;
                  }
                  break;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                disappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function disappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function reappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent) {
                var isHidden = fiber.memoizedState !== null;
                if (isHidden) {
                  reappearLayoutEffects_complete(subtreeRoot);
                  continue;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                reappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function reappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                reappearLayoutEffectsOnFiber(fiber);
              } catch (error3) {
                captureCommitPhaseError(fiber, fiber.return, error3);
              }
              resetCurrentFiber();
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountEffects(root2, finishedWork, committedLanes, committedTransitions) {
            nextEffect = finishedWork;
            commitPassiveMountEffects_begin(finishedWork, root2, committedLanes, committedTransitions);
          }
          function commitPassiveMountEffects_begin(subtreeRoot, root2, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions);
              }
            }
          }
          function commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                try {
                  commitPassiveMountOnFiber(root2, fiber, committedLanes, committedTransitions);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                  } finally {
                    recordPassiveEffectDuration(finishedWork);
                  }
                } else {
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffects(firstChild) {
            nextEffect = firstChild;
            commitPassiveUnmountEffects_begin();
          }
          function commitPassiveUnmountEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
                var deletions = fiber.deletions;
                if (deletions !== null) {
                  for (var i = 0; i < deletions.length; i++) {
                    var fiberToDelete = deletions[i];
                    nextEffect = fiberToDelete;
                    commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                  }
                  {
                    var previousFiber = fiber.alternate;
                    if (previousFiber !== null) {
                      var detachedChild = previousFiber.child;
                      if (detachedChild !== null) {
                        previousFiber.child = null;
                        do {
                          var detachedSibling = detachedChild.sibling;
                          detachedChild.sibling = null;
                          detachedChild = detachedSibling;
                        } while (detachedChild !== null);
                      }
                    }
                  }
                  nextEffect = fiber;
                }
              }
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffects_complete();
              }
            }
          }
          function commitPassiveUnmountEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                commitPassiveUnmountOnFiber(fiber);
                resetCurrentFiber();
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveUnmountOnFiber(finishedWork) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                  recordPassiveEffectDuration(finishedWork);
                } else {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
              resetCurrentFiber();
              var child = fiber.child;
              if (child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var sibling = fiber.sibling;
              var returnFiber = fiber.return;
              {
                detachFiberAfterEffects(fiber);
                if (fiber === deletedSubtreeRoot) {
                  nextEffect = null;
                  return;
                }
              }
              if (sibling !== null) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                return;
              }
              nextEffect = returnFiber;
            }
          }
          function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
            switch (current2.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (current2.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                  recordPassiveEffectDuration(current2);
                } else {
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                }
                break;
              }
            }
          }
          function invokeLayoutEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Layout | HasEffect, fiber);
                  } catch (error3) {
                    captureCommitPhaseError(fiber, fiber.return, error3);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  try {
                    instance.componentDidMount();
                  } catch (error3) {
                    captureCommitPhaseError(fiber, fiber.return, error3);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                  } catch (error3) {
                    captureCommitPhaseError(fiber, fiber.return, error3);
                  }
                  break;
                }
              }
            }
          }
          function invokeLayoutEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                  } catch (error3) {
                    captureCommitPhaseError(fiber, fiber.return, error3);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                  } catch (error3) {
                    captureCommitPhaseError(fiber, fiber.return, error3);
                  }
                }
              }
            }
          }
          var COMPONENT_TYPE = 0;
          var HAS_PSEUDO_CLASS_TYPE = 1;
          var ROLE_TYPE = 2;
          var TEST_NAME_TYPE = 3;
          var TEXT_TYPE = 4;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            COMPONENT_TYPE = symbolFor("selector.component");
            HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
            ROLE_TYPE = symbolFor("selector.role");
            TEST_NAME_TYPE = symbolFor("selector.test_id");
            TEXT_TYPE = symbolFor("selector.text");
          }
          var commitHooks = [];
          function onCommitRoot$1() {
            {
              commitHooks.forEach(function(commitHook) {
                return commitHook();
              });
            }
          }
          var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
          function isLegacyActEnvironment(fiber) {
            {
              var isReactActEnvironmentGlobal = (
                // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
                typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
              );
              var jestIsDefined = typeof jest !== "undefined";
              return jestIsDefined && isReactActEnvironmentGlobal !== false;
            }
          }
          function isConcurrentActEnvironment() {
            {
              var isReactActEnvironmentGlobal = (
                // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
                typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
              );
              if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
                error2("The current testing environment is not configured to support act(...)");
              }
              return isReactActEnvironmentGlobal;
            }
          }
          var ceil = Math.ceil;
          var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
          var NoContext = (
            /*             */
            0
          );
          var BatchedContext = (
            /*               */
            1
          );
          var RenderContext = (
            /*                */
            2
          );
          var CommitContext = (
            /*                */
            4
          );
          var RootInProgress = 0;
          var RootFatalErrored = 1;
          var RootErrored = 2;
          var RootSuspended = 3;
          var RootSuspendedWithDelay = 4;
          var RootCompleted = 5;
          var RootDidNotComplete = 6;
          var executionContext = NoContext;
          var workInProgressRoot = null;
          var workInProgress = null;
          var workInProgressRootRenderLanes = NoLanes;
          var subtreeRenderLanes = NoLanes;
          var subtreeRenderLanesCursor = createCursor(NoLanes);
          var workInProgressRootExitStatus = RootInProgress;
          var workInProgressRootFatalError = null;
          var workInProgressRootIncludedLanes = NoLanes;
          var workInProgressRootSkippedLanes = NoLanes;
          var workInProgressRootInterleavedUpdatedLanes = NoLanes;
          var workInProgressRootPingedLanes = NoLanes;
          var workInProgressRootConcurrentErrors = null;
          var workInProgressRootRecoverableErrors = null;
          var globalMostRecentFallbackTime = 0;
          var FALLBACK_THROTTLE_MS = 500;
          var workInProgressRootRenderTargetTime = Infinity;
          var RENDER_TIMEOUT_MS = 500;
          var workInProgressTransitions = null;
          function resetRenderTimer() {
            workInProgressRootRenderTargetTime = now2() + RENDER_TIMEOUT_MS;
          }
          function getRenderTargetTime() {
            return workInProgressRootRenderTargetTime;
          }
          var hasUncaughtError = false;
          var firstUncaughtError = null;
          var legacyErrorBoundariesThatAlreadyFailed = null;
          var rootDoesHavePassiveEffects = false;
          var rootWithPendingPassiveEffects = null;
          var pendingPassiveEffectsLanes = NoLanes;
          var pendingPassiveProfilerEffects = [];
          var pendingPassiveTransitions = null;
          var NESTED_UPDATE_LIMIT = 50;
          var nestedUpdateCount = 0;
          var rootWithNestedUpdates = null;
          var isFlushingPassiveEffects = false;
          var didScheduleUpdateDuringPassiveEffects = false;
          var NESTED_PASSIVE_UPDATE_LIMIT = 50;
          var nestedPassiveUpdateCount = 0;
          var rootWithPassiveNestedUpdates = null;
          var currentEventTime = NoTimestamp;
          var currentEventTransitionLane = NoLanes;
          var isRunningInsertionEffect = false;
          function getWorkInProgressRoot() {
            return workInProgressRoot;
          }
          function requestEventTime() {
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              return now2();
            }
            if (currentEventTime !== NoTimestamp) {
              return currentEventTime;
            }
            currentEventTime = now2();
            return currentEventTime;
          }
          function requestUpdateLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
              return SyncLane;
            } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
              return pickArbitraryLane(workInProgressRootRenderLanes);
            }
            var isTransition = requestCurrentTransition() !== NoTransition;
            if (isTransition) {
              if (ReactCurrentBatchConfig$3.transition !== null) {
                var transition = ReactCurrentBatchConfig$3.transition;
                if (!transition._updatedFibers) {
                  transition._updatedFibers = /* @__PURE__ */ new Set();
                }
                transition._updatedFibers.add(fiber);
              }
              if (currentEventTransitionLane === NoLane) {
                currentEventTransitionLane = claimNextTransitionLane();
              }
              return currentEventTransitionLane;
            }
            var updateLane = getCurrentUpdatePriority();
            if (updateLane !== NoLane) {
              return updateLane;
            }
            var eventLane = getCurrentEventPriority();
            return eventLane;
          }
          function requestRetryLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
              return SyncLane;
            }
            return claimNextRetryLane();
          }
          function scheduleUpdateOnFiber(root2, fiber, lane, eventTime) {
            checkForNestedUpdates();
            {
              if (isRunningInsertionEffect) {
                error2("useInsertionEffect must not schedule updates.");
              }
            }
            {
              if (isFlushingPassiveEffects) {
                didScheduleUpdateDuringPassiveEffects = true;
              }
            }
            markRootUpdated(root2, lane, eventTime);
            if ((executionContext & RenderContext) !== NoLanes && root2 === workInProgressRoot) {
              warnAboutRenderPhaseUpdatesInDEV(fiber);
            } else {
              {
                if (isDevToolsPresent) {
                  addFiberToLanesMap(root2, fiber, lane);
                }
              }
              warnIfUpdatesNotWrappedWithActDEV(fiber);
              if (root2 === workInProgressRoot) {
                if ((executionContext & RenderContext) === NoContext) {
                  workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
                }
                if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                  markRootSuspended$1(root2, workInProgressRootRenderLanes);
                }
              }
              ensureRootIsScheduled(root2, eventTime);
              if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
              !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function scheduleInitialHydrationOnRoot(root2, lane, eventTime) {
            var current2 = root2.current;
            current2.lanes = lane;
            markRootUpdated(root2, lane, eventTime);
            ensureRootIsScheduled(root2, eventTime);
          }
          function isUnsafeClassRenderPhaseUpdate(fiber) {
            return (
              // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
              // decided not to enable it.
              (executionContext & RenderContext) !== NoContext
            );
          }
          function ensureRootIsScheduled(root2, currentTime) {
            var existingCallbackNode = root2.callbackNode;
            markStarvedLanesAsExpired(root2, currentTime);
            var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (nextLanes === NoLanes) {
              if (existingCallbackNode !== null) {
                cancelCallback$1(existingCallbackNode);
              }
              root2.callbackNode = null;
              root2.callbackPriority = NoLane;
              return;
            }
            var newCallbackPriority = getHighestPriorityLane(nextLanes);
            var existingCallbackPriority = root2.callbackPriority;
            if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
            // Scheduler task, rather than an `act` task, cancel it and re-scheduled
            // on the `act` queue.
            !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
              {
                if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                  error2("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              return;
            }
            if (existingCallbackNode != null) {
              cancelCallback$1(existingCallbackNode);
            }
            var newCallbackNode;
            if (newCallbackPriority === SyncLane) {
              if (root2.tag === LegacyRoot) {
                if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                  ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
                }
                scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root2));
              } else {
                scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));
              }
              {
                if (ReactCurrentActQueue$1.current !== null) {
                  ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
                } else {
                  scheduleMicrotask(function() {
                    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                      flushSyncCallbacks();
                    }
                  });
                }
              }
              newCallbackNode = null;
            } else {
              var schedulerPriorityLevel;
              switch (lanesToEventPriority(nextLanes)) {
                case DiscreteEventPriority:
                  schedulerPriorityLevel = ImmediatePriority;
                  break;
                case ContinuousEventPriority:
                  schedulerPriorityLevel = UserBlockingPriority;
                  break;
                case DefaultEventPriority:
                  schedulerPriorityLevel = NormalPriority;
                  break;
                case IdleEventPriority:
                  schedulerPriorityLevel = IdlePriority;
                  break;
                default:
                  schedulerPriorityLevel = NormalPriority;
                  break;
              }
              newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
            }
            root2.callbackPriority = newCallbackPriority;
            root2.callbackNode = newCallbackNode;
          }
          function performConcurrentWorkOnRoot(root2, didTimeout) {
            {
              resetNestedUpdateFlag();
            }
            currentEventTime = NoTimestamp;
            currentEventTransitionLane = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var originalCallbackNode = root2.callbackNode;
            var didFlushPassiveEffects = flushPassiveEffects();
            if (didFlushPassiveEffects) {
              if (root2.callbackNode !== originalCallbackNode) {
                return null;
              }
            }
            var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (lanes === NoLanes) {
              return null;
            }
            var shouldTimeSlice = !includesBlockingLane(root2, lanes) && !includesExpiredLane(root2, lanes) && !didTimeout;
            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes);
            if (exitStatus !== RootInProgress) {
              if (exitStatus === RootErrored) {
                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
                if (errorRetryLanes !== NoLanes) {
                  lanes = errorRetryLanes;
                  exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
                }
              }
              if (exitStatus === RootFatalErrored) {
                var fatalError = workInProgressRootFatalError;
                prepareFreshStack(root2, NoLanes);
                markRootSuspended$1(root2, lanes);
                ensureRootIsScheduled(root2, now2());
                throw fatalError;
              }
              if (exitStatus === RootDidNotComplete) {
                markRootSuspended$1(root2, lanes);
              } else {
                var renderWasConcurrent = !includesBlockingLane(root2, lanes);
                var finishedWork = root2.current.alternate;
                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                  exitStatus = renderRootSync(root2, lanes);
                  if (exitStatus === RootErrored) {
                    var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
                    if (_errorRetryLanes !== NoLanes) {
                      lanes = _errorRetryLanes;
                      exitStatus = recoverFromConcurrentError(root2, _errorRetryLanes);
                    }
                  }
                  if (exitStatus === RootFatalErrored) {
                    var _fatalError = workInProgressRootFatalError;
                    prepareFreshStack(root2, NoLanes);
                    markRootSuspended$1(root2, lanes);
                    ensureRootIsScheduled(root2, now2());
                    throw _fatalError;
                  }
                }
                root2.finishedWork = finishedWork;
                root2.finishedLanes = lanes;
                finishConcurrentRender(root2, exitStatus, lanes);
              }
            }
            ensureRootIsScheduled(root2, now2());
            if (root2.callbackNode === originalCallbackNode) {
              return performConcurrentWorkOnRoot.bind(null, root2);
            }
            return null;
          }
          function recoverFromConcurrentError(root2, errorRetryLanes) {
            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
            if (isRootDehydrated(root2)) {
              var rootWorkInProgress = prepareFreshStack(root2, errorRetryLanes);
              rootWorkInProgress.flags |= ForceClientRender;
              {
                errorHydratingContainer(root2.containerInfo);
              }
            }
            var exitStatus = renderRootSync(root2, errorRetryLanes);
            if (exitStatus !== RootErrored) {
              var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
              if (errorsFromSecondAttempt !== null) {
                queueRecoverableErrors(errorsFromSecondAttempt);
              }
            }
            return exitStatus;
          }
          function queueRecoverableErrors(errors) {
            if (workInProgressRootRecoverableErrors === null) {
              workInProgressRootRecoverableErrors = errors;
            } else {
              workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
            }
          }
          function finishConcurrentRender(root2, exitStatus, lanes) {
            switch (exitStatus) {
              case RootInProgress:
              case RootFatalErrored: {
                throw new Error("Root did not complete. This is a bug in React.");
              }
              case RootErrored: {
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspended: {
                markRootSuspended$1(root2, lanes);
                if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
                !shouldForceFlushFallbacksInDEV()) {
                  var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now2();
                  if (msUntilTimeout > 10) {
                    var nextLanes = getNextLanes(root2, NoLanes);
                    if (nextLanes !== NoLanes) {
                      break;
                    }
                    var suspendedLanes = root2.suspendedLanes;
                    if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                      var eventTime = requestEventTime();
                      markRootPinged(root2, suspendedLanes);
                      break;
                    }
                    root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspendedWithDelay: {
                markRootSuspended$1(root2, lanes);
                if (includesOnlyTransitions(lanes)) {
                  break;
                }
                if (!shouldForceFlushFallbacksInDEV()) {
                  var mostRecentEventTime = getMostRecentEventTime(root2, lanes);
                  var eventTimeMs = mostRecentEventTime;
                  var timeElapsedMs = now2() - eventTimeMs;
                  var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                  if (_msUntilTimeout > 10) {
                    root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootCompleted: {
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              default: {
                throw new Error("Unknown root exit status.");
              }
            }
          }
          function isRenderConsistentWithExternalStores(finishedWork) {
            var node = finishedWork;
            while (true) {
              if (node.flags & StoreConsistency) {
                var updateQueue = node.updateQueue;
                if (updateQueue !== null) {
                  var checks = updateQueue.stores;
                  if (checks !== null) {
                    for (var i = 0; i < checks.length; i++) {
                      var check = checks[i];
                      var getSnapshot = check.getSnapshot;
                      var renderedValue = check.value;
                      try {
                        if (!objectIs(getSnapshot(), renderedValue)) {
                          return false;
                        }
                      } catch (error3) {
                        return false;
                      }
                    }
                  }
                }
              }
              var child = node.child;
              if (node.subtreeFlags & StoreConsistency && child !== null) {
                child.return = node;
                node = child;
                continue;
              }
              if (node === finishedWork) {
                return true;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === finishedWork) {
                  return true;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return true;
          }
          function markRootSuspended$1(root2, suspendedLanes) {
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
            markRootSuspended(root2, suspendedLanes);
          }
          function performSyncWorkOnRoot(root2) {
            {
              syncNestedUpdateFlag();
            }
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            flushPassiveEffects();
            var lanes = getNextLanes(root2, NoLanes);
            if (!includesSomeLane(lanes, SyncLane)) {
              ensureRootIsScheduled(root2, now2());
              return null;
            }
            var exitStatus = renderRootSync(root2, lanes);
            if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {
              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
              if (errorRetryLanes !== NoLanes) {
                lanes = errorRetryLanes;
                exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root2, NoLanes);
              markRootSuspended$1(root2, lanes);
              ensureRootIsScheduled(root2, now2());
              throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
              throw new Error("Root did not complete. This is a bug in React.");
            }
            var finishedWork = root2.current.alternate;
            root2.finishedWork = finishedWork;
            root2.finishedLanes = lanes;
            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
            ensureRootIsScheduled(root2, now2());
            return null;
          }
          function flushRoot(root2, lanes) {
            if (lanes !== NoLanes) {
              markRootEntangled(root2, mergeLanes(lanes, SyncLane));
              ensureRootIsScheduled(root2, now2());
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                resetRenderTimer();
                flushSyncCallbacks();
              }
            }
          }
          function batchedUpdates$1(fn2, a) {
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            try {
              return fn2(a);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
              !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function discreteUpdates(fn2, a, b, c, d) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              return fn2(a, b, c, d);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              if (executionContext === NoContext) {
                resetRenderTimer();
              }
            }
          }
          function flushSync(fn2) {
            if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
              flushPassiveEffects();
            }
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              if (fn2) {
                return fn2();
              } else {
                return void 0;
              }
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              executionContext = prevExecutionContext;
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                flushSyncCallbacks();
              }
            }
          }
          function isAlreadyRendering() {
            return (executionContext & (RenderContext | CommitContext)) !== NoContext;
          }
          function pushRenderLanes(fiber, lanes) {
            push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
          }
          function popRenderLanes(fiber) {
            subtreeRenderLanes = subtreeRenderLanesCursor.current;
            pop(subtreeRenderLanesCursor, fiber);
          }
          function prepareFreshStack(root2, lanes) {
            root2.finishedWork = null;
            root2.finishedLanes = NoLanes;
            var timeoutHandle = root2.timeoutHandle;
            if (timeoutHandle !== noTimeout) {
              root2.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }
            if (workInProgress !== null) {
              var interruptedWork = workInProgress.return;
              while (interruptedWork !== null) {
                var current2 = interruptedWork.alternate;
                unwindInterruptedWork(current2, interruptedWork);
                interruptedWork = interruptedWork.return;
              }
            }
            workInProgressRoot = root2;
            var rootWorkInProgress = createWorkInProgress(root2.current, null);
            workInProgress = rootWorkInProgress;
            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
            workInProgressRootExitStatus = RootInProgress;
            workInProgressRootFatalError = null;
            workInProgressRootSkippedLanes = NoLanes;
            workInProgressRootInterleavedUpdatedLanes = NoLanes;
            workInProgressRootPingedLanes = NoLanes;
            workInProgressRootConcurrentErrors = null;
            workInProgressRootRecoverableErrors = null;
            finishQueueingConcurrentUpdates();
            {
              ReactStrictModeWarnings.discardPendingWarnings();
            }
            return rootWorkInProgress;
          }
          function handleError(root2, thrownValue) {
            do {
              var erroredWork = workInProgress;
              try {
                resetContextDependencies();
                resetHooksAfterThrow();
                resetCurrentFiber();
                ReactCurrentOwner$2.current = null;
                if (erroredWork === null || erroredWork.return === null) {
                  workInProgressRootExitStatus = RootFatalErrored;
                  workInProgressRootFatalError = thrownValue;
                  workInProgress = null;
                  return;
                }
                if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                }
                if (enableSchedulingProfiler) {
                  markComponentRenderStopped();
                  if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                    var wakeable = thrownValue;
                    markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                  } else {
                    markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                  }
                }
                throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                completeUnitOfWork(erroredWork);
              } catch (yetAnotherThrownValue) {
                thrownValue = yetAnotherThrownValue;
                if (workInProgress === erroredWork && erroredWork !== null) {
                  erroredWork = erroredWork.return;
                  workInProgress = erroredWork;
                } else {
                  erroredWork = workInProgress;
                }
                continue;
              }
              return;
            } while (true);
          }
          function pushDispatcher() {
            var prevDispatcher = ReactCurrentDispatcher$2.current;
            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
            if (prevDispatcher === null) {
              return ContextOnlyDispatcher;
            } else {
              return prevDispatcher;
            }
          }
          function popDispatcher(prevDispatcher) {
            ReactCurrentDispatcher$2.current = prevDispatcher;
          }
          function markCommitTimeOfFallback() {
            globalMostRecentFallbackTime = now2();
          }
          function markSkippedUpdateLanes(lane) {
            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
          }
          function renderDidSuspend() {
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootSuspended;
            }
          }
          function renderDidSuspendDelayIfPossible() {
            if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
              workInProgressRootExitStatus = RootSuspendedWithDelay;
            }
            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
              markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
            }
          }
          function renderDidError(error3) {
            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
              workInProgressRootExitStatus = RootErrored;
            }
            if (workInProgressRootConcurrentErrors === null) {
              workInProgressRootConcurrentErrors = [error3];
            } else {
              workInProgressRootConcurrentErrors.push(error3);
            }
          }
          function renderHasNotSuspendedYet() {
            return workInProgressRootExitStatus === RootInProgress;
          }
          function renderRootSync(root2, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root2.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root2, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              prepareFreshStack(root2, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopSync();
                break;
              } catch (thrownValue) {
                handleError(root2, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            executionContext = prevExecutionContext;
            popDispatcher(prevDispatcher);
            if (workInProgress !== null) {
              throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
            }
            {
              markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
          function workLoopSync() {
            while (workInProgress !== null) {
              performUnitOfWork(workInProgress);
            }
          }
          function renderRootConcurrent(root2, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root2.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root2, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              resetRenderTimer();
              prepareFreshStack(root2, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopConcurrent();
                break;
              } catch (thrownValue) {
                handleError(root2, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            popDispatcher(prevDispatcher);
            executionContext = prevExecutionContext;
            if (workInProgress !== null) {
              {
                markRenderYielded();
              }
              return RootInProgress;
            } else {
              {
                markRenderStopped();
              }
              workInProgressRoot = null;
              workInProgressRootRenderLanes = NoLanes;
              return workInProgressRootExitStatus;
            }
          }
          function workLoopConcurrent() {
            while (workInProgress !== null && !shouldYield()) {
              performUnitOfWork(workInProgress);
            }
          }
          function performUnitOfWork(unitOfWork) {
            var current2 = unitOfWork.alternate;
            setCurrentFiber(unitOfWork);
            var next;
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              startProfilerTimer(unitOfWork);
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
              stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
            } else {
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            }
            resetCurrentFiber();
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            if (next === null) {
              completeUnitOfWork(unitOfWork);
            } else {
              workInProgress = next;
            }
            ReactCurrentOwner$2.current = null;
          }
          function completeUnitOfWork(unitOfWork) {
            var completedWork = unitOfWork;
            do {
              var current2 = completedWork.alternate;
              var returnFiber = completedWork.return;
              if ((completedWork.flags & Incomplete) === NoFlags) {
                setCurrentFiber(completedWork);
                var next = void 0;
                if ((completedWork.mode & ProfileMode) === NoMode) {
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                } else {
                  startProfilerTimer(completedWork);
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                }
                resetCurrentFiber();
                if (next !== null) {
                  workInProgress = next;
                  return;
                }
              } else {
                var _next = unwindWork(current2, completedWork);
                if (_next !== null) {
                  _next.flags &= HostEffectMask;
                  workInProgress = _next;
                  return;
                }
                if ((completedWork.mode & ProfileMode) !== NoMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                  var actualDuration = completedWork.actualDuration;
                  var child = completedWork.child;
                  while (child !== null) {
                    actualDuration += child.actualDuration;
                    child = child.sibling;
                  }
                  completedWork.actualDuration = actualDuration;
                }
                if (returnFiber !== null) {
                  returnFiber.flags |= Incomplete;
                  returnFiber.subtreeFlags = NoFlags;
                  returnFiber.deletions = null;
                } else {
                  workInProgressRootExitStatus = RootDidNotComplete;
                  workInProgress = null;
                  return;
                }
              }
              var siblingFiber = completedWork.sibling;
              if (siblingFiber !== null) {
                workInProgress = siblingFiber;
                return;
              }
              completedWork = returnFiber;
              workInProgress = completedWork;
            } while (completedWork !== null);
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootCompleted;
            }
          }
          function commitRoot(root2, recoverableErrors, transitions) {
            var previousUpdateLanePriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              commitRootImpl(root2, recoverableErrors, transitions, previousUpdateLanePriority);
            } finally {
              ReactCurrentBatchConfig$3.transition = prevTransition;
              setCurrentUpdatePriority(previousUpdateLanePriority);
            }
            return null;
          }
          function commitRootImpl(root2, recoverableErrors, transitions, renderPriorityLevel) {
            do {
              flushPassiveEffects();
            } while (rootWithPendingPassiveEffects !== null);
            flushRenderPhaseStrictModeWarningsInDEV();
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var finishedWork = root2.finishedWork;
            var lanes = root2.finishedLanes;
            {
              markCommitStarted(lanes);
            }
            if (finishedWork === null) {
              {
                markCommitStopped();
              }
              return null;
            } else {
              {
                if (lanes === NoLanes) {
                  error2("root.finishedLanes should not be empty during a commit. This is a bug in React.");
                }
              }
            }
            root2.finishedWork = null;
            root2.finishedLanes = NoLanes;
            if (finishedWork === root2.current) {
              throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
            }
            root2.callbackNode = null;
            root2.callbackPriority = NoLane;
            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
            markRootFinished(root2, remainingLanes);
            if (root2 === workInProgressRoot) {
              workInProgressRoot = null;
              workInProgress = null;
              workInProgressRootRenderLanes = NoLanes;
            }
            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                pendingPassiveTransitions = transitions;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            if (subtreeHasEffects || rootHasEffect) {
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              ReactCurrentBatchConfig$3.transition = null;
              var previousPriority = getCurrentUpdatePriority();
              setCurrentUpdatePriority(DiscreteEventPriority);
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              ReactCurrentOwner$2.current = null;
              var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root2, finishedWork);
              {
                recordCommitTime();
              }
              commitMutationEffects(root2, finishedWork, lanes);
              resetAfterCommit(root2.containerInfo);
              root2.current = finishedWork;
              {
                markLayoutEffectsStarted(lanes);
              }
              commitLayoutEffects(finishedWork, root2, lanes);
              {
                markLayoutEffectsStopped();
              }
              requestPaint();
              executionContext = prevExecutionContext;
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
            } else {
              root2.current = finishedWork;
              {
                recordCommitTime();
              }
            }
            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
            if (rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = false;
              rootWithPendingPassiveEffects = root2;
              pendingPassiveEffectsLanes = lanes;
            } else {
              {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
              }
            }
            remainingLanes = root2.pendingLanes;
            if (remainingLanes === NoLanes) {
              legacyErrorBoundariesThatAlreadyFailed = null;
            }
            {
              if (!rootDidHavePassiveEffects) {
                commitDoubleInvokeEffectsInDEV(root2.current, false);
              }
            }
            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
            {
              if (isDevToolsPresent) {
                root2.memoizedUpdaters.clear();
              }
            }
            {
              onCommitRoot$1();
            }
            ensureRootIsScheduled(root2, now2());
            if (recoverableErrors !== null) {
              var onRecoverableError = root2.onRecoverableError;
              for (var i = 0; i < recoverableErrors.length; i++) {
                var recoverableError = recoverableErrors[i];
                var componentStack = recoverableError.stack;
                var digest = recoverableError.digest;
                onRecoverableError(recoverableError.value, {
                  componentStack,
                  digest
                });
              }
            }
            if (hasUncaughtError) {
              hasUncaughtError = false;
              var error$1 = firstUncaughtError;
              firstUncaughtError = null;
              throw error$1;
            }
            if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root2.tag !== LegacyRoot) {
              flushPassiveEffects();
            }
            remainingLanes = root2.pendingLanes;
            if (includesSomeLane(remainingLanes, SyncLane)) {
              {
                markNestedUpdateScheduled();
              }
              if (root2 === rootWithNestedUpdates) {
                nestedUpdateCount++;
              } else {
                nestedUpdateCount = 0;
                rootWithNestedUpdates = root2;
              }
            } else {
              nestedUpdateCount = 0;
            }
            flushSyncCallbacks();
            {
              markCommitStopped();
            }
            return null;
          }
          function flushPassiveEffects() {
            if (rootWithPendingPassiveEffects !== null) {
              var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
              var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              var previousPriority = getCurrentUpdatePriority();
              try {
                ReactCurrentBatchConfig$3.transition = null;
                setCurrentUpdatePriority(priority);
                return flushPassiveEffectsImpl();
              } finally {
                setCurrentUpdatePriority(previousPriority);
                ReactCurrentBatchConfig$3.transition = prevTransition;
              }
            }
            return false;
          }
          function enqueuePendingPassiveProfilerEffect(fiber) {
            {
              pendingPassiveProfilerEffects.push(fiber);
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
          }
          function flushPassiveEffectsImpl() {
            if (rootWithPendingPassiveEffects === null) {
              return false;
            }
            var transitions = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root2 = rootWithPendingPassiveEffects;
            var lanes = pendingPassiveEffectsLanes;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsLanes = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Cannot flush passive effects while already rendering.");
            }
            {
              isFlushingPassiveEffects = true;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            {
              markPassiveEffectsStarted(lanes);
            }
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            commitPassiveUnmountEffects(root2.current);
            commitPassiveMountEffects(root2, root2.current, lanes, transitions);
            {
              var profilerEffects = pendingPassiveProfilerEffects;
              pendingPassiveProfilerEffects = [];
              for (var i = 0; i < profilerEffects.length; i++) {
                var _fiber = profilerEffects[i];
                commitPassiveEffectDurations(root2, _fiber);
              }
            }
            {
              markPassiveEffectsStopped();
            }
            {
              commitDoubleInvokeEffectsInDEV(root2.current, true);
            }
            executionContext = prevExecutionContext;
            flushSyncCallbacks();
            {
              if (didScheduleUpdateDuringPassiveEffects) {
                if (root2 === rootWithPassiveNestedUpdates) {
                  nestedPassiveUpdateCount++;
                } else {
                  nestedPassiveUpdateCount = 0;
                  rootWithPassiveNestedUpdates = root2;
                }
              } else {
                nestedPassiveUpdateCount = 0;
              }
              isFlushingPassiveEffects = false;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            onPostCommitRoot(root2);
            {
              var stateNode = root2.current.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
            return true;
          }
          function isAlreadyFailedLegacyErrorBoundary(instance) {
            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
          }
          function markLegacyErrorBoundaryAsFailed(instance) {
            if (legacyErrorBoundariesThatAlreadyFailed === null) {
              legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
            } else {
              legacyErrorBoundariesThatAlreadyFailed.add(instance);
            }
          }
          function prepareToThrowUncaughtError(error3) {
            if (!hasUncaughtError) {
              hasUncaughtError = true;
              firstUncaughtError = error3;
            }
          }
          var onUncaughtError = prepareToThrowUncaughtError;
          function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error3) {
            var errorInfo = createCapturedValueAtFiber(error3, sourceFiber);
            var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
            var root2 = enqueueUpdate(rootFiber, update, SyncLane);
            var eventTime = requestEventTime();
            if (root2 !== null) {
              markRootUpdated(root2, SyncLane, eventTime);
              ensureRootIsScheduled(root2, eventTime);
            }
          }
          function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
            {
              reportUncaughtErrorInDEV(error$1);
              setIsRunningInsertionEffect(false);
            }
            if (sourceFiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
              return;
            }
            var fiber = null;
            {
              fiber = nearestMountedAncestor;
            }
            while (fiber !== null) {
              if (fiber.tag === HostRoot) {
                captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
                return;
              } else if (fiber.tag === ClassComponent) {
                var ctor = fiber.type;
                var instance = fiber.stateNode;
                if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                  var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                  var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                  var root2 = enqueueUpdate(fiber, update, SyncLane);
                  var eventTime = requestEventTime();
                  if (root2 !== null) {
                    markRootUpdated(root2, SyncLane, eventTime);
                    ensureRootIsScheduled(root2, eventTime);
                  }
                  return;
                }
              }
              fiber = fiber.return;
            }
            {
              error2("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
            }
          }
          function pingSuspendedRoot(root2, wakeable, pingedLanes) {
            var pingCache = root2.pingCache;
            if (pingCache !== null) {
              pingCache.delete(wakeable);
            }
            var eventTime = requestEventTime();
            markRootPinged(root2, pingedLanes);
            warnIfSuspenseResolutionNotWrappedWithActDEV(root2);
            if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
              if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now2() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
                prepareFreshStack(root2, NoLanes);
              } else {
                workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
              }
            }
            ensureRootIsScheduled(root2, eventTime);
          }
          function retryTimedOutBoundary(boundaryFiber, retryLane) {
            if (retryLane === NoLane) {
              retryLane = requestRetryLane(boundaryFiber);
            }
            var eventTime = requestEventTime();
            var root2 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
            if (root2 !== null) {
              markRootUpdated(root2, retryLane, eventTime);
              ensureRootIsScheduled(root2, eventTime);
            }
          }
          function retryDehydratedSuspenseBoundary(boundaryFiber) {
            var suspenseState = boundaryFiber.memoizedState;
            var retryLane = NoLane;
            if (suspenseState !== null) {
              retryLane = suspenseState.retryLane;
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function resolveRetryWakeable(boundaryFiber, wakeable) {
            var retryLane = NoLane;
            var retryCache;
            switch (boundaryFiber.tag) {
              case SuspenseComponent:
                retryCache = boundaryFiber.stateNode;
                var suspenseState = boundaryFiber.memoizedState;
                if (suspenseState !== null) {
                  retryLane = suspenseState.retryLane;
                }
                break;
              case SuspenseListComponent:
                retryCache = boundaryFiber.stateNode;
                break;
              default:
                throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
            }
            if (retryCache !== null) {
              retryCache.delete(wakeable);
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function jnd(timeElapsed) {
            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
          }
          function checkForNestedUpdates() {
            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = null;
              throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
            }
            {
              if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
                error2("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
              }
            }
          }
          function flushRenderPhaseStrictModeWarningsInDEV() {
            {
              ReactStrictModeWarnings.flushLegacyContextWarning();
              {
                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
              }
            }
          }
          function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
            {
              setCurrentFiber(fiber);
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
              }
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
              }
              resetCurrentFiber();
            }
          }
          function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
            {
              var current2 = firstChild;
              var subtreeRoot = null;
              while (current2 !== null) {
                var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
                if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
                  current2 = current2.child;
                } else {
                  if ((current2.flags & fiberFlags) !== NoFlags) {
                    invokeEffectFn(current2);
                  }
                  if (current2.sibling !== null) {
                    current2 = current2.sibling;
                  } else {
                    current2 = subtreeRoot = current2.return;
                  }
                }
              }
            }
          }
          var didWarnStateUpdateForNotYetMountedComponent = null;
          function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
            {
              if ((executionContext & RenderContext) !== NoContext) {
                return;
              }
              if (!(fiber.mode & ConcurrentMode)) {
                return;
              }
              var tag = fiber.tag;
              if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
                return;
              }
              var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (didWarnStateUpdateForNotYetMountedComponent !== null) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                  return;
                }
                didWarnStateUpdateForNotYetMountedComponent.add(componentName);
              } else {
                didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
              }
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error2("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
          var beginWork$1;
          {
            var dummyFiber = null;
            beginWork$1 = function(current2, unitOfWork, lanes) {
              var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
              try {
                return beginWork(current2, unitOfWork, lanes);
              } catch (originalError) {
                if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                  throw originalError;
                }
                resetContextDependencies();
                resetHooksAfterThrow();
                unwindInterruptedWork(current2, unitOfWork);
                assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
                if (unitOfWork.mode & ProfileMode) {
                  startProfilerTimer(unitOfWork);
                }
                invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
                if (hasCaughtError()) {
                  var replayError = clearCaughtError();
                  if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                    originalError._suppressLogging = true;
                  }
                }
                throw originalError;
              }
            };
          }
          var didWarnAboutUpdateInRender = false;
          var didWarnAboutUpdateInRenderForAnotherComponent;
          {
            didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
          }
          function warnAboutRenderPhaseUpdatesInDEV(fiber) {
            {
              if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
                switch (fiber.tag) {
                  case FunctionComponent:
                  case ForwardRef:
                  case SimpleMemoComponent: {
                    var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                    var dedupeKey = renderingComponentName;
                    if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                      didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                      var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                      error2("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                    }
                    break;
                  }
                  case ClassComponent: {
                    if (!didWarnAboutUpdateInRender) {
                      error2("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                      didWarnAboutUpdateInRender = true;
                    }
                    break;
                  }
                }
              }
            }
          }
          function restorePendingUpdaters(root2, lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root2.memoizedUpdaters;
                memoizedUpdaters.forEach(function(schedulingFiber) {
                  addFiberToLanesMap(root2, schedulingFiber, lanes);
                });
              }
            }
          }
          var fakeActCallbackNode = {};
          function scheduleCallback$1(priorityLevel, callback) {
            {
              var actQueue = ReactCurrentActQueue$1.current;
              if (actQueue !== null) {
                actQueue.push(callback);
                return fakeActCallbackNode;
              } else {
                return scheduleCallback(priorityLevel, callback);
              }
            }
          }
          function cancelCallback$1(callbackNode) {
            if (callbackNode === fakeActCallbackNode) {
              return;
            }
            return cancelCallback(callbackNode);
          }
          function shouldForceFlushFallbacksInDEV() {
            return ReactCurrentActQueue$1.current !== null;
          }
          function warnIfUpdatesNotWrappedWithActDEV(fiber) {
            {
              if (fiber.mode & ConcurrentMode) {
                if (!isConcurrentActEnvironment()) {
                  return;
                }
              } else {
                if (!isLegacyActEnvironment()) {
                  return;
                }
                if (executionContext !== NoContext) {
                  return;
                }
                if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                  return;
                }
              }
              if (ReactCurrentActQueue$1.current === null) {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error2("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          function warnIfSuspenseResolutionNotWrappedWithActDEV(root2) {
            {
              if (root2.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
                error2("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
              }
            }
          }
          function setIsRunningInsertionEffect(isRunning) {
            {
              isRunningInsertionEffect = isRunning;
            }
          }
          var resolveFamily = null;
          var failedBoundaries = null;
          var setRefreshHandler = function(handler) {
            {
              resolveFamily = handler;
            }
          };
          function resolveFunctionForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                return type;
              }
              return family.current;
            }
          }
          function resolveClassForHotReloading(type) {
            return resolveFunctionForHotReloading(type);
          }
          function resolveForwardRefForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                if (type !== null && type !== void 0 && typeof type.render === "function") {
                  var currentRender = resolveFunctionForHotReloading(type.render);
                  if (type.render !== currentRender) {
                    var syntheticType = {
                      $$typeof: REACT_FORWARD_REF_TYPE,
                      render: currentRender
                    };
                    if (type.displayName !== void 0) {
                      syntheticType.displayName = type.displayName;
                    }
                    return syntheticType;
                  }
                }
                return type;
              }
              return family.current;
            }
          }
          function isCompatibleFamilyForHotReloading(fiber, element) {
            {
              if (resolveFamily === null) {
                return false;
              }
              var prevType = fiber.elementType;
              var nextType = element.type;
              var needsCompareFamilies = false;
              var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
              switch (fiber.tag) {
                case ClassComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case FunctionComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case ForwardRef: {
                  if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case MemoComponent:
                case SimpleMemoComponent: {
                  if ($$typeofNextType === REACT_MEMO_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                default:
                  return false;
              }
              if (needsCompareFamilies) {
                var prevFamily = resolveFamily(prevType);
                if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                  return true;
                }
              }
              return false;
            }
          }
          function markFailedErrorBoundaryForHotReloading(fiber) {
            {
              if (resolveFamily === null) {
                return;
              }
              if (typeof WeakSet !== "function") {
                return;
              }
              if (failedBoundaries === null) {
                failedBoundaries = /* @__PURE__ */ new WeakSet();
              }
              failedBoundaries.add(fiber);
            }
          }
          var scheduleRefresh = function(root2, update) {
            {
              if (resolveFamily === null) {
                return;
              }
              var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
              flushPassiveEffects();
              flushSync(function() {
                scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
              });
            }
          };
          var scheduleRoot = function(root2, element) {
            {
              if (root2.context !== emptyContextObject) {
                return;
              }
              flushPassiveEffects();
              flushSync(function() {
                updateContainer(element, root2, null, null);
              });
            }
          };
          function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
            {
              var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              if (resolveFamily === null) {
                throw new Error("Expected resolveFamily to be set during hot reload.");
              }
              var needsRender = false;
              var needsRemount = false;
              if (candidateType !== null) {
                var family = resolveFamily(candidateType);
                if (family !== void 0) {
                  if (staleFamilies.has(family)) {
                    needsRemount = true;
                  } else if (updatedFamilies.has(family)) {
                    if (tag === ClassComponent) {
                      needsRemount = true;
                    } else {
                      needsRender = true;
                    }
                  }
                }
              }
              if (failedBoundaries !== null) {
                if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                  needsRemount = true;
                }
              }
              if (needsRemount) {
                fiber._debugNeedsRemount = true;
              }
              if (needsRemount || needsRender) {
                var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (_root !== null) {
                  scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
                }
              }
              if (child !== null && !needsRemount) {
                scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
              }
              if (sibling !== null) {
                scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
              }
            }
          }
          var findHostInstancesForRefresh = function(root2, families) {
            {
              var hostInstances = /* @__PURE__ */ new Set();
              var types4 = new Set(families.map(function(family) {
                return family.current;
              }));
              findHostInstancesForMatchingFibersRecursively(root2.current, types4, hostInstances);
              return hostInstances;
            }
          };
          function findHostInstancesForMatchingFibersRecursively(fiber, types4, hostInstances) {
            {
              var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              var didMatch = false;
              if (candidateType !== null) {
                if (types4.has(candidateType)) {
                  didMatch = true;
                }
              }
              if (didMatch) {
                findHostInstancesForFiberShallowly(fiber, hostInstances);
              } else {
                if (child !== null) {
                  findHostInstancesForMatchingFibersRecursively(child, types4, hostInstances);
                }
              }
              if (sibling !== null) {
                findHostInstancesForMatchingFibersRecursively(sibling, types4, hostInstances);
              }
            }
          }
          function findHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
              if (foundHostInstances) {
                return;
              }
              var node = fiber;
              while (true) {
                switch (node.tag) {
                  case HostComponent:
                    hostInstances.add(node.stateNode);
                    return;
                  case HostPortal:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                  case HostRoot:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                }
                if (node.return === null) {
                  throw new Error("Expected to reach root first.");
                }
                node = node.return;
              }
            }
          }
          function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var node = fiber;
              var foundHostInstances = false;
              while (true) {
                if (node.tag === HostComponent) {
                  foundHostInstances = true;
                  hostInstances.add(node.stateNode);
                } else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === fiber) {
                  return foundHostInstances;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === fiber) {
                    return foundHostInstances;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
            return false;
          }
          var hasBadMapPolyfill;
          {
            hasBadMapPolyfill = false;
            try {
              var nonExtensibleObject = Object.preventExtensions({});
              /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
              /* @__PURE__ */ new Set([nonExtensibleObject]);
            } catch (e) {
              hasBadMapPolyfill = true;
            }
          }
          function FiberNode(tag, pendingProps, key, mode) {
            this.tag = tag;
            this.key = key;
            this.elementType = null;
            this.type = null;
            this.stateNode = null;
            this.return = null;
            this.child = null;
            this.sibling = null;
            this.index = 0;
            this.ref = null;
            this.pendingProps = pendingProps;
            this.memoizedProps = null;
            this.updateQueue = null;
            this.memoizedState = null;
            this.dependencies = null;
            this.mode = mode;
            this.flags = NoFlags;
            this.subtreeFlags = NoFlags;
            this.deletions = null;
            this.lanes = NoLanes;
            this.childLanes = NoLanes;
            this.alternate = null;
            {
              this.actualDuration = Number.NaN;
              this.actualStartTime = Number.NaN;
              this.selfBaseDuration = Number.NaN;
              this.treeBaseDuration = Number.NaN;
              this.actualDuration = 0;
              this.actualStartTime = -1;
              this.selfBaseDuration = 0;
              this.treeBaseDuration = 0;
            }
            {
              this._debugSource = null;
              this._debugOwner = null;
              this._debugNeedsRemount = false;
              this._debugHookTypes = null;
              if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
                Object.preventExtensions(this);
              }
            }
          }
          var createFiber = function(tag, pendingProps, key, mode) {
            return new FiberNode(tag, pendingProps, key, mode);
          };
          function shouldConstruct$1(Component9) {
            var prototype = Component9.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function isSimpleFunctionComponent(type) {
            return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
          }
          function resolveLazyComponentTag(Component9) {
            if (typeof Component9 === "function") {
              return shouldConstruct$1(Component9) ? ClassComponent : FunctionComponent;
            } else if (Component9 !== void 0 && Component9 !== null) {
              var $$typeof = Component9.$$typeof;
              if ($$typeof === REACT_FORWARD_REF_TYPE) {
                return ForwardRef;
              }
              if ($$typeof === REACT_MEMO_TYPE) {
                return MemoComponent;
              }
            }
            return IndeterminateComponent;
          }
          function createWorkInProgress(current2, pendingProps) {
            var workInProgress2 = current2.alternate;
            if (workInProgress2 === null) {
              workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
              workInProgress2.elementType = current2.elementType;
              workInProgress2.type = current2.type;
              workInProgress2.stateNode = current2.stateNode;
              {
                workInProgress2._debugSource = current2._debugSource;
                workInProgress2._debugOwner = current2._debugOwner;
                workInProgress2._debugHookTypes = current2._debugHookTypes;
              }
              workInProgress2.alternate = current2;
              current2.alternate = workInProgress2;
            } else {
              workInProgress2.pendingProps = pendingProps;
              workInProgress2.type = current2.type;
              workInProgress2.flags = NoFlags;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              {
                workInProgress2.actualDuration = 0;
                workInProgress2.actualStartTime = -1;
              }
            }
            workInProgress2.flags = current2.flags & StaticMask;
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            workInProgress2.sibling = current2.sibling;
            workInProgress2.index = current2.index;
            workInProgress2.ref = current2.ref;
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
            {
              workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
              switch (workInProgress2.tag) {
                case IndeterminateComponent:
                case FunctionComponent:
                case SimpleMemoComponent:
                  workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                  break;
                case ClassComponent:
                  workInProgress2.type = resolveClassForHotReloading(current2.type);
                  break;
                case ForwardRef:
                  workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                  break;
              }
            }
            return workInProgress2;
          }
          function resetWorkInProgress(workInProgress2, renderLanes2) {
            workInProgress2.flags &= StaticMask | Placement;
            var current2 = workInProgress2.alternate;
            if (current2 === null) {
              workInProgress2.childLanes = NoLanes;
              workInProgress2.lanes = renderLanes2;
              workInProgress2.child = null;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.memoizedProps = null;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              workInProgress2.dependencies = null;
              workInProgress2.stateNode = null;
              {
                workInProgress2.selfBaseDuration = 0;
                workInProgress2.treeBaseDuration = 0;
              }
            } else {
              workInProgress2.childLanes = current2.childLanes;
              workInProgress2.lanes = current2.lanes;
              workInProgress2.child = current2.child;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              workInProgress2.memoizedProps = current2.memoizedProps;
              workInProgress2.memoizedState = current2.memoizedState;
              workInProgress2.updateQueue = current2.updateQueue;
              workInProgress2.type = current2.type;
              var currentDependencies = current2.dependencies;
              workInProgress2.dependencies = currentDependencies === null ? null : {
                lanes: currentDependencies.lanes,
                firstContext: currentDependencies.firstContext
              };
              {
                workInProgress2.selfBaseDuration = current2.selfBaseDuration;
                workInProgress2.treeBaseDuration = current2.treeBaseDuration;
              }
            }
            return workInProgress2;
          }
          function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
            var mode;
            if (tag === ConcurrentRoot) {
              mode = ConcurrentMode;
              if (isStrictMode === true) {
                mode |= StrictLegacyMode;
                {
                  mode |= StrictEffectsMode;
                }
              }
            } else {
              mode = NoMode;
            }
            if (isDevToolsPresent) {
              mode |= ProfileMode;
            }
            return createFiber(HostRoot, null, null, mode);
          }
          function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
            var fiberTag = IndeterminateComponent;
            var resolvedType = type;
            if (typeof type === "function") {
              if (shouldConstruct$1(type)) {
                fiberTag = ClassComponent;
                {
                  resolvedType = resolveClassForHotReloading(resolvedType);
                }
              } else {
                {
                  resolvedType = resolveFunctionForHotReloading(resolvedType);
                }
              }
            } else if (typeof type === "string") {
              fiberTag = HostComponent;
            } else {
              getTag:
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                    return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                  case REACT_STRICT_MODE_TYPE:
                    fiberTag = Mode;
                    mode |= StrictLegacyMode;
                    if ((mode & ConcurrentMode) !== NoMode) {
                      mode |= StrictEffectsMode;
                    }
                    break;
                  case REACT_PROFILER_TYPE:
                    return createFiberFromProfiler(pendingProps, mode, lanes, key);
                  case REACT_SUSPENSE_TYPE:
                    return createFiberFromSuspense(pendingProps, mode, lanes, key);
                  case REACT_SUSPENSE_LIST_TYPE:
                    return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
                  case REACT_OFFSCREEN_TYPE:
                    return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                  case REACT_LEGACY_HIDDEN_TYPE:
                  case REACT_SCOPE_TYPE:
                  case REACT_CACHE_TYPE:
                  case REACT_TRACING_MARKER_TYPE:
                  case REACT_DEBUG_TRACING_MODE_TYPE:
                  default: {
                    if (typeof type === "object" && type !== null) {
                      switch (type.$$typeof) {
                        case REACT_PROVIDER_TYPE:
                          fiberTag = ContextProvider;
                          break getTag;
                        case REACT_CONTEXT_TYPE:
                          fiberTag = ContextConsumer;
                          break getTag;
                        case REACT_FORWARD_REF_TYPE:
                          fiberTag = ForwardRef;
                          {
                            resolvedType = resolveForwardRefForHotReloading(resolvedType);
                          }
                          break getTag;
                        case REACT_MEMO_TYPE:
                          fiberTag = MemoComponent;
                          break getTag;
                        case REACT_LAZY_TYPE:
                          fiberTag = LazyComponent;
                          resolvedType = null;
                          break getTag;
                      }
                    }
                    var info = "";
                    {
                      if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                        info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                      }
                      var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                      if (ownerName) {
                        info += "\n\nCheck the render method of `" + ownerName + "`.";
                      }
                    }
                    throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
                  }
                }
            }
            var fiber = createFiber(fiberTag, pendingProps, key, mode);
            fiber.elementType = type;
            fiber.type = resolvedType;
            fiber.lanes = lanes;
            {
              fiber._debugOwner = owner;
            }
            return fiber;
          }
          function createFiberFromElement(element, mode, lanes) {
            var owner = null;
            {
              owner = element._owner;
            }
            var type = element.type;
            var key = element.key;
            var pendingProps = element.props;
            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
            {
              fiber._debugSource = element._source;
              fiber._debugOwner = element._owner;
            }
            return fiber;
          }
          function createFiberFromFragment(elements, mode, lanes, key) {
            var fiber = createFiber(Fragment2, elements, key, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromProfiler(pendingProps, mode, lanes, key) {
            {
              if (typeof pendingProps.id !== "string") {
                error2('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
              }
            }
            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
            fiber.elementType = REACT_PROFILER_TYPE;
            fiber.lanes = lanes;
            {
              fiber.stateNode = {
                effectDuration: 0,
                passiveEffectDuration: 0
              };
            }
            return fiber;
          }
          function createFiberFromSuspense(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
            fiber.elementType = REACT_SUSPENSE_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
            fiber.elementType = REACT_OFFSCREEN_TYPE;
            fiber.lanes = lanes;
            var primaryChildInstance = {
              isHidden: false
            };
            fiber.stateNode = primaryChildInstance;
            return fiber;
          }
          function createFiberFromText(content, mode, lanes) {
            var fiber = createFiber(HostText, content, null, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromHostInstanceForDeletion() {
            var fiber = createFiber(HostComponent, null, null, NoMode);
            fiber.elementType = "DELETED";
            return fiber;
          }
          function createFiberFromDehydratedFragment(dehydratedNode) {
            var fiber = createFiber(DehydratedFragment, null, null, NoMode);
            fiber.stateNode = dehydratedNode;
            return fiber;
          }
          function createFiberFromPortal(portal, mode, lanes) {
            var pendingProps = portal.children !== null ? portal.children : [];
            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
            fiber.lanes = lanes;
            fiber.stateNode = {
              containerInfo: portal.containerInfo,
              pendingChildren: null,
              // Used by persistent updates
              implementation: portal.implementation
            };
            return fiber;
          }
          function assignFiberPropertiesInDEV(target, source) {
            if (target === null) {
              target = createFiber(IndeterminateComponent, null, null, NoMode);
            }
            target.tag = source.tag;
            target.key = source.key;
            target.elementType = source.elementType;
            target.type = source.type;
            target.stateNode = source.stateNode;
            target.return = source.return;
            target.child = source.child;
            target.sibling = source.sibling;
            target.index = source.index;
            target.ref = source.ref;
            target.pendingProps = source.pendingProps;
            target.memoizedProps = source.memoizedProps;
            target.updateQueue = source.updateQueue;
            target.memoizedState = source.memoizedState;
            target.dependencies = source.dependencies;
            target.mode = source.mode;
            target.flags = source.flags;
            target.subtreeFlags = source.subtreeFlags;
            target.deletions = source.deletions;
            target.lanes = source.lanes;
            target.childLanes = source.childLanes;
            target.alternate = source.alternate;
            {
              target.actualDuration = source.actualDuration;
              target.actualStartTime = source.actualStartTime;
              target.selfBaseDuration = source.selfBaseDuration;
              target.treeBaseDuration = source.treeBaseDuration;
            }
            target._debugSource = source._debugSource;
            target._debugOwner = source._debugOwner;
            target._debugNeedsRemount = source._debugNeedsRemount;
            target._debugHookTypes = source._debugHookTypes;
            return target;
          }
          function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
            this.tag = tag;
            this.containerInfo = containerInfo;
            this.pendingChildren = null;
            this.current = null;
            this.pingCache = null;
            this.finishedWork = null;
            this.timeoutHandle = noTimeout;
            this.context = null;
            this.pendingContext = null;
            this.callbackNode = null;
            this.callbackPriority = NoLane;
            this.eventTimes = createLaneMap(NoLanes);
            this.expirationTimes = createLaneMap(NoTimestamp);
            this.pendingLanes = NoLanes;
            this.suspendedLanes = NoLanes;
            this.pingedLanes = NoLanes;
            this.expiredLanes = NoLanes;
            this.mutableReadLanes = NoLanes;
            this.finishedLanes = NoLanes;
            this.entangledLanes = NoLanes;
            this.entanglements = createLaneMap(NoLanes);
            this.identifierPrefix = identifierPrefix;
            this.onRecoverableError = onRecoverableError;
            {
              this.mutableSourceEagerHydrationData = null;
            }
            {
              this.effectDuration = 0;
              this.passiveEffectDuration = 0;
            }
            {
              this.memoizedUpdaters = /* @__PURE__ */ new Set();
              var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
              for (var _i = 0; _i < TotalLanes; _i++) {
                pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
              }
            }
            {
              switch (tag) {
                case ConcurrentRoot:
                  this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
                  break;
                case LegacyRoot:
                  this._debugRootType = hydrate2 ? "hydrate()" : "render()";
                  break;
              }
            }
          }
          function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var root2 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
            var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
            root2.current = uninitializedFiber;
            uninitializedFiber.stateNode = root2;
            {
              var _initialState = {
                element: initialChildren,
                isDehydrated: hydrate2,
                cache: null,
                // not enabled yet
                transitions: null,
                pendingSuspenseBoundaries: null
              };
              uninitializedFiber.memoizedState = _initialState;
            }
            initializeUpdateQueue(uninitializedFiber);
            return root2;
          }
          var ReactVersion = "18.2.0";
          function createPortal3(children, containerInfo, implementation) {
            var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            {
              checkKeyStringCoercion(key);
            }
            return {
              // This tag allow us to uniquely identify this as a React Portal
              $$typeof: REACT_PORTAL_TYPE,
              key: key == null ? null : "" + key,
              children,
              containerInfo,
              implementation
            };
          }
          var didWarnAboutNestedUpdates;
          var didWarnAboutFindNodeInStrictMode;
          {
            didWarnAboutNestedUpdates = false;
            didWarnAboutFindNodeInStrictMode = {};
          }
          function getContextForSubtree(parentComponent) {
            if (!parentComponent) {
              return emptyContextObject;
            }
            var fiber = get2(parentComponent);
            var parentContext = findCurrentUnmaskedContext(fiber);
            if (fiber.tag === ClassComponent) {
              var Component9 = fiber.type;
              if (isContextProvider(Component9)) {
                return processChildContext(fiber, Component9, parentContext);
              }
            }
            return parentContext;
          }
          function findHostInstanceWithWarning(component, methodName) {
            {
              var fiber = get2(component);
              if (fiber === void 0) {
                if (typeof component.render === "function") {
                  throw new Error("Unable to find node on an unmounted component.");
                } else {
                  var keys5 = Object.keys(component).join(",");
                  throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys5);
                }
              }
              var hostFiber = findCurrentHostFiber(fiber);
              if (hostFiber === null) {
                return null;
              }
              if (hostFiber.mode & StrictLegacyMode) {
                var componentName = getComponentNameFromFiber(fiber) || "Component";
                if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                  didWarnAboutFindNodeInStrictMode[componentName] = true;
                  var previousFiber = current;
                  try {
                    setCurrentFiber(hostFiber);
                    if (fiber.mode & StrictLegacyMode) {
                      error2("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    } else {
                      error2("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    }
                  } finally {
                    if (previousFiber) {
                      setCurrentFiber(previousFiber);
                    } else {
                      resetCurrentFiber();
                    }
                  }
                }
              }
              return hostFiber.stateNode;
            }
          }
          function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate2 = false;
            var initialChildren = null;
            return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          }
          function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate2 = true;
            var root2 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            root2.context = getContextForSubtree(null);
            var current2 = root2.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current2);
            var update = createUpdate(eventTime, lane);
            update.callback = callback !== void 0 && callback !== null ? callback : null;
            enqueueUpdate(current2, update, lane);
            scheduleInitialHydrationOnRoot(root2, lane, eventTime);
            return root2;
          }
          function updateContainer(element, container, parentComponent, callback) {
            {
              onScheduleRoot(container, element);
            }
            var current$1 = container.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current$1);
            {
              markRenderScheduled(lane);
            }
            var context = getContextForSubtree(parentComponent);
            if (container.context === null) {
              container.context = context;
            } else {
              container.pendingContext = context;
            }
            {
              if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
                didWarnAboutNestedUpdates = true;
                error2("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
              }
            }
            var update = createUpdate(eventTime, lane);
            update.payload = {
              element
            };
            callback = callback === void 0 ? null : callback;
            if (callback !== null) {
              {
                if (typeof callback !== "function") {
                  error2("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
                }
              }
              update.callback = callback;
            }
            var root2 = enqueueUpdate(current$1, update, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, current$1, lane, eventTime);
              entangleTransitions(root2, current$1, lane);
            }
            return lane;
          }
          function getPublicRootInstance(container) {
            var containerFiber = container.current;
            if (!containerFiber.child) {
              return null;
            }
            switch (containerFiber.child.tag) {
              case HostComponent:
                return getPublicInstance(containerFiber.child.stateNode);
              default:
                return containerFiber.child.stateNode;
            }
          }
          function attemptSynchronousHydration$1(fiber) {
            switch (fiber.tag) {
              case HostRoot: {
                var root2 = fiber.stateNode;
                if (isRootDehydrated(root2)) {
                  var lanes = getHighestPriorityPendingLanes(root2);
                  flushRoot(root2, lanes);
                }
                break;
              }
              case SuspenseComponent: {
                flushSync(function() {
                  var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                  if (root3 !== null) {
                    var eventTime = requestEventTime();
                    scheduleUpdateOnFiber(root3, fiber, SyncLane, eventTime);
                  }
                });
                var retryLane = SyncLane;
                markRetryLaneIfNotHydrated(fiber, retryLane);
                break;
              }
            }
          }
          function markRetryLaneImpl(fiber, retryLane) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
            }
          }
          function markRetryLaneIfNotHydrated(fiber, retryLane) {
            markRetryLaneImpl(fiber, retryLane);
            var alternate = fiber.alternate;
            if (alternate) {
              markRetryLaneImpl(alternate, retryLane);
            }
          }
          function attemptContinuousHydration$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = SelectiveHydrationLane;
            var root2 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function attemptHydrationAtCurrentPriority$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = requestUpdateLane(fiber);
            var root2 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function findHostInstanceWithNoPortals(fiber) {
            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          var shouldErrorImpl = function(fiber) {
            return null;
          };
          function shouldError(fiber) {
            return shouldErrorImpl(fiber);
          }
          var shouldSuspendImpl = function(fiber) {
            return false;
          };
          function shouldSuspend(fiber) {
            return shouldSuspendImpl(fiber);
          }
          var overrideHookState = null;
          var overrideHookStateDeletePath = null;
          var overrideHookStateRenamePath = null;
          var overrideProps = null;
          var overridePropsDeletePath = null;
          var overridePropsRenamePath = null;
          var scheduleUpdate = null;
          var setErrorHandler = null;
          var setSuspenseHandler = null;
          {
            var copyWithDeleteImpl = function(obj, path, index2) {
              var key = path[index2];
              var updated = isArray(obj) ? obj.slice() : assign({}, obj);
              if (index2 + 1 === path.length) {
                if (isArray(updated)) {
                  updated.splice(key, 1);
                } else {
                  delete updated[key];
                }
                return updated;
              }
              updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);
              return updated;
            };
            var copyWithDelete = function(obj, path) {
              return copyWithDeleteImpl(obj, path, 0);
            };
            var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
              var oldKey = oldPath[index2];
              var updated = isArray(obj) ? obj.slice() : assign({}, obj);
              if (index2 + 1 === oldPath.length) {
                var newKey = newPath[index2];
                updated[newKey] = updated[oldKey];
                if (isArray(updated)) {
                  updated.splice(oldKey, 1);
                } else {
                  delete updated[oldKey];
                }
              } else {
                updated[oldKey] = copyWithRenameImpl(
                  // $FlowFixMe number or string is fine here
                  obj[oldKey],
                  oldPath,
                  newPath,
                  index2 + 1
                );
              }
              return updated;
            };
            var copyWithRename = function(obj, oldPath, newPath) {
              if (oldPath.length !== newPath.length) {
                warn("copyWithRename() expects paths of the same length");
                return;
              } else {
                for (var i = 0; i < newPath.length - 1; i++) {
                  if (oldPath[i] !== newPath[i]) {
                    warn("copyWithRename() expects paths to be the same except for the deepest key");
                    return;
                  }
                }
              }
              return copyWithRenameImpl(obj, oldPath, newPath, 0);
            };
            var copyWithSetImpl = function(obj, path, index2, value) {
              if (index2 >= path.length) {
                return value;
              }
              var key = path[index2];
              var updated = isArray(obj) ? obj.slice() : assign({}, obj);
              updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value);
              return updated;
            };
            var copyWithSet = function(obj, path, value) {
              return copyWithSetImpl(obj, path, 0, value);
            };
            var findHook = function(fiber, id) {
              var currentHook2 = fiber.memoizedState;
              while (currentHook2 !== null && id > 0) {
                currentHook2 = currentHook2.next;
                id--;
              }
              return currentHook2;
            };
            overrideHookState = function(fiber, id, path, value) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithSet(hook.memoizedState, path, value);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign({}, fiber.memoizedProps);
                var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root2 !== null) {
                  scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateDeletePath = function(fiber, id, path) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithDelete(hook.memoizedState, path);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign({}, fiber.memoizedProps);
                var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root2 !== null) {
                  scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign({}, fiber.memoizedProps);
                var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root2 !== null) {
                  scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideProps = function(fiber, path, value) {
              fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsDeletePath = function(fiber, path) {
              fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsRenamePath = function(fiber, oldPath, newPath) {
              fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            scheduleUpdate = function(fiber) {
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            setErrorHandler = function(newShouldErrorImpl) {
              shouldErrorImpl = newShouldErrorImpl;
            };
            setSuspenseHandler = function(newShouldSuspendImpl) {
              shouldSuspendImpl = newShouldSuspendImpl;
            };
          }
          function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          function emptyFindFiberByHostInstance(instance) {
            return null;
          }
          function getCurrentFiberForDevTools() {
            return current;
          }
          function injectIntoDevTools(devToolsConfig) {
            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
            var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
            return injectInternals({
              bundleType: devToolsConfig.bundleType,
              version: devToolsConfig.version,
              rendererPackageName: devToolsConfig.rendererPackageName,
              rendererConfig: devToolsConfig.rendererConfig,
              overrideHookState,
              overrideHookStateDeletePath,
              overrideHookStateRenamePath,
              overrideProps,
              overridePropsDeletePath,
              overridePropsRenamePath,
              setErrorHandler,
              setSuspenseHandler,
              scheduleUpdate,
              currentDispatcherRef: ReactCurrentDispatcher2,
              findHostInstanceByFiber,
              findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
              // React Refresh
              findHostInstancesForRefresh,
              scheduleRefresh,
              scheduleRoot,
              setRefreshHandler,
              // Enables DevTools to append owner stacks to error messages in DEV mode.
              getCurrentFiber: getCurrentFiberForDevTools,
              // Enables DevTools to detect reconciler version rather than renderer version
              // which may not match for third party renderers.
              reconcilerVersion: ReactVersion
            });
          }
          var defaultOnRecoverableError = typeof reportError === "function" ? (
            // In modern browsers, reportError will dispatch an error event,
            // emulating an uncaught JavaScript error.
            reportError
          ) : function(error3) {
            console["error"](error3);
          };
          function ReactDOMRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
            var root2 = this._internalRoot;
            if (root2 === null) {
              throw new Error("Cannot update an unmounted root.");
            }
            {
              if (typeof arguments[1] === "function") {
                error2("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              } else if (isValidContainer(arguments[1])) {
                error2("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
              } else if (typeof arguments[1] !== "undefined") {
                error2("You passed a second argument to root.render(...) but it only accepts one argument.");
              }
              var container = root2.containerInfo;
              if (container.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(root2.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container) {
                    error2("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                  }
                }
              }
            }
            updateContainer(children, root2, null, null);
          };
          ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
            {
              if (typeof arguments[0] === "function") {
                error2("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              }
            }
            var root2 = this._internalRoot;
            if (root2 !== null) {
              this._internalRoot = null;
              var container = root2.containerInfo;
              {
                if (isAlreadyRendering()) {
                  error2("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
                }
              }
              flushSync(function() {
                updateContainer(null, root2, null, null);
              });
              unmarkContainerAsRoot(container);
            }
          };
          function createRoot2(container, options3) {
            if (!isValidContainer(container)) {
              throw new Error("createRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container);
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            var transitionCallbacks = null;
            if (options3 !== null && options3 !== void 0) {
              {
                if (options3.hydrate) {
                  warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
                } else {
                  if (typeof options3 === "object" && options3 !== null && options3.$$typeof === REACT_ELEMENT_TYPE) {
                    error2("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
                  }
                }
              }
              if (options3.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options3.identifierPrefix !== void 0) {
                identifierPrefix = options3.identifierPrefix;
              }
              if (options3.onRecoverableError !== void 0) {
                onRecoverableError = options3.onRecoverableError;
              }
              if (options3.transitionCallbacks !== void 0) {
                transitionCallbacks = options3.transitionCallbacks;
              }
            }
            var root2 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root2.current, container);
            var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(rootContainerElement);
            return new ReactDOMRoot(root2);
          }
          function ReactDOMHydrationRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          function scheduleHydration(target) {
            if (target) {
              queueExplicitHydrationTarget(target);
            }
          }
          ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
          function hydrateRoot(container, initialChildren, options3) {
            if (!isValidContainer(container)) {
              throw new Error("hydrateRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container);
            {
              if (initialChildren === void 0) {
                error2("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
              }
            }
            var hydrationCallbacks = options3 != null ? options3 : null;
            var mutableSources = options3 != null && options3.hydratedSources || null;
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            if (options3 !== null && options3 !== void 0) {
              if (options3.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options3.identifierPrefix !== void 0) {
                identifierPrefix = options3.identifierPrefix;
              }
              if (options3.onRecoverableError !== void 0) {
                onRecoverableError = options3.onRecoverableError;
              }
            }
            var root2 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root2.current, container);
            listenToAllSupportedEvents(container);
            if (mutableSources) {
              for (var i = 0; i < mutableSources.length; i++) {
                var mutableSource = mutableSources[i];
                registerMutableSourceForHydration(root2, mutableSource);
              }
            }
            return new ReactDOMHydrationRoot(root2);
          }
          function isValidContainer(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
          }
          function isValidContainerLegacy(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
          }
          function warnIfReactDOMContainerInDEV(container) {
            {
              if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
                error2("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
              }
              if (isContainerMarkedAsRoot(container)) {
                if (container._reactRootContainer) {
                  error2("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
                } else {
                  error2("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
                }
              }
            }
          }
          var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
          var topLevelUpdateWarnings;
          {
            topLevelUpdateWarnings = function(container) {
              if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container) {
                    error2("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                  }
                }
              }
              var isRootRenderedBySomeReact = !!container._reactRootContainer;
              var rootEl = getReactRootElementInContainer(container);
              var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
              if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
                error2("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
              }
              if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
                error2("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
              }
            };
          }
          function getReactRootElementInContainer(container) {
            if (!container) {
              return null;
            }
            if (container.nodeType === DOCUMENT_NODE) {
              return container.documentElement;
            } else {
              return container.firstChild;
            }
          }
          function noopOnRecoverableError() {
          }
          function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {
            if (isHydrationContainer) {
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(root2);
                  originalCallback.call(instance);
                };
              }
              var root2 = createHydrationContainer(
                initialChildren,
                callback,
                container,
                LegacyRoot,
                null,
                // hydrationCallbacks
                false,
                // isStrictMode
                false,
                // concurrentUpdatesByDefaultOverride,
                "",
                // identifierPrefix
                noopOnRecoverableError
              );
              container._reactRootContainer = root2;
              markContainerAsRoot(root2.current, container);
              var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
              listenToAllSupportedEvents(rootContainerElement);
              flushSync();
              return root2;
            } else {
              var rootSibling;
              while (rootSibling = container.lastChild) {
                container.removeChild(rootSibling);
              }
              if (typeof callback === "function") {
                var _originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(_root);
                  _originalCallback.call(instance);
                };
              }
              var _root = createContainer(
                container,
                LegacyRoot,
                null,
                // hydrationCallbacks
                false,
                // isStrictMode
                false,
                // concurrentUpdatesByDefaultOverride,
                "",
                // identifierPrefix
                noopOnRecoverableError
              );
              container._reactRootContainer = _root;
              markContainerAsRoot(_root.current, container);
              var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
              listenToAllSupportedEvents(_rootContainerElement);
              flushSync(function() {
                updateContainer(initialChildren, _root, parentComponent, callback);
              });
              return _root;
            }
          }
          function warnOnInvalidCallback$1(callback, callerName) {
            {
              if (callback !== null && typeof callback !== "function") {
                error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            }
          }
          function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
            {
              topLevelUpdateWarnings(container);
              warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
            }
            var maybeRoot = container._reactRootContainer;
            var root2;
            if (!maybeRoot) {
              root2 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);
            } else {
              root2 = maybeRoot;
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(root2);
                  originalCallback.call(instance);
                };
              }
              updateContainer(children, root2, parentComponent, callback);
            }
            return getPublicRootInstance(root2);
          }
          function findDOMNode(componentOrElement) {
            {
              var owner = ReactCurrentOwner$3.current;
              if (owner !== null && owner.stateNode !== null) {
                var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
                if (!warnedAboutRefsInRender) {
                  error2("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
                }
                owner.stateNode._warnedAboutRefsInRender = true;
              }
            }
            if (componentOrElement == null) {
              return null;
            }
            if (componentOrElement.nodeType === ELEMENT_NODE) {
              return componentOrElement;
            }
            {
              return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
            }
          }
          function hydrate(element, container, callback) {
            {
              error2("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error2("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
          }
          function render(element, container, callback) {
            {
              error2("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error2("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
          }
          function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            {
              error2("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(containerNode)) {
              throw new Error("Target container is not a DOM element.");
            }
            if (parentComponent == null || !has(parentComponent)) {
              throw new Error("parentComponent must be a valid React Component");
            }
            return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
          }
          function unmountComponentAtNode(container) {
            if (!isValidContainerLegacy(container)) {
              throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error2("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
              }
            }
            if (container._reactRootContainer) {
              {
                var rootEl = getReactRootElementInContainer(container);
                var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
                if (renderedByDifferentReact) {
                  error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
                }
              }
              flushSync(function() {
                legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
                  container._reactRootContainer = null;
                  unmarkContainerAsRoot(container);
                });
              });
              return true;
            } else {
              {
                var _rootEl = getReactRootElementInContainer(container);
                var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
                var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;
                if (hasNonRootReactChild) {
                  error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
                }
              }
              return false;
            }
          }
          setAttemptSynchronousHydration(attemptSynchronousHydration$1);
          setAttemptContinuousHydration(attemptContinuousHydration$1);
          setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
          setGetCurrentUpdatePriority(getCurrentUpdatePriority);
          setAttemptHydrationAtPriority(runWithPriority);
          {
            if (typeof Map !== "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
            Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
            Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
              error2("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            }
          }
          setRestoreImplementation(restoreControlledState$3);
          setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
          function createPortal$1(children, container) {
            var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (!isValidContainer(container)) {
              throw new Error("Target container is not a DOM element.");
            }
            return createPortal3(children, container, null, key);
          }
          function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
          }
          var Internals = {
            usingClientEntryPoint: false,
            // Keep in sync with ReactTestUtils.js.
            // This is an array for better minification.
            Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
          };
          function createRoot$1(container, options3) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error2('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return createRoot2(container, options3);
          }
          function hydrateRoot$1(container, initialChildren, options3) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error2('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return hydrateRoot(container, initialChildren, options3);
          }
          function flushSync$1(fn2) {
            {
              if (isAlreadyRendering()) {
                error2("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
              }
            }
            return flushSync(fn2);
          }
          var foundDevTools = injectIntoDevTools({
            findFiberByHostInstance: getClosestInstanceFromNode,
            bundleType: 1,
            version: ReactVersion,
            rendererPackageName: "react-dom"
          });
          {
            if (!foundDevTools && canUseDOM && window.top === window.self) {
              if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
                var protocol = window.location.protocol;
                if (/^(https?|file):$/.test(protocol)) {
                  console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
                }
              }
            }
          }
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
          exports.createPortal = createPortal$1;
          exports.createRoot = createRoot$1;
          exports.findDOMNode = findDOMNode;
          exports.flushSync = flushSync$1;
          exports.hydrate = hydrate;
          exports.hydrateRoot = hydrateRoot$1;
          exports.render = render;
          exports.unmountComponentAtNode = unmountComponentAtNode;
          exports.unstable_batchedUpdates = batchedUpdates$1;
          exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports) {
      "use strict";
      var m = require_react_dom();
      if (false) {
        exports.createRoot = m.createRoot;
        exports.hydrateRoot = m.hydrateRoot;
      } else {
        i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        exports.createRoot = function(c, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.createRoot(c, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
        exports.hydrateRoot = function(c, h, o) {
          i.usingClientEntryPoint = true;
          try {
            return m.hydrateRoot(c, h, o);
          } finally {
            i.usingClientEntryPoint = false;
          }
        };
      }
      var i;
    }
  });

  // node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development = __commonJS({
    "node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var hasSymbol = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
          var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
          function isValidElementType2(type) {
            return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }
          function typeOf2(object) {
            if (typeof object === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element2 = REACT_ELEMENT_TYPE;
          var ForwardRef = REACT_FORWARD_REF_TYPE;
          var Fragment2 = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
              }
            }
            return isConcurrentMode(object) || typeOf2(object) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object) {
            return typeOf2(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer2(object) {
            return typeOf2(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf2(object) === REACT_PROVIDER_TYPE;
          }
          function isElement3(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf2(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf2(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf2(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf2(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf2(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf2(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf2(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf2(object) === REACT_SUSPENSE_TYPE;
          }
          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element2;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment2;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer2;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement3;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType2;
          exports.typeOf = typeOf2;
        })();
      }
    }
  });

  // node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "node_modules/react-is/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_is_development();
      }
    }
  });

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports, module) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);
          for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // node_modules/prop-types/lib/ReactPropTypesSecret.js
  var require_ReactPropTypesSecret = __commonJS({
    "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
      "use strict";
      var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      module.exports = ReactPropTypesSecret;
    }
  });

  // node_modules/prop-types/lib/has.js
  var require_has = __commonJS({
    "node_modules/prop-types/lib/has.js"(exports, module) {
      module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/prop-types/checkPropTypes.js
  var require_checkPropTypes = __commonJS({
    "node_modules/prop-types/checkPropTypes.js"(exports, module) {
      "use strict";
      var printWarning = function() {
      };
      if (true) {
        ReactPropTypesSecret = require_ReactPropTypesSecret();
        loggedTypeFailures = {};
        has = require_has();
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {
          }
        };
      }
      var ReactPropTypesSecret;
      var loggedTypeFailures;
      var has;
      function checkPropTypes(typeSpecs, values, location2, componentName, getStack) {
        if (true) {
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error2;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error(
                    (componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                  );
                  err.name = "Invariant Violation";
                  throw err;
                }
                error2 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, ReactPropTypesSecret);
              } catch (ex) {
                error2 = ex;
              }
              if (error2 && !(error2 instanceof Error)) {
                printWarning(
                  (componentName || "React class") + ": type specification of " + location2 + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error2 + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
                );
              }
              if (error2 instanceof Error && !(error2.message in loggedTypeFailures)) {
                loggedTypeFailures[error2.message] = true;
                var stack = getStack ? getStack() : "";
                printWarning(
                  "Failed " + location2 + " type: " + error2.message + (stack != null ? stack : "")
                );
              }
            }
          }
        }
      }
      checkPropTypes.resetWarningCache = function() {
        if (true) {
          loggedTypeFailures = {};
        }
      };
      module.exports = checkPropTypes;
    }
  });

  // node_modules/prop-types/factoryWithTypeCheckers.js
  var require_factoryWithTypeCheckers = __commonJS({
    "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
      "use strict";
      var ReactIs = require_react_is();
      var assign = require_object_assign();
      var ReactPropTypesSecret = require_ReactPropTypesSecret();
      var has = require_has();
      var checkPropTypes = require_checkPropTypes();
      var printWarning = function() {
      };
      if (true) {
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {
          }
        };
      }
      function emptyFunctionThatReturnsNull() {
        return null;
      }
      module.exports = function(isValidElement4, throwOnDirectAccess) {
        var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === "function") {
            return iteratorFn;
          }
        }
        var ANONYMOUS = "<<anonymous>>";
        var ReactPropTypes = {
          array: createPrimitiveTypeChecker("array"),
          bigint: createPrimitiveTypeChecker("bigint"),
          bool: createPrimitiveTypeChecker("boolean"),
          func: createPrimitiveTypeChecker("function"),
          number: createPrimitiveTypeChecker("number"),
          object: createPrimitiveTypeChecker("object"),
          string: createPrimitiveTypeChecker("string"),
          symbol: createPrimitiveTypeChecker("symbol"),
          any: createAnyTypeChecker(),
          arrayOf: createArrayOfTypeChecker,
          element: createElementTypeChecker(),
          elementType: createElementTypeTypeChecker(),
          instanceOf: createInstanceTypeChecker,
          node: createNodeChecker(),
          objectOf: createObjectOfTypeChecker,
          oneOf: createEnumTypeChecker,
          oneOfType: createUnionTypeChecker,
          shape: createShapeTypeChecker,
          exact: createStrictShapeTypeChecker
        };
        function is2(x, y) {
          if (x === y) {
            return x !== 0 || 1 / x === 1 / y;
          } else {
            return x !== x && y !== y;
          }
        }
        function PropTypeError(message, data) {
          this.message = message;
          this.data = data && typeof data === "object" ? data : {};
          this.stack = "";
        }
        PropTypeError.prototype = Error.prototype;
        function createChainableTypeChecker(validate3) {
          if (true) {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
          }
          function checkType(isRequired, props, propName, componentName, location2, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
              if (throwOnDirectAccess) {
                var err = new Error(
                  "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
                );
                err.name = "Invariant Violation";
                throw err;
              } else if (typeof console !== "undefined") {
                var cacheKey = componentName + ":" + propName;
                if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                manualPropTypeWarningCount < 3) {
                  printWarning(
                    "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                  );
                  manualPropTypeCallCache[cacheKey] = true;
                  manualPropTypeWarningCount++;
                }
              }
            }
            if (props[propName] == null) {
              if (isRequired) {
                if (props[propName] === null) {
                  return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                }
                return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
              }
              return null;
            } else {
              return validate3(props, propName, componentName, location2, propFullName);
            }
          }
          var chainedCheckType = checkType.bind(null, false);
          chainedCheckType.isRequired = checkType.bind(null, true);
          return chainedCheckType;
        }
        function createPrimitiveTypeChecker(expectedType) {
          function validate3(props, propName, componentName, location2, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
              var preciseType = getPreciseType(propValue);
              return new PropTypeError(
                "Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
                { expectedType }
              );
            }
            return null;
          }
          return createChainableTypeChecker(validate3);
        }
        function createAnyTypeChecker() {
          return createChainableTypeChecker(emptyFunctionThatReturnsNull);
        }
        function createArrayOfTypeChecker(typeChecker) {
          function validate3(props, propName, componentName, location2, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
            }
            for (var i = 0; i < propValue.length; i++) {
              var error2 = typeChecker(propValue, i, componentName, location2, propFullName + "[" + i + "]", ReactPropTypesSecret);
              if (error2 instanceof Error) {
                return error2;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate3);
        }
        function createElementTypeChecker() {
          function validate3(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            if (!isValidElement4(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
            }
            return null;
          }
          return createChainableTypeChecker(validate3);
        }
        function createElementTypeTypeChecker() {
          function validate3(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
            }
            return null;
          }
          return createChainableTypeChecker(validate3);
        }
        function createInstanceTypeChecker(expectedClass) {
          function validate3(props, propName, componentName, location2, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
              var expectedClassName = expectedClass.name || ANONYMOUS;
              var actualClassName = getClassName(props[propName]);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
            }
            return null;
          }
          return createChainableTypeChecker(validate3);
        }
        function createEnumTypeChecker(expectedValues) {
          if (!Array.isArray(expectedValues)) {
            if (true) {
              if (arguments.length > 1) {
                printWarning(
                  "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
                );
              } else {
                printWarning("Invalid argument supplied to oneOf, expected an array.");
              }
            }
            return emptyFunctionThatReturnsNull;
          }
          function validate3(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            for (var i = 0; i < expectedValues.length; i++) {
              if (is2(propValue, expectedValues[i])) {
                return null;
              }
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
              var type = getPreciseType(value);
              if (type === "symbol") {
                return String(value);
              }
              return value;
            });
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
          }
          return createChainableTypeChecker(validate3);
        }
        function createObjectOfTypeChecker(typeChecker) {
          function validate3(props, propName, componentName, location2, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
            }
            for (var key in propValue) {
              if (has(propValue, key)) {
                var error2 = typeChecker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
                if (error2 instanceof Error) {
                  return error2;
                }
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate3);
        }
        function createUnionTypeChecker(arrayOfTypeCheckers) {
          if (!Array.isArray(arrayOfTypeCheckers)) {
            true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
            return emptyFunctionThatReturnsNull;
          }
          for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== "function") {
              printWarning(
                "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
              );
              return emptyFunctionThatReturnsNull;
            }
          }
          function validate3(props, propName, componentName, location2, propFullName) {
            var expectedTypes = [];
            for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
              var checker2 = arrayOfTypeCheckers[i2];
              var checkerResult = checker2(props, propName, componentName, location2, propFullName, ReactPropTypesSecret);
              if (checkerResult == null) {
                return null;
              }
              if (checkerResult.data && has(checkerResult.data, "expectedType")) {
                expectedTypes.push(checkerResult.data.expectedType);
              }
            }
            var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
          }
          return createChainableTypeChecker(validate3);
        }
        function createNodeChecker() {
          function validate3(props, propName, componentName, location2, propFullName) {
            if (!isNode(props[propName])) {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
            }
            return null;
          }
          return createChainableTypeChecker(validate3);
        }
        function invalidValidatorError(componentName, location2, propFullName, key, type) {
          return new PropTypeError(
            (componentName || "React class") + ": " + location2 + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
          );
        }
        function createShapeTypeChecker(shapeTypes) {
          function validate3(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            for (var key in shapeTypes) {
              var checker = shapeTypes[key];
              if (typeof checker !== "function") {
                return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
              }
              var error2 = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
              if (error2) {
                return error2;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate3);
        }
        function createStrictShapeTypeChecker(shapeTypes) {
          function validate3(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            var allKeys = assign({}, props[propName], shapeTypes);
            for (var key in allKeys) {
              var checker = shapeTypes[key];
              if (has(shapeTypes, key) && typeof checker !== "function") {
                return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
              }
              if (!checker) {
                return new PropTypeError(
                  "Invalid " + location2 + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
                );
              }
              var error2 = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
              if (error2) {
                return error2;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate3);
        }
        function isNode(propValue) {
          switch (typeof propValue) {
            case "number":
            case "string":
            case "undefined":
              return true;
            case "boolean":
              return !propValue;
            case "object":
              if (Array.isArray(propValue)) {
                return propValue.every(isNode);
              }
              if (propValue === null || isValidElement4(propValue)) {
                return true;
              }
              var iteratorFn = getIteratorFn(propValue);
              if (iteratorFn) {
                var iterator = iteratorFn.call(propValue);
                var step;
                if (iteratorFn !== propValue.entries) {
                  while (!(step = iterator.next()).done) {
                    if (!isNode(step.value)) {
                      return false;
                    }
                  }
                } else {
                  while (!(step = iterator.next()).done) {
                    var entry = step.value;
                    if (entry) {
                      if (!isNode(entry[1])) {
                        return false;
                      }
                    }
                  }
                }
              } else {
                return false;
              }
              return true;
            default:
              return false;
          }
        }
        function isSymbol(propType, propValue) {
          if (propType === "symbol") {
            return true;
          }
          if (!propValue) {
            return false;
          }
          if (propValue["@@toStringTag"] === "Symbol") {
            return true;
          }
          if (typeof Symbol === "function" && propValue instanceof Symbol) {
            return true;
          }
          return false;
        }
        function getPropType(propValue) {
          var propType = typeof propValue;
          if (Array.isArray(propValue)) {
            return "array";
          }
          if (propValue instanceof RegExp) {
            return "object";
          }
          if (isSymbol(propType, propValue)) {
            return "symbol";
          }
          return propType;
        }
        function getPreciseType(propValue) {
          if (typeof propValue === "undefined" || propValue === null) {
            return "" + propValue;
          }
          var propType = getPropType(propValue);
          if (propType === "object") {
            if (propValue instanceof Date) {
              return "date";
            } else if (propValue instanceof RegExp) {
              return "regexp";
            }
          }
          return propType;
        }
        function getPostfixForTypeWarning(value) {
          var type = getPreciseType(value);
          switch (type) {
            case "array":
            case "object":
              return "an " + type;
            case "boolean":
            case "date":
            case "regexp":
              return "a " + type;
            default:
              return type;
          }
        }
        function getClassName(propValue) {
          if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
          }
          return propValue.constructor.name;
        }
        ReactPropTypes.checkPropTypes = checkPropTypes;
        ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
      };
    }
  });

  // node_modules/prop-types/index.js
  var require_prop_types = __commonJS({
    "node_modules/prop-types/index.js"(exports, module) {
      if (true) {
        ReactIs = require_react_is();
        throwOnDirectAccess = true;
        module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
      } else {
        module.exports = null();
      }
      var ReactIs;
      var throwOnDirectAccess;
    }
  });

  // node_modules/shallowequal/index.js
  var require_shallowequal = __commonJS({
    "node_modules/shallowequal/index.js"(exports, module) {
      module.exports = function shallowEqual5(objA, objB, compare, compareContext) {
        var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
        if (ret !== void 0) {
          return !!ret;
        }
        if (objA === objB) {
          return true;
        }
        if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
          return false;
        }
        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) {
          return false;
        }
        var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
        for (var idx = 0; idx < keysA.length; idx++) {
          var key = keysA[idx];
          if (!bHasOwnProperty(key)) {
            return false;
          }
          var valueA = objA[key];
          var valueB = objB[key];
          ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
          if (ret === false || ret === void 0 && valueA !== valueB) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/@emotion/stylis/dist/stylis.browser.cjs.js
  var require_stylis_browser_cjs = __commonJS({
    "node_modules/@emotion/stylis/dist/stylis.browser.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function stylis_min(W) {
        function M(d, c, e, h, a) {
          for (var m = 0, b = 0, v = 0, n = 0, q, g, x = 0, K = 0, k, u = k = q = 0, l = 0, r = 0, I = 0, t = 0, B2 = e.length, J = B2 - 1, y, f = "", p = "", F2 = "", G2 = "", C; l < B2; ) {
            g = e.charCodeAt(l);
            l === J && 0 !== b + n + v + m && (0 !== b && (g = 47 === b ? 10 : 47), n = v = m = 0, B2++, J++);
            if (0 === b + n + v + m) {
              if (l === J && (0 < r && (f = f.replace(N, "")), 0 < f.trim().length)) {
                switch (g) {
                  case 32:
                  case 9:
                  case 59:
                  case 13:
                  case 10:
                    break;
                  default:
                    f += e.charAt(l);
                }
                g = 59;
              }
              switch (g) {
                case 123:
                  f = f.trim();
                  q = f.charCodeAt(0);
                  k = 1;
                  for (t = ++l; l < B2; ) {
                    switch (g = e.charCodeAt(l)) {
                      case 123:
                        k++;
                        break;
                      case 125:
                        k--;
                        break;
                      case 47:
                        switch (g = e.charCodeAt(l + 1)) {
                          case 42:
                          case 47:
                            a: {
                              for (u = l + 1; u < J; ++u) {
                                switch (e.charCodeAt(u)) {
                                  case 47:
                                    if (42 === g && 42 === e.charCodeAt(u - 1) && l + 2 !== u) {
                                      l = u + 1;
                                      break a;
                                    }
                                    break;
                                  case 10:
                                    if (47 === g) {
                                      l = u + 1;
                                      break a;
                                    }
                                }
                              }
                              l = u;
                            }
                        }
                        break;
                      case 91:
                        g++;
                      case 40:
                        g++;
                      case 34:
                      case 39:
                        for (; l++ < J && e.charCodeAt(l) !== g; ) {
                        }
                    }
                    if (0 === k)
                      break;
                    l++;
                  }
                  k = e.substring(t, l);
                  0 === q && (q = (f = f.replace(ca, "").trim()).charCodeAt(0));
                  switch (q) {
                    case 64:
                      0 < r && (f = f.replace(N, ""));
                      g = f.charCodeAt(1);
                      switch (g) {
                        case 100:
                        case 109:
                        case 115:
                        case 45:
                          r = c;
                          break;
                        default:
                          r = O;
                      }
                      k = M(c, r, k, g, a + 1);
                      t = k.length;
                      0 < A && (r = X(O, f, I), C = H(3, k, r, c, D, z, t, g, a, h), f = r.join(""), void 0 !== C && 0 === (t = (k = C.trim()).length) && (g = 0, k = ""));
                      if (0 < t)
                        switch (g) {
                          case 115:
                            f = f.replace(da, ea);
                          case 100:
                          case 109:
                          case 45:
                            k = f + "{" + k + "}";
                            break;
                          case 107:
                            f = f.replace(fa, "$1 $2");
                            k = f + "{" + k + "}";
                            k = 1 === w || 2 === w && L("@" + k, 3) ? "@-webkit-" + k + "@" + k : "@" + k;
                            break;
                          default:
                            k = f + k, 112 === h && (k = (p += k, ""));
                        }
                      else
                        k = "";
                      break;
                    default:
                      k = M(c, X(c, f, I), k, h, a + 1);
                  }
                  F2 += k;
                  k = I = r = u = q = 0;
                  f = "";
                  g = e.charCodeAt(++l);
                  break;
                case 125:
                case 59:
                  f = (0 < r ? f.replace(N, "") : f).trim();
                  if (1 < (t = f.length))
                    switch (0 === u && (q = f.charCodeAt(0), 45 === q || 96 < q && 123 > q) && (t = (f = f.replace(" ", ":")).length), 0 < A && void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) && 0 === (t = (f = C.trim()).length) && (f = "\0\0"), q = f.charCodeAt(0), g = f.charCodeAt(1), q) {
                      case 0:
                        break;
                      case 64:
                        if (105 === g || 99 === g) {
                          G2 += f + e.charAt(l);
                          break;
                        }
                      default:
                        58 !== f.charCodeAt(t - 1) && (p += P(f, q, g, f.charCodeAt(2)));
                    }
                  I = r = u = q = 0;
                  f = "";
                  g = e.charCodeAt(++l);
              }
            }
            switch (g) {
              case 13:
              case 10:
                47 === b ? b = 0 : 0 === 1 + q && 107 !== h && 0 < f.length && (r = 1, f += "\0");
                0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);
                z = 1;
                D++;
                break;
              case 59:
              case 125:
                if (0 === b + n + v + m) {
                  z++;
                  break;
                }
              default:
                z++;
                y = e.charAt(l);
                switch (g) {
                  case 9:
                  case 32:
                    if (0 === n + m + b)
                      switch (x) {
                        case 44:
                        case 58:
                        case 9:
                        case 32:
                          y = "";
                          break;
                        default:
                          32 !== g && (y = " ");
                      }
                    break;
                  case 0:
                    y = "\\0";
                    break;
                  case 12:
                    y = "\\f";
                    break;
                  case 11:
                    y = "\\v";
                    break;
                  case 38:
                    0 === n + b + m && (r = I = 1, y = "\f" + y);
                    break;
                  case 108:
                    if (0 === n + b + m + E && 0 < u)
                      switch (l - u) {
                        case 2:
                          112 === x && 58 === e.charCodeAt(l - 3) && (E = x);
                        case 8:
                          111 === K && (E = K);
                      }
                    break;
                  case 58:
                    0 === n + b + m && (u = l);
                    break;
                  case 44:
                    0 === b + v + n + m && (r = 1, y += "\r");
                    break;
                  case 34:
                  case 39:
                    0 === b && (n = n === g ? 0 : 0 === n ? g : n);
                    break;
                  case 91:
                    0 === n + b + v && m++;
                    break;
                  case 93:
                    0 === n + b + v && m--;
                    break;
                  case 41:
                    0 === n + b + m && v--;
                    break;
                  case 40:
                    if (0 === n + b + m) {
                      if (0 === q)
                        switch (2 * x + 3 * K) {
                          case 533:
                            break;
                          default:
                            q = 1;
                        }
                      v++;
                    }
                    break;
                  case 64:
                    0 === b + v + n + m + u + k && (k = 1);
                    break;
                  case 42:
                  case 47:
                    if (!(0 < n + m + v))
                      switch (b) {
                        case 0:
                          switch (2 * g + 3 * e.charCodeAt(l + 1)) {
                            case 235:
                              b = 47;
                              break;
                            case 220:
                              t = l, b = 42;
                          }
                          break;
                        case 42:
                          47 === g && 42 === x && t + 2 !== l && (33 === e.charCodeAt(t + 2) && (p += e.substring(t, l + 1)), y = "", b = 0);
                      }
                }
                0 === b && (f += y);
            }
            K = x;
            x = g;
            l++;
          }
          t = p.length;
          if (0 < t) {
            r = c;
            if (0 < A && (C = H(2, p, r, d, D, z, t, h, a, h), void 0 !== C && 0 === (p = C).length))
              return G2 + p + F2;
            p = r.join(",") + "{" + p + "}";
            if (0 !== w * E) {
              2 !== w || L(p, 2) || (E = 0);
              switch (E) {
                case 111:
                  p = p.replace(ha, ":-moz-$1") + p;
                  break;
                case 112:
                  p = p.replace(Q, "::-webkit-input-$1") + p.replace(Q, "::-moz-$1") + p.replace(Q, ":-ms-input-$1") + p;
              }
              E = 0;
            }
          }
          return G2 + p + F2;
        }
        function X(d, c, e) {
          var h = c.trim().split(ia);
          c = h;
          var a = h.length, m = d.length;
          switch (m) {
            case 0:
            case 1:
              var b = 0;
              for (d = 0 === m ? "" : d[0] + " "; b < a; ++b) {
                c[b] = Z(d, c[b], e).trim();
              }
              break;
            default:
              var v = b = 0;
              for (c = []; b < a; ++b) {
                for (var n = 0; n < m; ++n) {
                  c[v++] = Z(d[n] + " ", h[b], e).trim();
                }
              }
          }
          return c;
        }
        function Z(d, c, e) {
          var h = c.charCodeAt(0);
          33 > h && (h = (c = c.trim()).charCodeAt(0));
          switch (h) {
            case 38:
              return c.replace(F, "$1" + d.trim());
            case 58:
              return d.trim() + c.replace(F, "$1" + d.trim());
            default:
              if (0 < 1 * e && 0 < c.indexOf("\f"))
                return c.replace(F, (58 === d.charCodeAt(0) ? "" : "$1") + d.trim());
          }
          return d + c;
        }
        function P(d, c, e, h) {
          var a = d + ";", m = 2 * c + 3 * e + 4 * h;
          if (944 === m) {
            d = a.indexOf(":", 9) + 1;
            var b = a.substring(d, a.length - 1).trim();
            b = a.substring(0, d).trim() + b + ";";
            return 1 === w || 2 === w && L(b, 1) ? "-webkit-" + b + b : b;
          }
          if (0 === w || 2 === w && !L(a, 1))
            return a;
          switch (m) {
            case 1015:
              return 97 === a.charCodeAt(10) ? "-webkit-" + a + a : a;
            case 951:
              return 116 === a.charCodeAt(3) ? "-webkit-" + a + a : a;
            case 963:
              return 110 === a.charCodeAt(5) ? "-webkit-" + a + a : a;
            case 1009:
              if (100 !== a.charCodeAt(4))
                break;
            case 969:
            case 942:
              return "-webkit-" + a + a;
            case 978:
              return "-webkit-" + a + "-moz-" + a + a;
            case 1019:
            case 983:
              return "-webkit-" + a + "-moz-" + a + "-ms-" + a + a;
            case 883:
              if (45 === a.charCodeAt(8))
                return "-webkit-" + a + a;
              if (0 < a.indexOf("image-set(", 11))
                return a.replace(ja, "$1-webkit-$2") + a;
              break;
            case 932:
              if (45 === a.charCodeAt(4))
                switch (a.charCodeAt(5)) {
                  case 103:
                    return "-webkit-box-" + a.replace("-grow", "") + "-webkit-" + a + "-ms-" + a.replace("grow", "positive") + a;
                  case 115:
                    return "-webkit-" + a + "-ms-" + a.replace("shrink", "negative") + a;
                  case 98:
                    return "-webkit-" + a + "-ms-" + a.replace("basis", "preferred-size") + a;
                }
              return "-webkit-" + a + "-ms-" + a + a;
            case 964:
              return "-webkit-" + a + "-ms-flex-" + a + a;
            case 1023:
              if (99 !== a.charCodeAt(8))
                break;
              b = a.substring(a.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify");
              return "-webkit-box-pack" + b + "-webkit-" + a + "-ms-flex-pack" + b + a;
            case 1005:
              return ka.test(a) ? a.replace(aa, ":-webkit-") + a.replace(aa, ":-moz-") + a : a;
            case 1e3:
              b = a.substring(13).trim();
              c = b.indexOf("-") + 1;
              switch (b.charCodeAt(0) + b.charCodeAt(c)) {
                case 226:
                  b = a.replace(G, "tb");
                  break;
                case 232:
                  b = a.replace(G, "tb-rl");
                  break;
                case 220:
                  b = a.replace(G, "lr");
                  break;
                default:
                  return a;
              }
              return "-webkit-" + a + "-ms-" + b + a;
            case 1017:
              if (-1 === a.indexOf("sticky", 9))
                break;
            case 975:
              c = (a = d).length - 10;
              b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a).substring(d.indexOf(":", 7) + 1).trim();
              switch (m = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {
                case 203:
                  if (111 > b.charCodeAt(8))
                    break;
                case 115:
                  a = a.replace(b, "-webkit-" + b) + ";" + a;
                  break;
                case 207:
                case 102:
                  a = a.replace(b, "-webkit-" + (102 < m ? "inline-" : "") + "box") + ";" + a.replace(b, "-webkit-" + b) + ";" + a.replace(b, "-ms-" + b + "box") + ";" + a;
              }
              return a + ";";
            case 938:
              if (45 === a.charCodeAt(5))
                switch (a.charCodeAt(6)) {
                  case 105:
                    return b = a.replace("-items", ""), "-webkit-" + a + "-webkit-box-" + b + "-ms-flex-" + b + a;
                  case 115:
                    return "-webkit-" + a + "-ms-flex-item-" + a.replace(ba, "") + a;
                  default:
                    return "-webkit-" + a + "-ms-flex-line-pack" + a.replace("align-content", "").replace(ba, "") + a;
                }
              break;
            case 973:
            case 989:
              if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4))
                break;
            case 931:
            case 953:
              if (true === la.test(d))
                return 115 === (b = d.substring(d.indexOf(":") + 1)).charCodeAt(0) ? P(d.replace("stretch", "fill-available"), c, e, h).replace(":fill-available", ":stretch") : a.replace(b, "-webkit-" + b) + a.replace(b, "-moz-" + b.replace("fill-", "")) + a;
              break;
            case 962:
              if (a = "-webkit-" + a + (102 === a.charCodeAt(5) ? "-ms-" + a : "") + a, 211 === e + h && 105 === a.charCodeAt(13) && 0 < a.indexOf("transform", 10))
                return a.substring(0, a.indexOf(";", 27) + 1).replace(ma, "$1-webkit-$2") + a;
          }
          return a;
        }
        function L(d, c) {
          var e = d.indexOf(1 === c ? ":" : "{"), h = d.substring(0, 3 !== c ? e : 10);
          e = d.substring(e + 1, d.length - 1);
          return R(2 !== c ? h : h.replace(na, "$1"), e, c);
        }
        function ea(d, c) {
          var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));
          return e !== c + ";" ? e.replace(oa, " or ($1)").substring(4) : "(" + c + ")";
        }
        function H(d, c, e, h, a, m, b, v, n, q) {
          for (var g = 0, x = c, w2; g < A; ++g) {
            switch (w2 = S[g].call(B, d, x, e, h, a, m, b, v, n, q)) {
              case void 0:
              case false:
              case true:
              case null:
                break;
              default:
                x = w2;
            }
          }
          if (x !== c)
            return x;
        }
        function T(d) {
          switch (d) {
            case void 0:
            case null:
              A = S.length = 0;
              break;
            default:
              if ("function" === typeof d)
                S[A++] = d;
              else if ("object" === typeof d)
                for (var c = 0, e = d.length; c < e; ++c) {
                  T(d[c]);
                }
              else
                Y = !!d | 0;
          }
          return T;
        }
        function U(d) {
          d = d.prefix;
          void 0 !== d && (R = null, d ? "function" !== typeof d ? w = 1 : (w = 2, R = d) : w = 0);
          return U;
        }
        function B(d, c) {
          var e = d;
          33 > e.charCodeAt(0) && (e = e.trim());
          V = e;
          e = [V];
          if (0 < A) {
            var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);
            void 0 !== h && "string" === typeof h && (c = h);
          }
          var a = M(O, e, c, 0, 0);
          0 < A && (h = H(-2, a, e, e, D, z, a.length, 0, 0, 0), void 0 !== h && (a = h));
          V = "";
          E = 0;
          z = D = 1;
          return a;
        }
        var ca = /^\0+/g, N = /[\0\r\f]/g, aa = /: */g, ka = /zoo|gra/, ma = /([,: ])(transform)/g, ia = /,\r+?/g, F = /([\t\r\n ])*\f?&/g, fa = /@(k\w+)\s*(\S*)\s*/, Q = /::(place)/g, ha = /:(read-only)/g, G = /[svh]\w+-[tblr]{2}/, da = /\(\s*(.*)\s*\)/g, oa = /([\s\S]*?);/g, ba = /-self|flex-/g, na = /[^]*?(:[rp][el]a[\w-]+)[^]*/, la = /stretch|:\s*\w+\-(?:conte|avail)/, ja = /([^-])(image-set\()/, z = 1, D = 1, E = 0, w = 1, O = [], S = [], A = 0, R = null, Y = 0, V = "";
        B.use = T;
        B.set = U;
        void 0 !== W && U(W);
        return B;
      }
      exports.default = stylis_min;
    }
  });

  // node_modules/@emotion/unitless/dist/unitless.browser.cjs.js
  var require_unitless_browser_cjs = __commonJS({
    "node_modules/@emotion/unitless/dist/unitless.browser.cjs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var unitlessKeys = {
        animationIterationCount: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        // SVG-related properties
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1
      };
      exports.default = unitlessKeys;
    }
  });

  // node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
  function memoize(fn2) {
    var cache2 = /* @__PURE__ */ Object.create(null);
    return function(arg) {
      if (cache2[arg] === void 0)
        cache2[arg] = fn2(arg);
      return cache2[arg];
    };
  }
  var emotion_memoize_esm_default;
  var init_emotion_memoize_esm = __esm({
    "node_modules/@emotion/memoize/dist/emotion-memoize.esm.js"() {
      emotion_memoize_esm_default = memoize;
    }
  });

  // node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
  var emotion_is_prop_valid_esm_exports = {};
  __export(emotion_is_prop_valid_esm_exports, {
    default: () => emotion_is_prop_valid_esm_default
  });
  var reactPropsRegex, isPropValid, emotion_is_prop_valid_esm_default;
  var init_emotion_is_prop_valid_esm = __esm({
    "node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js"() {
      init_emotion_memoize_esm();
      reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
      isPropValid = /* @__PURE__ */ emotion_memoize_esm_default(
        function(prop) {
          return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
        }
        /* Z+1 */
      );
      emotion_is_prop_valid_esm_default = isPropValid;
    }
  });

  // node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
  var require_hoist_non_react_statics_cjs = __commonJS({
    "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
      "use strict";
      var reactIs = require_react_is();
      var REACT_STATICS = {
        childContextTypes: true,
        contextType: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        getDerivedStateFromError: true,
        getDerivedStateFromProps: true,
        mixins: true,
        propTypes: true,
        type: true
      };
      var KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        callee: true,
        arguments: true,
        arity: true
      };
      var FORWARD_REF_STATICS = {
        "$$typeof": true,
        render: true,
        defaultProps: true,
        displayName: true,
        propTypes: true
      };
      var MEMO_STATICS = {
        "$$typeof": true,
        compare: true,
        defaultProps: true,
        displayName: true,
        propTypes: true,
        type: true
      };
      var TYPE_STATICS = {};
      TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
      TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
      function getStatics(component) {
        if (reactIs.isMemo(component)) {
          return MEMO_STATICS;
        }
        return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
      }
      var defineProperty = Object.defineProperty;
      var getOwnPropertyNames = Object.getOwnPropertyNames;
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var getPrototypeOf = Object.getPrototypeOf;
      var objectPrototype = Object.prototype;
      function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
        if (typeof sourceComponent !== "string") {
          if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
              hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
          }
          var keys5 = getOwnPropertyNames(sourceComponent);
          if (getOwnPropertySymbols) {
            keys5 = keys5.concat(getOwnPropertySymbols(sourceComponent));
          }
          var targetStatics = getStatics(targetComponent);
          var sourceStatics = getStatics(sourceComponent);
          for (var i = 0; i < keys5.length; ++i) {
            var key = keys5[i];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
              var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
              try {
                defineProperty(targetComponent, key, descriptor);
              } catch (e) {
              }
            }
          }
        }
        return targetComponent;
      }
      module.exports = hoistNonReactStatics;
    }
  });

  // node_modules/styled-components/dist/styled-components.browser.cjs.js
  var require_styled_components_browser_cjs = __commonJS({
    "node_modules/styled-components/dist/styled-components.browser.cjs.js"(exports) {
      "use strict";
      function e(e2) {
        return e2 && "object" == typeof e2 && "default" in e2 ? e2.default : e2;
      }
      Object.defineProperty(exports, "__esModule", { value: true });
      var t = require_react_is();
      var n = require_react();
      var r = e(n);
      var o = e(require_shallowequal());
      var s = e(require_stylis_browser_cjs());
      var i = e(require_unitless_browser_cjs());
      var a = e((init_emotion_is_prop_valid_esm(), __toCommonJS(emotion_is_prop_valid_esm_exports)));
      var c = e(require_hoist_non_react_statics_cjs());
      function u() {
        return (u = Object.assign || function(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var n2 = arguments[t2];
            for (var r2 in n2)
              Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
          }
          return e2;
        }).apply(this, arguments);
      }
      var l = function(e2, t2) {
        for (var n2 = [e2[0]], r2 = 0, o2 = t2.length; r2 < o2; r2 += 1)
          n2.push(t2[r2], e2[r2 + 1]);
        return n2;
      };
      var d = function(e2) {
        return null !== e2 && "object" == typeof e2 && "[object Object]" === (e2.toString ? e2.toString() : Object.prototype.toString.call(e2)) && !t.typeOf(e2);
      };
      var h = Object.freeze([]);
      var p = Object.freeze({});
      function f(e2) {
        return "function" == typeof e2;
      }
      function m(e2) {
        return "string" == typeof e2 && e2 || e2.displayName || e2.name || "Component";
      }
      function y(e2) {
        return e2 && "string" == typeof e2.styledComponentId;
      }
      var v = "undefined" != typeof process && void 0 !== process.env && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
      var g = "undefined" != typeof window && "HTMLElement" in window;
      var S = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && (void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : void 0 !== process.env.SC_DISABLE_SPEEDY && "" !== process.env.SC_DISABLE_SPEEDY ? "false" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : true));
      var w = {};
      var E = true ? { 1: "Cannot create styled-component for component: %s.\n\n", 2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n", 3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n", 4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n", 5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n", 6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n", 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: 'ThemeProvider: Please make your "theme" prop an object.\n\n', 9: "Missing document `<head>`\n\n", 10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n", 11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n", 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n", 14: 'ThemeProvider: "theme" prop is required.\n\n', 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n", 17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n" } : {};
      function b() {
        for (var e2 = arguments.length <= 0 ? void 0 : arguments[0], t2 = [], n2 = 1, r2 = arguments.length; n2 < r2; n2 += 1)
          t2.push(n2 < 0 || arguments.length <= n2 ? void 0 : arguments[n2]);
        return t2.forEach(function(t3) {
          e2 = e2.replace(/%[a-z]/, t3);
        }), e2;
      }
      function _(e2) {
        for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
          n2[r2 - 1] = arguments[r2];
        throw false ? new Error("An error occurred. See https://git.io/JUIaE#" + e2 + " for more information." + (n2.length > 0 ? " Args: " + n2.join(", ") : "")) : new Error(b.apply(void 0, [E[e2]].concat(n2)).trim());
      }
      var N = function() {
        function e2(e3) {
          this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e3;
        }
        var t2 = e2.prototype;
        return t2.indexOfGroup = function(e3) {
          for (var t3 = 0, n2 = 0; n2 < e3; n2++)
            t3 += this.groupSizes[n2];
          return t3;
        }, t2.insertRules = function(e3, t3) {
          if (e3 >= this.groupSizes.length) {
            for (var n2 = this.groupSizes, r2 = n2.length, o2 = r2; e3 >= o2; )
              (o2 <<= 1) < 0 && _(16, "" + e3);
            this.groupSizes = new Uint32Array(o2), this.groupSizes.set(n2), this.length = o2;
            for (var s2 = r2; s2 < o2; s2++)
              this.groupSizes[s2] = 0;
          }
          for (var i2 = this.indexOfGroup(e3 + 1), a2 = 0, c2 = t3.length; a2 < c2; a2++)
            this.tag.insertRule(i2, t3[a2]) && (this.groupSizes[e3]++, i2++);
        }, t2.clearGroup = function(e3) {
          if (e3 < this.length) {
            var t3 = this.groupSizes[e3], n2 = this.indexOfGroup(e3), r2 = n2 + t3;
            this.groupSizes[e3] = 0;
            for (var o2 = n2; o2 < r2; o2++)
              this.tag.deleteRule(n2);
          }
        }, t2.getGroup = function(e3) {
          var t3 = "";
          if (e3 >= this.length || 0 === this.groupSizes[e3])
            return t3;
          for (var n2 = this.groupSizes[e3], r2 = this.indexOfGroup(e3), o2 = r2 + n2, s2 = r2; s2 < o2; s2++)
            t3 += this.tag.getRule(s2) + "/*!sc*/\n";
          return t3;
        }, e2;
      }();
      var C = /* @__PURE__ */ new Map();
      var A = /* @__PURE__ */ new Map();
      var I = 1;
      var P = function(e2) {
        if (C.has(e2))
          return C.get(e2);
        for (; A.has(I); )
          I++;
        var t2 = I++;
        return ((0 | t2) < 0 || t2 > 1 << 30) && _(16, "" + t2), C.set(e2, t2), A.set(t2, e2), t2;
      };
      var O = function(e2) {
        return A.get(e2);
      };
      var x = function(e2, t2) {
        t2 >= I && (I = t2 + 1), C.set(e2, t2), A.set(t2, e2);
      };
      var R = "style[" + v + '][data-styled-version="5.3.9"]';
      var D = new RegExp("^" + v + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)');
      var T = function(e2, t2, n2) {
        for (var r2, o2 = n2.split(","), s2 = 0, i2 = o2.length; s2 < i2; s2++)
          (r2 = o2[s2]) && e2.registerName(t2, r2);
      };
      var j = function(e2, t2) {
        for (var n2 = (t2.textContent || "").split("/*!sc*/\n"), r2 = [], o2 = 0, s2 = n2.length; o2 < s2; o2++) {
          var i2 = n2[o2].trim();
          if (i2) {
            var a2 = i2.match(D);
            if (a2) {
              var c2 = 0 | parseInt(a2[1], 10), u2 = a2[2];
              0 !== c2 && (x(u2, c2), T(e2, u2, a2[3]), e2.getTag().insertRules(c2, r2)), r2.length = 0;
            } else
              r2.push(i2);
          }
        }
      };
      var k = function() {
        return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
      };
      var V = function(e2) {
        var t2 = document.head, n2 = e2 || t2, r2 = document.createElement("style"), o2 = function(e3) {
          for (var t3 = e3.childNodes, n3 = t3.length; n3 >= 0; n3--) {
            var r3 = t3[n3];
            if (r3 && 1 === r3.nodeType && r3.hasAttribute(v))
              return r3;
          }
        }(n2), s2 = void 0 !== o2 ? o2.nextSibling : null;
        r2.setAttribute(v, "active"), r2.setAttribute("data-styled-version", "5.3.9");
        var i2 = k();
        return i2 && r2.setAttribute("nonce", i2), n2.insertBefore(r2, s2), r2;
      };
      var M = function() {
        function e2(e3) {
          var t3 = this.element = V(e3);
          t3.appendChild(document.createTextNode("")), this.sheet = function(e4) {
            if (e4.sheet)
              return e4.sheet;
            for (var t4 = document.styleSheets, n2 = 0, r2 = t4.length; n2 < r2; n2++) {
              var o2 = t4[n2];
              if (o2.ownerNode === e4)
                return o2;
            }
            _(17);
          }(t3), this.length = 0;
        }
        var t2 = e2.prototype;
        return t2.insertRule = function(e3, t3) {
          try {
            return this.sheet.insertRule(t3, e3), this.length++, true;
          } catch (e4) {
            return false;
          }
        }, t2.deleteRule = function(e3) {
          this.sheet.deleteRule(e3), this.length--;
        }, t2.getRule = function(e3) {
          var t3 = this.sheet.cssRules[e3];
          return void 0 !== t3 && "string" == typeof t3.cssText ? t3.cssText : "";
        }, e2;
      }();
      var B = function() {
        function e2(e3) {
          var t3 = this.element = V(e3);
          this.nodes = t3.childNodes, this.length = 0;
        }
        var t2 = e2.prototype;
        return t2.insertRule = function(e3, t3) {
          if (e3 <= this.length && e3 >= 0) {
            var n2 = document.createTextNode(t3), r2 = this.nodes[e3];
            return this.element.insertBefore(n2, r2 || null), this.length++, true;
          }
          return false;
        }, t2.deleteRule = function(e3) {
          this.element.removeChild(this.nodes[e3]), this.length--;
        }, t2.getRule = function(e3) {
          return e3 < this.length ? this.nodes[e3].textContent : "";
        }, e2;
      }();
      var z = function() {
        function e2(e3) {
          this.rules = [], this.length = 0;
        }
        var t2 = e2.prototype;
        return t2.insertRule = function(e3, t3) {
          return e3 <= this.length && (this.rules.splice(e3, 0, t3), this.length++, true);
        }, t2.deleteRule = function(e3) {
          this.rules.splice(e3, 1), this.length--;
        }, t2.getRule = function(e3) {
          return e3 < this.length ? this.rules[e3] : "";
        }, e2;
      }();
      var q = g;
      var G = { isServer: !g, useCSSOMInjection: !S };
      var L = function() {
        function e2(e3, t3, n2) {
          void 0 === e3 && (e3 = p), void 0 === t3 && (t3 = {}), this.options = u({}, G, {}, e3), this.gs = t3, this.names = new Map(n2), this.server = !!e3.isServer, !this.server && g && q && (q = false, function(e4) {
            for (var t4 = document.querySelectorAll(R), n3 = 0, r2 = t4.length; n3 < r2; n3++) {
              var o2 = t4[n3];
              o2 && "active" !== o2.getAttribute(v) && (j(e4, o2), o2.parentNode && o2.parentNode.removeChild(o2));
            }
          }(this));
        }
        e2.registerId = function(e3) {
          return P(e3);
        };
        var t2 = e2.prototype;
        return t2.reconstructWithOptions = function(t3, n2) {
          return void 0 === n2 && (n2 = true), new e2(u({}, this.options, {}, t3), this.gs, n2 && this.names || void 0);
        }, t2.allocateGSInstance = function(e3) {
          return this.gs[e3] = (this.gs[e3] || 0) + 1;
        }, t2.getTag = function() {
          return this.tag || (this.tag = (n2 = (t3 = this.options).isServer, r2 = t3.useCSSOMInjection, o2 = t3.target, e3 = n2 ? new z(o2) : r2 ? new M(o2) : new B(o2), new N(e3)));
          var e3, t3, n2, r2, o2;
        }, t2.hasNameForId = function(e3, t3) {
          return this.names.has(e3) && this.names.get(e3).has(t3);
        }, t2.registerName = function(e3, t3) {
          if (P(e3), this.names.has(e3))
            this.names.get(e3).add(t3);
          else {
            var n2 = /* @__PURE__ */ new Set();
            n2.add(t3), this.names.set(e3, n2);
          }
        }, t2.insertRules = function(e3, t3, n2) {
          this.registerName(e3, t3), this.getTag().insertRules(P(e3), n2);
        }, t2.clearNames = function(e3) {
          this.names.has(e3) && this.names.get(e3).clear();
        }, t2.clearRules = function(e3) {
          this.getTag().clearGroup(P(e3)), this.clearNames(e3);
        }, t2.clearTag = function() {
          this.tag = void 0;
        }, t2.toString = function() {
          return function(e3) {
            for (var t3 = e3.getTag(), n2 = t3.length, r2 = "", o2 = 0; o2 < n2; o2++) {
              var s2 = O(o2);
              if (void 0 !== s2) {
                var i2 = e3.names.get(s2), a2 = t3.getGroup(o2);
                if (i2 && a2 && i2.size) {
                  var c2 = v + ".g" + o2 + '[id="' + s2 + '"]', u2 = "";
                  void 0 !== i2 && i2.forEach(function(e4) {
                    e4.length > 0 && (u2 += e4 + ",");
                  }), r2 += "" + a2 + c2 + '{content:"' + u2 + '"}/*!sc*/\n';
                }
              }
            }
            return r2;
          }(this);
        }, e2;
      }();
      var F = /(a)(d)/gi;
      var Y = function(e2) {
        return String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));
      };
      function H(e2) {
        var t2, n2 = "";
        for (t2 = Math.abs(e2); t2 > 52; t2 = t2 / 52 | 0)
          n2 = Y(t2 % 52) + n2;
        return (Y(t2 % 52) + n2).replace(F, "$1-$2");
      }
      var $2 = function(e2, t2) {
        for (var n2 = t2.length; n2; )
          e2 = 33 * e2 ^ t2.charCodeAt(--n2);
        return e2;
      };
      var W = function(e2) {
        return $2(5381, e2);
      };
      function U(e2) {
        for (var t2 = 0; t2 < e2.length; t2 += 1) {
          var n2 = e2[t2];
          if (f(n2) && !y(n2))
            return false;
        }
        return true;
      }
      var J = W("5.3.9");
      var X = function() {
        function e2(e3, t2, n2) {
          this.rules = e3, this.staticRulesId = "", this.isStatic = false, this.componentId = t2, this.baseHash = $2(J, t2), this.baseStyle = n2, L.registerId(t2);
        }
        return e2.prototype.generateAndInjectStyles = function(e3, t2, n2) {
          var r2 = this.componentId, o2 = [];
          if (this.baseStyle && o2.push(this.baseStyle.generateAndInjectStyles(e3, t2, n2)), this.isStatic && !n2.hash)
            if (this.staticRulesId && t2.hasNameForId(r2, this.staticRulesId))
              o2.push(this.staticRulesId);
            else {
              var s2 = me(this.rules, e3, t2, n2).join(""), i2 = H($2(this.baseHash, s2) >>> 0);
              if (!t2.hasNameForId(r2, i2)) {
                var a2 = n2(s2, "." + i2, void 0, r2);
                t2.insertRules(r2, i2, a2);
              }
              o2.push(i2), this.staticRulesId = i2;
            }
          else {
            for (var c2 = this.rules.length, u2 = $2(this.baseHash, n2.hash), l2 = "", d2 = 0; d2 < c2; d2++) {
              var h2 = this.rules[d2];
              if ("string" == typeof h2)
                l2 += h2, u2 = $2(u2, h2 + d2);
              else if (h2) {
                var p2 = me(h2, e3, t2, n2), f2 = Array.isArray(p2) ? p2.join("") : p2;
                u2 = $2(u2, f2 + d2), l2 += f2;
              }
            }
            if (l2) {
              var m2 = H(u2 >>> 0);
              if (!t2.hasNameForId(r2, m2)) {
                var y2 = n2(l2, "." + m2, void 0, r2);
                t2.insertRules(r2, m2, y2);
              }
              o2.push(m2);
            }
          }
          return o2.join(" ");
        }, e2;
      }();
      var Z = /^\s*\/\/.*$/gm;
      var K = [":", "[", ".", "#"];
      function Q(e2) {
        var t2, n2, r2, o2, i2 = void 0 === e2 ? p : e2, a2 = i2.options, c2 = void 0 === a2 ? p : a2, u2 = i2.plugins, l2 = void 0 === u2 ? h : u2, d2 = new s(c2), f2 = [], m2 = function(e3) {
          function t3(t4) {
            if (t4)
              try {
                e3(t4 + "}");
              } catch (e4) {
              }
          }
          return function(n3, r3, o3, s2, i3, a3, c3, u3, l3, d3) {
            switch (n3) {
              case 1:
                if (0 === l3 && 64 === r3.charCodeAt(0))
                  return e3(r3 + ";"), "";
                break;
              case 2:
                if (0 === u3)
                  return r3 + "/*|*/";
                break;
              case 3:
                switch (u3) {
                  case 102:
                  case 112:
                    return e3(o3[0] + r3), "";
                  default:
                    return r3 + (0 === d3 ? "/*|*/" : "");
                }
              case -2:
                r3.split("/*|*/}").forEach(t3);
            }
          };
        }(function(e3) {
          f2.push(e3);
        }), y2 = function(e3, r3, s2) {
          return 0 === r3 && -1 !== K.indexOf(s2[n2.length]) || s2.match(o2) ? e3 : "." + t2;
        };
        function v2(e3, s2, i3, a3) {
          void 0 === a3 && (a3 = "&");
          var c3 = e3.replace(Z, ""), u3 = s2 && i3 ? i3 + " " + s2 + " { " + c3 + " }" : c3;
          return t2 = a3, n2 = s2, r2 = new RegExp("\\" + n2 + "\\b", "g"), o2 = new RegExp("(\\" + n2 + "\\b){2,}"), d2(i3 || !s2 ? "" : s2, u3);
        }
        return d2.use([].concat(l2, [function(e3, t3, o3) {
          2 === e3 && o3.length && o3[0].lastIndexOf(n2) > 0 && (o3[0] = o3[0].replace(r2, y2));
        }, m2, function(e3) {
          if (-2 === e3) {
            var t3 = f2;
            return f2 = [], t3;
          }
        }])), v2.hash = l2.length ? l2.reduce(function(e3, t3) {
          return t3.name || _(15), $2(e3, t3.name);
        }, 5381).toString() : "", v2;
      }
      var ee = r.createContext();
      var te = ee.Consumer;
      var ne = r.createContext();
      var re = (ne.Consumer, new L());
      var oe = Q();
      function se() {
        return n.useContext(ee) || re;
      }
      function ie() {
        return n.useContext(ne) || oe;
      }
      function ae(e2) {
        var t2 = n.useState(e2.stylisPlugins), s2 = t2[0], i2 = t2[1], a2 = se(), c2 = n.useMemo(function() {
          var t3 = a2;
          return e2.sheet ? t3 = e2.sheet : e2.target && (t3 = t3.reconstructWithOptions({ target: e2.target }, false)), e2.disableCSSOMInjection && (t3 = t3.reconstructWithOptions({ useCSSOMInjection: false })), t3;
        }, [e2.disableCSSOMInjection, e2.sheet, e2.target]), u2 = n.useMemo(function() {
          return Q({ options: { prefix: !e2.disableVendorPrefixes }, plugins: s2 });
        }, [e2.disableVendorPrefixes, s2]);
        return n.useEffect(function() {
          o(s2, e2.stylisPlugins) || i2(e2.stylisPlugins);
        }, [e2.stylisPlugins]), r.createElement(ee.Provider, { value: c2 }, r.createElement(ne.Provider, { value: u2 }, true ? r.Children.only(e2.children) : e2.children));
      }
      var ce = function() {
        function e2(e3, t2) {
          var n2 = this;
          this.inject = function(e4, t3) {
            void 0 === t3 && (t3 = oe);
            var r2 = n2.name + t3.hash;
            e4.hasNameForId(n2.id, r2) || e4.insertRules(n2.id, r2, t3(n2.rules, r2, "@keyframes"));
          }, this.toString = function() {
            return _(12, String(n2.name));
          }, this.name = e3, this.id = "sc-keyframes-" + e3, this.rules = t2;
        }
        return e2.prototype.getName = function(e3) {
          return void 0 === e3 && (e3 = oe), this.name + e3.hash;
        }, e2;
      }();
      var ue = /([A-Z])/;
      var le = /([A-Z])/g;
      var de = /^ms-/;
      var he = function(e2) {
        return "-" + e2.toLowerCase();
      };
      function pe(e2) {
        return ue.test(e2) ? e2.replace(le, he).replace(de, "-ms-") : e2;
      }
      var fe = function(e2) {
        return null == e2 || false === e2 || "" === e2;
      };
      function me(e2, n2, r2, o2) {
        if (Array.isArray(e2)) {
          for (var s2, a2 = [], c2 = 0, u2 = e2.length; c2 < u2; c2 += 1)
            "" !== (s2 = me(e2[c2], n2, r2, o2)) && (Array.isArray(s2) ? a2.push.apply(a2, s2) : a2.push(s2));
          return a2;
        }
        if (fe(e2))
          return "";
        if (y(e2))
          return "." + e2.styledComponentId;
        if (f(e2)) {
          if ("function" != typeof (h2 = e2) || h2.prototype && h2.prototype.isReactComponent || !n2)
            return e2;
          var l2 = e2(n2);
          return t.isElement(l2) && console.warn(m(e2) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."), me(l2, n2, r2, o2);
        }
        var h2;
        return e2 instanceof ce ? r2 ? (e2.inject(r2, o2), e2.getName(o2)) : e2 : d(e2) ? function e3(t2, n3) {
          var r3, o3, s3 = [];
          for (var a3 in t2)
            t2.hasOwnProperty(a3) && !fe(t2[a3]) && (Array.isArray(t2[a3]) && t2[a3].isCss || f(t2[a3]) ? s3.push(pe(a3) + ":", t2[a3], ";") : d(t2[a3]) ? s3.push.apply(s3, e3(t2[a3], a3)) : s3.push(pe(a3) + ": " + (r3 = a3, null == (o3 = t2[a3]) || "boolean" == typeof o3 || "" === o3 ? "" : "number" != typeof o3 || 0 === o3 || r3 in i ? String(o3).trim() : o3 + "px") + ";"));
          return n3 ? [n3 + " {"].concat(s3, ["}"]) : s3;
        }(e2) : e2.toString();
      }
      var ye = function(e2) {
        return Array.isArray(e2) && (e2.isCss = true), e2;
      };
      function ve(e2) {
        for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
          n2[r2 - 1] = arguments[r2];
        return f(e2) || d(e2) ? ye(me(l(h, [e2].concat(n2)))) : 0 === n2.length && 1 === e2.length && "string" == typeof e2[0] ? e2 : ye(me(l(e2, n2)));
      }
      var ge = /invalid hook call/i;
      var Se = /* @__PURE__ */ new Set();
      var we = function(e2, t2) {
        if (true) {
          var r2 = "The component " + e2 + (t2 ? ' with the id of "' + t2 + '"' : "") + " has been created dynamically.\nYou may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.", o2 = console.error;
          try {
            var s2 = true;
            console.error = function(e3) {
              if (ge.test(e3))
                s2 = false, Se.delete(r2);
              else {
                for (var t3 = arguments.length, n2 = new Array(t3 > 1 ? t3 - 1 : 0), i2 = 1; i2 < t3; i2++)
                  n2[i2 - 1] = arguments[i2];
                o2.apply(void 0, [e3].concat(n2));
              }
            }, n.useRef(), s2 && !Se.has(r2) && (console.warn(r2), Se.add(r2));
          } catch (e3) {
            ge.test(e3.message) && Se.delete(r2);
          } finally {
            console.error = o2;
          }
        }
      };
      var Ee = function(e2, t2, n2) {
        return void 0 === n2 && (n2 = p), e2.theme !== n2.theme && e2.theme || t2 || n2.theme;
      };
      var be = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
      var _e = /(^-|-$)/g;
      function Ne(e2) {
        return e2.replace(be, "-").replace(_e, "");
      }
      var Ce = function(e2) {
        return H(W(e2) >>> 0);
      };
      function Ae(e2) {
        return "string" == typeof e2 && e2.charAt(0) === e2.charAt(0).toLowerCase();
      }
      var Ie = function(e2) {
        return "function" == typeof e2 || "object" == typeof e2 && null !== e2 && !Array.isArray(e2);
      };
      var Pe = function(e2) {
        return "__proto__" !== e2 && "constructor" !== e2 && "prototype" !== e2;
      };
      function Oe(e2, t2, n2) {
        var r2 = e2[n2];
        Ie(t2) && Ie(r2) ? xe(r2, t2) : e2[n2] = t2;
      }
      function xe(e2) {
        for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
          n2[r2 - 1] = arguments[r2];
        for (var o2 = 0, s2 = n2; o2 < s2.length; o2++) {
          var i2 = s2[o2];
          if (Ie(i2))
            for (var a2 in i2)
              Pe(a2) && Oe(e2, i2[a2], a2);
        }
        return e2;
      }
      var Re = r.createContext();
      var De = Re.Consumer;
      var Te = {};
      function je(e2, t2, o2) {
        var s2 = y(e2), i2 = !Ae(e2), l2 = t2.attrs, d2 = void 0 === l2 ? h : l2, v2 = t2.componentId, g2 = void 0 === v2 ? function(e3, t3) {
          var n2 = "string" != typeof e3 ? "sc" : Ne(e3);
          Te[n2] = (Te[n2] || 0) + 1;
          var r2 = n2 + "-" + Ce("5.3.9" + n2 + Te[n2]);
          return t3 ? t3 + "-" + r2 : r2;
        }(t2.displayName, t2.parentComponentId) : v2, S2 = t2.displayName, w2 = void 0 === S2 ? function(e3) {
          return Ae(e3) ? "styled." + e3 : "Styled(" + m(e3) + ")";
        }(e2) : S2, E2 = t2.displayName && t2.componentId ? Ne(t2.displayName) + "-" + t2.componentId : t2.componentId || g2, b2 = s2 && e2.attrs ? Array.prototype.concat(e2.attrs, d2).filter(Boolean) : d2, _2 = t2.shouldForwardProp;
        s2 && e2.shouldForwardProp && (_2 = t2.shouldForwardProp ? function(n2, r2, o3) {
          return e2.shouldForwardProp(n2, r2, o3) && t2.shouldForwardProp(n2, r2, o3);
        } : e2.shouldForwardProp);
        var N2, C2 = new X(o2, E2, s2 ? e2.componentStyle : void 0), A2 = C2.isStatic && 0 === d2.length, I2 = function(e3, t3) {
          return function(e4, t4, r2, o3) {
            var s3 = e4.attrs, i3 = e4.componentStyle, c2 = e4.defaultProps, l3 = e4.foldedComponentIds, d3 = e4.shouldForwardProp, h2 = e4.styledComponentId, m2 = e4.target;
            n.useDebugValue(h2);
            var y2 = function(e5, t5, n2) {
              void 0 === e5 && (e5 = p);
              var r3 = u({}, t5, { theme: e5 }), o4 = {};
              return n2.forEach(function(e6) {
                var t6, n3, s4, i4 = e6;
                for (t6 in f(i4) && (i4 = i4(r3)), i4)
                  r3[t6] = o4[t6] = "className" === t6 ? (n3 = o4[t6], s4 = i4[t6], n3 && s4 ? n3 + " " + s4 : n3 || s4) : i4[t6];
              }), [r3, o4];
            }(Ee(t4, n.useContext(Re), c2) || p, t4, s3), v3 = y2[0], g3 = y2[1], S3 = function(e5, t5, r3, o4) {
              var s4 = se(), i4 = ie(), a2 = t5 ? e5.generateAndInjectStyles(p, s4, i4) : e5.generateAndInjectStyles(r3, s4, i4);
              return n.useDebugValue(a2), !t5 && o4 && o4(a2), a2;
            }(i3, o3, v3, true ? e4.warnTooManyClasses : void 0), w3 = r2, E3 = g3.$as || t4.$as || g3.as || t4.as || m2, b3 = Ae(E3), _3 = g3 !== t4 ? u({}, t4, {}, g3) : t4, N3 = {};
            for (var C3 in _3)
              "$" !== C3[0] && "as" !== C3 && ("forwardedAs" === C3 ? N3.as = _3[C3] : (d3 ? d3(C3, a, E3) : !b3 || a(C3)) && (N3[C3] = _3[C3]));
            return t4.style && g3.style !== t4.style && (N3.style = u({}, t4.style, {}, g3.style)), N3.className = Array.prototype.concat(l3, h2, S3 !== h2 ? S3 : null, t4.className, g3.className).filter(Boolean).join(" "), N3.ref = w3, n.createElement(E3, N3);
          }(N2, e3, t3, A2);
        };
        return I2.displayName = w2, (N2 = r.forwardRef(I2)).attrs = b2, N2.componentStyle = C2, N2.displayName = w2, N2.shouldForwardProp = _2, N2.foldedComponentIds = s2 ? Array.prototype.concat(e2.foldedComponentIds, e2.styledComponentId) : h, N2.styledComponentId = E2, N2.target = s2 ? e2.target : e2, N2.withComponent = function(e3) {
          var n2 = t2.componentId, r2 = function(e4, t3) {
            if (null == e4)
              return {};
            var n3, r3, o3 = {}, s4 = Object.keys(e4);
            for (r3 = 0; r3 < s4.length; r3++)
              n3 = s4[r3], t3.indexOf(n3) >= 0 || (o3[n3] = e4[n3]);
            return o3;
          }(t2, ["componentId"]), s3 = n2 && n2 + "-" + (Ae(e3) ? e3 : Ne(m(e3)));
          return je(e3, u({}, r2, { attrs: b2, componentId: s3 }), o2);
        }, Object.defineProperty(N2, "defaultProps", { get: function() {
          return this._foldedDefaultProps;
        }, set: function(t3) {
          this._foldedDefaultProps = s2 ? xe({}, e2.defaultProps, t3) : t3;
        } }), we(w2, E2), N2.warnTooManyClasses = function(e3, t3) {
          var n2 = {}, r2 = false;
          return function(o3) {
            if (!r2 && (n2[o3] = true, Object.keys(n2).length >= 200)) {
              var s3 = t3 ? ' with the id of "' + t3 + '"' : "";
              console.warn("Over 200 classes were generated for component " + e3 + s3 + ".\nConsider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), r2 = true, n2 = {};
            }
          };
        }(w2, E2), Object.defineProperty(N2, "toString", { value: function() {
          return "." + N2.styledComponentId;
        } }), i2 && c(N2, e2, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true, withComponent: true }), N2;
      }
      var ke = function(e2) {
        return function e3(n2, r2, o2) {
          if (void 0 === o2 && (o2 = p), !t.isValidElementType(r2))
            return _(1, String(r2));
          var s2 = function() {
            return n2(r2, o2, ve.apply(void 0, arguments));
          };
          return s2.withConfig = function(t2) {
            return e3(n2, r2, u({}, o2, {}, t2));
          }, s2.attrs = function(t2) {
            return e3(n2, r2, u({}, o2, { attrs: Array.prototype.concat(o2.attrs, t2).filter(Boolean) }));
          }, s2;
        }(je, e2);
      };
      ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(e2) {
        ke[e2] = ke(e2);
      });
      var Ve = function() {
        function e2(e3, t3) {
          this.rules = e3, this.componentId = t3, this.isStatic = U(e3), L.registerId(this.componentId + 1);
        }
        var t2 = e2.prototype;
        return t2.createStyles = function(e3, t3, n2, r2) {
          var o2 = r2(me(this.rules, t3, n2, r2).join(""), ""), s2 = this.componentId + e3;
          n2.insertRules(s2, s2, o2);
        }, t2.removeStyles = function(e3, t3) {
          t3.clearRules(this.componentId + e3);
        }, t2.renderStyles = function(e3, t3, n2, r2) {
          e3 > 2 && L.registerId(this.componentId + e3), this.removeStyles(e3, n2), this.createStyles(e3, t3, n2, r2);
        }, e2;
      }();
      var Me = function() {
        function e2() {
          var e3 = this;
          this._emitSheetCSS = function() {
            var t3 = e3.instance.toString();
            if (!t3)
              return "";
            var n2 = k();
            return "<style " + [n2 && 'nonce="' + n2 + '"', v + '="true"', 'data-styled-version="5.3.9"'].filter(Boolean).join(" ") + ">" + t3 + "</style>";
          }, this.getStyleTags = function() {
            return e3.sealed ? _(2) : e3._emitSheetCSS();
          }, this.getStyleElement = function() {
            var t3;
            if (e3.sealed)
              return _(2);
            var n2 = ((t3 = {})[v] = "", t3["data-styled-version"] = "5.3.9", t3.dangerouslySetInnerHTML = { __html: e3.instance.toString() }, t3), o2 = k();
            return o2 && (n2.nonce = o2), [r.createElement("style", u({}, n2, { key: "sc-0-0" }))];
          }, this.seal = function() {
            e3.sealed = true;
          }, this.instance = new L({ isServer: true }), this.sealed = false;
        }
        var t2 = e2.prototype;
        return t2.collectStyles = function(e3) {
          return this.sealed ? _(2) : r.createElement(ae, { sheet: this.instance }, e3);
        }, t2.interleaveWithNodeStream = function(e3) {
          return _(3);
        }, e2;
      }();
      var Be = { StyleSheet: L, masterSheet: re };
      "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native"), "undefined" != typeof window && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, 1 === window["__styled-components-init__"] && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), window["__styled-components-init__"] += 1), exports.ServerStyleSheet = Me, exports.StyleSheetConsumer = te, exports.StyleSheetContext = ee, exports.StyleSheetManager = ae, exports.ThemeConsumer = De, exports.ThemeContext = Re, exports.ThemeProvider = function(e2) {
        var t2 = n.useContext(Re), o2 = n.useMemo(function() {
          return function(e3, t3) {
            if (!e3)
              return _(14);
            if (f(e3)) {
              var n2 = e3(t3);
              return null !== n2 && !Array.isArray(n2) && "object" == typeof n2 ? n2 : _(7);
            }
            return Array.isArray(e3) || "object" != typeof e3 ? _(8) : t3 ? u({}, t3, {}, e3) : e3;
          }(e2.theme, t2);
        }, [e2.theme, t2]);
        return e2.children ? r.createElement(Re.Provider, { value: o2 }, e2.children) : null;
      }, exports.__PRIVATE__ = Be, exports.createGlobalStyle = function(e2) {
        for (var t2 = arguments.length, o2 = new Array(t2 > 1 ? t2 - 1 : 0), s2 = 1; s2 < t2; s2++)
          o2[s2 - 1] = arguments[s2];
        var i2 = ve.apply(void 0, [e2].concat(o2)), a2 = "sc-global-" + Ce(JSON.stringify(i2)), c2 = new Ve(i2, a2);
        function l2(e3) {
          var t3 = se(), o3 = ie(), s3 = n.useContext(Re), u2 = n.useRef(t3.allocateGSInstance(a2)).current;
          return r.Children.count(e3.children) && console.warn("The global style component " + a2 + " was given child JSX. createGlobalStyle does not render children."), i2.some(function(e4) {
            return "string" == typeof e4 && -1 !== e4.indexOf("@import");
          }) && console.warn("Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app."), t3.server && d2(u2, e3, t3, s3, o3), n.useLayoutEffect(function() {
            if (!t3.server)
              return d2(u2, e3, t3, s3, o3), function() {
                return c2.removeStyles(u2, t3);
              };
          }, [u2, e3, t3, s3, o3]), null;
        }
        function d2(e3, t3, n2, r2, o3) {
          if (c2.isStatic)
            c2.renderStyles(e3, w, n2, o3);
          else {
            var s3 = u({}, t3, { theme: Ee(t3, r2, l2.defaultProps) });
            c2.renderStyles(e3, s3, n2, o3);
          }
        }
        return we(a2), r.memo(l2);
      }, exports.css = ve, exports.default = ke, exports.isStyledComponent = y, exports.keyframes = function(e2) {
        "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
        for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
          n2[r2 - 1] = arguments[r2];
        var o2 = ve.apply(void 0, [e2].concat(n2)).join(""), s2 = Ce(o2);
        return new ce(s2, o2);
      }, exports.useTheme = function() {
        return n.useContext(Re);
      }, exports.version = "5.3.9", exports.withTheme = function(e2) {
        var t2 = r.forwardRef(function(t3, o2) {
          var s2 = n.useContext(Re), i2 = e2.defaultProps, a2 = Ee(t3, s2, i2);
          return void 0 === a2 && console.warn('[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class "' + m(e2) + '"'), r.createElement(e2, u({}, t3, { theme: a2, ref: o2 }));
        });
        return c(t2, e2), t2.displayName = "WithTheme(" + m(e2) + ")", t2;
      };
    }
  });

  // node_modules/grommet-styles/utils/colors.js
  var require_colors = __commonJS({
    "node_modules/grommet-styles/utils/colors.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.normalizeColor = exports.colorIsDark = void 0;
      var parseHexToRGB3 = function parseHexToRGB4(color) {
        return color.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function(m, r, g, b) {
          return "#" + r + r + g + g + b + b;
        }).substring(1).match(/.{2}/g).map(function(x) {
          return parseInt(x, 16);
        });
      };
      var getRGBArray3 = function getRGBArray4(color) {
        if (/^#/.test(color)) {
          return parseHexToRGB3(color);
        }
        if (/^rgb/.test(color)) {
          return color.match(/rgba?\((\s?[0-9]*\s?),(\s?[0-9]*\s?),(\s?[0-9]*\s?).*?\)/).splice(1);
        }
        return color;
      };
      var colorIsDark3 = function colorIsDark4(color) {
        var _getRGBArray = getRGBArray3(color), red = _getRGBArray[0], green = _getRGBArray[1], blue = _getRGBArray[2];
        var brightness = (299 * red + 587 * green + 114 * blue) / 1e3;
        return brightness < 125;
      };
      exports.colorIsDark = colorIsDark3;
      var normalizeColor3 = function normalizeColor4(color, theme) {
        var colorSpec = theme.global.colors[color] || color;
        var result = colorSpec;
        if (theme.dark && colorSpec.dark) {
          result = colorSpec.dark;
        } else if (!theme.dark && colorSpec.light) {
          result = colorSpec.light;
        }
        if (result && theme.global.colors[result] && theme.global.colors[result] !== result) {
          result = normalizeColor4(result, theme);
        }
        return result;
      };
      exports.normalizeColor = normalizeColor3;
    }
  });

  // node_modules/grommet-styles/utils/index.js
  var require_utils = __commonJS({
    "node_modules/grommet-styles/utils/index.js"(exports) {
      "use strict";
      exports.__esModule = true;
      var _colors = require_colors();
      Object.keys(_colors).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        exports[key] = _colors[key];
      });
    }
  });

  // node_modules/grommet-styles/styles/color.js
  var require_color = __commonJS({
    "node_modules/grommet-styles/styles/color.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.colorStyle = void 0;
      var _styledComponents = require_styled_components_browser_cjs();
      var _utils = require_utils();
      var colorStyle4 = function colorStyle5(name, value, theme, required) {
        return (0, _styledComponents.css)(["", ":", ";"], name, (0, _utils.normalizeColor)(value, theme, required));
      };
      exports.colorStyle = colorStyle4;
    }
  });

  // node_modules/grommet-styles/styles/size.js
  var require_size = __commonJS({
    "node_modules/grommet-styles/styles/size.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.sizeStyle = void 0;
      var _styledComponents = require_styled_components_browser_cjs();
      var sizeStyle10 = function sizeStyle11(name, value, theme) {
        return (0, _styledComponents.css)(["", ":", ";"], name, theme.global.size[value] || value);
      };
      exports.sizeStyle = sizeStyle10;
    }
  });

  // node_modules/grommet-styles/styles/index.js
  var require_styles = __commonJS({
    "node_modules/grommet-styles/styles/index.js"(exports) {
      "use strict";
      exports.__esModule = true;
      var _color = require_color();
      Object.keys(_color).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        exports[key] = _color[key];
      });
      var _size = require_size();
      Object.keys(_size).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        exports[key] = _size[key];
      });
    }
  });

  // node_modules/grommet-styles/index.js
  var require_grommet_styles = __commonJS({
    "node_modules/grommet-styles/index.js"(exports) {
      "use strict";
      exports.__esModule = true;
      var _styles = require_styles();
      Object.keys(_styles).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        exports[key] = _styles[key];
      });
      var _utils = require_utils();
      Object.keys(_utils).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        exports[key] = _utils[key];
      });
    }
  });

  // node_modules/grommet-icons/utils.js
  var require_utils2 = __commonJS({
    "node_modules/grommet-icons/utils.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.deepMerge = deepMerge4;
      exports["default"] = void 0;
      exports.iconPad = iconPad2;
      exports.isObject = isObject8;
      exports.parseMetricToNum = void 0;
      exports.useScaleProps = useScaleProps2;
      var _react = require_react();
      var _styledComponents = require_styled_components_browser_cjs();
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      function isObject8(item) {
        return item && typeof item === "object" && !Array.isArray(item);
      }
      function deepMerge4(target) {
        for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          sources[_key - 1] = arguments[_key];
        }
        if (!sources.length) {
          return target;
        }
        var output = _extends89({}, target);
        sources.forEach(function(source) {
          if (isObject8(source)) {
            Object.keys(source).forEach(function(key) {
              if (isObject8(source[key])) {
                if (!output[key]) {
                  output[key] = _extends89({}, source[key]);
                } else {
                  output[key] = deepMerge4(output[key], source[key]);
                }
              } else {
                output[key] = source[key];
              }
            });
          }
        });
        return output;
      }
      var parseMetricToNum5 = function parseMetricToNum6(string) {
        if (string === void 0) {
          string = "";
        }
        return parseFloat(string.match(/\d+(\.\d+)?/), 10);
      };
      exports.parseMetricToNum = parseMetricToNum5;
      function useScaleProps2(props) {
        var _theme$icon;
        var theme = (0, _react.useContext)(_styledComponents.ThemeContext);
        var size = props.size;
        var result = {};
        if (theme != null && (_theme$icon = theme.icon) != null && _theme$icon.disableScaleDown) {
          var dimension = parseMetricToNum5(theme.icon.size[size] || size);
          if (dimension < 24)
            result.vectorEffect = "non-scaling-stroke";
        }
        return result;
      }
      var calculatePad3 = function calculatePad4(value, iconDimension) {
        return (value - iconDimension) / 2 + "px";
      };
      function iconPad2(props) {
        var _theme$icon2, _theme$icon2$size, _theme$text, _theme$text$height, _theme$text2, _theme$text2$width;
        var height = props.height, _props$size = props.size, size = _props$size === void 0 ? "medium" : _props$size, width = props.width;
        var theme = (0, _react.useContext)(_styledComponents.ThemeContext);
        var iconDimension = parseMetricToNum5(((_theme$icon2 = theme.icon) == null ? void 0 : (_theme$icon2$size = _theme$icon2.size) == null ? void 0 : _theme$icon2$size[size]) || size);
        var style = "";
        if (height && theme != null && (_theme$text = theme.text) != null && (_theme$text$height = _theme$text[height]) != null && _theme$text$height.height) {
          var lineHeight = parseMetricToNum5(theme.text[height].height);
          if (lineHeight > iconDimension) {
            var pad = calculatePad3(lineHeight, iconDimension);
            style += "padding-top: " + pad + "; padding-bottom: " + pad + ";";
          }
        }
        if (width && theme != null && (_theme$text2 = theme.text) != null && (_theme$text2$width = _theme$text2[width]) != null && _theme$text2$width.height) {
          var desiredWidth = parseMetricToNum5(theme.text[width].height);
          if (desiredWidth > iconDimension) {
            var _pad = calculatePad3(desiredWidth, iconDimension);
            style += "padding-left: " + _pad + "; padding-right: " + _pad + ";";
          }
        }
        return style;
      }
      var _default = {
        deepMerge: deepMerge4,
        isObject: isObject8,
        parseMetricToNum: parseMetricToNum5,
        iconPad: iconPad2,
        useScaleProps: useScaleProps2
      };
      exports["default"] = _default;
    }
  });

  // node_modules/grommet-icons/themes/base.js
  var require_base = __commonJS({
    "node_modules/grommet-icons/themes/base.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.base = void 0;
      var base3 = {
        global: {
          colors: {
            icon: "#666666"
          }
        },
        icon: {
          size: {
            small: "12px",
            medium: "24px",
            large: "48px",
            xlarge: "96px"
          }
        }
      };
      exports.base = base3;
    }
  });

  // node_modules/grommet-icons/themes/index.js
  var require_themes = __commonJS({
    "node_modules/grommet-icons/themes/index.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.base = void 0;
      var _base = require_base();
      exports.base = _base.base;
    }
  });

  // node_modules/grommet-icons/default-props.js
  var require_default_props = __commonJS({
    "node_modules/grommet-icons/default-props.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.extendDefaultTheme = exports.defaultProps = void 0;
      var _utils = require_utils2();
      var _themes = require_themes();
      var defaultProps4 = {
        theme: _themes.base
      };
      exports.defaultProps = defaultProps4;
      var extendDefaultTheme = function extendDefaultTheme2(theme) {
        defaultProps4.theme = (0, _utils.deepMerge)(_themes.base, theme);
      };
      exports.extendDefaultTheme = extendDefaultTheme;
    }
  });

  // node_modules/grommet-icons/StyledIcon.js
  var require_StyledIcon = __commonJS({
    "node_modules/grommet-icons/StyledIcon.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.StyledIcon = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _styledComponents = _interopRequireWildcard(require_styled_components_browser_cjs());
      var _grommetStyles = require_grommet_styles();
      var _defaultProps = require_default_props();
      var _utils = require_utils2();
      var _excluded68 = ["a11yTitle", "color", "size", "theme"];
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      function _objectWithoutPropertiesLoose56(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      var colorCss2 = (0, _styledComponents.css)(["", " ", ' g{fill:inherit;stroke:inherit;}*:not([stroke]){&[fill="none"]{stroke-width:0;}}*[stroke*="#"],*[STROKE*="#"]{stroke:inherit;fill:none;}*[fill-rule],*[FILL-RULE],*[fill*="#"],*[FILL*="#"]{fill:inherit;stroke:none;}'], function(props) {
        return (0, _grommetStyles.colorStyle)("fill", props.color || props.theme.global.colors.icon, props.theme);
      }, function(props) {
        return (0, _grommetStyles.colorStyle)("stroke", props.color || props.theme.global.colors.icon, props.theme);
      });
      var IconInner2 = /* @__PURE__ */ (0, _react.forwardRef)(function(_ref, ref) {
        var a11yTitle = _ref.a11yTitle, color = _ref.color, size = _ref.size, theme = _ref.theme, rest = _objectWithoutPropertiesLoose56(_ref, _excluded68);
        return /* @__PURE__ */ _react["default"].createElement("svg", _extends89({
          ref,
          "aria-label": a11yTitle
        }, rest));
      });
      IconInner2.displayName = "Icon";
      var StyledIcon3 = (0, _styledComponents["default"])(IconInner2).withConfig({
        // don't let height attribute leak to DOM
        // https://styled-components.com/docs/api#shouldforwardprop
        shouldForwardProp: function shouldForwardProp5(prop) {
          return !["height", "width"].includes(prop);
        }
      }).withConfig({
        displayName: "StyledIcon",
        componentId: "sc-ofa7kd-0"
      })(["display:inline-block;flex:0 0 auto;", " ", " ", " ", ""], function(_ref2) {
        var _ref2$size = _ref2.size, size = _ref2$size === void 0 ? "medium" : _ref2$size, theme = _ref2.theme, viewBox = _ref2.viewBox;
        var _split = (viewBox || "0 0 24 24").split(" "), w = _split[2], h = _split[3];
        var scale = w / h;
        var dimension = (0, _utils.parseMetricToNum)(theme.icon.size[size] || size);
        if (w < h) {
          return "\n      width: " + dimension + "px;\n      height: " + dimension / scale + "px;\n    ";
        }
        if (h < w) {
          return "\n      width: " + dimension * scale + "px;\n      height: " + dimension + "px;\n    ";
        }
        return "\n      width: " + dimension + "px;\n      height: " + dimension + "px;\n    ";
      }, function(_ref3) {
        var color = _ref3.color;
        return color !== "plain" && colorCss2;
      }, function(props) {
        return (props.height || props.width) && (0, _utils.iconPad)(props);
      }, function(_ref4) {
        var theme = _ref4.theme;
        return theme && theme.icon.extend;
      });
      exports.StyledIcon = StyledIcon3;
      StyledIcon3.defaultProps = {};
      Object.setPrototypeOf(StyledIcon3.defaultProps, _defaultProps.defaultProps);
    }
  });

  // node_modules/grommet-icons/icons/Actions.js
  var require_Actions = __commonJS({
    "node_modules/grommet-icons/icons/Actions.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Actions = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Actions2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "Actions"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "M12 17.5a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zm0-11V1m0 22v-5.5M1 12h5.5m11 0H23M4.437 4.437l4.125 4.125m6.876 6.876 4.124 4.124m0-15.125-4.125 4.125m-6.874 6.876-4.126 4.124"
        }));
      });
      exports.Actions = Actions2;
      Actions2.displayName = "Actions";
    }
  });

  // node_modules/grommet-icons/icons/AssistListening.js
  var require_AssistListening = __commonJS({
    "node_modules/grommet-icons/icons/AssistListening.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.AssistListening = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var AssistListening2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "AssistListening"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "2",
          d: "M11 21c.757.667 1.424 1 2 1 2 0 3-1 3-3 0-1.333.667-2.667 2-4 1.267-1.267 2-3.067 2-5a7 7 0 0 0-14 0m11 0a4 4 0 1 0-8 0M3 20l5-6 1 4 5-6"
        }));
      });
      exports.AssistListening = AssistListening2;
      AssistListening2.displayName = "AssistListening";
    }
  });

  // node_modules/grommet-icons/icons/CircleInformation.js
  var require_CircleInformation = __commonJS({
    "node_modules/grommet-icons/icons/CircleInformation.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.CircleInformation = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var CircleInformation2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "CircleInformation"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10zm0-12v8m0-12v2"
        }));
      });
      exports.CircleInformation = CircleInformation2;
      CircleInformation2.displayName = "CircleInformation";
    }
  });

  // node_modules/grommet-icons/icons/ClosedCaption.js
  var require_ClosedCaption = __commonJS({
    "node_modules/grommet-icons/icons/ClosedCaption.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.ClosedCaption = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var ClosedCaption2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "ClosedCaption"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "M1 12c0-7 1.5-8 11-8s11 1 11 8-1.5 8-11 8-11-1-11-8zm4.25 2c0 1.5.75 2 2.5 2s2.5-.5 2.5-2h-.271c0 1.25-1 2-2.229 2-1.23 0-2.229-.75-2.229-2v-4C5.5 8.75 6.5 8 7.75 8s2.25.75 2.229 2h.271c0-1.25-1.021-2-2.5-2s-2.5.75-2.5 2v4zm8 0c0 1.5.75 2 2.5 2s2.5-.5 2.5-2h-.271c0 1.25-1 2-2.229 2-1.23 0-2.229-.75-2.229-2v-4c-.021-1.25.979-2 2.229-2s2.25.75 2.229 2h.271c0-1.25-1.021-2-2.5-2s-2.5.75-2.5 2v4z"
        }));
      });
      exports.ClosedCaption = ClosedCaption2;
      ClosedCaption2.displayName = "ClosedCaption";
    }
  });

  // node_modules/grommet-icons/icons/Expand.js
  var require_Expand = __commonJS({
    "node_modules/grommet-icons/icons/Expand.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Expand = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Expand2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "Expand"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "m10 14-8 8m-1-7v8h8M22 2l-8 8m1-9h8v8"
        }));
      });
      exports.Expand = Expand2;
      Expand2.displayName = "Expand";
    }
  });

  // node_modules/grommet-icons/icons/FormClose.js
  var require_FormClose = __commonJS({
    "node_modules/grommet-icons/icons/FormClose.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.FormClose = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var FormClose4 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "FormClose"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "m7 7 10 10M7 17 17 7"
        }));
      });
      exports.FormClose = FormClose4;
      FormClose4.displayName = "FormClose";
    }
  });

  // node_modules/grommet-icons/icons/FormDown.js
  var require_FormDown = __commonJS({
    "node_modules/grommet-icons/icons/FormDown.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.FormDown = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var FormDown3 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "FormDown"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "m18 9-6 6-6-6"
        }));
      });
      exports.FormDown = FormDown3;
      FormDown3.displayName = "FormDown";
    }
  });

  // node_modules/grommet-icons/icons/FormNext.js
  var require_FormNext = __commonJS({
    "node_modules/grommet-icons/icons/FormNext.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.FormNext = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var FormNext3 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "FormNext"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "m9 6 6 6-6 6"
        }));
      });
      exports.FormNext = FormNext3;
      FormNext3.displayName = "FormNext";
    }
  });

  // node_modules/grommet-icons/icons/FormPrevious.js
  var require_FormPrevious = __commonJS({
    "node_modules/grommet-icons/icons/FormPrevious.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.FormPrevious = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var FormPrevious3 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "FormPrevious"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "m15 6-6 6 6 6"
        }));
      });
      exports.FormPrevious = FormPrevious3;
      FormPrevious3.displayName = "FormPrevious";
    }
  });

  // node_modules/grommet-icons/icons/FormUp.js
  var require_FormUp = __commonJS({
    "node_modules/grommet-icons/icons/FormUp.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.FormUp = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var FormUp4 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "FormUp"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "m18 15-6-6-6 6"
        }));
      });
      exports.FormUp = FormUp4;
      FormUp4.displayName = "FormUp";
    }
  });

  // node_modules/grommet-icons/icons/Next.js
  var require_Next = __commonJS({
    "node_modules/grommet-icons/icons/Next.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Next = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      var _utils = require_utils2();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Next3 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        var scaleProps = (0, _utils.useScaleProps)(props);
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "Next"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", _extends89({
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "m7 2 10 10L7 22"
        }, scaleProps)));
      });
      exports.Next = Next3;
      Next3.displayName = "Next";
    }
  });

  // node_modules/grommet-icons/icons/Pause.js
  var require_Pause = __commonJS({
    "node_modules/grommet-icons/icons/Pause.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Pause = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Pause2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "Pause"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "M3 21h6V3H3v18zm12 0h6V3h-6v18z"
        }));
      });
      exports.Pause = Pause2;
      Pause2.displayName = "Pause";
    }
  });

  // node_modules/grommet-icons/icons/Play.js
  var require_Play = __commonJS({
    "node_modules/grommet-icons/icons/Play.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Play = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Play2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "Play"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "m3 22 18-10L3 2z"
        }));
      });
      exports.Play = Play2;
      Play2.displayName = "Play";
    }
  });

  // node_modules/grommet-icons/icons/FormPin.js
  var require_FormPin = __commonJS({
    "node_modules/grommet-icons/icons/FormPin.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.FormPin = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var FormPin2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "FormPin"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "m4 19 4.455-4.454M12.273 5 18 10.727m-4.454-4.454L9.727 10.09s-2.545-.636-4.454 1.273l6.363 6.363c1.91-1.909 1.273-4.454 1.273-4.454l3.818-3.818-3.181-3.182Z"
        }));
      });
      exports.FormPin = FormPin2;
      FormPin2.displayName = "FormPin";
    }
  });

  // node_modules/grommet-icons/icons/Previous.js
  var require_Previous = __commonJS({
    "node_modules/grommet-icons/icons/Previous.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Previous = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      var _utils = require_utils2();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Previous3 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        var scaleProps = (0, _utils.useScaleProps)(props);
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "Previous"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", _extends89({
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "M17 2 7 12l10 10"
        }, scaleProps)));
      });
      exports.Previous = Previous3;
      Previous3.displayName = "Previous";
    }
  });

  // node_modules/grommet-icons/icons/StatusCriticalSmall.js
  var require_StatusCriticalSmall = __commonJS({
    "node_modules/grommet-icons/icons/StatusCriticalSmall.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.StatusCriticalSmall = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var StatusCriticalSmall2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 12 12",
          a11yTitle: "Status is critical"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fillRule: "evenodd",
          stroke: "#000",
          d: "M6.712 1.263a1.005 1.005 0 0 0-1.424 0L1.263 5.288a1.005 1.005 0 0 0 0 1.424l4.025 4.025a1.005 1.005 0 0 0 1.424 0l4.025-4.025a1.005 1.005 0 0 0 0-1.424L6.712 1.263z"
        }));
      });
      exports.StatusCriticalSmall = StatusCriticalSmall2;
      StatusCriticalSmall2.displayName = "StatusCriticalSmall";
    }
  });

  // node_modules/grommet-icons/icons/StatusGoodSmall.js
  var require_StatusGoodSmall = __commonJS({
    "node_modules/grommet-icons/icons/StatusGoodSmall.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.StatusGoodSmall = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var StatusGoodSmall2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 12 12",
          a11yTitle: "Status is okay"
        }, props), /* @__PURE__ */ _react["default"].createElement("circle", {
          cx: "6",
          cy: "6",
          r: "5",
          fillRule: "evenodd",
          stroke: "#000"
        }));
      });
      exports.StatusGoodSmall = StatusGoodSmall2;
      StatusGoodSmall2.displayName = "StatusGoodSmall";
    }
  });

  // node_modules/grommet-icons/icons/StatusWarningSmall.js
  var require_StatusWarningSmall = __commonJS({
    "node_modules/grommet-icons/icons/StatusWarningSmall.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.StatusWarningSmall = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var StatusWarningSmall2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 12 12",
          a11yTitle: "Status is warning"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fillRule: "evenodd",
          stroke: "#000",
          strokeLinejoin: "round",
          d: "m6 1 5 9H1z"
        }));
      });
      exports.StatusWarningSmall = StatusWarningSmall2;
      StatusWarningSmall2.displayName = "StatusWarningSmall";
    }
  });

  // node_modules/grommet-icons/icons/StatusUnknownSmall.js
  var require_StatusUnknownSmall = __commonJS({
    "node_modules/grommet-icons/icons/StatusUnknownSmall.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.StatusUnknownSmall = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var StatusUnknownSmall2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 12 12",
          a11yTitle: "Status is unknown"
        }, props), /* @__PURE__ */ _react["default"].createElement("rect", {
          width: "10",
          height: "10",
          x: "1",
          y: "1",
          fillRule: "evenodd",
          stroke: "#000",
          rx: "1"
        }));
      });
      exports.StatusUnknownSmall = StatusUnknownSmall2;
      StatusUnknownSmall2.displayName = "StatusUnknownSmall";
    }
  });

  // node_modules/grommet-icons/icons/Subtract.js
  var require_Subtract = __commonJS({
    "node_modules/grommet-icons/icons/Subtract.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Subtract = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Subtract2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "Subtract"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "M2 12h20"
        }));
      });
      exports.Subtract = Subtract2;
      Subtract2.displayName = "Subtract";
    }
  });

  // node_modules/grommet-icons/icons/Volume.js
  var require_Volume = __commonJS({
    "node_modules/grommet-icons/icons/Volume.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Volume = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Volume2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "Volume"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "M15 16a4 4 0 0 0 0-8m0 12c5 0 8-3.589 8-8s-3.589-8-8-8M1 12V8h5l6-5v18l-6-5H1v-4"
        }));
      });
      exports.Volume = Volume2;
      Volume2.displayName = "Volume";
    }
  });

  // node_modules/grommet-icons/icons/VolumeLow.js
  var require_VolumeLow = __commonJS({
    "node_modules/grommet-icons/icons/VolumeLow.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.VolumeLow = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var VolumeLow2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "VolumeLow"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "M1 8v8h5.099L12 21V3L6 8H1zm14 8a4 4 0 1 0 0-8"
        }));
      });
      exports.VolumeLow = VolumeLow2;
      VolumeLow2.displayName = "VolumeLow";
    }
  });

  // node_modules/grommet-icons/icons/Filter.js
  var require_Filter = __commonJS({
    "node_modules/grommet-icons/icons/Filter.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Filter = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Filter2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "Filter"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "m3 6 7 7v8h4v-8l7-7V3H3z"
        }));
      });
      exports.Filter = Filter2;
      Filter2.displayName = "Filter";
    }
  });

  // node_modules/grommet-icons/icons/Descend.js
  var require_Descend = __commonJS({
    "node_modules/grommet-icons/icons/Descend.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Descend = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Descend2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "Descend"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "m2 16 6 6 6-6M11 3h11M11 7h8m-8 4h5M8 22V2"
        }));
      });
      exports.Descend = Descend2;
      Descend2.displayName = "Descend";
    }
  });

  // node_modules/grommet-icons/icons/Search.js
  var require_Search = __commonJS({
    "node_modules/grommet-icons/icons/Search.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Search = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      var _utils = require_utils2();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Search3 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        var scaleProps = (0, _utils.useScaleProps)(props);
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "Search"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", _extends89({
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "m15 15 7 7-7-7zm-5.5 2a7.5 7.5 0 1 0 0-15 7.5 7.5 0 0 0 0 15z"
        }, scaleProps)));
      });
      exports.Search = Search3;
      Search3.displayName = "Search";
    }
  });

  // node_modules/grommet-icons/icons/FormSearch.js
  var require_FormSearch = __commonJS({
    "node_modules/grommet-icons/icons/FormSearch.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.FormSearch = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var FormSearch2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "FormSearch"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "M13.8 13.8 18 18l-4.2-4.2zM10.5 15a4.5 4.5 0 1 0 0-9 4.5 4.5 0 0 0 0 9z"
        }));
      });
      exports.FormSearch = FormSearch2;
      FormSearch2.displayName = "FormSearch";
    }
  });

  // node_modules/grommet-icons/icons/Blank.js
  var require_Blank = __commonJS({
    "node_modules/grommet-icons/icons/Blank.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Blank = void 0;
      var _react = _interopRequireDefault(require_react());
      var _StyledIcon = require_StyledIcon();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Blank3 = function Blank4(props) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          viewBox: "0 0 24 24",
          "aria-hidden": true
        }, props));
      };
      exports.Blank = Blank3;
    }
  });

  // node_modules/grommet-icons/icons/CircleAlert.js
  var require_CircleAlert = __commonJS({
    "node_modules/grommet-icons/icons/CircleAlert.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.CircleAlert = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var CircleAlert2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "CircleAlert"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          stroke: "#000",
          strokeWidth: "2",
          d: "M12 14V6m0 12v-2m0-14C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2z"
        }));
      });
      exports.CircleAlert = CircleAlert2;
      CircleAlert2.displayName = "CircleAlert";
    }
  });

  // node_modules/grommet-icons/icons/Ascending.js
  var require_Ascending = __commonJS({
    "node_modules/grommet-icons/icons/Ascending.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Ascending = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Ascending2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "Ascending"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "m12.08 7.286.354-.353.354.353L17 11.498l-.707.708-3.358-3.359V17h-1V8.847l-3.359 3.359-.707-.708 4.212-4.212z",
          fill: "#000"
        }));
      });
      exports.Ascending = Ascending2;
      Ascending2.displayName = "Ascending";
    }
  });

  // node_modules/grommet-icons/icons/Descending.js
  var require_Descending = __commonJS({
    "node_modules/grommet-icons/icons/Descending.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Descending = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Descending2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "Descending"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "m11.92 16.714-.354.353-.354-.353L7 12.502l.707-.708 3.359 3.359V7h1v8.153l3.358-3.359.707.708-4.212 4.212z",
          fill: "#000"
        }));
      });
      exports.Descending = Descending2;
      Descending2.displayName = "Descending";
    }
  });

  // node_modules/grommet-icons/icons/Unsorted.js
  var require_Unsorted = __commonJS({
    "node_modules/grommet-icons/icons/Unsorted.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Unsorted = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Unsorted2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "Unsorted"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "m15.204 15.321 1.597-1.597.707.707-2.45 2.45-.354.354-.353-.353-2.45-2.45.707-.708 1.596 1.597V7.217h1v8.104zm-5.9-6.407v8.104h1V8.914l1.597 1.597.707-.707-2.45-2.45L9.803 7l-.354.354L7 9.804l.707.707 1.597-1.597z",
          fill: "#000"
        }));
      });
      exports.Unsorted = Unsorted2;
      Unsorted2.displayName = "Unsorted";
    }
  });

  // node_modules/grommet-icons/icons/Hpe.js
  var require_Hpe = __commonJS({
    "node_modules/grommet-icons/icons/Hpe.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Hpe = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Hpe3 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 48 24",
          a11yTitle: "Hpe"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M2 6h44v12H2V6zm3 3h38v6H5V9z",
          fill: "#00C781"
        }));
      });
      exports.Hpe = Hpe3;
      Hpe3.displayName = "Hpe";
    }
  });

  // node_modules/grommet/utils/animation.js
  var require_animation = __commonJS({
    "node_modules/grommet/utils/animation.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.normalizeTiming = exports.animationObjectStyle = exports.animationEnding = exports.animationBounds = void 0;
      var _styledComponents = require_styled_components_browser_cjs();
      var PULSE_SIZES2 = {
        xsmall: 1.001,
        small: 1.01,
        medium: 1.1,
        large: 1.5,
        xlarge: 2
      };
      var SLIDE_SIZES2 = {
        xsmall: 1,
        small: 5,
        medium: 10,
        large: 50,
        xlarge: 200
      };
      var JIGGLE_SIZES2 = {
        xsmall: 0.1,
        small: 1,
        medium: 5,
        large: 400,
        xlarge: 1e3
      };
      var ZOOM_SIZES2 = {
        xsmall: 1e-3,
        small: 0.01,
        medium: 0.05,
        large: 0.1,
        xlarge: 0.5
      };
      var animationBounds3 = function animationBounds4(type, size) {
        if (size === void 0) {
          size = "medium";
        }
        if (type === "draw") {
          return ["", "stroke-dashoffset: 0"];
        }
        if (type === "fadeIn") {
          return ["opacity: 0;", "opacity: 1;"];
        }
        if (type === "fadeOut") {
          return ["opacity: 1;", "opacity: 0;"];
        }
        if (type === "jiggle") {
          var deg = JIGGLE_SIZES2[size];
          return ["transform: rotate(-" + deg + "deg);", "transform: rotate(" + deg + "deg);"];
        }
        if (type === "pulse") {
          return ["transform: scale(1);", "transform: scale(" + PULSE_SIZES2[size] + ")"];
        }
        if (type === "rotateRight") {
          return ["transform: rotate(0deg);", "transform: rotate(359deg);"];
        }
        if (type === "rotateLeft") {
          return ["transform: rotate(0deg);", "transform: rotate(-359deg);"];
        }
        if (type === "flipIn") {
          return ["transform: rotateY(90deg);", "transform: rotateY(0);"];
        }
        if (type === "flipOut") {
          return ["transform: rotateY(0);", "transform: rotateY(90deg);"];
        }
        if (type === "slideDown") {
          return ["transform: translateY(-" + SLIDE_SIZES2[size] + "%);", "transform: none;"];
        }
        if (type === "slideLeft") {
          return ["transform: translateX(" + SLIDE_SIZES2[size] + "%);", "transform: none;"];
        }
        if (type === "slideRight") {
          return ["transform: translateX(-" + SLIDE_SIZES2[size] + "%);", "transform: none;"];
        }
        if (type === "slideUp") {
          return ["transform: translateY(" + SLIDE_SIZES2[size] + "%);", "transform: none;"];
        }
        if (type === "zoomIn") {
          return ["transform: scale(" + (1 - ZOOM_SIZES2[size]) + ");", "transform: none;"];
        }
        if (type === "zoomOut") {
          return ["transform: scale(" + (1 + ZOOM_SIZES2[size]) + ");", "transform: none;"];
        }
        return [];
      };
      exports.animationBounds = animationBounds3;
      var normalizeTiming3 = function normalizeTiming4(time, defaultTiming) {
        return typeof time === "number" ? time / 1e3 + "s" : time || defaultTiming;
      };
      exports.normalizeTiming = normalizeTiming3;
      var animationEnding3 = function animationEnding4(type) {
        if (type === "draw") {
          return "linear forwards";
        }
        if (type === "jiggle") {
          return "alternate infinite";
        }
        if (type === "pulse") {
          return "alternate infinite";
        }
        if (type === "rotateRight" || type === "rotateLeft") {
          return "infinite linear";
        }
        return "forwards";
      };
      exports.animationEnding = animationEnding3;
      var animationObjectStyle3 = function animationObjectStyle4(animation, theme, themeObj) {
        var bounds2 = animationBounds3(animation.type, animation.size);
        var animationTheme = themeObj && themeObj.animation || theme.global.animation;
        if (bounds2) {
          var animationTransition = (0, _styledComponents.css)(["from{", ";}to{", ";}"], bounds2[0], bounds2[1]);
          var defaultDuration = function defaultDuration2() {
            return normalizeTiming3(animationTheme[animation.type] ? animationTheme[animation.type].duration : animation.duration, animationTheme.duration);
          };
          return (0, _styledComponents.css)(["", " ", " ", " ", ""], (0, _styledComponents.keyframes)(["", ""], animationTransition), normalizeTiming3(animation.duration, defaultDuration()), normalizeTiming3(animation.delay, "0s"), animationEnding3(animation.type));
        }
        return "";
      };
      exports.animationObjectStyle = animationObjectStyle3;
    }
  });

  // node_modules/grommet/utils/mixins.js
  var require_mixins = __commonJS({
    "node_modules/grommet/utils/mixins.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.parseMetricToNum = exports.getAvailableAtBadge = exports.fontSize = exports.findAllByType = exports.edgeToNum = exports.breakpointStyle = void 0;
      var _styledComponents = require_styled_components_browser_cjs();
      var parseMetricToNum5 = function parseMetricToNum6(metric) {
        if (typeof metric === "number")
          return metric;
        if (metric.match(/\s/) && true) {
          console.warn('Invalid single measurement value: "' + metric + '"');
        }
        return parseFloat(metric.match(/\d+(\.\d+)?/), 10);
      };
      exports.parseMetricToNum = parseMetricToNum5;
      var edgeToNum = function edgeToNum2(size, theme) {
        return size ? parseMetricToNum5(theme.global.edgeSize[size] || size) : 0;
      };
      exports.edgeToNum = edgeToNum;
      var fontSize = function fontSize2(size, lineHeight) {
        return (0, _styledComponents.css)(["font-size:", ";line-height:", ";"], function(props) {
          return parseMetricToNum5(size) / parseMetricToNum5(props.theme.global.font.size) * 1 + "rem";
        }, function(props) {
          return lineHeight || Math.ceil(parseMetricToNum5(size) / parseMetricToNum5(props.theme.global.lineHeight)) * (parseMetricToNum5(props.theme.global.lineHeight) / parseMetricToNum5(size)) + "px";
        });
      };
      exports.fontSize = fontSize;
      var breakpointStyle3 = function breakpointStyle4(breakpoint, content) {
        return (0, _styledComponents.css)(["@media only screen ", "{", ";}"], breakpoint.value && "and (max-width: " + breakpoint.value + "px)", content);
      };
      exports.breakpointStyle = breakpointStyle3;
      var findAllByType = function findAllByType2(component, type) {
        var matches = [];
        if (component.type === type) {
          matches.push(component);
        }
        if (component.children) {
          component.children.forEach(function(child) {
            matches = matches.concat(findAllByType2(child, type));
          });
        }
        return matches;
      };
      exports.findAllByType = findAllByType;
      var getAvailableAtBadge = function getAvailableAtBadge2(availableAt, componentType) {
        return [{
          url: "https://storybook.grommet.io/?selectedKind=" + componentType + "-" + availableAt + "&full=0&stories=1&panelRight=0",
          badge: "https://cdn-images-1.medium.com/fit/c/120/120/1*TD1P0HtIH9zF0UEH28zYtw.png",
          label: "Storybook"
        }, {
          url: "https://codesandbox.io/s/github/grommet/grommet-sandbox?initialpath=/" + availableAt.toLowerCase() + "&module=%2Fsrc%2F" + availableAt + ".js",
          badge: "https://codesandbox.io/static/img/play-codesandbox.svg",
          label: "CodeSandbox"
        }];
      };
      exports.getAvailableAtBadge = getAvailableAtBadge;
    }
  });

  // node_modules/grommet/utils/colors.js
  var require_colors2 = __commonJS({
    "node_modules/grommet/utils/colors.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.normalizeColor = exports.getRGBArray = exports.getRGBA = exports.colorIsDark = exports.canExtractRGBArray = void 0;
      var normalizeColor3 = function normalizeColor4(color, theme, dark) {
        var colorSpec = theme.global && theme.global.colors[color] !== void 0 ? theme.global.colors[color] : color;
        var result = colorSpec;
        if (colorSpec) {
          if ((dark === true || dark === void 0 && theme.dark) && colorSpec.dark !== void 0) {
            result = colorSpec.dark;
          } else if ((dark === false || !theme.dark) && colorSpec.light !== void 0) {
            result = colorSpec.light;
          }
        }
        if (result && theme.global && theme.global.colors[result] !== void 0) {
          result = normalizeColor4(result, theme, dark);
        }
        return result;
      };
      exports.normalizeColor = normalizeColor3;
      var parseHexToRGB3 = function parseHexToRGB4(color) {
        return color.length < 7 ? color.match(/[A-Za-z0-9]{1}/g).map(function(v) {
          return parseInt("" + v + v, 16);
        }) : (
          // https://stackoverflow.com/a/42429333
          color.match(/[A-Za-z0-9]{2}/g).map(function(v) {
            return parseInt(v, 16);
          })
        );
      };
      var hslToRGB3 = function hslToRGB4(h, s, l) {
        var r;
        var g;
        var b;
        if (s === 0 || s === "0") {
          r = l;
          g = l;
          b = l;
        } else {
          var hue2rgb = function hue2rgb2(p2, q2, inT) {
            var t = inT;
            if (t < 0)
              t += 1;
            if (t > 1)
              t -= 1;
            if (t < 0.16666667)
              return p2 + (q2 - p2) * 6 * t;
            if (t < 1 / 2)
              return q2;
            if (t < 0.66666667)
              return p2 + (q2 - p2) * (0.66666667 - t) * 6;
            return p2;
          };
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h + 0.33333333);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 0.33333333);
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
      };
      var hexExp2 = /^#[A-Za-z0-9]{3,4}$|^#[A-Za-z0-9]{6,8}$/;
      var rgbExp2 = /^rgba?\(\s?([0-9]*)\s?,\s?([0-9]*)\s?,\s?([0-9]*)\s?\)/;
      var rgbaExp2 = /^rgba?\(\s?([0-9]*)\s?,\s?([0-9]*)\s?,\s?([0-9]*)\s?,\s?([.0-9]*)\s?\)/;
      var hslExp2 = /^hsla?\(\s?([0-9]*)\s?,\s?([0-9]*)%?\s?,\s?([0-9]*)%?\s?.*?\)/;
      var canExtractRGBArray3 = function canExtractRGBArray4(color) {
        return hexExp2.test(color) || rgbExp2.test(color) || rgbaExp2.test(color) || hslExp2.test(color);
      };
      exports.canExtractRGBArray = canExtractRGBArray3;
      var getRGBArray3 = function getRGBArray4(color) {
        if (hexExp2.test(color)) {
          var _parseHexToRGB = parseHexToRGB3(color), red = _parseHexToRGB[0], green = _parseHexToRGB[1], blue = _parseHexToRGB[2], alpha = _parseHexToRGB[3];
          return [red, green, blue, alpha !== void 0 ? alpha / 255 : void 0];
        }
        var match2 = color.match(rgbExp2);
        if (match2) {
          return match2.splice(1).map(function(v) {
            return parseInt(v, 10);
          });
        }
        match2 = color.match(rgbaExp2);
        if (match2) {
          return match2.splice(1).map(function(v) {
            return parseFloat(v, 10);
          });
        }
        match2 = color.match(hslExp2);
        if (match2) {
          var _match$splice$map = match2.splice(1).map(function(v) {
            return parseInt(v, 10);
          }), h = _match$splice$map[0], s = _match$splice$map[1], l = _match$splice$map[2];
          return hslToRGB3(h / 360, s / 100, l / 100);
        }
        return color;
      };
      exports.getRGBArray = getRGBArray3;
      var colorIsDark3 = function colorIsDark4(color) {
        if (color && canExtractRGBArray3(color)) {
          var _getRGBArray = getRGBArray3(color), red = _getRGBArray[0], green = _getRGBArray[1], blue = _getRGBArray[2], alpha = _getRGBArray[3];
          if (alpha < 0.5)
            return void 0;
          var brightness = (299 * red + 587 * green + 114 * blue) / 1e3;
          return brightness < 125;
        }
        return void 0;
      };
      exports.colorIsDark = colorIsDark3;
      var getRGBA3 = function getRGBA4(color, opacity) {
        if (color && canExtractRGBArray3(color)) {
          var _getRGBArray2 = getRGBArray3(color), red = _getRGBArray2[0], green = _getRGBArray2[1], blue = _getRGBArray2[2], alpha = _getRGBArray2[3];
          var normalizedAlpha;
          if (opacity !== void 0) {
            normalizedAlpha = opacity;
          } else if (alpha !== void 0) {
            normalizedAlpha = alpha;
          } else {
            normalizedAlpha = 1;
          }
          return "rgba(" + red + ", " + green + ", " + blue + ", " + normalizedAlpha + ")";
        }
        return void 0;
      };
      exports.getRGBA = getRGBA3;
    }
  });

  // node_modules/grommet/utils/background.js
  var require_background = __commonJS({
    "node_modules/grommet/utils/background.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.selectedStyle = exports.normalizeBackground = exports.getHoverIndicatorStyle = exports.backgroundStyle = exports.backgroundIsDark = exports.backgroundAndTextColors = exports.activeStyle = void 0;
      var _styledComponents = require_styled_components_browser_cjs();
      var _colors = require_colors2();
      var evalStyle3 = function evalStyle4(arg, theme) {
        if (arg && Array.isArray(arg) && typeof arg[0] === "function") {
          return arg[0]({
            theme
          });
        }
        return arg;
      };
      var normalizeBackground3 = function normalizeBackground4(backgroundArg, theme) {
        var _theme$global$backgro;
        var background = ((_theme$global$backgro = theme.global.backgrounds) == null ? void 0 : _theme$global$backgro[backgroundArg]) || backgroundArg;
        var result = background;
        if (background) {
          if (theme.dark && background.dark && typeof background.dark !== "boolean") {
            result = background.dark;
          } else if (!theme.dark && background.light && typeof background.light !== "boolean") {
            result = background.light;
          }
          result = evalStyle3(result, theme);
        }
        return result;
      };
      exports.normalizeBackground = normalizeBackground3;
      var normalizeBackgroundColor5 = function normalizeBackgroundColor6(backgroundArg, theme) {
        var _theme$global$backgro2;
        var background = backgroundArg.color || backgroundArg;
        var result = (0, _colors.normalizeColor)(
          // Background color may be defined by theme.global.backgrounds or
          // theme.global.colors.
          ((_theme$global$backgro2 = theme.global.backgrounds) == null ? void 0 : _theme$global$backgro2[background]) || background,
          theme,
          backgroundArg.dark
        );
        return result;
      };
      var normalizeBackgroundImage3 = function normalizeBackgroundImage4(background, theme) {
        var result;
        if (background.image) {
          var _theme$global$backgro3, _theme$global$backgro4, _theme$global$backgro5;
          result = normalizeBackground3(background.dark ? (_theme$global$backgro3 = theme.global.backgrounds) == null ? void 0 : (_theme$global$backgro4 = _theme$global$backgro3[background.image]) == null ? void 0 : _theme$global$backgro4.dark : (_theme$global$backgro5 = theme.global.backgrounds) == null ? void 0 : _theme$global$backgro5[background.image], theme) || background.image;
        } else {
          var _theme$global$backgro6;
          var normalized = normalizeBackground3((_theme$global$backgro6 = theme.global.backgrounds) == null ? void 0 : _theme$global$backgro6[background], theme);
          result = typeof normalized === "object" ? normalizeBackgroundImage4(normalized, theme) : normalized;
        }
        return result;
      };
      var rotateBackground3 = function rotateBackground4(background, theme) {
        var backgroundImage = normalizeBackgroundImage3(background, theme);
        var result = backgroundImage;
        if (backgroundImage.lastIndexOf("linear-gradient", 0) === 0) {
          var regex = /\d{1,}deg\b,/gm;
          result = backgroundImage.lastIndexOf("deg,") >= 0 ? backgroundImage.replace(regex, background.rotate + "deg,") : backgroundImage.replace("linear-gradient(", "linear-gradient(" + background.rotate + "deg, ");
        } else {
          console.warn(
            // eslint-disable-next-line max-len
            "'background.rotate' property only supports 'background.image' containing a linear-gradient string."
          );
        }
        return result;
      };
      var backgroundIsDark3 = function backgroundIsDark4(backgroundArg, theme) {
        var background = normalizeBackground3(backgroundArg, theme);
        var result;
        if (background) {
          if (typeof background === "object") {
            var color = background.color, dark = background.dark, opacity = background.opacity;
            if (typeof dark === "boolean") {
              result = dark;
            } else if (color && // weak opacity means we keep the existing darkness
            (!opacity || opacity !== "weak")) {
              var backgroundColor = (0, _colors.normalizeColor)(background.color, theme);
              if (backgroundColor) {
                result = (0, _colors.colorIsDark)(backgroundColor);
              }
            }
          } else {
            var _color = (0, _colors.normalizeColor)(background, theme);
            if (_color) {
              result = (0, _colors.colorIsDark)(_color);
            }
          }
        }
        return result;
      };
      exports.backgroundIsDark = backgroundIsDark3;
      var darkContext3 = function darkContext4(backgroundColor) {
        var isDark = (0, _colors.colorIsDark)(backgroundColor);
        if (isDark === void 0)
          return void 0;
        return isDark ? "dark" : "light";
      };
      var backgroundAndTextColors3 = function backgroundAndTextColors4(backgroundArg, textArg, theme) {
        if (!backgroundArg)
          return [void 0, textArg];
        var global2 = theme.global;
        var background = normalizeBackground3(backgroundArg, theme);
        var text = textArg || global2.colors.text;
        var backgroundColor;
        var textColor;
        if (typeof background === "object") {
          if (background.dark === false) {
            textColor = text.light || text;
          } else if (background.dark) {
            textColor = text.dark || text;
          }
          if (background.color) {
            var color = normalizeBackgroundColor5(background, theme);
            var opacity = background.opacity === true ? global2.opacity.medium : global2.opacity[background.opacity] || background.opacity;
            backgroundColor = (0, _colors.getRGBA)(color, opacity) || color;
            if (!textColor && (opacity === void 0 || opacity > 0.3)) {
              var shade = darkContext3(backgroundColor, theme);
              textColor = (0, _colors.normalizeColor)(shade && text[shade] || text, theme);
            }
          }
        } else {
          backgroundColor = normalizeBackgroundColor5(background, theme);
          var _shade = darkContext3(backgroundColor, theme);
          var transparent;
          if (backgroundColor && (0, _colors.canExtractRGBArray)(backgroundColor)) {
            var colorArray3 = (0, _colors.getRGBArray)(backgroundColor);
            if (colorArray3[3] < 0.5)
              transparent = true;
          }
          if (_shade) {
            textColor = (0, _colors.normalizeColor)(text[_shade] || text, theme, _shade === "dark");
          } else if (transparent && text) {
            textColor = (0, _colors.normalizeColor)(text, theme);
          } else {
            if (backgroundColor !== "transparent")
              backgroundColor = void 0;
            if (text)
              textColor = (0, _colors.normalizeColor)(text, theme);
          }
        }
        if (textArg === false)
          textColor = void 0;
        return [backgroundColor, textColor];
      };
      exports.backgroundAndTextColors = backgroundAndTextColors3;
      var backgroundStyle3 = function backgroundStyle4(backgroundArg, theme, textColorArg) {
        if (backgroundArg === void 0)
          return void 0;
        var background = normalizeBackground3(backgroundArg, theme);
        var _backgroundAndTextCol = backgroundAndTextColors3(background, textColorArg, theme), backgroundColor = _backgroundAndTextCol[0], textColor = _backgroundAndTextCol[1];
        var backgroundImage = background.rotate ? rotateBackground3(background, theme) : normalizeBackgroundImage3(background, theme);
        var backgroundClipStyle = "";
        if (background.clip) {
          backgroundClipStyle = background.clip === "text" ? "-webkit-text-fill-color: transparent; \n           -webkit-background-clip: text; \n           background-clip: text;" : "background-clip: " + background.clip + ";";
        }
        if (typeof background === "string" && background.lastIndexOf("url", 0) === 0) {
          return (0, _styledComponents.css)(["background:", " no-repeat center center;background-size:cover;"], background);
        }
        if (backgroundImage) {
          var backgroundStyles = "\n      " + (backgroundColor ? "background-color: " + backgroundColor + ";" : "") + "\n      background-image: " + backgroundImage + ";\n      background-repeat: " + (typeof background === "object" && background.repeat || "no-repeat") + ";\n      background-position: " + (background.position || "center center") + ";\n      background-size: " + (background.size || "cover") + ";\n      " + backgroundClipStyle + "\n    ";
          return (0, _styledComponents.css)(["", " ", ""], textColor ? "color: " + textColor + ";" : "", !background.opacity ? backgroundStyles : "position: relative;\n        z-index: 0;\n        &:before {\n          content: '';\n          position: absolute;\n          top: 0;\n          right: 0;\n          left: 0;\n          bottom: 0;\n          z-index: -1;\n          border-radius: inherit;\n          " + backgroundStyles + "\n          opacity: " + (background.opacity === true ? theme.global.opacity.medium : theme.global.opacity[background.opacity] || background.opacity) + ";\n        }");
        }
        if (backgroundColor) {
          return (0, _styledComponents.css)(["background-color:", ";", ""], backgroundColor, textColor ? "color: " + textColor + ";" : "");
        }
        if (typeof background === "string")
          return (0, _styledComponents.css)(["background:", ";"], (0, _colors.normalizeColor)(background, theme));
        return void 0;
      };
      exports.backgroundStyle = backgroundStyle3;
      var activeStyle2 = (0, _styledComponents.css)(["", ""], function(props) {
        return backgroundStyle3((0, _colors.normalizeColor)(props.theme.global.active.background, props.theme), props.theme, props.theme.global.active.color);
      });
      exports.activeStyle = activeStyle2;
      var selectedStyle2 = (0, _styledComponents.css)(["", ""], function(props) {
        return backgroundStyle3((0, _colors.normalizeColor)(props.theme.global.selected.background, props.theme), props.theme, props.theme.global.selected.color);
      });
      exports.selectedStyle = selectedStyle2;
      var getHoverIndicatorStyle3 = function getHoverIndicatorStyle4(hoverIndicator, theme) {
        var background;
        var elevation;
        if (hoverIndicator === true || hoverIndicator === "background") {
          background = theme.global.hover.background;
        } else if (typeof hoverIndicator === "object") {
          if (hoverIndicator.elevation || hoverIndicator.background) {
            elevation = hoverIndicator.elevation;
            background = hoverIndicator.background;
          } else
            background = hoverIndicator;
        } else {
          background = hoverIndicator;
        }
        return (0, _styledComponents.css)(["", " ", ""], backgroundStyle3(background, theme, theme.global.hover.color), elevation && "box-shadow: " + theme.global.elevation[theme.dark ? "dark" : "light"][elevation] + ";");
      };
      exports.getHoverIndicatorStyle = getHoverIndicatorStyle3;
    }
  });

  // node_modules/grommet/utils/border.js
  var require_border = __commonJS({
    "node_modules/grommet/utils/border.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.responsiveBorderStyle = exports.borderStyle = void 0;
      var _styledComponents = require_styled_components_browser_cjs();
      var _colors = require_colors2();
      var _mixins = require_mixins();
      var responsiveBorderStyle3 = function responsiveBorderStyle4(data, theme) {
        var color = (0, _colors.normalizeColor)(data.color || "border", theme);
        var borderSize = data.size || "xsmall";
        var style = data.style || "solid";
        var side = typeof data === "string" ? data : data.side || "all";
        var breakpoint = theme.box.responsiveBreakpoint && theme.global.breakpoints[theme.box.responsiveBreakpoint];
        if (!breakpoint.borderSize)
          breakpoint.borderSize = theme.global.borderSize;
        var value = breakpoint && (breakpoint.borderSize[borderSize] || borderSize) && style + " " + (breakpoint.borderSize[borderSize] || borderSize) + " " + color;
        if (!value)
          return void 0;
        if (side === "top" || side === "bottom" || side === "left" || side === "right")
          return "border-" + side + ": " + value + ";";
        if (side === "end" || side === "start")
          return "border-inline-" + side + ": " + value + ";";
        if (side === "vertical")
          return "\n      border-left: " + value + ";\n      border-right: " + value + ";\n    ";
        if (side === "horizontal")
          return "\n      border-top: " + value + ";\n      border-bottom: " + value + ";\n    ";
        if (side === "between")
          return void 0;
        return "border: " + value + ";";
      };
      exports.responsiveBorderStyle = responsiveBorderStyle3;
      var borderStyle3 = function borderStyle4(borderData, responsive, theme) {
        var borderStyles = [];
        (Array.isArray(borderData) ? borderData : [borderData]).forEach(function(data) {
          var styles = [];
          var color = (0, _colors.normalizeColor)(data.color || "border", theme);
          var borderSize = data.size || "xsmall";
          var style = data.style || "solid";
          var side = typeof data === "string" ? data : data.side || "all";
          var value = style + " " + (theme.global.borderSize[borderSize] || borderSize) + " " + color;
          var responsiveStyle = responsive && responsiveBorderStyle3(data, theme);
          var breakpoint = responsiveStyle && theme.box.responsiveBreakpoint && theme.global.breakpoints[theme.box.responsiveBreakpoint];
          if (side === "top" || side === "bottom" || side === "left" || side === "right") {
            styles.push("border-" + side + ": " + value + ";");
            if (responsiveStyle) {
              styles.push((0, _mixins.breakpointStyle)(breakpoint, responsiveStyle));
            }
          } else if (side === "end" || side === "start") {
            styles.push((0, _styledComponents.css)(["border-inline-", ":", ";"], side, value));
            if (responsiveStyle) {
              styles.push((0, _mixins.breakpointStyle)(breakpoint, responsiveStyle));
            }
          } else if (side === "vertical") {
            styles.push((0, _styledComponents.css)(["border-left:", ";border-right:", ";"], value, value));
            if (responsiveStyle) {
              styles.push((0, _mixins.breakpointStyle)(breakpoint, responsiveStyle));
            }
          } else if (side === "horizontal") {
            styles.push((0, _styledComponents.css)(["border-top:", ";border-bottom:", ";"], value, value));
            if (responsiveStyle) {
              styles.push((0, _mixins.breakpointStyle)(breakpoint, responsiveStyle));
            }
          } else if (side === "between") {
          } else {
            styles.push((0, _styledComponents.css)(["border:", ";"], value));
            if (responsiveStyle) {
              styles.push((0, _mixins.breakpointStyle)(breakpoint, responsiveStyle));
            }
          }
          borderStyles.push(styles);
        });
        return borderStyles;
      };
      exports.borderStyle = borderStyle3;
    }
  });

  // node_modules/grommet/utils/dates.js
  var require_dates = __commonJS({
    "node_modules/grommet/utils/dates.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.setHoursWithOffset = void 0;
      var setHoursWithOffset = function setHoursWithOffset2(date) {
        var newDate = new Date(date);
        if ((date == null ? void 0 : date.indexOf("T")) === -1) {
          var offset2 = newDate.getTimezoneOffset();
          var hour = newDate.getHours();
          newDate.setHours(hour, offset2 < 0 ? -offset2 : offset2);
        }
        return newDate;
      };
      exports.setHoursWithOffset = setHoursWithOffset;
    }
  });

  // node_modules/grommet/utils/DOM.js
  var require_DOM = __commonJS({
    "node_modules/grommet/utils/DOM.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.withinDropPortal = exports.shouldKeepFocus = exports.setFocusWithoutScroll = exports.makeNodeUnfocusable = exports.makeNodeFocusable = exports.isNodeBeforeScroll = exports.isNodeAfterScroll = exports.isFocusable = exports.getNewContainer = exports.getFirstFocusableDescendant = exports.findVisibleParent = exports.findScrollParents = exports.findScrollParent = exports.findButtonParent = exports.containsFocus = void 0;
      var findScrollParent3 = function findScrollParent4(element, horizontal12) {
        var result;
        if (element) {
          var parent = element.parentNode;
          while (!result && parent && parent.getBoundingClientRect) {
            var rect = parent.getBoundingClientRect();
            if (horizontal12) {
              if (rect.width && parent.scrollWidth > rect.width + 10) {
                result = parent;
              }
            } else if (rect.height && parent.scrollHeight > rect.height + 10) {
              result = parent;
            }
            parent = parent.parentNode;
          }
          if (!result) {
            result = document;
          } else if (result.tagName.toLowerCase() === "body") {
            result = document;
          }
        }
        return result;
      };
      exports.findScrollParent = findScrollParent3;
      var documentTags2 = ["html", "body"];
      var findScrollParents3 = function findScrollParents4(element, horizontal12) {
        var result = [];
        if (element) {
          var parent = element.parentNode;
          while (parent && parent.getBoundingClientRect) {
            var rect = parent.getBoundingClientRect();
            if (horizontal12) {
              if (rect.width && parent.scrollWidth > rect.width + 10) {
                result.push(parent);
              }
            } else if (rect.height && parent.scrollHeight > rect.height + 10) {
              result.push(parent);
            }
            parent = parent.parentNode;
          }
          if (result.length && documentTags2.includes(result[0].tagName.toLowerCase())) {
            result.length = 0;
          }
          result.push(document);
        }
        return result;
      };
      exports.findScrollParents = findScrollParents3;
      var containsFocus3 = function containsFocus4(node) {
        var root = node.getRootNode();
        var element = root.activeElement;
        while (element) {
          if (element === node)
            break;
          element = element.parentElement;
        }
        return !!element;
      };
      exports.containsFocus = containsFocus3;
      var withinDropPortal3 = function withinDropPortal4(node, portalContext) {
        var root = node == null ? void 0 : node.getRootNode();
        var element = node;
        var portalId;
        while (element && element !== root) {
          if (element.hasAttribute("data-g-portal-id")) {
            portalId = element.getAttribute("data-g-portal-id");
            element = root;
          } else {
            element = element.parentElement;
          }
        }
        if (portalId === void 0 || portalContext.indexOf(parseInt(portalId, 10)) !== -1)
          return false;
        return true;
      };
      exports.withinDropPortal = withinDropPortal3;
      var isFocusable3 = function isFocusable4(element) {
        var tagName = element.tagName.toLowerCase();
        return tagName === "input" || tagName === "select" || tagName === "textarea";
      };
      exports.isFocusable = isFocusable3;
      var getFirstFocusableDescendant3 = function getFirstFocusableDescendant4(element) {
        var children = element.getElementsByTagName("*");
        for (var i = 0; i < children.length; i += 1) {
          var child = children[i];
          if (isFocusable3(child)) {
            return child;
          }
        }
        return void 0;
      };
      exports.getFirstFocusableDescendant = getFirstFocusableDescendant3;
      var shouldKeepFocus3 = function shouldKeepFocus4(root) {
        var element = root.activeElement;
        if (isFocusable3(element))
          return true;
        return !!getFirstFocusableDescendant3(element);
      };
      exports.shouldKeepFocus = shouldKeepFocus3;
      var getNewContainer3 = function getNewContainer4(target, targetChildPosition) {
        if (target === void 0) {
          target = document.body;
        }
        var container = document.createElement("div");
        if (targetChildPosition === "first") {
          target.prepend(container);
        } else {
          target.appendChild(container);
        }
        return container;
      };
      exports.getNewContainer = getNewContainer3;
      var setFocusWithoutScroll3 = function setFocusWithoutScroll4(element) {
        var x = window.scrollX;
        var y = window.scrollY;
        element.focus();
        window.scrollTo(x, y);
      };
      exports.setFocusWithoutScroll = setFocusWithoutScroll3;
      var TABINDEX2 = "tabindex";
      var TABINDEX_STATE2 = "data-g-tabindex";
      var makeNodeFocusable3 = function makeNodeFocusable4(node) {
        if (!node.hasAttribute("aria-live")) {
          node.removeAttribute("aria-hidden");
          var elements = node.getElementsByTagName("*");
          Array.prototype.filter.call(elements || [], function(element) {
            return element.hasAttribute(TABINDEX_STATE2);
          }).forEach(function(element) {
            var prior = element.getAttribute(TABINDEX_STATE2);
            if (prior >= 0) {
              element.setAttribute(TABINDEX2, element.getAttribute(TABINDEX_STATE2));
            } else if (prior === "none") {
              element.removeAttribute(TABINDEX2);
            }
            element.removeAttribute(TABINDEX_STATE2);
          });
        }
      };
      exports.makeNodeFocusable = makeNodeFocusable3;
      var autoFocusingTags2 = /(a|area|input|select|textarea|button|iframe)$/;
      var makeNodeUnfocusable3 = function makeNodeUnfocusable4(node) {
        if (!node.hasAttribute("aria-live")) {
          node.setAttribute("aria-hidden", true);
          var elements = node.getElementsByTagName("*");
          Array.prototype.filter.call(elements || [], function(element) {
            return element.getAttribute(TABINDEX2) !== null;
          }).forEach(function(element) {
            element.setAttribute(TABINDEX_STATE2, element.getAttribute(TABINDEX2));
            element.setAttribute(TABINDEX2, -1);
          });
          Array.prototype.filter.call(elements || [], function(element) {
            var currentTag = element.tagName.toLowerCase();
            return currentTag.match(autoFocusingTags2) && element.focus && element.getAttribute(TABINDEX_STATE2) === null;
          }).forEach(function(element) {
            element.setAttribute(TABINDEX_STATE2, "none");
            element.setAttribute(TABINDEX2, -1);
          });
        }
      };
      exports.makeNodeUnfocusable = makeNodeUnfocusable3;
      var findVisibleParent3 = function findVisibleParent4(element) {
        if (element) {
          return element.offsetParent ? element : findVisibleParent4(element.parentElement) || element;
        }
        return void 0;
      };
      exports.findVisibleParent = findVisibleParent3;
      var isNodeAfterScroll3 = function isNodeAfterScroll4(node, target) {
        var _node$getBoundingClie = node.getBoundingClientRect(), bottom2 = _node$getBoundingClie.bottom;
        var _ref = target.getBoundingClientRect ? target.getBoundingClientRect() : {
          height: 0,
          top: 0
        }, height = _ref.height, top2 = _ref.top;
        return bottom2 >= top2 + height;
      };
      exports.isNodeAfterScroll = isNodeAfterScroll3;
      var isNodeBeforeScroll3 = function isNodeBeforeScroll4(node, target) {
        var _node$getBoundingClie2 = node.getBoundingClientRect(), top2 = _node$getBoundingClie2.top;
        var _ref2 = target.getBoundingClientRect ? target.getBoundingClientRect() : {
          top: 0
        }, targetTop = _ref2.top;
        return top2 <= targetTop;
      };
      exports.isNodeBeforeScroll = isNodeBeforeScroll3;
      var findButtonParent3 = function findButtonParent4(element) {
        if (element && element.nodeName !== "BUTTON" && element.nodeName !== "A")
          return findButtonParent4(element.parentElement);
        return element;
      };
      exports.findButtonParent = findButtonParent3;
    }
  });

  // node_modules/grommet/utils/graphics.js
  var require_graphics = __commonJS({
    "node_modules/grommet/utils/graphics.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.translateEndAngle = exports.polarToCartesian = exports.baseUnit = exports.arcCommands = void 0;
      var POST_DECIMAL_DIGITS = 10;
      var baseUnit = 24;
      exports.baseUnit = baseUnit;
      var polarToCartesian = function polarToCartesian2(centerX, centerY, radius, angleInDegrees) {
        var angleInRadians = (angleInDegrees - 90) * Math.PI / 180;
        return {
          x: centerX + radius * Math.cos(angleInRadians),
          y: centerY + radius * Math.sin(angleInRadians)
        };
      };
      exports.polarToCartesian = polarToCartesian;
      var arcCommands = function arcCommands2(centerX, centerY, radius, startAngle, endAngle) {
        var normalizedEndAngle = endAngle;
        if (endAngle > startAngle && endAngle - startAngle >= 360) {
          normalizedEndAngle = startAngle + 359.99;
        }
        var start3 = polarToCartesian(centerX, centerY, radius, normalizedEndAngle);
        var end2 = polarToCartesian(centerX, centerY, radius, startAngle);
        var arcSweep = normalizedEndAngle - startAngle <= 180 ? "0" : "1";
        var d = ["M", start3.x.toFixed(POST_DECIMAL_DIGITS), start3.y.toFixed(POST_DECIMAL_DIGITS), "A", radius.toFixed(POST_DECIMAL_DIGITS), radius.toFixed(POST_DECIMAL_DIGITS), 0, arcSweep, 0, end2.x.toFixed(POST_DECIMAL_DIGITS), end2.y.toFixed(POST_DECIMAL_DIGITS)].join(" ");
        return d;
      };
      exports.arcCommands = arcCommands;
      var translateEndAngle = function translateEndAngle2(startAngle, anglePer, value) {
        return Math.max(0, startAngle + anglePer * value) % 360;
      };
      exports.translateEndAngle = translateEndAngle;
    }
  });

  // node_modules/grommet/utils/responsive.js
  var require_responsive = __commonJS({
    "node_modules/grommet/utils/responsive.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.getDeviceBreakpoint = exports.getBreakpointStyle = exports.getBreakpoint = void 0;
      var getBreakpoint3 = function getBreakpoint4(viewportWidth, theme) {
        var sortedBreakpoints = Object.keys(theme.global.breakpoints).sort(function(a, b) {
          var first = theme.global.breakpoints[a];
          var second = theme.global.breakpoints[b];
          if (!first)
            return 1;
          if (!second)
            return -1;
          if (!first.value)
            return 1;
          if (!second.value)
            return -1;
          return first.value - second.value;
        });
        var lastBreakpoint = sortedBreakpoints[sortedBreakpoints.length - 1];
        var result = sortedBreakpoints.find(function(name) {
          var breakpoint = theme.global.breakpoints[name];
          return !breakpoint.value || breakpoint.value >= viewportWidth ? name : false;
        });
        return result || lastBreakpoint;
      };
      exports.getBreakpoint = getBreakpoint3;
      var getDeviceBreakpoint3 = function getDeviceBreakpoint4(type, theme) {
        return theme.global.deviceBreakpoints[type];
      };
      exports.getDeviceBreakpoint = getDeviceBreakpoint3;
      var getBreakpointStyle3 = function getBreakpointStyle4(theme, breakpointSize) {
        var breakpoint = breakpointSize && theme.global.breakpoints[breakpointSize] || {};
        if (!breakpoint.edgeSize)
          breakpoint.edgeSize = theme.global.edgeSize;
        if (!breakpoint.borderSize)
          breakpoint.borderSize = theme.global.borderSize;
        if (!breakpoint.size)
          breakpoint.size = theme.global.size;
        return breakpoint;
      };
      exports.getBreakpointStyle = getBreakpointStyle3;
    }
  });

  // node_modules/grommet/utils/styles.js
  var require_styles2 = __commonJS({
    "node_modules/grommet/utils/styles.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.widthStyle = exports.unfocusStyle = exports.textAlignStyle = exports.sizeStyle = exports.roundStyle = exports.plainInputStyle = exports.overflowStyle = exports.kindPartStyles = exports.inputStyle = exports.heightStyle = exports.getInputPadBySide = exports.genericStyles = exports.focusStyle = exports.fillStyle = exports.edgeStyle = exports.disabledStyle = exports.controlBorderStyle = exports.baseStyle = exports.alignStyle = exports.alignContentStyle = void 0;
      var _styledComponents = require_styled_components_browser_cjs();
      var _background = require_background();
      var _colors = require_colors2();
      var _responsive = require_responsive();
      var _mixins = require_mixins();
      var baseStyle2 = (0, _styledComponents.css)(["font-family:", ";font-size:", ";line-height:", ";font-weight:", ";", " ", " box-sizing:border-box;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;"], function(props) {
        return props.theme.global.font.family;
      }, function(props) {
        return props.theme.global.font.size;
      }, function(props) {
        return props.theme.global.font.height;
      }, function(props) {
        return props.theme.global.font.weight;
      }, function(props) {
        return props.theme.global.font.variant && "\n    font-variant:" + props.theme.global.font.variant + ";\n  ";
      }, function(props) {
        return !props.plain && (0, _background.backgroundStyle)(props.theme.baseBackground, props.theme);
      });
      exports.baseStyle = baseStyle2;
      var controlBorderStyle2 = (0, _styledComponents.css)(["border:", " solid ", ";border-radius:", ";"], function(props) {
        return props.theme.global.control.border.width;
      }, function(props) {
        return (0, _colors.normalizeColor)(props.theme.global.control.border.color || "border", props.theme);
      }, function(props) {
        return props.theme.global.control.border.radius;
      });
      exports.controlBorderStyle = controlBorderStyle2;
      var edgeStyle3 = function edgeStyle4(kind, data, responsive, responsiveBreakpoint, theme) {
        var breakpoint = responsiveBreakpoint && theme.global.breakpoints[responsiveBreakpoint];
        if (typeof data === "string") {
          return (0, _styledComponents.css)(["", ":", ";", ";"], kind, theme.global.edgeSize[data] || data, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n        " + kind + ": " + (breakpoint.edgeSize[data] || data) + ";\n      ") : "");
        }
        var result = [];
        var horizontal12 = data.horizontal, vertical12 = data.vertical, top2 = data.top, bottom2 = data.bottom, left2 = data.left, right2 = data.right;
        var horizontalVerticalEqual = horizontal12 && vertical12 && horizontal12 === vertical12;
        var allSidesEqual = top2 && bottom2 && left2 && right2 && top2 === bottom2 === left2 === right2;
        if (horizontalVerticalEqual || allSidesEqual) {
          var value = horizontalVerticalEqual ? horizontal12 : top2;
          return (0, _styledComponents.css)(["", ":", ";", ";"], kind, theme.global.edgeSize[value] || value, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n        " + kind + ": " + (breakpoint.edgeSize[value] || value) + ";\n      ") : "");
        }
        if (horizontal12) {
          result.push((0, _styledComponents.css)(["", "-left:", ";", "-right:", ";", ";"], kind, theme.global.edgeSize[horizontal12] || horizontal12, kind, theme.global.edgeSize[horizontal12] || horizontal12, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-left: " + (breakpoint.edgeSize[horizontal12] || horizontal12) + ";\n          " + kind + "-right: " + (breakpoint.edgeSize[horizontal12] || horizontal12) + ";\n        ") : ""));
        }
        if (vertical12) {
          result.push((0, _styledComponents.css)(["", "-top:", ";", "-bottom:", ";", ";"], kind, theme.global.edgeSize[vertical12] || vertical12, kind, theme.global.edgeSize[vertical12] || vertical12, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-top: " + (breakpoint.edgeSize[vertical12] || vertical12) + ";\n          " + kind + "-bottom: " + (breakpoint.edgeSize[vertical12] || vertical12) + ";\n        ") : ""));
        }
        if (top2) {
          result.push((0, _styledComponents.css)(["", "-top:", ";", ";"], kind, theme.global.edgeSize[top2] || top2, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-top: " + (breakpoint.edgeSize[top2] || top2) + ";\n        ") : ""));
        }
        if (bottom2) {
          result.push((0, _styledComponents.css)(["", "-bottom:", ";", ";"], kind, theme.global.edgeSize[bottom2] || bottom2, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-bottom: " + (breakpoint.edgeSize[bottom2] || bottom2) + ";\n        ") : ""));
        }
        if (left2) {
          result.push((0, _styledComponents.css)(["", "-left:", ";", ";"], kind, theme.global.edgeSize[left2] || left2, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-left: " + (breakpoint.edgeSize[left2] || left2) + ";\n        ") : ""));
        }
        if (right2) {
          result.push((0, _styledComponents.css)(["", "-right:", ";", ";"], kind, theme.global.edgeSize[right2] || right2, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-right: " + (breakpoint.edgeSize[right2] || right2) + ";\n        ") : ""));
        }
        if (data.start) {
          result.push((0, _styledComponents.css)(["", "-inline-start:", ";", ";"], kind, theme.global.edgeSize[data.start] || data.start, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-inline-start: " + (breakpoint.edgeSize[data.start] || data.start) + ";\n        ") : ""));
        }
        if (data.end) {
          result.push((0, _styledComponents.css)(["", "-inline-end:", ";", ";"], kind, theme.global.edgeSize[data.end] || data.end, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-inline-end: " + (breakpoint.edgeSize[data.end] || data.end) + ";\n        ") : ""));
        }
        return result;
      };
      exports.edgeStyle = edgeStyle3;
      var fillStyle10 = function fillStyle11(fillProp) {
        if (fillProp === "horizontal") {
          return "width: 100%;";
        }
        if (fillProp === "vertical") {
          return "height: 100%;";
        }
        if (fillProp) {
          return "\n      width: 100%;\n      height: 100%;\n    ";
        }
        return void 0;
      };
      exports.fillStyle = fillStyle10;
      var focusStyles3 = function focusStyles4(props, _temp) {
        var _ref = _temp === void 0 ? {} : _temp, forceOutline = _ref.forceOutline, justBorder = _ref.justBorder;
        var focus = props.theme.global.focus;
        if (!focus || forceOutline && !focus.outline) {
          var color = (0, _colors.normalizeColor)("focus", props.theme);
          if (color)
            return "outline: 2px solid " + color + ";";
          return "";
        }
        if (focus.outline && (!focus.border || !justBorder)) {
          if (typeof focus.outline === "object") {
            var _color = (0, _colors.normalizeColor)(focus.outline.color || "focus", props.theme);
            var size = focus.outline.size || "2px";
            return "\n        outline-offset: 0px;\n        outline: " + size + " solid " + _color + ";\n      ";
          }
          return "outline: " + focus.outline + ";";
        }
        if (focus.shadow && (!focus.border || !justBorder)) {
          if (typeof focus.shadow === "object") {
            var _color2 = (0, _colors.normalizeColor)(
              // If there is a focus.border.color, use that for shadow too.
              // This is for backwards compatibility in v2.
              focus.border && focus.border.color || focus.shadow.color || "focus",
              props.theme
            );
            var _size = focus.shadow.size || "2px";
            return "\n        outline: none;\n        box-shadow: 0 0 " + _size + " " + _size + " " + _color2 + ";\n      ";
          }
          return "\n      outline: none;\n      box-shadow: " + focus.shadow + ";\n    ";
        }
        if (focus.border) {
          var _color3 = (0, _colors.normalizeColor)(focus.border.color || "focus", props.theme);
          return "\n      outline: none;\n      border-color: " + _color3 + ";\n    ";
        }
        return "";
      };
      var unfocusStyles3 = function unfocusStyles4(props, _temp2) {
        var _ref2 = _temp2 === void 0 ? {} : _temp2, forceOutline = _ref2.forceOutline, justBorder = _ref2.justBorder;
        var focus = props.theme.global.focus;
        if (!focus || forceOutline && !focus.outline) {
          var color = (0, _colors.normalizeColor)("focus", props.theme);
          if (color)
            return "outline: none;";
          return "";
        }
        if (focus.outline && (!focus.border || !justBorder)) {
          if (typeof focus.outline === "object") {
            return "\n        outline-offset: 0px;\n        outline: none;\n      ";
          }
          return "outline: none;";
        }
        if (focus.shadow && (!focus.border || !justBorder)) {
          if (typeof focus.shadow === "object") {
            return "\n        outline: none;\n        box-shadow: none;\n      ";
          }
          return "\n      outline: none;\n      box-shadow: none;\n    ";
        }
        if (focus.border) {
          return "\n      outline: none;\n      border-color: none;\n    ";
        }
        return "";
      };
      var focusStyle3 = function focusStyle4(_temp3) {
        var _ref3 = _temp3 === void 0 ? {} : _temp3, forceOutline = _ref3.forceOutline, justBorder = _ref3.justBorder, skipSvgChildren = _ref3.skipSvgChildren;
        return (0, _styledComponents.css)(["", " ", " ", ""], function(props) {
          return !skipSvgChildren && "\n  > circle,\n  > ellipse,\n  > line,\n  > path,\n  > polygon,\n  > polyline,\n  > rect {\n    " + focusStyles3(props) + "\n  }";
        }, function(props) {
          return focusStyles3(props, {
            forceOutline,
            justBorder
          });
        }, !forceOutline && "\n  ::-moz-focus-inner {\n    border: 0;\n  }\n  ");
      };
      exports.focusStyle = focusStyle3;
      var unfocusStyle3 = function unfocusStyle4(_temp4) {
        var _ref4 = _temp4 === void 0 ? {} : _temp4, forceOutline = _ref4.forceOutline, justBorder = _ref4.justBorder, skipSvgChildren = _ref4.skipSvgChildren;
        return (0, _styledComponents.css)(["", " ", " ", ""], function(props) {
          return !skipSvgChildren && "\n  > circle,\n  > ellipse,\n  > line,\n  > path,\n  > polygon,\n  > polyline,\n  > rect {\n    " + unfocusStyles3(props) + "\n  }";
        }, function(props) {
          return unfocusStyles3(props, {
            forceOutline,
            justBorder
          });
        }, !forceOutline && "\n  ::-moz-focus-inner {\n    border: 0;\n  }\n  ");
      };
      exports.unfocusStyle = unfocusStyle3;
      var adjustPad3 = function adjustPad4(props, value) {
        return (0, _mixins.parseMetricToNum)((props.theme.global.edgeSize[value] || value) + "px") + (0, _mixins.parseMetricToNum)(props.theme.global.control.border.width + "px") + "px";
      };
      var getInputPadBySide3 = function getInputPadBySide4(props, side) {
        if (typeof props.theme.global.input.padding !== "object") {
          var _adjustedPad = adjustPad3(props, props.theme.global.input.padding);
          return _adjustedPad;
        }
        var orientation;
        if (side === "left" || side === "right")
          orientation = "horizontal";
        else if (side === "top" || side === "bottom")
          orientation = "vertical";
        else
          orientation = void 0;
        var pad = props.theme.global.input.padding[side] || props.theme.global.input.padding[orientation];
        var adjustedPad = adjustPad3(props, pad);
        return adjustedPad;
      };
      exports.getInputPadBySide = getInputPadBySide3;
      var placeholderColor2 = (0, _styledComponents.css)(["color:", ";"], function(props) {
        return (0, _colors.normalizeColor)(props.theme.global.colors.placeholder, props.theme);
      });
      var placeholderStyle2 = (0, _styledComponents.css)(["&::-webkit-input-placeholder{", ";}&::-moz-placeholder{", ";}&:-ms-input-placeholder{", ";}"], placeholderColor2, placeholderColor2, placeholderColor2);
      var inputSizeStyle3 = function inputSizeStyle4(props) {
        var data = props.theme.text[props.size];
        if (!data) {
          return (0, _styledComponents.css)(["font-size:", ";"], props.size);
        }
        return (0, _styledComponents.css)(["font-size:", ";line-height:", ";"], data.size, data.height);
      };
      var inputStyle2 = (0, _styledComponents.css)(["box-sizing:border-box;", " font-family:inherit;border:none;-webkit-appearance:none;background:transparent;color:inherit;width:100%;", " ", " ", " margin:0;", " &:focus{", ";}", " ", "::-webkit-search-decoration{-webkit-appearance:none;}&::-moz-focus-inner{border:none;outline:none;}&:-moz-placeholder,&::-moz-placeholder{opacity:1;}", ""], function(props) {
        var _props$theme$text$pro;
        return "font-size: " + (props.theme.global.input.font.size ? ((_props$theme$text$pro = props.theme.text[props.theme.global.input.font.size]) == null ? void 0 : _props$theme$text$pro.size) || props.theme.global.input.font.size : "inherit") + ";";
      }, function(props) {
        return props.theme.global.input.font.height && "line-height: " + props.theme.global.input.font.height + ";";
      }, function(props) {
        return props.theme.global.input.padding && typeof props.theme.global.input.padding !== "object" ? (
          // On a breaking change release, this condition could be removed and
          // just the edgeStyle could remain. Currently, this is needed for
          // backwards compatibility since we are placing the calculation in
          // base.js
          "padding: " + ((0, _mixins.parseMetricToNum)(props.theme.global.edgeSize[props.theme.global.input.padding] || props.theme.global.input.padding) - (0, _mixins.parseMetricToNum)(props.theme.global.control.border.width)) + "px;"
        ) : edgeStyle3("padding", props.theme.global.input.padding, props.responsive, props.theme.box.responsiveBreakpoint, props.theme);
      }, function(props) {
        return (
          // for backwards compatibility, check if props.theme.global.input.weight
          (props.theme.global.input.weight || props.theme.global.input.font.weight) && (0, _styledComponents.css)(["font-weight:", ";"], props.theme.global.input.weight || props.theme.global.input.font.weight)
        );
      }, function(props) {
        return props.size && inputSizeStyle3(props);
      }, function(props) {
        return (!props.plain || props.focusIndicator) && focusStyle3();
      }, controlBorderStyle2, placeholderStyle2, function(props) {
        return props.theme.global.input.extend;
      });
      exports.inputStyle = inputStyle2;
      var overflowStyle3 = function overflowStyle4(overflowProp) {
        if (typeof overflowProp === "string") {
          return (0, _styledComponents.css)(["overflow:", ";"], overflowProp);
        }
        return (0, _styledComponents.css)(["", " ", ";"], overflowProp.horizontal && "overflow-x: " + overflowProp.horizontal + ";", overflowProp.vertical && "overflow-y: " + overflowProp.vertical + ";");
      };
      exports.overflowStyle = overflowStyle3;
      var ALIGN_SELF_MAP2 = {
        center: "center",
        end: "flex-end",
        start: "flex-start",
        stretch: "stretch",
        baseline: "baseline"
      };
      var genericStyles2 = (0, _styledComponents.css)(["", " ", " ", ""], function(props) {
        return props.alignSelf && "align-self: " + ALIGN_SELF_MAP2[props.alignSelf] + ";";
      }, function(props) {
        return props.gridArea && "grid-area: " + props.gridArea + ";";
      }, function(props) {
        return props.margin && props.theme.global && edgeStyle3("margin", props.margin, props.responsive, props.theme.global.edgeSize.responsiveBreakpoint, props.theme);
      });
      exports.genericStyles = genericStyles2;
      var disabledStyle5 = function disabledStyle6(componentStyle) {
        return (0, _styledComponents.css)(["opacity:", ";cursor:default;"], function(props) {
          return componentStyle || props.theme.global.control.disabled.opacity;
        });
      };
      exports.disabledStyle = disabledStyle5;
      var sizeStyle10 = function sizeStyle11(name, value, theme) {
        return (0, _styledComponents.css)(["", ":", ";"], name, theme.global.size[value] || value);
      };
      exports.sizeStyle = sizeStyle10;
      var plainInputStyle2 = (0, _styledComponents.css)(["outline:none;border:none;"]);
      exports.plainInputStyle = plainInputStyle2;
      var kindPartStyles3 = function kindPartStyles4(obj, theme, colorValue) {
        var styles = [];
        if (obj.padding || obj.pad) {
          var pad = obj.padding || obj.pad;
          if (pad.vertical || pad.horizontal)
            styles.push("padding: " + (theme.global.edgeSize[pad.vertical] || pad.vertical || 0) + " " + (theme.global.edgeSize[pad.horizontal] || pad.horizontal || 0) + ";");
          else
            styles.push("padding: " + (theme.global.edgeSize[pad] || pad || 0) + ";");
        }
        if (obj.background)
          styles.push((0, _background.backgroundStyle)(colorValue || obj.background, theme, obj.color || (Object.prototype.hasOwnProperty.call(obj, "color") && obj.color === void 0 ? false : void 0)));
        else if (obj.color)
          styles.push("color: " + (0, _colors.normalizeColor)(obj.color, theme) + ";");
        if (obj.border) {
          if (obj.border.width)
            styles.push((0, _styledComponents.css)(["border-style:solid;border-width:", ";"], obj.border.width));
          if (obj.border.color)
            styles.push((0, _styledComponents.css)(["border-color:", ";"], (0, _colors.normalizeColor)(!obj.background && colorValue || obj.border.color || "border", theme)));
          if (obj.border.radius)
            styles.push((0, _styledComponents.css)(["border-radius:", ";"], obj.border.radius));
        } else if (obj.border === false)
          styles.push("border: none;");
        if (colorValue && !obj.border && !obj.background)
          styles.push("color: " + (0, _colors.normalizeColor)(colorValue, theme) + ";");
        if (obj.font) {
          if (obj.font.size) {
            styles.push("font-size: " + (theme.text[obj.font.size].size || obj.font.size) + ";");
          }
          if (obj.font.height) {
            styles.push("line-height: " + obj.font.height + ";");
          }
          if (obj.font.weight) {
            styles.push("font-weight: " + obj.font.weight + ";");
          }
        }
        if (obj.opacity) {
          var opacity = obj.opacity === true ? theme.global.opacity.medium : theme.global.opacity[obj.opacity] || obj.opacity;
          styles.push("opacity: " + opacity + ";");
        }
        if (obj.extend)
          styles.push(obj.extend);
        return styles;
      };
      exports.kindPartStyles = kindPartStyles3;
      var ROUND_MAP2 = {
        full: "100%"
      };
      var roundStyle5 = function roundStyle6(data, responsive, theme) {
        var breakpoint = (0, _responsive.getBreakpointStyle)(theme, theme.box.responsiveBreakpoint);
        var styles = [];
        if (typeof data === "object") {
          var size = ROUND_MAP2[data.size] || theme.global.edgeSize[data.size || "medium"] || data.size;
          var responsiveSize = responsive && breakpoint && breakpoint.edgeSize[data.size] && (breakpoint.edgeSize[data.size] || data.size);
          if (data.corner === "top") {
            styles.push((0, _styledComponents.css)(["border-top-left-radius:", ";border-top-right-radius:", ";"], size, size));
            if (responsiveSize) {
              styles.push((0, _mixins.breakpointStyle)(breakpoint, "\n          border-top-left-radius: " + responsiveSize + ";\n          border-top-right-radius: " + responsiveSize + ";\n        "));
            }
          } else if (data.corner === "bottom") {
            styles.push((0, _styledComponents.css)(["border-bottom-left-radius:", ";border-bottom-right-radius:", ";"], size, size));
            if (responsiveSize) {
              styles.push((0, _mixins.breakpointStyle)(breakpoint, "\n          border-bottom-left-radius: " + responsiveSize + ";\n          border-bottom-right-radius: " + responsiveSize + ";\n        "));
            }
          } else if (data.corner === "left") {
            styles.push((0, _styledComponents.css)(["border-top-left-radius:", ";border-bottom-left-radius:", ";"], size, size));
            if (responsiveSize) {
              styles.push((0, _mixins.breakpointStyle)(breakpoint, "\n          border-top-left-radius: " + responsiveSize + ";\n          border-bottom-left-radius: " + responsiveSize + ";\n        "));
            }
          } else if (data.corner === "right") {
            styles.push((0, _styledComponents.css)(["border-top-right-radius:", ";border-bottom-right-radius:", ";"], size, size));
            if (responsiveSize) {
              styles.push((0, _mixins.breakpointStyle)(breakpoint, "\n          border-top-right-radius: " + responsiveSize + ";\n          border-bottom-right-radius: " + responsiveSize + ";\n        "));
            }
          } else if (data.corner) {
            styles.push((0, _styledComponents.css)(["border-", "-radius:", ";"], data.corner, size));
            if (responsiveSize) {
              styles.push((0, _mixins.breakpointStyle)(breakpoint, "\n          border-" + data.corner + "-radius: " + responsiveSize + ";\n        "));
            }
          } else {
            styles.push((0, _styledComponents.css)(["border-radius:", ";"], size));
            if (responsiveSize) {
              styles.push((0, _mixins.breakpointStyle)(breakpoint, "\n          border-radius: " + responsiveSize + ";\n        "));
            }
          }
        } else {
          var _size2 = data === true ? "medium" : data;
          styles.push((0, _styledComponents.css)(["border-radius:", ";"], ROUND_MAP2[_size2] || theme.global.edgeSize[_size2] || _size2));
          var _responsiveSize = breakpoint && breakpoint.edgeSize[_size2];
          if (_responsiveSize) {
            styles.push((0, _mixins.breakpointStyle)(breakpoint, "\n        border-radius: " + _responsiveSize + ";\n      "));
          }
        }
        return styles;
      };
      exports.roundStyle = roundStyle5;
      var TEXT_ALIGN_MAP2 = {
        center: "center",
        end: "right",
        justify: "justify",
        start: "left"
      };
      var textAlignStyle2 = (0, _styledComponents.css)(["text-align:", ";"], function(props) {
        return TEXT_ALIGN_MAP2[props.textAlign];
      });
      exports.textAlignStyle = textAlignStyle2;
      var ALIGN_ITEMS_MAP2 = {
        baseline: "baseline",
        center: "center",
        end: "flex-end",
        start: "flex-start",
        stretch: "stretch"
      };
      var alignStyle2 = (0, _styledComponents.css)(["align-items:", ";"], function(props) {
        var _ALIGN_ITEMS_MAP$prop;
        return (_ALIGN_ITEMS_MAP$prop = ALIGN_ITEMS_MAP2[props.align]) != null ? _ALIGN_ITEMS_MAP$prop : props.align;
      });
      exports.alignStyle = alignStyle2;
      var ALIGN_CONTENT_MAP2 = {
        around: "space-around",
        baseline: "baseline",
        between: "space-between",
        center: "center",
        evenly: "space-evenly",
        end: "flex-end",
        start: "flex-start",
        stretch: "stretch"
      };
      var alignContentStyle2 = (0, _styledComponents.css)(["align-content:", ";"], function(props) {
        var _ALIGN_CONTENT_MAP$pr;
        return (_ALIGN_CONTENT_MAP$pr = ALIGN_CONTENT_MAP2[props.alignContent]) != null ? _ALIGN_CONTENT_MAP$pr : props.alignContent;
      });
      exports.alignContentStyle = alignContentStyle2;
      var getSize3 = function getSize4(theme, size) {
        return theme.global.size[size] || size;
      };
      var widthObjectStyle3 = function widthObjectStyle4(width, theme) {
        var result = [];
        if (width.max)
          result.push((0, _styledComponents.css)(["max-width:", ";"], getSize3(theme, width.max)));
        if (width.min)
          result.push((0, _styledComponents.css)(["min-width:", ";"], getSize3(theme, width.min)));
        if (width.width)
          result.push((0, _styledComponents.css)(["width:", ";"], getSize3(theme, width.width)));
        return result;
      };
      var widthStringStyle3 = function widthStringStyle4(width, theme) {
        return (0, _styledComponents.css)(["width:", ";"], getSize3(theme, width));
      };
      var widthStyle3 = function widthStyle4(width, theme) {
        return typeof width === "object" ? widthObjectStyle3(width, theme) : widthStringStyle3(width, theme);
      };
      exports.widthStyle = widthStyle3;
      var heightObjectStyle3 = function heightObjectStyle4(height, theme) {
        var result = [];
        if (height.max)
          result.push((0, _styledComponents.css)(["max-height:", ";"], getSize3(theme, height.max)));
        if (height.min)
          result.push((0, _styledComponents.css)(["min-height:", ";"], getSize3(theme, height.min)));
        if (height.width)
          result.push((0, _styledComponents.css)(["height:", ";"], getSize3(theme, height.height)));
        if (height.height)
          result.push((0, _styledComponents.css)(["height:", ";"], getSize3(theme, height.height)));
        return result;
      };
      var heightStringStyle3 = function heightStringStyle4(height, theme) {
        return (0, _styledComponents.css)(["height:", ";"], getSize3(theme, height));
      };
      var heightStyle3 = function heightStyle4(height, theme) {
        return typeof height === "object" ? heightObjectStyle3(height, theme) : heightStringStyle3(height, theme);
      };
      exports.heightStyle = heightStyle3;
    }
  });

  // node_modules/grommet/utils/object.js
  var require_object = __commonJS({
    "node_modules/grommet/utils/object.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.removeUndefined = exports.isObject = exports.deepMerge = exports.deepFreeze = void 0;
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var isObject8 = function isObject9(item) {
        return item && typeof item === "object" && !Array.isArray(item);
      };
      exports.isObject = isObject8;
      var deepFreeze5 = function deepFreeze6(obj) {
        Object.keys(obj).forEach(function(key) {
          return key && isObject8(obj[key]) && Object.freeze(obj[key]);
        });
        return Object.freeze(obj);
      };
      exports.deepFreeze = deepFreeze5;
      var deepMerge4 = function deepMerge5(target) {
        for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          sources[_key - 1] = arguments[_key];
        }
        if (!sources.length) {
          return target;
        }
        var output = _extends89({}, target);
        sources.forEach(function(source) {
          if (isObject8(source)) {
            Object.keys(source).forEach(function(key) {
              if (isObject8(source[key])) {
                if (!output[key]) {
                  output[key] = _extends89({}, source[key]);
                } else {
                  output[key] = deepMerge5(output[key], source[key]);
                }
              } else {
                output[key] = source[key];
              }
            });
          }
        });
        return output;
      };
      exports.deepMerge = deepMerge4;
      var removeUndefined3 = function removeUndefined4(obj) {
        var result = {};
        Object.keys(obj).forEach(function(key) {
          if (obj[key] !== void 0) {
            result[key] = obj[key];
          }
        });
        return result;
      };
      exports.removeUndefined = removeUndefined3;
    }
  });

  // node_modules/grommet/utils/pagination.js
  var require_pagination = __commonJS({
    "node_modules/grommet/utils/pagination.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.usePagination = exports.normalizeShow = void 0;
      var _react = require_react();
      var _excluded68 = ["data", "page", "step"];
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      function _objectWithoutPropertiesLoose56(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      var normalizeShow3 = function normalizeShow4(showProp, step) {
        var page;
        if (typeof showProp === "number")
          page = Math.ceil((showProp + 1) / step);
        else if (typeof showProp === "object" && "page" in showProp)
          page = showProp.page;
        return page;
      };
      exports.normalizeShow = normalizeShow3;
      var usePagination3 = function usePagination4(_ref) {
        var data = _ref.data, page = _ref.page, step = _ref.step, rest = _objectWithoutPropertiesLoose56(_ref, _excluded68);
        var totalPages = data ? Math.ceil(data.length / step) : 0;
        var _useState = (0, _react.useState)(Math.min(page, totalPages) || 1), activePage = _useState[0], setActivePage = _useState[1];
        if (activePage > totalPages && (data == null ? void 0 : data.length) > 0)
          setActivePage(Math.max(totalPages, 1));
        var itemsBeginIndex = step * (activePage - 1);
        var itemsEndIndex = itemsBeginIndex + step;
        var currentItems = (0, _react.useMemo)(function() {
          if (Array.isArray(data))
            return data.slice(itemsBeginIndex, itemsEndIndex);
          return [];
        }, [data, itemsBeginIndex, itemsEndIndex]);
        var paginationProps = _extends89({
          numberItems: data && data.length,
          onChange: function onChange2(event) {
            return setActivePage(event.page);
          },
          page: activePage,
          step
        }, rest);
        return [currentItems, paginationProps];
      };
      exports.usePagination = usePagination3;
    }
  });

  // node_modules/grommet/utils/PortalContext.js
  var require_PortalContext = __commonJS({
    "node_modules/grommet/utils/PortalContext.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.PortalContext = void 0;
      var _react = _interopRequireDefault(require_react());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var PortalContext2 = /* @__PURE__ */ _react["default"].createContext([]);
      exports.PortalContext = PortalContext2;
    }
  });

  // node_modules/grommet/utils/refs.js
  var require_refs = __commonJS({
    "node_modules/grommet/utils/refs.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.useForwardedRef = void 0;
      var _react = require_react();
      var useForwardedRef3 = function useForwardedRef4(ref) {
        var innerRef = (0, _react.useRef)(null);
        (0, _react.useImperativeHandle)(ref, function() {
          return innerRef.current;
        });
        return innerRef;
      };
      exports.useForwardedRef = useForwardedRef3;
    }
  });

  // node_modules/grommet/utils/use-keyboard.js
  var require_use_keyboard = __commonJS({
    "node_modules/grommet/utils/use-keyboard.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.useKeyboard = exports["default"] = void 0;
      var _react = require_react();
      var useKeyboard3 = function useKeyboard4() {
        var _useState = (0, _react.useState)(), usingKeyboard = _useState[0], setUsingKeyboard = _useState[1];
        (0, _react.useEffect)(function() {
          var onMouseDown = function onMouseDown2() {
            return setUsingKeyboard(false);
          };
          var onKeyDown = function onKeyDown2() {
            return setUsingKeyboard(true);
          };
          document.addEventListener("mousedown", onMouseDown);
          document.addEventListener("keydown", onKeyDown);
          return function() {
            document.removeEventListener("mousedown", onMouseDown);
            document.removeEventListener("keydown", onKeyDown);
          };
        }, []);
        return usingKeyboard;
      };
      exports.useKeyboard = useKeyboard3;
      var _default = useKeyboard3;
      exports["default"] = _default;
    }
  });

  // node_modules/grommet/utils/index.js
  var require_utils3 = __commonJS({
    "node_modules/grommet/utils/index.js"(exports) {
      "use strict";
      exports.__esModule = true;
      var _animation = require_animation();
      Object.keys(_animation).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _animation[key])
          return;
        exports[key] = _animation[key];
      });
      var _mixins = require_mixins();
      Object.keys(_mixins).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _mixins[key])
          return;
        exports[key] = _mixins[key];
      });
      var _background = require_background();
      Object.keys(_background).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _background[key])
          return;
        exports[key] = _background[key];
      });
      var _border = require_border();
      Object.keys(_border).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _border[key])
          return;
        exports[key] = _border[key];
      });
      var _colors = require_colors2();
      Object.keys(_colors).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _colors[key])
          return;
        exports[key] = _colors[key];
      });
      var _dates = require_dates();
      Object.keys(_dates).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _dates[key])
          return;
        exports[key] = _dates[key];
      });
      var _DOM = require_DOM();
      Object.keys(_DOM).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _DOM[key])
          return;
        exports[key] = _DOM[key];
      });
      var _graphics = require_graphics();
      Object.keys(_graphics).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _graphics[key])
          return;
        exports[key] = _graphics[key];
      });
      var _styles = require_styles2();
      Object.keys(_styles).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _styles[key])
          return;
        exports[key] = _styles[key];
      });
      var _object = require_object();
      Object.keys(_object).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _object[key])
          return;
        exports[key] = _object[key];
      });
      var _pagination = require_pagination();
      Object.keys(_pagination).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _pagination[key])
          return;
        exports[key] = _pagination[key];
      });
      var _PortalContext = require_PortalContext();
      Object.keys(_PortalContext).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _PortalContext[key])
          return;
        exports[key] = _PortalContext[key];
      });
      var _refs = require_refs();
      Object.keys(_refs).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _refs[key])
          return;
        exports[key] = _refs[key];
      });
      var _responsive = require_responsive();
      Object.keys(_responsive).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _responsive[key])
          return;
        exports[key] = _responsive[key];
      });
      var _useKeyboard = require_use_keyboard();
      Object.keys(_useKeyboard).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports && exports[key] === _useKeyboard[key])
          return;
        exports[key] = _useKeyboard[key];
      });
    }
  });

  // node_modules/grommet-icons/icons/Info.js
  var require_Info = __commonJS({
    "node_modules/grommet-icons/icons/Info.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Info = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _StyledIcon = require_StyledIcon();
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function")
          return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _extends89() {
        _extends89 = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends89.apply(this, arguments);
      }
      var Info2 = /* @__PURE__ */ (0, _react.forwardRef)(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_StyledIcon.StyledIcon, _extends89({
          ref,
          viewBox: "0 0 24 24",
          a11yTitle: "Info"
        }, props), /* @__PURE__ */ _react["default"].createElement("path", {
          fill: "none",
          stroke: "#000",
          strokeWidth: "2",
          d: "M15 17c0-3 4-5 4-9s-3-7-7-7-7 3-7 7 4 6 4 9v3c0 2 1 3 3 3s3-1 3-3v-3zm-6 1h6"
        }));
      });
      exports.Info = Info2;
      Info2.displayName = "Info";
    }
  });

  // node_modules/jquery/dist/jquery.js
  var require_jquery = __commonJS({
    "node_modules/jquery/dist/jquery.js"(exports, module) {
      (function(global2, factory15) {
        "use strict";
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global2.document ? factory15(global2, true) : function(w) {
            if (!w.document) {
              throw new Error("jQuery requires a window with a document");
            }
            return factory15(w);
          };
        } else {
          factory15(global2);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        "use strict";
        var arr = [];
        var getProto = Object.getPrototypeOf;
        var slice = arr.slice;
        var flat = arr.flat ? function(array) {
          return arr.flat.call(array);
        } : function(array) {
          return arr.concat.apply([], array);
        };
        var push = arr.push;
        var indexOf2 = arr.indexOf;
        var class2type = {};
        var toString = class2type.toString;
        var hasOwn = class2type.hasOwnProperty;
        var fnToString = hasOwn.toString;
        var ObjectFunctionString = fnToString.call(Object);
        var support = {};
        var isFunction = function isFunction2(obj) {
          return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
        };
        var isWindow = function isWindow2(obj) {
          return obj != null && obj === obj.window;
        };
        var document2 = window2.document;
        var preservedScriptAttributes = {
          type: true,
          src: true,
          nonce: true,
          noModule: true
        };
        function DOMEval(code, node, doc) {
          doc = doc || document2;
          var i, val, script = doc.createElement("script");
          script.text = code;
          if (node) {
            for (i in preservedScriptAttributes) {
              val = node[i] || node.getAttribute && node.getAttribute(i);
              if (val) {
                script.setAttribute(i, val);
              }
            }
          }
          doc.head.appendChild(script).parentNode.removeChild(script);
        }
        function toType2(obj) {
          if (obj == null) {
            return obj + "";
          }
          return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        }
        var version = "3.6.4", jQuery = function(selector, context) {
          return new jQuery.fn.init(selector, context);
        };
        jQuery.fn = jQuery.prototype = {
          // The current version of jQuery being used
          jquery: version,
          constructor: jQuery,
          // The default length of a jQuery object is 0
          length: 0,
          toArray: function() {
            return slice.call(this);
          },
          // Get the Nth element in the matched element set OR
          // Get the whole matched element set as a clean array
          get: function(num) {
            if (num == null) {
              return slice.call(this);
            }
            return num < 0 ? this[num + this.length] : this[num];
          },
          // Take an array of elements and push it onto the stack
          // (returning the new matched element set)
          pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            return ret;
          },
          // Execute a callback for every element in the matched set.
          each: function(callback) {
            return jQuery.each(this, callback);
          },
          map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
              return callback.call(elem, i, elem);
            }));
          },
          slice: function() {
            return this.pushStack(slice.apply(this, arguments));
          },
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          even: function() {
            return this.pushStack(jQuery.grep(this, function(_elem, i) {
              return (i + 1) % 2;
            }));
          },
          odd: function() {
            return this.pushStack(jQuery.grep(this, function(_elem, i) {
              return i % 2;
            }));
          },
          eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
          },
          end: function() {
            return this.prevObject || this.constructor();
          },
          // For internal use only.
          // Behaves like an Array's method, not like a jQuery method.
          push,
          sort: arr.sort,
          splice: arr.splice
        };
        jQuery.extend = jQuery.fn.extend = function() {
          var options2, name, src, copy, copyIsArray, clone5, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
          if (typeof target === "boolean") {
            deep = target;
            target = arguments[i] || {};
            i++;
          }
          if (typeof target !== "object" && !isFunction(target)) {
            target = {};
          }
          if (i === length) {
            target = this;
            i--;
          }
          for (; i < length; i++) {
            if ((options2 = arguments[i]) != null) {
              for (name in options2) {
                copy = options2[name];
                if (name === "__proto__" || target === copy) {
                  continue;
                }
                if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                  src = target[name];
                  if (copyIsArray && !Array.isArray(src)) {
                    clone5 = [];
                  } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                    clone5 = {};
                  } else {
                    clone5 = src;
                  }
                  copyIsArray = false;
                  target[name] = jQuery.extend(deep, clone5, copy);
                } else if (copy !== void 0) {
                  target[name] = copy;
                }
              }
            }
          }
          return target;
        };
        jQuery.extend({
          // Unique for each copy of jQuery on the page
          expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
          // Assume jQuery is ready without the ready module
          isReady: true,
          error: function(msg) {
            throw new Error(msg);
          },
          noop: function() {
          },
          isPlainObject: function(obj) {
            var proto, Ctor;
            if (!obj || toString.call(obj) !== "[object Object]") {
              return false;
            }
            proto = getProto(obj);
            if (!proto) {
              return true;
            }
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
          },
          isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
              return false;
            }
            return true;
          },
          // Evaluates a script in a provided context; falls back to the global one
          // if not specified.
          globalEval: function(code, options2, doc) {
            DOMEval(code, { nonce: options2 && options2.nonce }, doc);
          },
          each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
              length = obj.length;
              for (; i < length; i++) {
                if (callback.call(obj[i], i, obj[i]) === false) {
                  break;
                }
              }
            } else {
              for (i in obj) {
                if (callback.call(obj[i], i, obj[i]) === false) {
                  break;
                }
              }
            }
            return obj;
          },
          // results is for internal usage only
          makeArray: function(arr2, results) {
            var ret = results || [];
            if (arr2 != null) {
              if (isArrayLike(Object(arr2))) {
                jQuery.merge(
                  ret,
                  typeof arr2 === "string" ? [arr2] : arr2
                );
              } else {
                push.call(ret, arr2);
              }
            }
            return ret;
          },
          inArray: function(elem, arr2, i) {
            return arr2 == null ? -1 : indexOf2.call(arr2, elem, i);
          },
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (; j < len; j++) {
              first[i++] = second[j];
            }
            first.length = i;
            return first;
          },
          grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (; i < length; i++) {
              callbackInverse = !callback(elems[i], i);
              if (callbackInverse !== callbackExpect) {
                matches.push(elems[i]);
              }
            }
            return matches;
          },
          // arg is for internal usage only
          map: function(elems, callback, arg) {
            var length, value, i = 0, ret = [];
            if (isArrayLike(elems)) {
              length = elems.length;
              for (; i < length; i++) {
                value = callback(elems[i], i, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            } else {
              for (i in elems) {
                value = callback(elems[i], i, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            }
            return flat(ret);
          },
          // A global GUID counter for objects
          guid: 1,
          // jQuery.support is not used in Core but other projects attach their
          // properties to it so it needs to exist.
          support
        });
        if (typeof Symbol === "function") {
          jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
        }
        jQuery.each(
          "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
          function(_i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
          }
        );
        function isArrayLike(obj) {
          var length = !!obj && "length" in obj && obj.length, type = toType2(obj);
          if (isFunction(obj) || isWindow(obj)) {
            return false;
          }
          return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
        }
        var Sizzle = (
          /*!
           * Sizzle CSS Selector Engine v2.3.10
           * https://sizzlejs.com/
           *
           * Copyright JS Foundation and other contributors
           * Released under the MIT license
           * https://js.foundation/
           *
           * Date: 2023-02-14
           */
          function(window3) {
            var i, support2, Expr, getText, isXML, tokenize2, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document3, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains2, expando = "sizzle" + 1 * /* @__PURE__ */ new Date(), preferredDoc = window3.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
              if (a === b) {
                hasDuplicate = true;
              }
              return 0;
            }, hasOwn2 = {}.hasOwnProperty, arr2 = [], pop = arr2.pop, pushNative = arr2.push, push2 = arr2.push, slice2 = arr2.slice, indexOf3 = function(list, elem) {
              var i2 = 0, len = list.length;
              for (; i2 < len; i2++) {
                if (list[i2] === elem) {
                  return i2;
                }
              }
              return -1;
            }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace2 = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace2 + "*(" + identifier + ")(?:" + whitespace2 + // Operator (capture 2)
            "*([*^$|!~]?=)" + whitespace2 + // "Attribute values must be CSS identifiers [capture 5]
            // or strings [capture 3 or capture 4]"
            `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace2 + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace2 + "+", "g"), rtrim2 = new RegExp("^" + whitespace2 + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace2 + "+$", "g"), rcomma = new RegExp("^" + whitespace2 + "*," + whitespace2 + "*"), rleadingCombinator = new RegExp("^" + whitespace2 + "*([>+~]|" + whitespace2 + ")" + whitespace2 + "*"), rdescend = new RegExp(whitespace2 + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
              "ID": new RegExp("^#(" + identifier + ")"),
              "CLASS": new RegExp("^\\.(" + identifier + ")"),
              "TAG": new RegExp("^(" + identifier + "|[*])"),
              "ATTR": new RegExp("^" + attributes),
              "PSEUDO": new RegExp("^" + pseudos),
              "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace2 + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace2 + "*(?:([+-]|)" + whitespace2 + "*(\\d+)|))" + whitespace2 + "*\\)|)", "i"),
              "bool": new RegExp("^(?:" + booleans + ")$", "i"),
              // For use in libraries implementing .is()
              // We use this for POS matching in `select`
              "needsContext": new RegExp("^" + whitespace2 + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace2 + "*((?:-\\d)?\\d*)" + whitespace2 + "*\\)|)(?=[^-]|$)", "i")
            }, rhtml2 = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
              var high = "0x" + escape.slice(1) - 65536;
              return nonHex ? (
                // Strip the backslash prefix from a non-hex escape sequence
                nonHex
              ) : (
                // Replace a hexadecimal escape sequence with the encoded Unicode code point
                // Support: IE <=11+
                // For values outside the Basic Multilingual Plane (BMP), manually construct a
                // surrogate pair
                high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
              );
            }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
              if (asCodePoint) {
                if (ch === "\0") {
                  return "\uFFFD";
                }
                return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
              }
              return "\\" + ch;
            }, unloadHandler = function() {
              setDocument();
            }, inDisabledFieldset = addCombinator(
              function(elem) {
                return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
              },
              { dir: "parentNode", next: "legend" }
            );
            try {
              push2.apply(
                arr2 = slice2.call(preferredDoc.childNodes),
                preferredDoc.childNodes
              );
              arr2[preferredDoc.childNodes.length].nodeType;
            } catch (e) {
              push2 = {
                apply: arr2.length ? (
                  // Leverage slice if possible
                  function(target, els) {
                    pushNative.apply(target, slice2.call(els));
                  }
                ) : (
                  // Support: IE<9
                  // Otherwise append directly
                  function(target, els) {
                    var j = target.length, i2 = 0;
                    while (target[j++] = els[i2++]) {
                    }
                    target.length = j - 1;
                  }
                )
              };
            }
            function Sizzle2(selector, context, results, seed) {
              var m, i2, elem, nid, match2, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
              results = results || [];
              if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
              }
              if (!seed) {
                setDocument(context);
                context = context || document3;
                if (documentIsHTML) {
                  if (nodeType !== 11 && (match2 = rquickExpr2.exec(selector))) {
                    if (m = match2[1]) {
                      if (nodeType === 9) {
                        if (elem = context.getElementById(m)) {
                          if (elem.id === m) {
                            results.push(elem);
                            return results;
                          }
                        } else {
                          return results;
                        }
                      } else {
                        if (newContext && (elem = newContext.getElementById(m)) && contains2(context, elem) && elem.id === m) {
                          results.push(elem);
                          return results;
                        }
                      }
                    } else if (match2[2]) {
                      push2.apply(results, context.getElementsByTagName(selector));
                      return results;
                    } else if ((m = match2[3]) && support2.getElementsByClassName && context.getElementsByClassName) {
                      push2.apply(results, context.getElementsByClassName(m));
                      return results;
                    }
                  }
                  if (support2.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && // Support: IE 8 only
                  // Exclude object elements
                  (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
                    newSelector = selector;
                    newContext = context;
                    if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                      newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                      if (newContext !== context || !support2.scope) {
                        if (nid = context.getAttribute("id")) {
                          nid = nid.replace(rcssescape, fcssescape);
                        } else {
                          context.setAttribute("id", nid = expando);
                        }
                      }
                      groups = tokenize2(selector);
                      i2 = groups.length;
                      while (i2--) {
                        groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
                      }
                      newSelector = groups.join(",");
                    }
                    try {
                      push2.apply(
                        results,
                        newContext.querySelectorAll(newSelector)
                      );
                      return results;
                    } catch (qsaError) {
                      nonnativeSelectorCache(selector, true);
                    } finally {
                      if (nid === expando) {
                        context.removeAttribute("id");
                      }
                    }
                  }
                }
              }
              return select(selector.replace(rtrim2, "$1"), context, results, seed);
            }
            function createCache() {
              var keys5 = [];
              function cache2(key, value) {
                if (keys5.push(key + " ") > Expr.cacheLength) {
                  delete cache2[keys5.shift()];
                }
                return cache2[key + " "] = value;
              }
              return cache2;
            }
            function markFunction(fn2) {
              fn2[expando] = true;
              return fn2;
            }
            function assert(fn2) {
              var el = document3.createElement("fieldset");
              try {
                return !!fn2(el);
              } catch (e) {
                return false;
              } finally {
                if (el.parentNode) {
                  el.parentNode.removeChild(el);
                }
                el = null;
              }
            }
            function addHandle(attrs, handler) {
              var arr3 = attrs.split("|"), i2 = arr3.length;
              while (i2--) {
                Expr.attrHandle[arr3[i2]] = handler;
              }
            }
            function siblingCheck(a, b) {
              var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
              if (diff) {
                return diff;
              }
              if (cur) {
                while (cur = cur.nextSibling) {
                  if (cur === b) {
                    return -1;
                  }
                }
              }
              return a ? 1 : -1;
            }
            function createInputPseudo(type) {
              return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
              };
            }
            function createButtonPseudo(type) {
              return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
              };
            }
            function createDisabledPseudo(disabled) {
              return function(elem) {
                if ("form" in elem) {
                  if (elem.parentNode && elem.disabled === false) {
                    if ("label" in elem) {
                      if ("label" in elem.parentNode) {
                        return elem.parentNode.disabled === disabled;
                      } else {
                        return elem.disabled === disabled;
                      }
                    }
                    return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                    /* jshint -W018 */
                    elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                  }
                  return elem.disabled === disabled;
                } else if ("label" in elem) {
                  return elem.disabled === disabled;
                }
                return false;
              };
            }
            function createPositionalPseudo(fn2) {
              return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches2) {
                  var j, matchIndexes = fn2([], seed.length, argument), i2 = matchIndexes.length;
                  while (i2--) {
                    if (seed[j = matchIndexes[i2]]) {
                      seed[j] = !(matches2[j] = seed[j]);
                    }
                  }
                });
              });
            }
            function testContext(context) {
              return context && typeof context.getElementsByTagName !== "undefined" && context;
            }
            support2 = Sizzle2.support = {};
            isXML = Sizzle2.isXML = function(elem) {
              var namespace = elem && elem.namespaceURI, docElem2 = elem && (elem.ownerDocument || elem).documentElement;
              return !rhtml2.test(namespace || docElem2 && docElem2.nodeName || "HTML");
            };
            setDocument = Sizzle2.setDocument = function(node) {
              var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
              if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
                return document3;
              }
              document3 = doc;
              docElem = document3.documentElement;
              documentIsHTML = !isXML(document3);
              if (preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
                if (subWindow.addEventListener) {
                  subWindow.addEventListener("unload", unloadHandler, false);
                } else if (subWindow.attachEvent) {
                  subWindow.attachEvent("onunload", unloadHandler);
                }
              }
              support2.scope = assert(function(el) {
                docElem.appendChild(el).appendChild(document3.createElement("div"));
                return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
              });
              support2.cssHas = assert(function() {
                try {
                  document3.querySelector(":has(*,:jqfake)");
                  return false;
                } catch (e) {
                  return true;
                }
              });
              support2.attributes = assert(function(el) {
                el.className = "i";
                return !el.getAttribute("className");
              });
              support2.getElementsByTagName = assert(function(el) {
                el.appendChild(document3.createComment(""));
                return !el.getElementsByTagName("*").length;
              });
              support2.getElementsByClassName = rnative.test(document3.getElementsByClassName);
              support2.getById = assert(function(el) {
                docElem.appendChild(el).id = expando;
                return !document3.getElementsByName || !document3.getElementsByName(expando).length;
              });
              if (support2.getById) {
                Expr.filter["ID"] = function(id) {
                  var attrId = id.replace(runescape, funescape);
                  return function(elem) {
                    return elem.getAttribute("id") === attrId;
                  };
                };
                Expr.find["ID"] = function(id, context) {
                  if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                    var elem = context.getElementById(id);
                    return elem ? [elem] : [];
                  }
                };
              } else {
                Expr.filter["ID"] = function(id) {
                  var attrId = id.replace(runescape, funescape);
                  return function(elem) {
                    var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                    return node2 && node2.value === attrId;
                  };
                };
                Expr.find["ID"] = function(id, context) {
                  if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                    var node2, i2, elems, elem = context.getElementById(id);
                    if (elem) {
                      node2 = elem.getAttributeNode("id");
                      if (node2 && node2.value === id) {
                        return [elem];
                      }
                      elems = context.getElementsByName(id);
                      i2 = 0;
                      while (elem = elems[i2++]) {
                        node2 = elem.getAttributeNode("id");
                        if (node2 && node2.value === id) {
                          return [elem];
                        }
                      }
                    }
                    return [];
                  }
                };
              }
              Expr.find["TAG"] = support2.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") {
                  return context.getElementsByTagName(tag);
                } else if (support2.qsa) {
                  return context.querySelectorAll(tag);
                }
              } : function(tag, context) {
                var elem, tmp = [], i2 = 0, results = context.getElementsByTagName(tag);
                if (tag === "*") {
                  while (elem = results[i2++]) {
                    if (elem.nodeType === 1) {
                      tmp.push(elem);
                    }
                  }
                  return tmp;
                }
                return results;
              };
              Expr.find["CLASS"] = support2.getElementsByClassName && function(className, context) {
                if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                  return context.getElementsByClassName(className);
                }
              };
              rbuggyMatches = [];
              rbuggyQSA = [];
              if (support2.qsa = rnative.test(document3.querySelectorAll)) {
                assert(function(el) {
                  var input;
                  docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>";
                  if (el.querySelectorAll("[msallowcapture^='']").length) {
                    rbuggyQSA.push("[*^$]=" + whitespace2 + `*(?:''|"")`);
                  }
                  if (!el.querySelectorAll("[selected]").length) {
                    rbuggyQSA.push("\\[" + whitespace2 + "*(?:value|" + booleans + ")");
                  }
                  if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                    rbuggyQSA.push("~=");
                  }
                  input = document3.createElement("input");
                  input.setAttribute("name", "");
                  el.appendChild(input);
                  if (!el.querySelectorAll("[name='']").length) {
                    rbuggyQSA.push("\\[" + whitespace2 + "*name" + whitespace2 + "*=" + whitespace2 + `*(?:''|"")`);
                  }
                  if (!el.querySelectorAll(":checked").length) {
                    rbuggyQSA.push(":checked");
                  }
                  if (!el.querySelectorAll("a#" + expando + "+*").length) {
                    rbuggyQSA.push(".#.+[+~]");
                  }
                  el.querySelectorAll("\\\f");
                  rbuggyQSA.push("[\\r\\n\\f]");
                });
                assert(function(el) {
                  el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                  var input = document3.createElement("input");
                  input.setAttribute("type", "hidden");
                  el.appendChild(input).setAttribute("name", "D");
                  if (el.querySelectorAll("[name=d]").length) {
                    rbuggyQSA.push("name" + whitespace2 + "*[*^$|!~]?=");
                  }
                  if (el.querySelectorAll(":enabled").length !== 2) {
                    rbuggyQSA.push(":enabled", ":disabled");
                  }
                  docElem.appendChild(el).disabled = true;
                  if (el.querySelectorAll(":disabled").length !== 2) {
                    rbuggyQSA.push(":enabled", ":disabled");
                  }
                  el.querySelectorAll("*,:x");
                  rbuggyQSA.push(",.*:");
                });
              }
              if (support2.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function(el) {
                  support2.disconnectedMatch = matches.call(el, "*");
                  matches.call(el, "[s!='']:x");
                  rbuggyMatches.push("!=", pseudos);
                });
              }
              if (!support2.cssHas) {
                rbuggyQSA.push(":has");
              }
              rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
              rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
              hasCompare = rnative.test(docElem.compareDocumentPosition);
              contains2 = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = a.nodeType === 9 && a.documentElement || a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
              } : function(a, b) {
                if (b) {
                  while (b = b.parentNode) {
                    if (b === a) {
                      return true;
                    }
                  }
                }
                return false;
              };
              sortOrder = hasCompare ? function(a, b) {
                if (a === b) {
                  hasDuplicate = true;
                  return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                  return compare;
                }
                compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : (
                  // Otherwise we know they are disconnected
                  1
                );
                if (compare & 1 || !support2.sortDetached && b.compareDocumentPosition(a) === compare) {
                  if (a == document3 || a.ownerDocument == preferredDoc && contains2(preferredDoc, a)) {
                    return -1;
                  }
                  if (b == document3 || b.ownerDocument == preferredDoc && contains2(preferredDoc, b)) {
                    return 1;
                  }
                  return sortInput ? indexOf3(sortInput, a) - indexOf3(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
              } : function(a, b) {
                if (a === b) {
                  hasDuplicate = true;
                  return 0;
                }
                var cur, i2 = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                if (!aup || !bup) {
                  return a == document3 ? -1 : b == document3 ? 1 : (
                    /* eslint-enable eqeqeq */
                    aup ? -1 : bup ? 1 : sortInput ? indexOf3(sortInput, a) - indexOf3(sortInput, b) : 0
                  );
                } else if (aup === bup) {
                  return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                  ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                  bp.unshift(cur);
                }
                while (ap[i2] === bp[i2]) {
                  i2++;
                }
                return i2 ? (
                  // Do a sibling check if the nodes have a common ancestor
                  siblingCheck(ap[i2], bp[i2])
                ) : (
                  // Otherwise nodes in our document sort first
                  // Support: IE 11+, Edge 17 - 18+
                  // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                  // two documents; shallow comparisons work.
                  /* eslint-disable eqeqeq */
                  ap[i2] == preferredDoc ? -1 : bp[i2] == preferredDoc ? 1 : (
                    /* eslint-enable eqeqeq */
                    0
                  )
                );
              };
              return document3;
            };
            Sizzle2.matches = function(expr, elements) {
              return Sizzle2(expr, null, null, elements);
            };
            Sizzle2.matchesSelector = function(elem, expr) {
              setDocument(elem);
              if (support2.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                  var ret = matches.call(elem, expr);
                  if (ret || support2.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                  // fragment in IE 9
                  elem.document && elem.document.nodeType !== 11) {
                    return ret;
                  }
                } catch (e) {
                  nonnativeSelectorCache(expr, true);
                }
              }
              return Sizzle2(expr, document3, null, [elem]).length > 0;
            };
            Sizzle2.contains = function(context, elem) {
              if ((context.ownerDocument || context) != document3) {
                setDocument(context);
              }
              return contains2(context, elem);
            };
            Sizzle2.attr = function(elem, name) {
              if ((elem.ownerDocument || elem) != document3) {
                setDocument(elem);
              }
              var fn2 = Expr.attrHandle[name.toLowerCase()], val = fn2 && hasOwn2.call(Expr.attrHandle, name.toLowerCase()) ? fn2(elem, name, !documentIsHTML) : void 0;
              return val !== void 0 ? val : support2.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
            };
            Sizzle2.escape = function(sel) {
              return (sel + "").replace(rcssescape, fcssescape);
            };
            Sizzle2.error = function(msg) {
              throw new Error("Syntax error, unrecognized expression: " + msg);
            };
            Sizzle2.uniqueSort = function(results) {
              var elem, duplicates = [], j = 0, i2 = 0;
              hasDuplicate = !support2.detectDuplicates;
              sortInput = !support2.sortStable && results.slice(0);
              results.sort(sortOrder);
              if (hasDuplicate) {
                while (elem = results[i2++]) {
                  if (elem === results[i2]) {
                    j = duplicates.push(i2);
                  }
                }
                while (j--) {
                  results.splice(duplicates[j], 1);
                }
              }
              sortInput = null;
              return results;
            };
            getText = Sizzle2.getText = function(elem) {
              var node, ret = "", i2 = 0, nodeType = elem.nodeType;
              if (!nodeType) {
                while (node = elem[i2++]) {
                  ret += getText(node);
                }
              } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === "string") {
                  return elem.textContent;
                } else {
                  for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                    ret += getText(elem);
                  }
                }
              } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
              }
              return ret;
            };
            Expr = Sizzle2.selectors = {
              // Can be adjusted by the user
              cacheLength: 50,
              createPseudo: markFunction,
              match: matchExpr,
              attrHandle: {},
              find: {},
              relative: {
                ">": { dir: "parentNode", first: true },
                " ": { dir: "parentNode" },
                "+": { dir: "previousSibling", first: true },
                "~": { dir: "previousSibling" }
              },
              preFilter: {
                "ATTR": function(match2) {
                  match2[1] = match2[1].replace(runescape, funescape);
                  match2[3] = (match2[3] || match2[4] || match2[5] || "").replace(runescape, funescape);
                  if (match2[2] === "~=") {
                    match2[3] = " " + match2[3] + " ";
                  }
                  return match2.slice(0, 4);
                },
                "CHILD": function(match2) {
                  match2[1] = match2[1].toLowerCase();
                  if (match2[1].slice(0, 3) === "nth") {
                    if (!match2[3]) {
                      Sizzle2.error(match2[0]);
                    }
                    match2[4] = +(match2[4] ? match2[5] + (match2[6] || 1) : 2 * (match2[3] === "even" || match2[3] === "odd"));
                    match2[5] = +(match2[7] + match2[8] || match2[3] === "odd");
                  } else if (match2[3]) {
                    Sizzle2.error(match2[0]);
                  }
                  return match2;
                },
                "PSEUDO": function(match2) {
                  var excess, unquoted = !match2[6] && match2[2];
                  if (matchExpr["CHILD"].test(match2[0])) {
                    return null;
                  }
                  if (match2[3]) {
                    match2[2] = match2[4] || match2[5] || "";
                  } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
                  (excess = tokenize2(unquoted, true)) && // advance to the next closing parenthesis
                  (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                    match2[0] = match2[0].slice(0, excess);
                    match2[2] = unquoted.slice(0, excess);
                  }
                  return match2.slice(0, 3);
                }
              },
              filter: {
                "TAG": function(nodeNameSelector) {
                  var nodeName2 = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                  return nodeNameSelector === "*" ? function() {
                    return true;
                  } : function(elem) {
                    return elem.nodeName && elem.nodeName.toLowerCase() === nodeName2;
                  };
                },
                "CLASS": function(className) {
                  var pattern = classCache[className + " "];
                  return pattern || (pattern = new RegExp("(^|" + whitespace2 + ")" + className + "(" + whitespace2 + "|$)")) && classCache(
                    className,
                    function(elem) {
                      return pattern.test(
                        typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                      );
                    }
                  );
                },
                "ATTR": function(name, operator, check) {
                  return function(elem) {
                    var result = Sizzle2.attr(elem, name);
                    if (result == null) {
                      return operator === "!=";
                    }
                    if (!operator) {
                      return true;
                    }
                    result += "";
                    return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                  };
                },
                "CHILD": function(type, what, _argument, first, last5) {
                  var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                  return first === 1 && last5 === 0 ? (
                    // Shortcut for :nth-*(n)
                    function(elem) {
                      return !!elem.parentNode;
                    }
                  ) : function(elem, _context, xml) {
                    var cache2, uniqueCache, outerCache, node, nodeIndex, start3, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                    if (parent) {
                      if (simple) {
                        while (dir2) {
                          node = elem;
                          while (node = node[dir2]) {
                            if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                              return false;
                            }
                          }
                          start3 = dir2 = type === "only" && !start3 && "nextSibling";
                        }
                        return true;
                      }
                      start3 = [forward ? parent.firstChild : parent.lastChild];
                      if (forward && useCache) {
                        node = parent;
                        outerCache = node[expando] || (node[expando] = {});
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        cache2 = uniqueCache[type] || [];
                        nodeIndex = cache2[0] === dirruns && cache2[1];
                        diff = nodeIndex && cache2[2];
                        node = nodeIndex && parent.childNodes[nodeIndex];
                        while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                        (diff = nodeIndex = 0) || start3.pop()) {
                          if (node.nodeType === 1 && ++diff && node === elem) {
                            uniqueCache[type] = [dirruns, nodeIndex, diff];
                            break;
                          }
                        }
                      } else {
                        if (useCache) {
                          node = elem;
                          outerCache = node[expando] || (node[expando] = {});
                          uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                          cache2 = uniqueCache[type] || [];
                          nodeIndex = cache2[0] === dirruns && cache2[1];
                          diff = nodeIndex;
                        }
                        if (diff === false) {
                          while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start3.pop()) {
                            if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                              if (useCache) {
                                outerCache = node[expando] || (node[expando] = {});
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                uniqueCache[type] = [dirruns, diff];
                              }
                              if (node === elem) {
                                break;
                              }
                            }
                          }
                        }
                      }
                      diff -= last5;
                      return diff === first || diff % first === 0 && diff / first >= 0;
                    }
                  };
                },
                "PSEUDO": function(pseudo, argument) {
                  var args, fn2 = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle2.error("unsupported pseudo: " + pseudo);
                  if (fn2[expando]) {
                    return fn2(argument);
                  }
                  if (fn2.length > 1) {
                    args = [pseudo, pseudo, "", argument];
                    return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                      var idx, matched = fn2(seed, argument), i2 = matched.length;
                      while (i2--) {
                        idx = indexOf3(seed, matched[i2]);
                        seed[idx] = !(matches2[idx] = matched[i2]);
                      }
                    }) : function(elem) {
                      return fn2(elem, 0, args);
                    };
                  }
                  return fn2;
                }
              },
              pseudos: {
                // Potentially complex pseudos
                "not": markFunction(function(selector) {
                  var input = [], results = [], matcher = compile(selector.replace(rtrim2, "$1"));
                  return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                    var elem, unmatched = matcher(seed, null, xml, []), i2 = seed.length;
                    while (i2--) {
                      if (elem = unmatched[i2]) {
                        seed[i2] = !(matches2[i2] = elem);
                      }
                    }
                  }) : function(elem, _context, xml) {
                    input[0] = elem;
                    matcher(input, null, xml, results);
                    input[0] = null;
                    return !results.pop();
                  };
                }),
                "has": markFunction(function(selector) {
                  return function(elem) {
                    return Sizzle2(selector, elem).length > 0;
                  };
                }),
                "contains": markFunction(function(text) {
                  text = text.replace(runescape, funescape);
                  return function(elem) {
                    return (elem.textContent || getText(elem)).indexOf(text) > -1;
                  };
                }),
                // "Whether an element is represented by a :lang() selector
                // is based solely on the element's language value
                // being equal to the identifier C,
                // or beginning with the identifier C immediately followed by "-".
                // The matching of C against the element's language value is performed case-insensitively.
                // The identifier C does not have to be a valid language name."
                // http://www.w3.org/TR/selectors/#lang-pseudo
                "lang": markFunction(function(lang) {
                  if (!ridentifier.test(lang || "")) {
                    Sizzle2.error("unsupported lang: " + lang);
                  }
                  lang = lang.replace(runescape, funescape).toLowerCase();
                  return function(elem) {
                    var elemLang;
                    do {
                      if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                        elemLang = elemLang.toLowerCase();
                        return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                      }
                    } while ((elem = elem.parentNode) && elem.nodeType === 1);
                    return false;
                  };
                }),
                // Miscellaneous
                "target": function(elem) {
                  var hash3 = window3.location && window3.location.hash;
                  return hash3 && hash3.slice(1) === elem.id;
                },
                "root": function(elem) {
                  return elem === docElem;
                },
                "focus": function(elem) {
                  return elem === document3.activeElement && (!document3.hasFocus || document3.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                // Boolean properties
                "enabled": createDisabledPseudo(false),
                "disabled": createDisabledPseudo(true),
                "checked": function(elem) {
                  var nodeName2 = elem.nodeName.toLowerCase();
                  return nodeName2 === "input" && !!elem.checked || nodeName2 === "option" && !!elem.selected;
                },
                "selected": function(elem) {
                  if (elem.parentNode) {
                    elem.parentNode.selectedIndex;
                  }
                  return elem.selected === true;
                },
                // Contents
                "empty": function(elem) {
                  for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                    if (elem.nodeType < 6) {
                      return false;
                    }
                  }
                  return true;
                },
                "parent": function(elem) {
                  return !Expr.pseudos["empty"](elem);
                },
                // Element/input types
                "header": function(elem) {
                  return rheader.test(elem.nodeName);
                },
                "input": function(elem) {
                  return rinputs.test(elem.nodeName);
                },
                "button": function(elem) {
                  var name = elem.nodeName.toLowerCase();
                  return name === "input" && elem.type === "button" || name === "button";
                },
                "text": function(elem) {
                  var attr;
                  return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && // Support: IE <10 only
                  // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                  ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                // Position-in-collection
                "first": createPositionalPseudo(function() {
                  return [0];
                }),
                "last": createPositionalPseudo(function(_matchIndexes, length) {
                  return [length - 1];
                }),
                "eq": createPositionalPseudo(function(_matchIndexes, length, argument) {
                  return [argument < 0 ? argument + length : argument];
                }),
                "even": createPositionalPseudo(function(matchIndexes, length) {
                  var i2 = 0;
                  for (; i2 < length; i2 += 2) {
                    matchIndexes.push(i2);
                  }
                  return matchIndexes;
                }),
                "odd": createPositionalPseudo(function(matchIndexes, length) {
                  var i2 = 1;
                  for (; i2 < length; i2 += 2) {
                    matchIndexes.push(i2);
                  }
                  return matchIndexes;
                }),
                "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                  var i2 = argument < 0 ? argument + length : argument > length ? length : argument;
                  for (; --i2 >= 0; ) {
                    matchIndexes.push(i2);
                  }
                  return matchIndexes;
                }),
                "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                  var i2 = argument < 0 ? argument + length : argument;
                  for (; ++i2 < length; ) {
                    matchIndexes.push(i2);
                  }
                  return matchIndexes;
                })
              }
            };
            Expr.pseudos["nth"] = Expr.pseudos["eq"];
            for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
              Expr.pseudos[i] = createInputPseudo(i);
            }
            for (i in { submit: true, reset: true }) {
              Expr.pseudos[i] = createButtonPseudo(i);
            }
            function setFilters() {
            }
            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();
            tokenize2 = Sizzle2.tokenize = function(selector, parseOnly) {
              var matched, match2, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
              if (cached) {
                return parseOnly ? 0 : cached.slice(0);
              }
              soFar = selector;
              groups = [];
              preFilters = Expr.preFilter;
              while (soFar) {
                if (!matched || (match2 = rcomma.exec(soFar))) {
                  if (match2) {
                    soFar = soFar.slice(match2[0].length) || soFar;
                  }
                  groups.push(tokens = []);
                }
                matched = false;
                if (match2 = rleadingCombinator.exec(soFar)) {
                  matched = match2.shift();
                  tokens.push({
                    value: matched,
                    // Cast descendant combinators to space
                    type: match2[0].replace(rtrim2, " ")
                  });
                  soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                  if ((match2 = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match2 = preFilters[type](match2)))) {
                    matched = match2.shift();
                    tokens.push({
                      value: matched,
                      type,
                      matches: match2
                    });
                    soFar = soFar.slice(matched.length);
                  }
                }
                if (!matched) {
                  break;
                }
              }
              return parseOnly ? soFar.length : soFar ? Sizzle2.error(selector) : (
                // Cache the tokens
                tokenCache(selector, groups).slice(0)
              );
            };
            function toSelector(tokens) {
              var i2 = 0, len = tokens.length, selector = "";
              for (; i2 < len; i2++) {
                selector += tokens[i2].value;
              }
              return selector;
            }
            function addCombinator(matcher, combinator, base3) {
              var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base3 && key === "parentNode", doneName = done++;
              return combinator.first ? (
                // Check against closest ancestor/preceding element
                function(elem, context, xml) {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      return matcher(elem, context, xml);
                    }
                  }
                  return false;
                }
              ) : (
                // Check against all ancestor/preceding elements
                function(elem, context, xml) {
                  var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
                  if (xml) {
                    while (elem = elem[dir2]) {
                      if (elem.nodeType === 1 || checkNonElements) {
                        if (matcher(elem, context, xml)) {
                          return true;
                        }
                      }
                    }
                  } else {
                    while (elem = elem[dir2]) {
                      if (elem.nodeType === 1 || checkNonElements) {
                        outerCache = elem[expando] || (elem[expando] = {});
                        uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                        if (skip && skip === elem.nodeName.toLowerCase()) {
                          elem = elem[dir2] || elem;
                        } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                          return newCache[2] = oldCache[2];
                        } else {
                          uniqueCache[key] = newCache;
                          if (newCache[2] = matcher(elem, context, xml)) {
                            return true;
                          }
                        }
                      }
                    }
                  }
                  return false;
                }
              );
            }
            function elementMatcher(matchers) {
              return matchers.length > 1 ? function(elem, context, xml) {
                var i2 = matchers.length;
                while (i2--) {
                  if (!matchers[i2](elem, context, xml)) {
                    return false;
                  }
                }
                return true;
              } : matchers[0];
            }
            function multipleContexts(selector, contexts, results) {
              var i2 = 0, len = contexts.length;
              for (; i2 < len; i2++) {
                Sizzle2(selector, contexts[i2], results);
              }
              return results;
            }
            function condense(unmatched, map, filter3, context, xml) {
              var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map != null;
              for (; i2 < len; i2++) {
                if (elem = unmatched[i2]) {
                  if (!filter3 || filter3(elem, context, xml)) {
                    newUnmatched.push(elem);
                    if (mapped) {
                      map.push(i2);
                    }
                  }
                }
              }
              return newUnmatched;
            }
            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
              if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
              }
              if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
              }
              return markFunction(function(seed, results, context, xml) {
                var temp, i2, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
                  selector || "*",
                  context.nodeType ? [context] : context,
                  []
                ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? (
                  // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                  postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                    // ...intermediate processing is necessary
                    []
                  ) : (
                    // ...otherwise use results directly
                    results
                  )
                ) : matcherIn;
                if (matcher) {
                  matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                  temp = condense(matcherOut, postMap);
                  postFilter(temp, [], context, xml);
                  i2 = temp.length;
                  while (i2--) {
                    if (elem = temp[i2]) {
                      matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
                    }
                  }
                }
                if (seed) {
                  if (postFinder || preFilter) {
                    if (postFinder) {
                      temp = [];
                      i2 = matcherOut.length;
                      while (i2--) {
                        if (elem = matcherOut[i2]) {
                          temp.push(matcherIn[i2] = elem);
                        }
                      }
                      postFinder(null, matcherOut = [], temp, xml);
                    }
                    i2 = matcherOut.length;
                    while (i2--) {
                      if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf3(seed, elem) : preMap[i2]) > -1) {
                        seed[temp] = !(results[temp] = elem);
                      }
                    }
                  }
                } else {
                  matcherOut = condense(
                    matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
                  );
                  if (postFinder) {
                    postFinder(null, results, matcherOut, xml);
                  } else {
                    push2.apply(results, matcherOut);
                  }
                }
              });
            }
            function matcherFromTokens(tokens) {
              var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext;
              }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf3(checkContext, elem) > -1;
              }, implicitRelative, true), matchers = [function(elem, context, xml) {
                var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                checkContext = null;
                return ret;
              }];
              for (; i2 < len; i2++) {
                if (matcher = Expr.relative[tokens[i2].type]) {
                  matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                  matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
                  if (matcher[expando]) {
                    j = ++i2;
                    for (; j < len; j++) {
                      if (Expr.relative[tokens[j].type]) {
                        break;
                      }
                    }
                    return setMatcher(
                      i2 > 1 && elementMatcher(matchers),
                      i2 > 1 && toSelector(
                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                        tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })
                      ).replace(rtrim2, "$1"),
                      matcher,
                      i2 < j && matcherFromTokens(tokens.slice(i2, j)),
                      j < len && matcherFromTokens(tokens = tokens.slice(j)),
                      j < len && toSelector(tokens)
                    );
                  }
                  matchers.push(matcher);
                }
              }
              return elementMatcher(matchers);
            }
            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
              var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                if (outermost) {
                  outermostContext = context == document3 || context || outermost;
                }
                for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
                  if (byElement && elem) {
                    j = 0;
                    if (!context && elem.ownerDocument != document3) {
                      setDocument(elem);
                      xml = !documentIsHTML;
                    }
                    while (matcher = elementMatchers[j++]) {
                      if (matcher(elem, context || document3, xml)) {
                        results.push(elem);
                        break;
                      }
                    }
                    if (outermost) {
                      dirruns = dirrunsUnique;
                    }
                  }
                  if (bySet) {
                    if (elem = !matcher && elem) {
                      matchedCount--;
                    }
                    if (seed) {
                      unmatched.push(elem);
                    }
                  }
                }
                matchedCount += i2;
                if (bySet && i2 !== matchedCount) {
                  j = 0;
                  while (matcher = setMatchers[j++]) {
                    matcher(unmatched, setMatched, context, xml);
                  }
                  if (seed) {
                    if (matchedCount > 0) {
                      while (i2--) {
                        if (!(unmatched[i2] || setMatched[i2])) {
                          setMatched[i2] = pop.call(results);
                        }
                      }
                    }
                    setMatched = condense(setMatched);
                  }
                  push2.apply(results, setMatched);
                  if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                    Sizzle2.uniqueSort(results);
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                  outermostContext = contextBackup;
                }
                return unmatched;
              };
              return bySet ? markFunction(superMatcher) : superMatcher;
            }
            compile = Sizzle2.compile = function(selector, match2) {
              var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
              if (!cached) {
                if (!match2) {
                  match2 = tokenize2(selector);
                }
                i2 = match2.length;
                while (i2--) {
                  cached = matcherFromTokens(match2[i2]);
                  if (cached[expando]) {
                    setMatchers.push(cached);
                  } else {
                    elementMatchers.push(cached);
                  }
                }
                cached = compilerCache(
                  selector,
                  matcherFromGroupMatchers(elementMatchers, setMatchers)
                );
                cached.selector = selector;
              }
              return cached;
            };
            select = Sizzle2.select = function(selector, context, results, seed) {
              var i2, tokens, token, type, find, compiled = typeof selector === "function" && selector, match2 = !seed && tokenize2(selector = compiled.selector || selector);
              results = results || [];
              if (match2.length === 1) {
                tokens = match2[0] = match2[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                  context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                  if (!context) {
                    return results;
                  } else if (compiled) {
                    context = context.parentNode;
                  }
                  selector = selector.slice(tokens.shift().value.length);
                }
                i2 = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while (i2--) {
                  token = tokens[i2];
                  if (Expr.relative[type = token.type]) {
                    break;
                  }
                  if (find = Expr.find[type]) {
                    if (seed = find(
                      token.matches[0].replace(runescape, funescape),
                      rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                    )) {
                      tokens.splice(i2, 1);
                      selector = seed.length && toSelector(tokens);
                      if (!selector) {
                        push2.apply(results, seed);
                        return results;
                      }
                      break;
                    }
                  }
                }
              }
              (compiled || compile(selector, match2))(
                seed,
                context,
                !documentIsHTML,
                results,
                !context || rsibling.test(selector) && testContext(context.parentNode) || context
              );
              return results;
            };
            support2.sortStable = expando.split("").sort(sortOrder).join("") === expando;
            support2.detectDuplicates = !!hasDuplicate;
            setDocument();
            support2.sortDetached = assert(function(el) {
              return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
            });
            if (!assert(function(el) {
              el.innerHTML = "<a href='#'></a>";
              return el.firstChild.getAttribute("href") === "#";
            })) {
              addHandle("type|href|height|width", function(elem, name, isXML2) {
                if (!isXML2) {
                  return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                }
              });
            }
            if (!support2.attributes || !assert(function(el) {
              el.innerHTML = "<input/>";
              el.firstChild.setAttribute("value", "");
              return el.firstChild.getAttribute("value") === "";
            })) {
              addHandle("value", function(elem, _name, isXML2) {
                if (!isXML2 && elem.nodeName.toLowerCase() === "input") {
                  return elem.defaultValue;
                }
              });
            }
            if (!assert(function(el) {
              return el.getAttribute("disabled") == null;
            })) {
              addHandle(booleans, function(elem, name, isXML2) {
                var val;
                if (!isXML2) {
                  return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
              });
            }
            return Sizzle2;
          }(window2)
        );
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[":"] = jQuery.expr.pseudos;
        jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;
        jQuery.escapeSelector = Sizzle.escape;
        var dir = function(elem, dir2, until) {
          var matched = [], truncate = until !== void 0;
          while ((elem = elem[dir2]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
              if (truncate && jQuery(elem).is(until)) {
                break;
              }
              matched.push(elem);
            }
          }
          return matched;
        };
        var siblings = function(n, elem) {
          var matched = [];
          for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
              matched.push(n);
            }
          }
          return matched;
        };
        var rneedsContext = jQuery.expr.match.needsContext;
        function nodeName(elem, name) {
          return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        }
        var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        function winnow(elements, qualifier, not) {
          if (isFunction(qualifier)) {
            return jQuery.grep(elements, function(elem, i) {
              return !!qualifier.call(elem, i, elem) !== not;
            });
          }
          if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem) {
              return elem === qualifier !== not;
            });
          }
          if (typeof qualifier !== "string") {
            return jQuery.grep(elements, function(elem) {
              return indexOf2.call(qualifier, elem) > -1 !== not;
            });
          }
          return jQuery.filter(qualifier, elements, not);
        }
        jQuery.filter = function(expr, elems, not) {
          var elem = elems[0];
          if (not) {
            expr = ":not(" + expr + ")";
          }
          if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
          }
          return jQuery.find.matches(expr, jQuery.grep(elems, function(elem2) {
            return elem2.nodeType === 1;
          }));
        };
        jQuery.fn.extend({
          find: function(selector) {
            var i, ret, len = this.length, self2 = this;
            if (typeof selector !== "string") {
              return this.pushStack(jQuery(selector).filter(function() {
                for (i = 0; i < len; i++) {
                  if (jQuery.contains(self2[i], this)) {
                    return true;
                  }
                }
              }));
            }
            ret = this.pushStack([]);
            for (i = 0; i < len; i++) {
              jQuery.find(selector, self2[i], ret);
            }
            return len > 1 ? jQuery.uniqueSort(ret) : ret;
          },
          filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
          },
          not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
          },
          is: function(selector) {
            return !!winnow(
              this,
              // If this is a positional/relative selector, check membership in the returned set
              // so $("p:first").is("p:last") won't return true for a doc with two "p".
              typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [],
              false
            ).length;
          }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root) {
          var match2, elem;
          if (!selector) {
            return this;
          }
          root = root || rootjQuery;
          if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
              match2 = [null, selector, null];
            } else {
              match2 = rquickExpr.exec(selector);
            }
            if (match2 && (match2[1] || !context)) {
              if (match2[1]) {
                context = context instanceof jQuery ? context[0] : context;
                jQuery.merge(this, jQuery.parseHTML(
                  match2[1],
                  context && context.nodeType ? context.ownerDocument || context : document2,
                  true
                ));
                if (rsingleTag.test(match2[1]) && jQuery.isPlainObject(context)) {
                  for (match2 in context) {
                    if (isFunction(this[match2])) {
                      this[match2](context[match2]);
                    } else {
                      this.attr(match2, context[match2]);
                    }
                  }
                }
                return this;
              } else {
                elem = document2.getElementById(match2[2]);
                if (elem) {
                  this[0] = elem;
                  this.length = 1;
                }
                return this;
              }
            } else if (!context || context.jquery) {
              return (context || root).find(selector);
            } else {
              return this.constructor(context).find(selector);
            }
          } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;
          } else if (isFunction(selector)) {
            return root.ready !== void 0 ? root.ready(selector) : (
              // Execute immediately if ready is not present
              selector(jQuery)
            );
          }
          return jQuery.makeArray(selector, this);
        };
        init.prototype = jQuery.fn;
        rootjQuery = jQuery(document2);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
          children: true,
          contents: true,
          next: true,
          prev: true
        };
        jQuery.fn.extend({
          has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
              var i = 0;
              for (; i < l; i++) {
                if (jQuery.contains(this, targets[i])) {
                  return true;
                }
              }
            });
          },
          closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
            if (!rneedsContext.test(selectors)) {
              for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                  if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                    // Don't pass non-elements to Sizzle
                    cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors)
                  ))) {
                    matched.push(cur);
                    break;
                  }
                }
              }
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
          },
          // Determine the position of an element within the set
          index: function(elem) {
            if (!elem) {
              return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
              return indexOf2.call(jQuery(elem), this[0]);
            }
            return indexOf2.call(
              this,
              // If it receives a jQuery object, the first element is used
              elem.jquery ? elem[0] : elem
            );
          },
          add: function(selector, context) {
            return this.pushStack(
              jQuery.uniqueSort(
                jQuery.merge(this.get(), jQuery(selector, context))
              )
            );
          },
          addBack: function(selector) {
            return this.add(
              selector == null ? this.prevObject : this.prevObject.filter(selector)
            );
          }
        });
        function sibling(cur, dir2) {
          while ((cur = cur[dir2]) && cur.nodeType !== 1) {
          }
          return cur;
        }
        jQuery.each({
          parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
          },
          parents: function(elem) {
            return dir(elem, "parentNode");
          },
          parentsUntil: function(elem, _i, until) {
            return dir(elem, "parentNode", until);
          },
          next: function(elem) {
            return sibling(elem, "nextSibling");
          },
          prev: function(elem) {
            return sibling(elem, "previousSibling");
          },
          nextAll: function(elem) {
            return dir(elem, "nextSibling");
          },
          prevAll: function(elem) {
            return dir(elem, "previousSibling");
          },
          nextUntil: function(elem, _i, until) {
            return dir(elem, "nextSibling", until);
          },
          prevUntil: function(elem, _i, until) {
            return dir(elem, "previousSibling", until);
          },
          siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
          },
          children: function(elem) {
            return siblings(elem.firstChild);
          },
          contents: function(elem) {
            if (elem.contentDocument != null && // Support: IE 11+
            // <object> elements with no `data` attribute has an object
            // `contentDocument` with a `null` prototype.
            getProto(elem.contentDocument)) {
              return elem.contentDocument;
            }
            if (nodeName(elem, "template")) {
              elem = elem.content || elem;
            }
            return jQuery.merge([], elem.childNodes);
          }
        }, function(name, fn2) {
          jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn2, until);
            if (name.slice(-5) !== "Until") {
              selector = until;
            }
            if (selector && typeof selector === "string") {
              matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
              if (!guaranteedUnique[name]) {
                jQuery.uniqueSort(matched);
              }
              if (rparentsprev.test(name)) {
                matched.reverse();
              }
            }
            return this.pushStack(matched);
          };
        });
        var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
        function createOptions(options2) {
          var object = {};
          jQuery.each(options2.match(rnothtmlwhite) || [], function(_, flag) {
            object[flag] = true;
          });
          return object;
        }
        jQuery.Callbacks = function(options2) {
          options2 = typeof options2 === "string" ? createOptions(options2) : jQuery.extend({}, options2);
          var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            locked = locked || options2.once;
            fired = firing = true;
            for (; queue.length; firingIndex = -1) {
              memory = queue.shift();
              while (++firingIndex < list.length) {
                if (list[firingIndex].apply(memory[0], memory[1]) === false && options2.stopOnFalse) {
                  firingIndex = list.length;
                  memory = false;
                }
              }
            }
            if (!options2.memory) {
              memory = false;
            }
            firing = false;
            if (locked) {
              if (memory) {
                list = [];
              } else {
                list = "";
              }
            }
          }, self2 = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
              if (list) {
                if (memory && !firing) {
                  firingIndex = list.length - 1;
                  queue.push(memory);
                }
                (function add2(args) {
                  jQuery.each(args, function(_, arg) {
                    if (isFunction(arg)) {
                      if (!options2.unique || !self2.has(arg)) {
                        list.push(arg);
                      }
                    } else if (arg && arg.length && toType2(arg) !== "string") {
                      add2(arg);
                    }
                  });
                })(arguments);
                if (memory && !firing) {
                  fire();
                }
              }
              return this;
            },
            // Remove a callback from the list
            remove: function() {
              jQuery.each(arguments, function(_, arg) {
                var index;
                while ((index = jQuery.inArray(arg, list, index)) > -1) {
                  list.splice(index, 1);
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              });
              return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn2) {
              return fn2 ? jQuery.inArray(fn2, list) > -1 : list.length > 0;
            },
            // Remove all callbacks from the list
            empty: function() {
              if (list) {
                list = [];
              }
              return this;
            },
            // Disable .fire and .add
            // Abort any current/pending executions
            // Clear all callbacks and values
            disable: function() {
              locked = queue = [];
              list = memory = "";
              return this;
            },
            disabled: function() {
              return !list;
            },
            // Disable .fire
            // Also disable .add unless we have memory (since it would have no effect)
            // Abort any pending executions
            lock: function() {
              locked = queue = [];
              if (!memory && !firing) {
                list = memory = "";
              }
              return this;
            },
            locked: function() {
              return !!locked;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function(context, args) {
              if (!locked) {
                args = args || [];
                args = [context, args.slice ? args.slice() : args];
                queue.push(args);
                if (!firing) {
                  fire();
                }
              }
              return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
              self2.fireWith(this, arguments);
              return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
              return !!fired;
            }
          };
          return self2;
        };
        function Identity(v) {
          return v;
        }
        function Thrower(ex) {
          throw ex;
        }
        function adoptValue(value, resolve, reject, noValue) {
          var method;
          try {
            if (value && isFunction(method = value.promise)) {
              method.call(value).done(resolve).fail(reject);
            } else if (value && isFunction(method = value.then)) {
              method.call(value, resolve, reject);
            } else {
              resolve.apply(void 0, [value].slice(noValue));
            }
          } catch (value2) {
            reject.apply(void 0, [value2]);
          }
        }
        jQuery.extend({
          Deferred: function(func) {
            var tuples = [
              // action, add listener, callbacks,
              // ... .then handlers, argument index, [final state]
              [
                "notify",
                "progress",
                jQuery.Callbacks("memory"),
                jQuery.Callbacks("memory"),
                2
              ],
              [
                "resolve",
                "done",
                jQuery.Callbacks("once memory"),
                jQuery.Callbacks("once memory"),
                0,
                "resolved"
              ],
              [
                "reject",
                "fail",
                jQuery.Callbacks("once memory"),
                jQuery.Callbacks("once memory"),
                1,
                "rejected"
              ]
            ], state = "pending", promise = {
              state: function() {
                return state;
              },
              always: function() {
                deferred.done(arguments).fail(arguments);
                return this;
              },
              "catch": function(fn2) {
                return promise.then(null, fn2);
              },
              // Keep pipe for back-compat
              pipe: function() {
                var fns = arguments;
                return jQuery.Deferred(function(newDefer) {
                  jQuery.each(tuples, function(_i, tuple) {
                    var fn2 = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                    deferred[tuple[1]](function() {
                      var returned = fn2 && fn2.apply(this, arguments);
                      if (returned && isFunction(returned.promise)) {
                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                      } else {
                        newDefer[tuple[0] + "With"](
                          this,
                          fn2 ? [returned] : arguments
                        );
                      }
                    });
                  });
                  fns = null;
                }).promise();
              },
              then: function(onFulfilled, onRejected, onProgress) {
                var maxDepth = 0;
                function resolve(depth, deferred2, handler, special) {
                  return function() {
                    var that = this, args = arguments, mightThrow = function() {
                      var returned, then;
                      if (depth < maxDepth) {
                        return;
                      }
                      returned = handler.apply(that, args);
                      if (returned === deferred2.promise()) {
                        throw new TypeError("Thenable self-resolution");
                      }
                      then = returned && // Support: Promises/A+ section 2.3.4
                      // https://promisesaplus.com/#point-64
                      // Only check objects and functions for thenability
                      (typeof returned === "object" || typeof returned === "function") && returned.then;
                      if (isFunction(then)) {
                        if (special) {
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special)
                          );
                        } else {
                          maxDepth++;
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special),
                            resolve(
                              maxDepth,
                              deferred2,
                              Identity,
                              deferred2.notifyWith
                            )
                          );
                        }
                      } else {
                        if (handler !== Identity) {
                          that = void 0;
                          args = [returned];
                        }
                        (special || deferred2.resolveWith)(that, args);
                      }
                    }, process2 = special ? mightThrow : function() {
                      try {
                        mightThrow();
                      } catch (e) {
                        if (jQuery.Deferred.exceptionHook) {
                          jQuery.Deferred.exceptionHook(
                            e,
                            process2.stackTrace
                          );
                        }
                        if (depth + 1 >= maxDepth) {
                          if (handler !== Thrower) {
                            that = void 0;
                            args = [e];
                          }
                          deferred2.rejectWith(that, args);
                        }
                      }
                    };
                    if (depth) {
                      process2();
                    } else {
                      if (jQuery.Deferred.getStackHook) {
                        process2.stackTrace = jQuery.Deferred.getStackHook();
                      }
                      window2.setTimeout(process2);
                    }
                  };
                }
                return jQuery.Deferred(function(newDefer) {
                  tuples[0][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onProgress) ? onProgress : Identity,
                      newDefer.notifyWith
                    )
                  );
                  tuples[1][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onFulfilled) ? onFulfilled : Identity
                    )
                  );
                  tuples[2][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onRejected) ? onRejected : Thrower
                    )
                  );
                }).promise();
              },
              // Get a promise for this deferred
              // If obj is provided, the promise aspect is added to the object
              promise: function(obj) {
                return obj != null ? jQuery.extend(obj, promise) : promise;
              }
            }, deferred = {};
            jQuery.each(tuples, function(i, tuple) {
              var list = tuple[2], stateString = tuple[5];
              promise[tuple[1]] = list.add;
              if (stateString) {
                list.add(
                  function() {
                    state = stateString;
                  },
                  // rejected_callbacks.disable
                  // fulfilled_callbacks.disable
                  tuples[3 - i][2].disable,
                  // rejected_handlers.disable
                  // fulfilled_handlers.disable
                  tuples[3 - i][3].disable,
                  // progress_callbacks.lock
                  tuples[0][2].lock,
                  // progress_handlers.lock
                  tuples[0][3].lock
                );
              }
              list.add(tuple[3].fire);
              deferred[tuple[0]] = function() {
                deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
                return this;
              };
              deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
              func.call(deferred, deferred);
            }
            return deferred;
          },
          // Deferred helper
          when: function(singleValue) {
            var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), primary = jQuery.Deferred(), updateFunc = function(i2) {
              return function(value) {
                resolveContexts[i2] = this;
                resolveValues[i2] = arguments.length > 1 ? slice.call(arguments) : value;
                if (!--remaining) {
                  primary.resolveWith(resolveContexts, resolveValues);
                }
              };
            };
            if (remaining <= 1) {
              adoptValue(
                singleValue,
                primary.done(updateFunc(i)).resolve,
                primary.reject,
                !remaining
              );
              if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
                return primary.then();
              }
            }
            while (i--) {
              adoptValue(resolveValues[i], updateFunc(i), primary.reject);
            }
            return primary.promise();
          }
        });
        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        jQuery.Deferred.exceptionHook = function(error2, stack) {
          if (window2.console && window2.console.warn && error2 && rerrorNames.test(error2.name)) {
            window2.console.warn("jQuery.Deferred exception: " + error2.message, error2.stack, stack);
          }
        };
        jQuery.readyException = function(error2) {
          window2.setTimeout(function() {
            throw error2;
          });
        };
        var readyList = jQuery.Deferred();
        jQuery.fn.ready = function(fn2) {
          readyList.then(fn2).catch(function(error2) {
            jQuery.readyException(error2);
          });
          return this;
        };
        jQuery.extend({
          // Is the DOM ready to be used? Set to true once it occurs.
          isReady: false,
          // A counter to track how many items to wait for before
          // the ready event fires. See trac-6781
          readyWait: 1,
          // Handle when the DOM is ready
          ready: function(wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
              return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
              return;
            }
            readyList.resolveWith(document2, [jQuery]);
          }
        });
        jQuery.ready.then = readyList.then;
        function completed() {
          document2.removeEventListener("DOMContentLoaded", completed);
          window2.removeEventListener("load", completed);
          jQuery.ready();
        }
        if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
          window2.setTimeout(jQuery.ready);
        } else {
          document2.addEventListener("DOMContentLoaded", completed);
          window2.addEventListener("load", completed);
        }
        var access = function(elems, fn2, key, value, chainable, emptyGet, raw) {
          var i = 0, len = elems.length, bulk = key == null;
          if (toType2(key) === "object") {
            chainable = true;
            for (i in key) {
              access(elems, fn2, i, key[i], true, emptyGet, raw);
            }
          } else if (value !== void 0) {
            chainable = true;
            if (!isFunction(value)) {
              raw = true;
            }
            if (bulk) {
              if (raw) {
                fn2.call(elems, value);
                fn2 = null;
              } else {
                bulk = fn2;
                fn2 = function(elem, _key, value2) {
                  return bulk.call(jQuery(elem), value2);
                };
              }
            }
            if (fn2) {
              for (; i < len; i++) {
                fn2(
                  elems[i],
                  key,
                  raw ? value : value.call(elems[i], i, fn2(elems[i], key))
                );
              }
            }
          }
          if (chainable) {
            return elems;
          }
          if (bulk) {
            return fn2.call(elems);
          }
          return len ? fn2(elems[0], key) : emptyGet;
        };
        var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
        function fcamelCase(_all, letter) {
          return letter.toUpperCase();
        }
        function camelCase(string) {
          return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        }
        var acceptData = function(owner) {
          return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
        };
        function Data4() {
          this.expando = jQuery.expando + Data4.uid++;
        }
        Data4.uid = 1;
        Data4.prototype = {
          cache: function(owner) {
            var value = owner[this.expando];
            if (!value) {
              value = {};
              if (acceptData(owner)) {
                if (owner.nodeType) {
                  owner[this.expando] = value;
                } else {
                  Object.defineProperty(owner, this.expando, {
                    value,
                    configurable: true
                  });
                }
              }
            }
            return value;
          },
          set: function(owner, data, value) {
            var prop, cache2 = this.cache(owner);
            if (typeof data === "string") {
              cache2[camelCase(data)] = value;
            } else {
              for (prop in data) {
                cache2[camelCase(prop)] = data[prop];
              }
            }
            return cache2;
          },
          get: function(owner, key) {
            return key === void 0 ? this.cache(owner) : (
              // Always use camelCase key (gh-2257)
              owner[this.expando] && owner[this.expando][camelCase(key)]
            );
          },
          access: function(owner, key, value) {
            if (key === void 0 || key && typeof key === "string" && value === void 0) {
              return this.get(owner, key);
            }
            this.set(owner, key, value);
            return value !== void 0 ? value : key;
          },
          remove: function(owner, key) {
            var i, cache2 = owner[this.expando];
            if (cache2 === void 0) {
              return;
            }
            if (key !== void 0) {
              if (Array.isArray(key)) {
                key = key.map(camelCase);
              } else {
                key = camelCase(key);
                key = key in cache2 ? [key] : key.match(rnothtmlwhite) || [];
              }
              i = key.length;
              while (i--) {
                delete cache2[key[i]];
              }
            }
            if (key === void 0 || jQuery.isEmptyObject(cache2)) {
              if (owner.nodeType) {
                owner[this.expando] = void 0;
              } else {
                delete owner[this.expando];
              }
            }
          },
          hasData: function(owner) {
            var cache2 = owner[this.expando];
            return cache2 !== void 0 && !jQuery.isEmptyObject(cache2);
          }
        };
        var dataPriv = new Data4();
        var dataUser = new Data4();
        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
        function getData(data) {
          if (data === "true") {
            return true;
          }
          if (data === "false") {
            return false;
          }
          if (data === "null") {
            return null;
          }
          if (data === +data + "") {
            return +data;
          }
          if (rbrace.test(data)) {
            return JSON.parse(data);
          }
          return data;
        }
        function dataAttr(elem, key, data) {
          var name;
          if (data === void 0 && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
              try {
                data = getData(data);
              } catch (e) {
              }
              dataUser.set(elem, key, data);
            } else {
              data = void 0;
            }
          }
          return data;
        }
        jQuery.extend({
          hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
          },
          data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
          },
          removeData: function(elem, name) {
            dataUser.remove(elem, name);
          },
          // TODO: Now that all calls to _data and _removeData have been replaced
          // with direct calls to dataPriv methods, these can be deprecated.
          _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
          },
          _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
          }
        });
        jQuery.fn.extend({
          data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === void 0) {
              if (this.length) {
                data = dataUser.get(elem);
                if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                  i = attrs.length;
                  while (i--) {
                    if (attrs[i]) {
                      name = attrs[i].name;
                      if (name.indexOf("data-") === 0) {
                        name = camelCase(name.slice(5));
                        dataAttr(elem, name, data[name]);
                      }
                    }
                  }
                  dataPriv.set(elem, "hasDataAttrs", true);
                }
              }
              return data;
            }
            if (typeof key === "object") {
              return this.each(function() {
                dataUser.set(this, key);
              });
            }
            return access(this, function(value2) {
              var data2;
              if (elem && value2 === void 0) {
                data2 = dataUser.get(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                data2 = dataAttr(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                return;
              }
              this.each(function() {
                dataUser.set(this, key, value2);
              });
            }, null, value, arguments.length > 1, null, true);
          },
          removeData: function(key) {
            return this.each(function() {
              dataUser.remove(this, key);
            });
          }
        });
        jQuery.extend({
          queue: function(elem, type, data) {
            var queue;
            if (elem) {
              type = (type || "fx") + "queue";
              queue = dataPriv.get(elem, type);
              if (data) {
                if (!queue || Array.isArray(data)) {
                  queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                } else {
                  queue.push(data);
                }
              }
              return queue || [];
            }
          },
          dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn2 = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
              jQuery.dequeue(elem, type);
            };
            if (fn2 === "inprogress") {
              fn2 = queue.shift();
              startLength--;
            }
            if (fn2) {
              if (type === "fx") {
                queue.unshift("inprogress");
              }
              delete hooks.stop;
              fn2.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
              hooks.empty.fire();
            }
          },
          // Not public - generate a queueHooks object, or return the current one
          _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
              empty: jQuery.Callbacks("once memory").add(function() {
                dataPriv.remove(elem, [type + "queue", key]);
              })
            });
          }
        });
        jQuery.fn.extend({
          queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
              data = type;
              type = "fx";
              setter--;
            }
            if (arguments.length < setter) {
              return jQuery.queue(this[0], type);
            }
            return data === void 0 ? this : this.each(function() {
              var queue = jQuery.queue(this, type, data);
              jQuery._queueHooks(this, type);
              if (type === "fx" && queue[0] !== "inprogress") {
                jQuery.dequeue(this, type);
              }
            });
          },
          dequeue: function(type) {
            return this.each(function() {
              jQuery.dequeue(this, type);
            });
          },
          clearQueue: function(type) {
            return this.queue(type || "fx", []);
          },
          // Get a promise resolved when queues of a certain type
          // are emptied (fx is the type by default)
          promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
              if (!--count) {
                defer.resolveWith(elements, [elements]);
              }
            };
            if (typeof type !== "string") {
              obj = type;
              type = void 0;
            }
            type = type || "fx";
            while (i--) {
              tmp = dataPriv.get(elements[i], type + "queueHooks");
              if (tmp && tmp.empty) {
                count++;
                tmp.empty.add(resolve);
              }
            }
            resolve();
            return defer.promise(obj);
          }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
        var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
        var cssExpand = ["Top", "Right", "Bottom", "Left"];
        var documentElement = document2.documentElement;
        var isAttached = function(elem) {
          return jQuery.contains(elem.ownerDocument, elem);
        }, composed = { composed: true };
        if (documentElement.getRootNode) {
          isAttached = function(elem) {
            return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
          };
        }
        var isHiddenWithinTree = function(elem, el) {
          elem = el || elem;
          return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
          // Support: Firefox <=43 - 45
          // Disconnected elements can have computed display: none, so first confirm that elem is
          // in the document.
          isAttached(elem) && jQuery.css(elem, "display") === "none";
        };
        function adjustCSS(elem, prop, valueParts, tween) {
          var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
          } : function() {
            return jQuery.css(elem, prop, "");
          }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
          if (initialInUnit && initialInUnit[3] !== unit) {
            initial = initial / 2;
            unit = unit || initialInUnit[3];
            initialInUnit = +initial || 1;
            while (maxIterations--) {
              jQuery.style(elem, prop, initialInUnit + unit);
              if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                maxIterations = 0;
              }
              initialInUnit = initialInUnit / scale;
            }
            initialInUnit = initialInUnit * 2;
            jQuery.style(elem, prop, initialInUnit + unit);
            valueParts = valueParts || [];
          }
          if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
              tween.unit = unit;
              tween.start = initialInUnit;
              tween.end = adjusted;
            }
          }
          return adjusted;
        }
        var defaultDisplayMap = {};
        function getDefaultDisplay(elem) {
          var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
          if (display) {
            return display;
          }
          temp = doc.body.appendChild(doc.createElement(nodeName2));
          display = jQuery.css(temp, "display");
          temp.parentNode.removeChild(temp);
          if (display === "none") {
            display = "block";
          }
          defaultDisplayMap[nodeName2] = display;
          return display;
        }
        function showHide(elements, show) {
          var display, elem, values = [], index = 0, length = elements.length;
          for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
              continue;
            }
            display = elem.style.display;
            if (show) {
              if (display === "none") {
                values[index] = dataPriv.get(elem, "display") || null;
                if (!values[index]) {
                  elem.style.display = "";
                }
              }
              if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                values[index] = getDefaultDisplay(elem);
              }
            } else {
              if (display !== "none") {
                values[index] = "none";
                dataPriv.set(elem, "display", display);
              }
            }
          }
          for (index = 0; index < length; index++) {
            if (values[index] != null) {
              elements[index].style.display = values[index];
            }
          }
          return elements;
        }
        jQuery.fn.extend({
          show: function() {
            return showHide(this, true);
          },
          hide: function() {
            return showHide(this);
          },
          toggle: function(state) {
            if (typeof state === "boolean") {
              return state ? this.show() : this.hide();
            }
            return this.each(function() {
              if (isHiddenWithinTree(this)) {
                jQuery(this).show();
              } else {
                jQuery(this).hide();
              }
            });
          }
        });
        var rcheckableType = /^(?:checkbox|radio)$/i;
        var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
        var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
        (function() {
          var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
          input.setAttribute("type", "radio");
          input.setAttribute("checked", "checked");
          input.setAttribute("name", "t");
          div.appendChild(input);
          support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
          div.innerHTML = "<textarea>x</textarea>";
          support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
          div.innerHTML = "<option></option>";
          support.option = !!div.lastChild;
        })();
        var wrapMap = {
          // XHTML parsers do not magically insert elements in the
          // same way that tag soup parsers do. So we cannot shorten
          // this by omitting <tbody> or other required elements.
          thead: [1, "<table>", "</table>"],
          col: [2, "<table><colgroup>", "</colgroup></table>"],
          tr: [2, "<table><tbody>", "</tbody></table>"],
          td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
          _default: [0, "", ""]
        };
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        if (!support.option) {
          wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
        }
        function getAll(context, tag) {
          var ret;
          if (typeof context.getElementsByTagName !== "undefined") {
            ret = context.getElementsByTagName(tag || "*");
          } else if (typeof context.querySelectorAll !== "undefined") {
            ret = context.querySelectorAll(tag || "*");
          } else {
            ret = [];
          }
          if (tag === void 0 || tag && nodeName(context, tag)) {
            return jQuery.merge([context], ret);
          }
          return ret;
        }
        function setGlobalEval(elems, refElements) {
          var i = 0, l = elems.length;
          for (; i < l; i++) {
            dataPriv.set(
              elems[i],
              "globalEval",
              !refElements || dataPriv.get(refElements[i], "globalEval")
            );
          }
        }
        var rhtml = /<|&#?\w+;/;
        function buildFragment(elems, context, scripts, selection, ignored) {
          var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
          for (; i < l; i++) {
            elem = elems[i];
            if (elem || elem === 0) {
              if (toType2(elem) === "object") {
                jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
              } else if (!rhtml.test(elem)) {
                nodes.push(context.createTextNode(elem));
              } else {
                tmp = tmp || fragment.appendChild(context.createElement("div"));
                tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                wrap = wrapMap[tag] || wrapMap._default;
                tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                j = wrap[0];
                while (j--) {
                  tmp = tmp.lastChild;
                }
                jQuery.merge(nodes, tmp.childNodes);
                tmp = fragment.firstChild;
                tmp.textContent = "";
              }
            }
          }
          fragment.textContent = "";
          i = 0;
          while (elem = nodes[i++]) {
            if (selection && jQuery.inArray(elem, selection) > -1) {
              if (ignored) {
                ignored.push(elem);
              }
              continue;
            }
            attached = isAttached(elem);
            tmp = getAll(fragment.appendChild(elem), "script");
            if (attached) {
              setGlobalEval(tmp);
            }
            if (scripts) {
              j = 0;
              while (elem = tmp[j++]) {
                if (rscriptType.test(elem.type || "")) {
                  scripts.push(elem);
                }
              }
            }
          }
          return fragment;
        }
        var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
        function returnTrue() {
          return true;
        }
        function returnFalse() {
          return false;
        }
        function expectSync(elem, type) {
          return elem === safeActiveElement() === (type === "focus");
        }
        function safeActiveElement() {
          try {
            return document2.activeElement;
          } catch (err) {
          }
        }
        function on(elem, types4, selector, data, fn2, one) {
          var origFn, type;
          if (typeof types4 === "object") {
            if (typeof selector !== "string") {
              data = data || selector;
              selector = void 0;
            }
            for (type in types4) {
              on(elem, type, selector, data, types4[type], one);
            }
            return elem;
          }
          if (data == null && fn2 == null) {
            fn2 = selector;
            data = selector = void 0;
          } else if (fn2 == null) {
            if (typeof selector === "string") {
              fn2 = data;
              data = void 0;
            } else {
              fn2 = data;
              data = selector;
              selector = void 0;
            }
          }
          if (fn2 === false) {
            fn2 = returnFalse;
          } else if (!fn2) {
            return elem;
          }
          if (one === 1) {
            origFn = fn2;
            fn2 = function(event) {
              jQuery().off(event);
              return origFn.apply(this, arguments);
            };
            fn2.guid = origFn.guid || (origFn.guid = jQuery.guid++);
          }
          return elem.each(function() {
            jQuery.event.add(this, types4, fn2, data, selector);
          });
        }
        jQuery.event = {
          global: {},
          add: function(elem, types4, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!acceptData(elem)) {
              return;
            }
            if (handler.handler) {
              handleObjIn = handler;
              handler = handleObjIn.handler;
              selector = handleObjIn.selector;
            }
            if (selector) {
              jQuery.find.matchesSelector(documentElement, selector);
            }
            if (!handler.guid) {
              handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
              events = elemData.events = /* @__PURE__ */ Object.create(null);
            }
            if (!(eventHandle = elemData.handle)) {
              eventHandle = elemData.handle = function(e) {
                return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
              };
            }
            types4 = (types4 || "").match(rnothtmlwhite) || [""];
            t = types4.length;
            while (t--) {
              tmp = rtypenamespace.exec(types4[t]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                continue;
              }
              special = jQuery.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              special = jQuery.event.special[type] || {};
              handleObj = jQuery.extend({
                type,
                origType,
                data,
                handler,
                guid: handler.guid,
                selector,
                needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
              }, handleObjIn);
              if (!(handlers = events[type])) {
                handlers = events[type] = [];
                handlers.delegateCount = 0;
                if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                  if (elem.addEventListener) {
                    elem.addEventListener(type, eventHandle);
                  }
                }
              }
              if (special.add) {
                special.add.call(elem, handleObj);
                if (!handleObj.handler.guid) {
                  handleObj.handler.guid = handler.guid;
                }
              }
              if (selector) {
                handlers.splice(handlers.delegateCount++, 0, handleObj);
              } else {
                handlers.push(handleObj);
              }
              jQuery.event.global[type] = true;
            }
          },
          // Detach an event or set of events from an element
          remove: function(elem, types4, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
              return;
            }
            types4 = (types4 || "").match(rnothtmlwhite) || [""];
            t = types4.length;
            while (t--) {
              tmp = rtypenamespace.exec(types4[t]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                for (type in events) {
                  jQuery.event.remove(elem, type + types4[t], handler, selector, true);
                }
                continue;
              }
              special = jQuery.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              handlers = events[type] || [];
              tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
              origCount = j = handlers.length;
              while (j--) {
                handleObj = handlers[j];
                if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                  handlers.splice(j, 1);
                  if (handleObj.selector) {
                    handlers.delegateCount--;
                  }
                  if (special.remove) {
                    special.remove.call(elem, handleObj);
                  }
                }
              }
              if (origCount && !handlers.length) {
                if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                  jQuery.removeEvent(elem, type, elemData.handle);
                }
                delete events[type];
              }
            }
            if (jQuery.isEmptyObject(events)) {
              dataPriv.remove(elem, "handle events");
            }
          },
          dispatch: function(nativeEvent) {
            var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            for (i = 1; i < arguments.length; i++) {
              args[i] = arguments[i];
            }
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
              return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
              event.currentTarget = matched.elem;
              j = 0;
              while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                  event.handleObj = handleObj;
                  event.data = handleObj.data;
                  ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                  if (ret !== void 0) {
                    if ((event.result = ret) === false) {
                      event.preventDefault();
                      event.stopPropagation();
                    }
                  }
                }
              }
            }
            if (special.postDispatch) {
              special.postDispatch.call(this, event);
            }
            return event.result;
          },
          handlers: function(event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && // Support: IE <=9
            // Black-hole SVG <use> instance trees (trac-13180)
            cur.nodeType && // Support: Firefox <=42
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11 only
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !(event.type === "click" && event.button >= 1)) {
              for (; cur !== this; cur = cur.parentNode || this) {
                if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                  matchedHandlers = [];
                  matchedSelectors = {};
                  for (i = 0; i < delegateCount; i++) {
                    handleObj = handlers[i];
                    sel = handleObj.selector + " ";
                    if (matchedSelectors[sel] === void 0) {
                      matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                    }
                    if (matchedSelectors[sel]) {
                      matchedHandlers.push(handleObj);
                    }
                  }
                  if (matchedHandlers.length) {
                    handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                  }
                }
              }
            }
            cur = this;
            if (delegateCount < handlers.length) {
              handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
            }
            return handlerQueue;
          },
          addProp: function(name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
              enumerable: true,
              configurable: true,
              get: isFunction(hook) ? function() {
                if (this.originalEvent) {
                  return hook(this.originalEvent);
                }
              } : function() {
                if (this.originalEvent) {
                  return this.originalEvent[name];
                }
              },
              set: function(value) {
                Object.defineProperty(this, name, {
                  enumerable: true,
                  configurable: true,
                  writable: true,
                  value
                });
              }
            });
          },
          fix: function(originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
          },
          special: {
            load: {
              // Prevent triggered image.load events from bubbling to window.load
              noBubble: true
            },
            click: {
              // Utilize native event to ensure correct state for checkable inputs
              setup: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click", returnTrue);
                }
                return false;
              },
              trigger: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click");
                }
                return true;
              },
              // For cross-browser consistency, suppress native .click() on links
              // Also prevent it if we're currently inside a leveraged native-event stack
              _default: function(event) {
                var target = event.target;
                return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
              }
            },
            beforeunload: {
              postDispatch: function(event) {
                if (event.result !== void 0 && event.originalEvent) {
                  event.originalEvent.returnValue = event.result;
                }
              }
            }
          }
        };
        function leverageNative(el, type, expectSync2) {
          if (!expectSync2) {
            if (dataPriv.get(el, type) === void 0) {
              jQuery.event.add(el, type, returnTrue);
            }
            return;
          }
          dataPriv.set(el, type, false);
          jQuery.event.add(el, type, {
            namespace: false,
            handler: function(event) {
              var notAsync, result, saved = dataPriv.get(this, type);
              if (event.isTrigger & 1 && this[type]) {
                if (!saved.length) {
                  saved = slice.call(arguments);
                  dataPriv.set(this, type, saved);
                  notAsync = expectSync2(this, type);
                  this[type]();
                  result = dataPriv.get(this, type);
                  if (saved !== result || notAsync) {
                    dataPriv.set(this, type, false);
                  } else {
                    result = {};
                  }
                  if (saved !== result) {
                    event.stopImmediatePropagation();
                    event.preventDefault();
                    return result && result.value;
                  }
                } else if ((jQuery.event.special[type] || {}).delegateType) {
                  event.stopPropagation();
                }
              } else if (saved.length) {
                dataPriv.set(this, type, {
                  value: jQuery.event.trigger(
                    // Support: IE <=9 - 11+
                    // Extend with the prototype to reset the above stopImmediatePropagation()
                    jQuery.extend(saved[0], jQuery.Event.prototype),
                    saved.slice(1),
                    this
                  )
                });
                event.stopImmediatePropagation();
              }
            }
          });
        }
        jQuery.removeEvent = function(elem, type, handle) {
          if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
          }
        };
        jQuery.Event = function(src, props) {
          if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
          }
          if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
            src.returnValue === false ? returnTrue : returnFalse;
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
          } else {
            this.type = src;
          }
          if (props) {
            jQuery.extend(this, props);
          }
          this.timeStamp = src && src.timeStamp || Date.now();
          this[jQuery.expando] = true;
        };
        jQuery.Event.prototype = {
          constructor: jQuery.Event,
          isDefaultPrevented: returnFalse,
          isPropagationStopped: returnFalse,
          isImmediatePropagationStopped: returnFalse,
          isSimulated: false,
          preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) {
              e.preventDefault();
            }
          },
          stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
              e.stopPropagation();
            }
          },
          stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
              e.stopImmediatePropagation();
            }
            this.stopPropagation();
          }
        };
        jQuery.each({
          altKey: true,
          bubbles: true,
          cancelable: true,
          changedTouches: true,
          ctrlKey: true,
          detail: true,
          eventPhase: true,
          metaKey: true,
          pageX: true,
          pageY: true,
          shiftKey: true,
          view: true,
          "char": true,
          code: true,
          charCode: true,
          key: true,
          keyCode: true,
          button: true,
          buttons: true,
          clientX: true,
          clientY: true,
          offsetX: true,
          offsetY: true,
          pointerId: true,
          pointerType: true,
          screenX: true,
          screenY: true,
          targetTouches: true,
          toElement: true,
          touches: true,
          which: true
        }, jQuery.event.addProp);
        jQuery.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
          jQuery.event.special[type] = {
            // Utilize native event if possible so blur/focus sequence is correct
            setup: function() {
              leverageNative(this, type, expectSync);
              return false;
            },
            trigger: function() {
              leverageNative(this, type);
              return true;
            },
            // Suppress native focus or blur if we're currently inside
            // a leveraged native-event stack
            _default: function(event) {
              return dataPriv.get(event.target, type);
            },
            delegateType
          };
        });
        jQuery.each({
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          pointerenter: "pointerover",
          pointerleave: "pointerout"
        }, function(orig, fix) {
          jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
              var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
              if (!related || related !== target && !jQuery.contains(target, related)) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply(this, arguments);
                event.type = fix;
              }
              return ret;
            }
          };
        });
        jQuery.fn.extend({
          on: function(types4, selector, data, fn2) {
            return on(this, types4, selector, data, fn2);
          },
          one: function(types4, selector, data, fn2) {
            return on(this, types4, selector, data, fn2, 1);
          },
          off: function(types4, selector, fn2) {
            var handleObj, type;
            if (types4 && types4.preventDefault && types4.handleObj) {
              handleObj = types4.handleObj;
              jQuery(types4.delegateTarget).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
              );
              return this;
            }
            if (typeof types4 === "object") {
              for (type in types4) {
                this.off(type, selector, types4[type]);
              }
              return this;
            }
            if (selector === false || typeof selector === "function") {
              fn2 = selector;
              selector = void 0;
            }
            if (fn2 === false) {
              fn2 = returnFalse;
            }
            return this.each(function() {
              jQuery.event.remove(this, types4, fn2, selector);
            });
          }
        });
        var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
        function manipulationTarget(elem, content) {
          if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
            return jQuery(elem).children("tbody")[0] || elem;
          }
          return elem;
        }
        function disableScript(elem) {
          elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
          return elem;
        }
        function restoreScript(elem) {
          if ((elem.type || "").slice(0, 5) === "true/") {
            elem.type = elem.type.slice(5);
          } else {
            elem.removeAttribute("type");
          }
          return elem;
        }
        function cloneCopyEvent(src, dest) {
          var i, l, type, pdataOld, udataOld, udataCur, events;
          if (dest.nodeType !== 1) {
            return;
          }
          if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.get(src);
            events = pdataOld.events;
            if (events) {
              dataPriv.remove(dest, "handle events");
              for (type in events) {
                for (i = 0, l = events[type].length; i < l; i++) {
                  jQuery.event.add(dest, type, events[type][i]);
                }
              }
            }
          }
          if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);
            dataUser.set(dest, udataCur);
          }
        }
        function fixInput(src, dest) {
          var nodeName2 = dest.nodeName.toLowerCase();
          if (nodeName2 === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
          } else if (nodeName2 === "input" || nodeName2 === "textarea") {
            dest.defaultValue = src.defaultValue;
          }
        }
        function domManip(collection, args, callback, ignored) {
          args = flat(args);
          var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);
          if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
            return collection.each(function(index) {
              var self2 = collection.eq(index);
              if (valueIsFunction) {
                args[0] = value.call(this, index, self2.html());
              }
              domManip(self2, args, callback, ignored);
            });
          }
          if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
              fragment = first;
            }
            if (first || ignored) {
              scripts = jQuery.map(getAll(fragment, "script"), disableScript);
              hasScripts = scripts.length;
              for (; i < l; i++) {
                node = fragment;
                if (i !== iNoClone) {
                  node = jQuery.clone(node, true, true);
                  if (hasScripts) {
                    jQuery.merge(scripts, getAll(node, "script"));
                  }
                }
                callback.call(collection[i], node, i);
              }
              if (hasScripts) {
                doc = scripts[scripts.length - 1].ownerDocument;
                jQuery.map(scripts, restoreScript);
                for (i = 0; i < hasScripts; i++) {
                  node = scripts[i];
                  if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                    if (node.src && (node.type || "").toLowerCase() !== "module") {
                      if (jQuery._evalUrl && !node.noModule) {
                        jQuery._evalUrl(node.src, {
                          nonce: node.nonce || node.getAttribute("nonce")
                        }, doc);
                      }
                    } else {
                      DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                    }
                  }
                }
              }
            }
          }
          return collection;
        }
        function remove(elem, selector, keepData) {
          var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
          for (; (node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
              jQuery.cleanData(getAll(node));
            }
            if (node.parentNode) {
              if (keepData && isAttached(node)) {
                setGlobalEval(getAll(node, "script"));
              }
              node.parentNode.removeChild(node);
            }
          }
          return elem;
        }
        jQuery.extend({
          htmlPrefilter: function(html) {
            return html;
          },
          clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone5 = elem.cloneNode(true), inPage = isAttached(elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
              destElements = getAll(clone5);
              srcElements = getAll(elem);
              for (i = 0, l = srcElements.length; i < l; i++) {
                fixInput(srcElements[i], destElements[i]);
              }
            }
            if (dataAndEvents) {
              if (deepDataAndEvents) {
                srcElements = srcElements || getAll(elem);
                destElements = destElements || getAll(clone5);
                for (i = 0, l = srcElements.length; i < l; i++) {
                  cloneCopyEvent(srcElements[i], destElements[i]);
                }
              } else {
                cloneCopyEvent(elem, clone5);
              }
            }
            destElements = getAll(clone5, "script");
            if (destElements.length > 0) {
              setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone5;
          },
          cleanData: function(elems) {
            var data, elem, type, special = jQuery.event.special, i = 0;
            for (; (elem = elems[i]) !== void 0; i++) {
              if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                  if (data.events) {
                    for (type in data.events) {
                      if (special[type]) {
                        jQuery.event.remove(elem, type);
                      } else {
                        jQuery.removeEvent(elem, type, data.handle);
                      }
                    }
                  }
                  elem[dataPriv.expando] = void 0;
                }
                if (elem[dataUser.expando]) {
                  elem[dataUser.expando] = void 0;
                }
              }
            }
          }
        });
        jQuery.fn.extend({
          detach: function(selector) {
            return remove(this, selector, true);
          },
          remove: function(selector) {
            return remove(this, selector);
          },
          text: function(value) {
            return access(this, function(value2) {
              return value2 === void 0 ? jQuery.text(this) : this.empty().each(function() {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  this.textContent = value2;
                }
              });
            }, null, value, arguments.length);
          },
          append: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.appendChild(elem);
              }
            });
          },
          prepend: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.insertBefore(elem, target.firstChild);
              }
            });
          },
          before: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this);
              }
            });
          },
          after: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this.nextSibling);
              }
            });
          },
          empty: function() {
            var elem, i = 0;
            for (; (elem = this[i]) != null; i++) {
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.textContent = "";
              }
            }
            return this;
          },
          clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
              return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
          },
          html: function(value) {
            return access(this, function(value2) {
              var elem = this[0] || {}, i = 0, l = this.length;
              if (value2 === void 0 && elem.nodeType === 1) {
                return elem.innerHTML;
              }
              if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
                value2 = jQuery.htmlPrefilter(value2);
                try {
                  for (; i < l; i++) {
                    elem = this[i] || {};
                    if (elem.nodeType === 1) {
                      jQuery.cleanData(getAll(elem, false));
                      elem.innerHTML = value2;
                    }
                  }
                  elem = 0;
                } catch (e) {
                }
              }
              if (elem) {
                this.empty().append(value2);
              }
            }, null, value, arguments.length);
          },
          replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
              var parent = this.parentNode;
              if (jQuery.inArray(this, ignored) < 0) {
                jQuery.cleanData(getAll(this));
                if (parent) {
                  parent.replaceChild(elem, this);
                }
              }
            }, ignored);
          }
        });
        jQuery.each({
          appendTo: "append",
          prependTo: "prepend",
          insertBefore: "before",
          insertAfter: "after",
          replaceAll: "replaceWith"
        }, function(name, original) {
          jQuery.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery(selector), last5 = insert.length - 1, i = 0;
            for (; i <= last5; i++) {
              elems = i === last5 ? this : this.clone(true);
              jQuery(insert[i])[original](elems);
              push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
          };
        });
        var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
        var rcustomProp = /^--/;
        var getStyles = function(elem) {
          var view = elem.ownerDocument.defaultView;
          if (!view || !view.opener) {
            view = window2;
          }
          return view.getComputedStyle(elem);
        };
        var swap = function(elem, options2, callback) {
          var ret, name, old = {};
          for (name in options2) {
            old[name] = elem.style[name];
            elem.style[name] = options2[name];
          }
          ret = callback.call(elem);
          for (name in options2) {
            elem.style[name] = old[name];
          }
          return ret;
        };
        var rboxStyle = new RegExp(cssExpand.join("|"), "i");
        var whitespace = "[\\x20\\t\\r\\n\\f]";
        var rtrimCSS = new RegExp(
          "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
          "g"
        );
        (function() {
          function computeStyleTests() {
            if (!div) {
              return;
            }
            container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
            div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div);
            var divStyle = window2.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            div.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
            documentElement.removeChild(container);
            div = null;
          }
          function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
          }
          var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
          if (!div.style) {
            return;
          }
          div.style.backgroundClip = "content-box";
          div.cloneNode(true).style.backgroundClip = "";
          support.clearCloneStyle = div.style.backgroundClip === "content-box";
          jQuery.extend(support, {
            boxSizingReliable: function() {
              computeStyleTests();
              return boxSizingReliableVal;
            },
            pixelBoxStyles: function() {
              computeStyleTests();
              return pixelBoxStylesVal;
            },
            pixelPosition: function() {
              computeStyleTests();
              return pixelPositionVal;
            },
            reliableMarginLeft: function() {
              computeStyleTests();
              return reliableMarginLeftVal;
            },
            scrollboxSize: function() {
              computeStyleTests();
              return scrollboxSizeVal;
            },
            // Support: IE 9 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Behavior in IE 9 is more subtle than in newer versions & it passes
            // some versions of this test; make sure not to make it pass there!
            //
            // Support: Firefox 70+
            // Only Firefox includes border widths
            // in computed dimensions. (gh-4529)
            reliableTrDimensions: function() {
              var table, tr, trChild, trStyle;
              if (reliableTrDimensionsVal == null) {
                table = document2.createElement("table");
                tr = document2.createElement("tr");
                trChild = document2.createElement("div");
                table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
                tr.style.cssText = "border:1px solid";
                tr.style.height = "1px";
                trChild.style.height = "9px";
                trChild.style.display = "block";
                documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
                trStyle = window2.getComputedStyle(tr);
                reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
                documentElement.removeChild(table);
              }
              return reliableTrDimensionsVal;
            }
          });
        })();
        function curCSS(elem, name, computed) {
          var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem.style;
          computed = computed || getStyles(elem);
          if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
            if (isCustomProp && ret) {
              ret = ret.replace(rtrimCSS, "$1") || void 0;
            }
            if (ret === "" && !isAttached(elem)) {
              ret = jQuery.style(elem, name);
            }
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
              width = style.width;
              minWidth = style.minWidth;
              maxWidth = style.maxWidth;
              style.minWidth = style.maxWidth = style.width = ret;
              ret = computed.width;
              style.width = width;
              style.minWidth = minWidth;
              style.maxWidth = maxWidth;
            }
          }
          return ret !== void 0 ? (
            // Support: IE <=9 - 11 only
            // IE returns zIndex value as an integer.
            ret + ""
          ) : ret;
        }
        function addGetHookIf(conditionFn, hookFn) {
          return {
            get: function() {
              if (conditionFn()) {
                delete this.get;
                return;
              }
              return (this.get = hookFn).apply(this, arguments);
            }
          };
        }
        var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
        function vendorPropName(name) {
          var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
          while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
              return name;
            }
          }
        }
        function finalPropName(name) {
          var final = jQuery.cssProps[name] || vendorProps[name];
          if (final) {
            return final;
          }
          if (name in emptyStyle) {
            return name;
          }
          return vendorProps[name] = vendorPropName(name) || name;
        }
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
          letterSpacing: "0",
          fontWeight: "400"
        };
        function setPositiveNumber(_elem, value, subtract) {
          var matches = rcssNum.exec(value);
          return matches ? (
            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
          ) : value;
        }
        function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
          var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0;
          if (box === (isBorderBox ? "border" : "content")) {
            return 0;
          }
          for (; i < 4; i += 2) {
            if (box === "margin") {
              delta += jQuery.css(elem, box + cssExpand[i], true, styles);
            }
            if (!isBorderBox) {
              delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
              if (box !== "padding") {
                delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
              } else {
                extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
              }
            } else {
              if (box === "content") {
                delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
              }
              if (box !== "margin") {
                delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
              }
            }
          }
          if (!isBorderBox && computedVal >= 0) {
            delta += Math.max(0, Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
              // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
              // Use an explicit zero to avoid NaN (gh-3964)
            )) || 0;
          }
          return delta;
        }
        function getWidthOrHeight(elem, dimension, extra) {
          var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
          if (rnumnonpx.test(val)) {
            if (!extra) {
              return val;
            }
            val = "auto";
          }
          if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Interestingly, in some cases IE 9 doesn't suffer from this issue.
          !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
          // This happens for inline elements with no explicit setting (gh-3571)
          val === "auto" || // Support: Android <=4.1 - 4.3 only
          // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
          !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
          elem.getClientRects().length) {
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) {
              val = elem[offsetProp];
            }
          }
          val = parseFloat(val) || 0;
          return val + boxModelAdjustment(
            elem,
            dimension,
            extra || (isBorderBox ? "border" : "content"),
            valueIsBorderBox,
            styles,
            // Provide the current computed size to request scroll gutter calculation (gh-3589)
            val
          ) + "px";
        }
        jQuery.extend({
          // Add in style property hooks for overriding the default
          // behavior of getting and setting a style property
          cssHooks: {
            opacity: {
              get: function(elem, computed) {
                if (computed) {
                  var ret = curCSS(elem, "opacity");
                  return ret === "" ? "1" : ret;
                }
              }
            }
          },
          // Don't automatically add "px" to these possibly-unitless properties
          cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "gridArea": true,
            "gridColumn": true,
            "gridColumnEnd": true,
            "gridColumnStart": true,
            "gridRow": true,
            "gridRowEnd": true,
            "gridRowStart": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
          },
          // Add in properties whose names you wish to fix before
          // setting or getting the value
          cssProps: {},
          // Get and set the style property on a DOM Node
          style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
              return;
            }
            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== void 0) {
              type = typeof value;
              if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                value = adjustCSS(elem, name, ret);
                type = "number";
              }
              if (value == null || value !== value) {
                return;
              }
              if (type === "number" && !isCustomProp) {
                value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
              }
              if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                style[name] = "inherit";
              }
              if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
                if (isCustomProp) {
                  style.setProperty(name, value);
                } else {
                  style[name] = value;
                }
              }
            } else {
              if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
                return ret;
              }
              return style[name];
            }
          },
          css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && "get" in hooks) {
              val = hooks.get(elem, true, extra);
            }
            if (val === void 0) {
              val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
              val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
              num = parseFloat(val);
              return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
          }
        });
        jQuery.each(["height", "width"], function(_i, dimension) {
          jQuery.cssHooks[dimension] = {
            get: function(elem, computed, extra) {
              if (computed) {
                return rdisplayswap.test(jQuery.css(elem, "display")) && // Support: Safari 8+
                // Table columns in Safari have non-zero offsetWidth & zero
                // getBoundingClientRect().width unless display is changed.
                // Support: IE <=11 only
                // Running getBoundingClientRect on a disconnected node
                // in IE throws an error.
                (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                  return getWidthOrHeight(elem, dimension, extra);
                }) : getWidthOrHeight(elem, dimension, extra);
              }
            },
            set: function(elem, value, extra) {
              var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
                elem,
                dimension,
                extra,
                isBorderBox,
                styles
              ) : 0;
              if (isBorderBox && scrollboxSizeBuggy) {
                subtract -= Math.ceil(
                  elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
                );
              }
              if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                elem.style[dimension] = value;
                value = jQuery.css(elem, dimension);
              }
              return setPositiveNumber(elem, value, subtract);
            }
          };
        });
        jQuery.cssHooks.marginLeft = addGetHookIf(
          support.reliableMarginLeft,
          function(elem, computed) {
            if (computed) {
              return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
                return elem.getBoundingClientRect().left;
              })) + "px";
            }
          }
        );
        jQuery.each({
          margin: "",
          padding: "",
          border: "Width"
        }, function(prefix, suffix) {
          jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
              var i = 0, expanded = {}, parts2 = typeof value === "string" ? value.split(" ") : [value];
              for (; i < 4; i++) {
                expanded[prefix + cssExpand[i] + suffix] = parts2[i] || parts2[i - 2] || parts2[0];
              }
              return expanded;
            }
          };
          if (prefix !== "margin") {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
          }
        });
        jQuery.fn.extend({
          css: function(name, value) {
            return access(this, function(elem, name2, value2) {
              var styles, len, map = {}, i = 0;
              if (Array.isArray(name2)) {
                styles = getStyles(elem);
                len = name2.length;
                for (; i < len; i++) {
                  map[name2[i]] = jQuery.css(elem, name2[i], false, styles);
                }
                return map;
              }
              return value2 !== void 0 ? jQuery.style(elem, name2, value2) : jQuery.css(elem, name2);
            }, name, value, arguments.length > 1);
          }
        });
        function Tween(elem, options2, prop, end2, easing) {
          return new Tween.prototype.init(elem, options2, prop, end2, easing);
        }
        jQuery.Tween = Tween;
        Tween.prototype = {
          constructor: Tween,
          init: function(elem, options2, prop, end2, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options2;
            this.start = this.now = this.cur();
            this.end = end2;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
          },
          cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
          },
          run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
              this.pos = eased = jQuery.easing[this.easing](
                percent,
                this.options.duration * percent,
                0,
                1,
                this.options.duration
              );
            } else {
              this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
              this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
              hooks.set(this);
            } else {
              Tween.propHooks._default.set(this);
            }
            return this;
          }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
          _default: {
            get: function(tween) {
              var result;
              if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                return tween.elem[tween.prop];
              }
              result = jQuery.css(tween.elem, tween.prop, "");
              return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
              if (jQuery.fx.step[tween.prop]) {
                jQuery.fx.step[tween.prop](tween);
              } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
                jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
              } else {
                tween.elem[tween.prop] = tween.now;
              }
            }
          }
        };
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
          set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
              tween.elem[tween.prop] = tween.now;
            }
          }
        };
        jQuery.easing = {
          linear: function(p) {
            return p;
          },
          swing: function(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
          },
          _default: "swing"
        };
        jQuery.fx = Tween.prototype.init;
        jQuery.fx.step = {};
        var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
        function schedule() {
          if (inProgress) {
            if (document2.hidden === false && window2.requestAnimationFrame) {
              window2.requestAnimationFrame(schedule);
            } else {
              window2.setTimeout(schedule, jQuery.fx.interval);
            }
            jQuery.fx.tick();
          }
        }
        function createFxNow() {
          window2.setTimeout(function() {
            fxNow = void 0;
          });
          return fxNow = Date.now();
        }
        function genFx(type, includeWidth) {
          var which, i = 0, attrs = { height: type };
          includeWidth = includeWidth ? 1 : 0;
          for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
          }
          if (includeWidth) {
            attrs.opacity = attrs.width = type;
          }
          return attrs;
        }
        function createTween(value, prop, animation) {
          var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
          for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
              return tween;
            }
          }
        }
        function defaultPrefilter(elem, props, opts) {
          var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
          if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
              hooks.unqueued = 0;
              oldfire = hooks.empty.fire;
              hooks.empty.fire = function() {
                if (!hooks.unqueued) {
                  oldfire();
                }
              };
            }
            hooks.unqueued++;
            anim.always(function() {
              anim.always(function() {
                hooks.unqueued--;
                if (!jQuery.queue(elem, "fx").length) {
                  hooks.empty.fire();
                }
              });
            });
          }
          for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
              delete props[prop];
              toggle = toggle || value === "toggle";
              if (value === (hidden ? "hide" : "show")) {
                if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                  hidden = true;
                } else {
                  continue;
                }
              }
              orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
          }
          propTween = !jQuery.isEmptyObject(props);
          if (!propTween && jQuery.isEmptyObject(orig)) {
            return;
          }
          if (isBox && elem.nodeType === 1) {
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
              restoreDisplay = dataPriv.get(elem, "display");
            }
            display = jQuery.css(elem, "display");
            if (display === "none") {
              if (restoreDisplay) {
                display = restoreDisplay;
              } else {
                showHide([elem], true);
                restoreDisplay = elem.style.display || restoreDisplay;
                display = jQuery.css(elem, "display");
                showHide([elem]);
              }
            }
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
              if (jQuery.css(elem, "float") === "none") {
                if (!propTween) {
                  anim.done(function() {
                    style.display = restoreDisplay;
                  });
                  if (restoreDisplay == null) {
                    display = style.display;
                    restoreDisplay = display === "none" ? "" : display;
                  }
                }
                style.display = "inline-block";
              }
            }
          }
          if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
              style.overflow = opts.overflow[0];
              style.overflowX = opts.overflow[1];
              style.overflowY = opts.overflow[2];
            });
          }
          propTween = false;
          for (prop in orig) {
            if (!propTween) {
              if (dataShow) {
                if ("hidden" in dataShow) {
                  hidden = dataShow.hidden;
                }
              } else {
                dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
              }
              if (toggle) {
                dataShow.hidden = !hidden;
              }
              if (hidden) {
                showHide([elem], true);
              }
              anim.done(function() {
                if (!hidden) {
                  showHide([elem]);
                }
                dataPriv.remove(elem, "fxshow");
                for (prop in orig) {
                  jQuery.style(elem, prop, orig[prop]);
                }
              });
            }
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
              dataShow[prop] = propTween.start;
              if (hidden) {
                propTween.end = propTween.start;
                propTween.start = 0;
              }
            }
          }
        }
        function propFilter(props, specialEasing) {
          var index, name, easing, value, hooks;
          for (index in props) {
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
              easing = value[1];
              value = props[index] = value[0];
            }
            if (index !== name) {
              props[name] = value;
              delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
              value = hooks.expand(value);
              delete props[name];
              for (index in value) {
                if (!(index in props)) {
                  props[index] = value[index];
                  specialEasing[index] = easing;
                }
              }
            } else {
              specialEasing[name] = easing;
            }
          }
        }
        function Animation(elem, properties, options2) {
          var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
            delete tick.elem;
          }), tick = function() {
            if (stopped) {
              return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
            for (; index2 < length2; index2++) {
              animation.tweens[index2].run(percent);
            }
            deferred.notifyWith(elem, [animation, percent, remaining]);
            if (percent < 1 && length2) {
              return remaining;
            }
            if (!length2) {
              deferred.notifyWith(elem, [animation, 1, 0]);
            }
            deferred.resolveWith(elem, [animation]);
            return false;
          }, animation = deferred.promise({
            elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
              specialEasing: {},
              easing: jQuery.easing._default
            }, options2),
            originalProperties: properties,
            originalOptions: options2,
            startTime: fxNow || createFxNow(),
            duration: options2.duration,
            tweens: [],
            createTween: function(prop, end2) {
              var tween = jQuery.Tween(
                elem,
                animation.opts,
                prop,
                end2,
                animation.opts.specialEasing[prop] || animation.opts.easing
              );
              animation.tweens.push(tween);
              return tween;
            },
            stop: function(gotoEnd) {
              var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
              if (stopped) {
                return this;
              }
              stopped = true;
              for (; index2 < length2; index2++) {
                animation.tweens[index2].run(1);
              }
              if (gotoEnd) {
                deferred.notifyWith(elem, [animation, 1, 0]);
                deferred.resolveWith(elem, [animation, gotoEnd]);
              } else {
                deferred.rejectWith(elem, [animation, gotoEnd]);
              }
              return this;
            }
          }), props = animation.props;
          propFilter(props, animation.opts.specialEasing);
          for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
              if (isFunction(result.stop)) {
                jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
              }
              return result;
            }
          }
          jQuery.map(props, createTween, animation);
          if (isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
          }
          animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
          jQuery.fx.timer(
            jQuery.extend(tick, {
              elem,
              anim: animation,
              queue: animation.opts.queue
            })
          );
          return animation;
        }
        jQuery.Animation = jQuery.extend(Animation, {
          tweeners: {
            "*": [function(prop, value) {
              var tween = this.createTween(prop, value);
              adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
              return tween;
            }]
          },
          tweener: function(props, callback) {
            if (isFunction(props)) {
              callback = props;
              props = ["*"];
            } else {
              props = props.match(rnothtmlwhite);
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
              prop = props[index];
              Animation.tweeners[prop] = Animation.tweeners[prop] || [];
              Animation.tweeners[prop].unshift(callback);
            }
          },
          prefilters: [defaultPrefilter],
          prefilter: function(callback, prepend) {
            if (prepend) {
              Animation.prefilters.unshift(callback);
            } else {
              Animation.prefilters.push(callback);
            }
          }
        });
        jQuery.speed = function(speed, easing, fn2) {
          var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn2 || !fn2 && easing || isFunction(speed) && speed,
            duration: speed,
            easing: fn2 && easing || easing && !isFunction(easing) && easing
          };
          if (jQuery.fx.off) {
            opt.duration = 0;
          } else {
            if (typeof opt.duration !== "number") {
              if (opt.duration in jQuery.fx.speeds) {
                opt.duration = jQuery.fx.speeds[opt.duration];
              } else {
                opt.duration = jQuery.fx.speeds._default;
              }
            }
          }
          if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
          }
          opt.old = opt.complete;
          opt.complete = function() {
            if (isFunction(opt.old)) {
              opt.old.call(this);
            }
            if (opt.queue) {
              jQuery.dequeue(this, opt.queue);
            }
          };
          return opt;
        };
        jQuery.fn.extend({
          fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
          },
          animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
              var anim = Animation(this, jQuery.extend({}, prop), optall);
              if (empty || dataPriv.get(this, "finish")) {
                anim.stop(true);
              }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
          },
          stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
              var stop = hooks.stop;
              delete hooks.stop;
              stop(gotoEnd);
            };
            if (typeof type !== "string") {
              gotoEnd = clearQueue;
              clearQueue = type;
              type = void 0;
            }
            if (clearQueue) {
              this.queue(type || "fx", []);
            }
            return this.each(function() {
              var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
              if (index) {
                if (data[index] && data[index].stop) {
                  stopQueue(data[index]);
                }
              } else {
                for (index in data) {
                  if (data[index] && data[index].stop && rrun.test(index)) {
                    stopQueue(data[index]);
                  }
                }
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                  timers[index].anim.stop(gotoEnd);
                  dequeue = false;
                  timers.splice(index, 1);
                }
              }
              if (dequeue || !gotoEnd) {
                jQuery.dequeue(this, type);
              }
            });
          },
          finish: function(type) {
            if (type !== false) {
              type = type || "fx";
            }
            return this.each(function() {
              var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
              data.finish = true;
              jQuery.queue(this, type, []);
              if (hooks && hooks.stop) {
                hooks.stop.call(this, true);
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && timers[index].queue === type) {
                  timers[index].anim.stop(true);
                  timers.splice(index, 1);
                }
              }
              for (index = 0; index < length; index++) {
                if (queue[index] && queue[index].finish) {
                  queue[index].finish.call(this);
                }
              }
              delete data.finish;
            });
          }
        });
        jQuery.each(["toggle", "show", "hide"], function(_i, name) {
          var cssFn = jQuery.fn[name];
          jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
          };
        });
        jQuery.each({
          slideDown: genFx("show"),
          slideUp: genFx("hide"),
          slideToggle: genFx("toggle"),
          fadeIn: { opacity: "show" },
          fadeOut: { opacity: "hide" },
          fadeToggle: { opacity: "toggle" }
        }, function(name, props) {
          jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
          };
        });
        jQuery.timers = [];
        jQuery.fx.tick = function() {
          var timer, i = 0, timers = jQuery.timers;
          fxNow = Date.now();
          for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
              timers.splice(i--, 1);
            }
          }
          if (!timers.length) {
            jQuery.fx.stop();
          }
          fxNow = void 0;
        };
        jQuery.fx.timer = function(timer) {
          jQuery.timers.push(timer);
          jQuery.fx.start();
        };
        jQuery.fx.interval = 13;
        jQuery.fx.start = function() {
          if (inProgress) {
            return;
          }
          inProgress = true;
          schedule();
        };
        jQuery.fx.stop = function() {
          inProgress = null;
        };
        jQuery.fx.speeds = {
          slow: 600,
          fast: 200,
          // Default speed
          _default: 400
        };
        jQuery.fn.delay = function(time, type) {
          time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
          type = type || "fx";
          return this.queue(type, function(next, hooks) {
            var timeout = window2.setTimeout(next, time);
            hooks.stop = function() {
              window2.clearTimeout(timeout);
            };
          });
        };
        (function() {
          var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
          input.type = "checkbox";
          support.checkOn = input.value !== "";
          support.optSelected = opt.selected;
          input = document2.createElement("input");
          input.value = "t";
          input.type = "radio";
          support.radioValue = input.value === "t";
        })();
        var boolHook, attrHandle = jQuery.expr.attrHandle;
        jQuery.fn.extend({
          attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
          },
          removeAttr: function(name) {
            return this.each(function() {
              jQuery.removeAttr(this, name);
            });
          }
        });
        jQuery.extend({
          attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (typeof elem.getAttribute === "undefined") {
              return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
              hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0);
            }
            if (value !== void 0) {
              if (value === null) {
                jQuery.removeAttr(elem, name);
                return;
              }
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              elem.setAttribute(name, value + "");
              return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            ret = jQuery.find.attr(elem, name);
            return ret == null ? void 0 : ret;
          },
          attrHooks: {
            type: {
              set: function(elem, value) {
                if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                  var val = elem.value;
                  elem.setAttribute("type", value);
                  if (val) {
                    elem.value = val;
                  }
                  return value;
                }
              }
            }
          },
          removeAttr: function(elem, value) {
            var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) {
              while (name = attrNames[i++]) {
                elem.removeAttribute(name);
              }
            }
          }
        });
        boolHook = {
          set: function(elem, value, name) {
            if (value === false) {
              jQuery.removeAttr(elem, name);
            } else {
              elem.setAttribute(name, name);
            }
            return name;
          }
        };
        jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name) {
          var getter = attrHandle[name] || jQuery.find.attr;
          attrHandle[name] = function(elem, name2, isXML) {
            var ret, handle, lowercaseName = name2.toLowerCase();
            if (!isXML) {
              handle = attrHandle[lowercaseName];
              attrHandle[lowercaseName] = ret;
              ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
              attrHandle[lowercaseName] = handle;
            }
            return ret;
          };
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
        jQuery.fn.extend({
          prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
          },
          removeProp: function(name) {
            return this.each(function() {
              delete this[jQuery.propFix[name] || name];
            });
          }
        });
        jQuery.extend({
          prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
              name = jQuery.propFix[name] || name;
              hooks = jQuery.propHooks[name];
            }
            if (value !== void 0) {
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              return elem[name] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            return elem[name];
          },
          propHooks: {
            tabIndex: {
              get: function(elem) {
                var tabindex = jQuery.find.attr(elem, "tabindex");
                if (tabindex) {
                  return parseInt(tabindex, 10);
                }
                if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                  return 0;
                }
                return -1;
              }
            }
          },
          propFix: {
            "for": "htmlFor",
            "class": "className"
          }
        });
        if (!support.optSelected) {
          jQuery.propHooks.selected = {
            get: function(elem) {
              var parent = elem.parentNode;
              if (parent && parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
              return null;
            },
            set: function(elem) {
              var parent = elem.parentNode;
              if (parent) {
                parent.selectedIndex;
                if (parent.parentNode) {
                  parent.parentNode.selectedIndex;
                }
              }
            }
          };
        }
        jQuery.each([
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ], function() {
          jQuery.propFix[this.toLowerCase()] = this;
        });
        function stripAndCollapse(value) {
          var tokens = value.match(rnothtmlwhite) || [];
          return tokens.join(" ");
        }
        function getClass(elem) {
          return elem.getAttribute && elem.getAttribute("class") || "";
        }
        function classesToArray(value) {
          if (Array.isArray(value)) {
            return value;
          }
          if (typeof value === "string") {
            return value.match(rnothtmlwhite) || [];
          }
          return [];
        }
        jQuery.fn.extend({
          addClass: function(value) {
            var classNames8, cur, curValue, className, i, finalValue;
            if (isFunction(value)) {
              return this.each(function(j) {
                jQuery(this).addClass(value.call(this, j, getClass(this)));
              });
            }
            classNames8 = classesToArray(value);
            if (classNames8.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i = 0; i < classNames8.length; i++) {
                    className = classNames8[i];
                    if (cur.indexOf(" " + className + " ") < 0) {
                      cur += className + " ";
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          removeClass: function(value) {
            var classNames8, cur, curValue, className, i, finalValue;
            if (isFunction(value)) {
              return this.each(function(j) {
                jQuery(this).removeClass(value.call(this, j, getClass(this)));
              });
            }
            if (!arguments.length) {
              return this.attr("class", "");
            }
            classNames8 = classesToArray(value);
            if (classNames8.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i = 0; i < classNames8.length; i++) {
                    className = classNames8[i];
                    while (cur.indexOf(" " + className + " ") > -1) {
                      cur = cur.replace(" " + className + " ", " ");
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          toggleClass: function(value, stateVal) {
            var classNames8, className, i, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
            if (isFunction(value)) {
              return this.each(function(i2) {
                jQuery(this).toggleClass(
                  value.call(this, i2, getClass(this), stateVal),
                  stateVal
                );
              });
            }
            if (typeof stateVal === "boolean" && isValidValue) {
              return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            classNames8 = classesToArray(value);
            return this.each(function() {
              if (isValidValue) {
                self2 = jQuery(this);
                for (i = 0; i < classNames8.length; i++) {
                  className = classNames8[i];
                  if (self2.hasClass(className)) {
                    self2.removeClass(className);
                  } else {
                    self2.addClass(className);
                  }
                }
              } else if (value === void 0 || type === "boolean") {
                className = getClass(this);
                if (className) {
                  dataPriv.set(this, "__className__", className);
                }
                if (this.setAttribute) {
                  this.setAttribute(
                    "class",
                    className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                  );
                }
              }
            });
          },
          hasClass: function(selector) {
            var className, elem, i = 0;
            className = " " + selector + " ";
            while (elem = this[i++]) {
              if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                return true;
              }
            }
            return false;
          }
        });
        var rreturn = /\r/g;
        jQuery.fn.extend({
          val: function(value) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
              if (elem) {
                hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                  return ret;
                }
                ret = elem.value;
                if (typeof ret === "string") {
                  return ret.replace(rreturn, "");
                }
                return ret == null ? "" : ret;
              }
              return;
            }
            valueIsFunction = isFunction(value);
            return this.each(function(i) {
              var val;
              if (this.nodeType !== 1) {
                return;
              }
              if (valueIsFunction) {
                val = value.call(this, i, jQuery(this).val());
              } else {
                val = value;
              }
              if (val == null) {
                val = "";
              } else if (typeof val === "number") {
                val += "";
              } else if (Array.isArray(val)) {
                val = jQuery.map(val, function(value2) {
                  return value2 == null ? "" : value2 + "";
                });
              }
              hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
              if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
                this.value = val;
              }
            });
          }
        });
        jQuery.extend({
          valHooks: {
            option: {
              get: function(elem) {
                var val = jQuery.find.attr(elem, "value");
                return val != null ? val : (
                  // Support: IE <=10 - 11 only
                  // option.text throws exceptions (trac-14686, trac-14858)
                  // Strip and collapse whitespace
                  // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                  stripAndCollapse(jQuery.text(elem))
                );
              }
            },
            select: {
              get: function(elem) {
                var value, option, i, options2 = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max2 = one ? index + 1 : options2.length;
                if (index < 0) {
                  i = max2;
                } else {
                  i = one ? index : 0;
                }
                for (; i < max2; i++) {
                  option = options2[i];
                  if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
                  !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                    value = jQuery(option).val();
                    if (one) {
                      return value;
                    }
                    values.push(value);
                  }
                }
                return values;
              },
              set: function(elem, value) {
                var optionSet, option, options2 = elem.options, values = jQuery.makeArray(value), i = options2.length;
                while (i--) {
                  option = options2[i];
                  if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                    optionSet = true;
                  }
                }
                if (!optionSet) {
                  elem.selectedIndex = -1;
                }
                return values;
              }
            }
          }
        });
        jQuery.each(["radio", "checkbox"], function() {
          jQuery.valHooks[this] = {
            set: function(elem, value) {
              if (Array.isArray(value)) {
                return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
              }
            }
          };
          if (!support.checkOn) {
            jQuery.valHooks[this].get = function(elem) {
              return elem.getAttribute("value") === null ? "on" : elem.value;
            };
          }
        });
        support.focusin = "onfocusin" in window2;
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
          e.stopPropagation();
        };
        jQuery.extend(jQuery.event, {
          trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = lastElement = tmp = elem = elem || document2;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
              return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
              return;
            }
            if (type.indexOf(".") > -1) {
              namespaces = type.split(".");
              type = namespaces.shift();
              namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = void 0;
            if (!event.target) {
              event.target = elem;
            }
            data = data == null ? [event] : jQuery.makeArray(data, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
              return;
            }
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
              bubbleType = special.delegateType || type;
              if (!rfocusMorph.test(bubbleType + type)) {
                cur = cur.parentNode;
              }
              for (; cur; cur = cur.parentNode) {
                eventPath.push(cur);
                tmp = cur;
              }
              if (tmp === (elem.ownerDocument || document2)) {
                eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
              }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
              lastElement = cur;
              event.type = i > 1 ? bubbleType : special.bindType || type;
              handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
              if (handle) {
                handle.apply(cur, data);
              }
              handle = ontype && cur[ontype];
              if (handle && handle.apply && acceptData(cur)) {
                event.result = handle.apply(cur, data);
                if (event.result === false) {
                  event.preventDefault();
                }
              }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
              if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                  tmp = elem[ontype];
                  if (tmp) {
                    elem[ontype] = null;
                  }
                  jQuery.event.triggered = type;
                  if (event.isPropagationStopped()) {
                    lastElement.addEventListener(type, stopPropagationCallback);
                  }
                  elem[type]();
                  if (event.isPropagationStopped()) {
                    lastElement.removeEventListener(type, stopPropagationCallback);
                  }
                  jQuery.event.triggered = void 0;
                  if (tmp) {
                    elem[ontype] = tmp;
                  }
                }
              }
            }
            return event.result;
          },
          // Piggyback on a donor event to simulate a different one
          // Used only for `focus(in | out)` events
          simulate: function(type, elem, event) {
            var e = jQuery.extend(
              new jQuery.Event(),
              event,
              {
                type,
                isSimulated: true
              }
            );
            jQuery.event.trigger(e, null, elem);
          }
        });
        jQuery.fn.extend({
          trigger: function(type, data) {
            return this.each(function() {
              jQuery.event.trigger(type, data, this);
            });
          },
          triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
              return jQuery.event.trigger(type, data, elem, true);
            }
          }
        });
        if (!support.focusin) {
          jQuery.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {
            var handler = function(event) {
              jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
            };
            jQuery.event.special[fix] = {
              setup: function() {
                var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix);
                if (!attaches) {
                  doc.addEventListener(orig, handler, true);
                }
                dataPriv.access(doc, fix, (attaches || 0) + 1);
              },
              teardown: function() {
                var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix) - 1;
                if (!attaches) {
                  doc.removeEventListener(orig, handler, true);
                  dataPriv.remove(doc, fix);
                } else {
                  dataPriv.access(doc, fix, attaches);
                }
              }
            };
          });
        }
        var location2 = window2.location;
        var nonce = { guid: Date.now() };
        var rquery = /\?/;
        jQuery.parseXML = function(data) {
          var xml, parserErrorElem;
          if (!data || typeof data !== "string") {
            return null;
          }
          try {
            xml = new window2.DOMParser().parseFromString(data, "text/xml");
          } catch (e) {
          }
          parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
          if (!xml || parserErrorElem) {
            jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
              return el.textContent;
            }).join("\n") : data));
          }
          return xml;
        };
        var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        function buildParams(prefix, obj, traditional, add2) {
          var name;
          if (Array.isArray(obj)) {
            jQuery.each(obj, function(i, v) {
              if (traditional || rbracket.test(prefix)) {
                add2(prefix, v);
              } else {
                buildParams(
                  prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
                  v,
                  traditional,
                  add2
                );
              }
            });
          } else if (!traditional && toType2(obj) === "object") {
            for (name in obj) {
              buildParams(prefix + "[" + name + "]", obj[name], traditional, add2);
            }
          } else {
            add2(prefix, obj);
          }
        }
        jQuery.param = function(a, traditional) {
          var prefix, s = [], add2 = function(key, valueOrFunction) {
            var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
          };
          if (a == null) {
            return "";
          }
          if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function() {
              add2(this.name, this.value);
            });
          } else {
            for (prefix in a) {
              buildParams(prefix, a[prefix], traditional, add2);
            }
          }
          return s.join("&");
        };
        jQuery.fn.extend({
          serialize: function() {
            return jQuery.param(this.serializeArray());
          },
          serializeArray: function() {
            return this.map(function() {
              var elements = jQuery.prop(this, "elements");
              return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
              var type = this.type;
              return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(_i, elem) {
              var val = jQuery(this).val();
              if (val == null) {
                return null;
              }
              if (Array.isArray(val)) {
                return jQuery.map(val, function(val2) {
                  return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
                });
              }
              return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            }).get();
          }
        });
        var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
        originAnchor.href = location2.href;
        function addToPrefiltersOrTransports(structure) {
          return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
              func = dataTypeExpression;
              dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction(func)) {
              while (dataType = dataTypes[i++]) {
                if (dataType[0] === "+") {
                  dataType = dataType.slice(1) || "*";
                  (structure[dataType] = structure[dataType] || []).unshift(func);
                } else {
                  (structure[dataType] = structure[dataType] || []).push(func);
                }
              }
            }
          };
        }
        function inspectPrefiltersOrTransports(structure, options2, originalOptions, jqXHR) {
          var inspected = {}, seekingTransport = structure === transports;
          function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
              var dataTypeOrTransport = prefilterOrFactory(options2, originalOptions, jqXHR);
              if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                options2.dataTypes.unshift(dataTypeOrTransport);
                inspect(dataTypeOrTransport);
                return false;
              } else if (seekingTransport) {
                return !(selected = dataTypeOrTransport);
              }
            });
            return selected;
          }
          return inspect(options2.dataTypes[0]) || !inspected["*"] && inspect("*");
        }
        function ajaxExtend(target, src) {
          var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
          for (key in src) {
            if (src[key] !== void 0) {
              (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
          }
          if (deep) {
            jQuery.extend(true, target, deep);
          }
          return target;
        }
        function ajaxHandleResponses(s, jqXHR, responses) {
          var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
          while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === void 0) {
              ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
          }
          if (ct) {
            for (type in contents) {
              if (contents[type] && contents[type].test(ct)) {
                dataTypes.unshift(type);
                break;
              }
            }
          }
          if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
          } else {
            for (type in responses) {
              if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                finalDataType = type;
                break;
              }
              if (!firstDataType) {
                firstDataType = type;
              }
            }
            finalDataType = finalDataType || firstDataType;
          }
          if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
              dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
          }
        }
        function ajaxConvert(s, response, jqXHR, isSuccess) {
          var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
          if (dataTypes[1]) {
            for (conv in s.converters) {
              converters[conv.toLowerCase()] = s.converters[conv];
            }
          }
          current = dataTypes.shift();
          while (current) {
            if (s.responseFields[current]) {
              jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
              response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
              if (current === "*") {
                current = prev;
              } else if (prev !== "*" && prev !== current) {
                conv = converters[prev + " " + current] || converters["* " + current];
                if (!conv) {
                  for (conv2 in converters) {
                    tmp = conv2.split(" ");
                    if (tmp[1] === current) {
                      conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                      if (conv) {
                        if (conv === true) {
                          conv = converters[conv2];
                        } else if (converters[conv2] !== true) {
                          current = tmp[0];
                          dataTypes.unshift(tmp[1]);
                        }
                        break;
                      }
                    }
                  }
                }
                if (conv !== true) {
                  if (conv && s.throws) {
                    response = conv(response);
                  } else {
                    try {
                      response = conv(response);
                    } catch (e) {
                      return {
                        state: "parsererror",
                        error: conv ? e : "No conversion from " + prev + " to " + current
                      };
                    }
                  }
                }
              }
            }
          }
          return { state: "success", data: response };
        }
        jQuery.extend({
          // Counter for holding the number of active queries
          active: 0,
          // Last-Modified header cache for next request
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: location2.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location2.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            throws: false,
            traditional: false,
            headers: {},
            */
            accepts: {
              "*": allTypes,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript"
            },
            contents: {
              xml: /\bxml\b/,
              html: /\bhtml/,
              json: /\bjson\b/
            },
            responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON"
            },
            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
              // Convert anything to text
              "* text": String,
              // Text to html (true = no transformation)
              "text html": true,
              // Evaluate text as a json expression
              "text json": JSON.parse,
              // Parse text as xml
              "text xml": jQuery.parseXML
            },
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
              url: true,
              context: true
            }
          },
          // Creates a full fledged settings object into target
          // with both ajaxSettings and settings fields.
          // If target is omitted, writes into ajaxSettings.
          ajaxSetup: function(target, settings4) {
            return settings4 ? (
              // Building a settings object
              ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings4)
            ) : (
              // Extending ajaxSettings
              ajaxExtend(jQuery.ajaxSettings, target)
            );
          },
          ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
          ajaxTransport: addToPrefiltersOrTransports(transports),
          // Main method
          ajax: function(url, options2) {
            if (typeof url === "object") {
              options2 = url;
              url = void 0;
            }
            options2 = options2 || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options2), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
              readyState: 0,
              // Builds headers hashtable if needed
              getResponseHeader: function(key) {
                var match2;
                if (completed2) {
                  if (!responseHeaders) {
                    responseHeaders = {};
                    while (match2 = rheaders.exec(responseHeadersString)) {
                      responseHeaders[match2[1].toLowerCase() + " "] = (responseHeaders[match2[1].toLowerCase() + " "] || []).concat(match2[2]);
                    }
                  }
                  match2 = responseHeaders[key.toLowerCase() + " "];
                }
                return match2 == null ? null : match2.join(", ");
              },
              // Raw string
              getAllResponseHeaders: function() {
                return completed2 ? responseHeadersString : null;
              },
              // Caches the header
              setRequestHeader: function(name, value) {
                if (completed2 == null) {
                  name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                  requestHeaders[name] = value;
                }
                return this;
              },
              // Overrides response content-type header
              overrideMimeType: function(type) {
                if (completed2 == null) {
                  s.mimeType = type;
                }
                return this;
              },
              // Status-dependent callbacks
              statusCode: function(map) {
                var code;
                if (map) {
                  if (completed2) {
                    jqXHR.always(map[jqXHR.status]);
                  } else {
                    for (code in map) {
                      statusCode[code] = [statusCode[code], map[code]];
                    }
                  }
                }
                return this;
              },
              // Cancel the request
              abort: function(statusText) {
                var finalText = statusText || strAbort;
                if (transport) {
                  transport.abort(finalText);
                }
                done(0, finalText);
                return this;
              }
            };
            deferred.promise(jqXHR);
            s.url = ((url || s.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
            s.type = options2.method || options2.type || s.method || s.type;
            s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
            if (s.crossDomain == null) {
              urlAnchor = document2.createElement("a");
              try {
                urlAnchor.href = s.url;
                urlAnchor.href = urlAnchor.href;
                s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
              } catch (e) {
                s.crossDomain = true;
              }
            }
            if (s.data && s.processData && typeof s.data !== "string") {
              s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options2, jqXHR);
            if (completed2) {
              return jqXHR;
            }
            fireGlobals = jQuery.event && s.global;
            if (fireGlobals && jQuery.active++ === 0) {
              jQuery.event.trigger("ajaxStart");
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url.replace(rhash, "");
            if (!s.hasContent) {
              uncached = s.url.slice(cacheURL.length);
              if (s.data && (s.processData || typeof s.data === "string")) {
                cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                delete s.data;
              }
              if (s.cache === false) {
                cacheURL = cacheURL.replace(rantiCache, "$1");
                uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
              }
              s.url = cacheURL + uncached;
            } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
              s.data = s.data.replace(r20, "+");
            }
            if (s.ifModified) {
              if (jQuery.lastModified[cacheURL]) {
                jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
              }
              if (jQuery.etag[cacheURL]) {
                jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
              }
            }
            if (s.data && s.hasContent && s.contentType !== false || options2.contentType) {
              jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            jqXHR.setRequestHeader(
              "Accept",
              s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]
            );
            for (i in s.headers) {
              jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed2)) {
              return jqXHR.abort();
            }
            strAbort = "abort";
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);
            transport = inspectPrefiltersOrTransports(transports, s, options2, jqXHR);
            if (!transport) {
              done(-1, "No Transport");
            } else {
              jqXHR.readyState = 1;
              if (fireGlobals) {
                globalEventContext.trigger("ajaxSend", [jqXHR, s]);
              }
              if (completed2) {
                return jqXHR;
              }
              if (s.async && s.timeout > 0) {
                timeoutTimer = window2.setTimeout(function() {
                  jqXHR.abort("timeout");
                }, s.timeout);
              }
              try {
                completed2 = false;
                transport.send(requestHeaders, done);
              } catch (e) {
                if (completed2) {
                  throw e;
                }
                done(-1, e);
              }
            }
            function done(status, nativeStatusText, responses, headers) {
              var isSuccess, success, error2, response, modified, statusText = nativeStatusText;
              if (completed2) {
                return;
              }
              completed2 = true;
              if (timeoutTimer) {
                window2.clearTimeout(timeoutTimer);
              }
              transport = void 0;
              responseHeadersString = headers || "";
              jqXHR.readyState = status > 0 ? 4 : 0;
              isSuccess = status >= 200 && status < 300 || status === 304;
              if (responses) {
                response = ajaxHandleResponses(s, jqXHR, responses);
              }
              if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
                s.converters["text script"] = function() {
                };
              }
              response = ajaxConvert(s, response, jqXHR, isSuccess);
              if (isSuccess) {
                if (s.ifModified) {
                  modified = jqXHR.getResponseHeader("Last-Modified");
                  if (modified) {
                    jQuery.lastModified[cacheURL] = modified;
                  }
                  modified = jqXHR.getResponseHeader("etag");
                  if (modified) {
                    jQuery.etag[cacheURL] = modified;
                  }
                }
                if (status === 204 || s.type === "HEAD") {
                  statusText = "nocontent";
                } else if (status === 304) {
                  statusText = "notmodified";
                } else {
                  statusText = response.state;
                  success = response.data;
                  error2 = response.error;
                  isSuccess = !error2;
                }
              } else {
                error2 = statusText;
                if (status || !statusText) {
                  statusText = "error";
                  if (status < 0) {
                    status = 0;
                  }
                }
              }
              jqXHR.status = status;
              jqXHR.statusText = (nativeStatusText || statusText) + "";
              if (isSuccess) {
                deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
              } else {
                deferred.rejectWith(callbackContext, [jqXHR, statusText, error2]);
              }
              jqXHR.statusCode(statusCode);
              statusCode = void 0;
              if (fireGlobals) {
                globalEventContext.trigger(
                  isSuccess ? "ajaxSuccess" : "ajaxError",
                  [jqXHR, s, isSuccess ? success : error2]
                );
              }
              completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
              if (fireGlobals) {
                globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                if (!--jQuery.active) {
                  jQuery.event.trigger("ajaxStop");
                }
              }
            }
            return jqXHR;
          },
          getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
          },
          getScript: function(url, callback) {
            return jQuery.get(url, void 0, callback, "script");
          }
        });
        jQuery.each(["get", "post"], function(_i, method) {
          jQuery[method] = function(url, data, callback, type) {
            if (isFunction(data)) {
              type = type || callback;
              callback = data;
              data = void 0;
            }
            return jQuery.ajax(jQuery.extend({
              url,
              type: method,
              dataType: type,
              data,
              success: callback
            }, jQuery.isPlainObject(url) && url));
          };
        });
        jQuery.ajaxPrefilter(function(s) {
          var i;
          for (i in s.headers) {
            if (i.toLowerCase() === "content-type") {
              s.contentType = s.headers[i] || "";
            }
          }
        });
        jQuery._evalUrl = function(url, options2, doc) {
          return jQuery.ajax({
            url,
            // Make this explicit, since user can override this through ajaxSetup (trac-11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            // Only evaluate the response if it is successful (gh-4126)
            // dataFilter is not invoked for failure responses, so using it instead
            // of the default converter is kludgy but it works.
            converters: {
              "text script": function() {
              }
            },
            dataFilter: function(response) {
              jQuery.globalEval(response, options2, doc);
            }
          });
        };
        jQuery.fn.extend({
          wrapAll: function(html) {
            var wrap;
            if (this[0]) {
              if (isFunction(html)) {
                html = html.call(this[0]);
              }
              wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
              if (this[0].parentNode) {
                wrap.insertBefore(this[0]);
              }
              wrap.map(function() {
                var elem = this;
                while (elem.firstElementChild) {
                  elem = elem.firstElementChild;
                }
                return elem;
              }).append(this);
            }
            return this;
          },
          wrapInner: function(html) {
            if (isFunction(html)) {
              return this.each(function(i) {
                jQuery(this).wrapInner(html.call(this, i));
              });
            }
            return this.each(function() {
              var self2 = jQuery(this), contents = self2.contents();
              if (contents.length) {
                contents.wrapAll(html);
              } else {
                self2.append(html);
              }
            });
          },
          wrap: function(html) {
            var htmlIsFunction = isFunction(html);
            return this.each(function(i) {
              jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
            });
          },
          unwrap: function(selector) {
            this.parent(selector).not("body").each(function() {
              jQuery(this).replaceWith(this.childNodes);
            });
            return this;
          }
        });
        jQuery.expr.pseudos.hidden = function(elem) {
          return !jQuery.expr.pseudos.visible(elem);
        };
        jQuery.expr.pseudos.visible = function(elem) {
          return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
        };
        jQuery.ajaxSettings.xhr = function() {
          try {
            return new window2.XMLHttpRequest();
          } catch (e) {
          }
        };
        var xhrSuccessStatus = {
          // File protocol always yields status code 0, assume 200
          0: 200,
          // Support: IE <=9 only
          // trac-1450: sometimes IE returns 1223 when it should be 204
          1223: 204
        }, xhrSupported = jQuery.ajaxSettings.xhr();
        support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
        support.ajax = xhrSupported = !!xhrSupported;
        jQuery.ajaxTransport(function(options2) {
          var callback, errorCallback;
          if (support.cors || xhrSupported && !options2.crossDomain) {
            return {
              send: function(headers, complete) {
                var i, xhr = options2.xhr();
                xhr.open(
                  options2.type,
                  options2.url,
                  options2.async,
                  options2.username,
                  options2.password
                );
                if (options2.xhrFields) {
                  for (i in options2.xhrFields) {
                    xhr[i] = options2.xhrFields[i];
                  }
                }
                if (options2.mimeType && xhr.overrideMimeType) {
                  xhr.overrideMimeType(options2.mimeType);
                }
                if (!options2.crossDomain && !headers["X-Requested-With"]) {
                  headers["X-Requested-With"] = "XMLHttpRequest";
                }
                for (i in headers) {
                  xhr.setRequestHeader(i, headers[i]);
                }
                callback = function(type) {
                  return function() {
                    if (callback) {
                      callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                      if (type === "abort") {
                        xhr.abort();
                      } else if (type === "error") {
                        if (typeof xhr.status !== "number") {
                          complete(0, "error");
                        } else {
                          complete(
                            // File: protocol always yields status 0; see trac-8605, trac-14207
                            xhr.status,
                            xhr.statusText
                          );
                        }
                      } else {
                        complete(
                          xhrSuccessStatus[xhr.status] || xhr.status,
                          xhr.statusText,
                          // Support: IE <=9 only
                          // IE9 has no XHR2 but throws on binary (trac-11426)
                          // For XHR2 non-text, let the caller handle it (gh-2498)
                          (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                          xhr.getAllResponseHeaders()
                        );
                      }
                    }
                  };
                };
                xhr.onload = callback();
                errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                if (xhr.onabort !== void 0) {
                  xhr.onabort = errorCallback;
                } else {
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      window2.setTimeout(function() {
                        if (callback) {
                          errorCallback();
                        }
                      });
                    }
                  };
                }
                callback = callback("abort");
                try {
                  xhr.send(options2.hasContent && options2.data || null);
                } catch (e) {
                  if (callback) {
                    throw e;
                  }
                }
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        jQuery.ajaxPrefilter(function(s) {
          if (s.crossDomain) {
            s.contents.script = false;
          }
        });
        jQuery.ajaxSetup({
          accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
          },
          contents: {
            script: /\b(?:java|ecma)script\b/
          },
          converters: {
            "text script": function(text) {
              jQuery.globalEval(text);
              return text;
            }
          }
        });
        jQuery.ajaxPrefilter("script", function(s) {
          if (s.cache === void 0) {
            s.cache = false;
          }
          if (s.crossDomain) {
            s.type = "GET";
          }
        });
        jQuery.ajaxTransport("script", function(s) {
          if (s.crossDomain || s.scriptAttrs) {
            var script, callback;
            return {
              send: function(_, complete) {
                script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({ charset: s.scriptCharset, src: s.url }).on("load error", callback = function(evt) {
                  script.remove();
                  callback = null;
                  if (evt) {
                    complete(evt.type === "error" ? 404 : 200, evt.type);
                  }
                });
                document2.head.appendChild(script[0]);
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery.ajaxSetup({
          jsonp: "callback",
          jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
            this[callback] = true;
            return callback;
          }
        });
        jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
          var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
          if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
              s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
              s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            s.converters["script json"] = function() {
              if (!responseContainer) {
                jQuery.error(callbackName + " was not called");
              }
              return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            overwritten = window2[callbackName];
            window2[callbackName] = function() {
              responseContainer = arguments;
            };
            jqXHR.always(function() {
              if (overwritten === void 0) {
                jQuery(window2).removeProp(callbackName);
              } else {
                window2[callbackName] = overwritten;
              }
              if (s[callbackName]) {
                s.jsonpCallback = originalSettings.jsonpCallback;
                oldCallbacks.push(callbackName);
              }
              if (responseContainer && isFunction(overwritten)) {
                overwritten(responseContainer[0]);
              }
              responseContainer = overwritten = void 0;
            });
            return "script";
          }
        });
        support.createHTMLDocument = function() {
          var body = document2.implementation.createHTMLDocument("").body;
          body.innerHTML = "<form></form><form></form>";
          return body.childNodes.length === 2;
        }();
        jQuery.parseHTML = function(data, context, keepScripts) {
          if (typeof data !== "string") {
            return [];
          }
          if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
          }
          var base3, parsed, scripts;
          if (!context) {
            if (support.createHTMLDocument) {
              context = document2.implementation.createHTMLDocument("");
              base3 = context.createElement("base");
              base3.href = document2.location.href;
              context.head.appendChild(base3);
            } else {
              context = document2;
            }
          }
          parsed = rsingleTag.exec(data);
          scripts = !keepScripts && [];
          if (parsed) {
            return [context.createElement(parsed[1])];
          }
          parsed = buildFragment([data], context, scripts);
          if (scripts && scripts.length) {
            jQuery(scripts).remove();
          }
          return jQuery.merge([], parsed.childNodes);
        };
        jQuery.fn.load = function(url, params, callback) {
          var selector, type, response, self2 = this, off = url.indexOf(" ");
          if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
          }
          if (isFunction(params)) {
            callback = params;
            params = void 0;
          } else if (params && typeof params === "object") {
            type = "POST";
          }
          if (self2.length > 0) {
            jQuery.ajax({
              url,
              // If "type" variable is undefined, then "GET" method will be used.
              // Make value of this field explicit since
              // user can override it through ajaxSetup method
              type: type || "GET",
              dataType: "html",
              data: params
            }).done(function(responseText) {
              response = arguments;
              self2.html(selector ? (
                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector)
              ) : (
                // Otherwise use the full result
                responseText
              ));
            }).always(callback && function(jqXHR, status) {
              self2.each(function() {
                callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
              });
            });
          }
          return this;
        };
        jQuery.expr.pseudos.animated = function(elem) {
          return jQuery.grep(jQuery.timers, function(fn2) {
            return elem === fn2.elem;
          }).length;
        };
        jQuery.offset = {
          setOffset: function(elem, options2, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            if (position === "static") {
              elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
              curPosition = curElem.position();
              curTop = curPosition.top;
              curLeft = curPosition.left;
            } else {
              curTop = parseFloat(curCSSTop) || 0;
              curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction(options2)) {
              options2 = options2.call(elem, i, jQuery.extend({}, curOffset));
            }
            if (options2.top != null) {
              props.top = options2.top - curOffset.top + curTop;
            }
            if (options2.left != null) {
              props.left = options2.left - curOffset.left + curLeft;
            }
            if ("using" in options2) {
              options2.using.call(elem, props);
            } else {
              curElem.css(props);
            }
          }
        };
        jQuery.fn.extend({
          // offset() relates an element's border box to the document origin
          offset: function(options2) {
            if (arguments.length) {
              return options2 === void 0 ? this : this.each(function(i) {
                jQuery.offset.setOffset(this, options2, i);
              });
            }
            var rect, win, elem = this[0];
            if (!elem) {
              return;
            }
            if (!elem.getClientRects().length) {
              return { top: 0, left: 0 };
            }
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
              top: rect.top + win.pageYOffset,
              left: rect.left + win.pageXOffset
            };
          },
          // position() relates an element's margin box to its offset parent's padding box
          // This corresponds to the behavior of CSS absolute positioning
          position: function() {
            if (!this[0]) {
              return;
            }
            var offsetParent, offset2, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
            if (jQuery.css(elem, "position") === "fixed") {
              offset2 = elem.getBoundingClientRect();
            } else {
              offset2 = this.offset();
              doc = elem.ownerDocument;
              offsetParent = elem.offsetParent || doc.documentElement;
              while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.parentNode;
              }
              if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                parentOffset = jQuery(offsetParent).offset();
                parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
              }
            }
            return {
              top: offset2.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
              left: offset2.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
          },
          // This method will return documentElement in the following cases:
          // 1) For the element inside the iframe without offsetParent, this method will return
          //    documentElement of the parent window
          // 2) For the hidden or detached element
          // 3) For body or html element, i.e. in case of the html node - it will return itself
          //
          // but those exceptions were never presented as a real life use-cases
          // and might be considered as more preferable results.
          //
          // This logic, however, is not guaranteed and can change at any point in the future
          offsetParent: function() {
            return this.map(function() {
              var offsetParent = this.offsetParent;
              while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.offsetParent;
              }
              return offsetParent || documentElement;
            });
          }
        });
        jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
          var top2 = "pageYOffset" === prop;
          jQuery.fn[method] = function(val) {
            return access(this, function(elem, method2, val2) {
              var win;
              if (isWindow(elem)) {
                win = elem;
              } else if (elem.nodeType === 9) {
                win = elem.defaultView;
              }
              if (val2 === void 0) {
                return win ? win[prop] : elem[method2];
              }
              if (win) {
                win.scrollTo(
                  !top2 ? val2 : win.pageXOffset,
                  top2 ? val2 : win.pageYOffset
                );
              } else {
                elem[method2] = val2;
              }
            }, method, val, arguments.length);
          };
        });
        jQuery.each(["top", "left"], function(_i, prop) {
          jQuery.cssHooks[prop] = addGetHookIf(
            support.pixelPosition,
            function(elem, computed) {
              if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
              }
            }
          );
        });
        jQuery.each({ Height: "height", Width: "width" }, function(name, type) {
          jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
          }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
              var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
              return access(this, function(elem, type2, value2) {
                var doc;
                if (isWindow(elem)) {
                  return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                }
                if (elem.nodeType === 9) {
                  doc = elem.documentElement;
                  return Math.max(
                    elem.body["scroll" + name],
                    doc["scroll" + name],
                    elem.body["offset" + name],
                    doc["offset" + name],
                    doc["client" + name]
                  );
                }
                return value2 === void 0 ? (
                  // Get width or height on the element, requesting but not forcing parseFloat
                  jQuery.css(elem, type2, extra)
                ) : (
                  // Set width or height on the element
                  jQuery.style(elem, type2, value2, extra)
                );
              }, type, chainable ? margin : void 0, chainable);
            };
          });
        });
        jQuery.each([
          "ajaxStart",
          "ajaxStop",
          "ajaxComplete",
          "ajaxError",
          "ajaxSuccess",
          "ajaxSend"
        ], function(_i, type) {
          jQuery.fn[type] = function(fn2) {
            return this.on(type, fn2);
          };
        });
        jQuery.fn.extend({
          bind: function(types4, data, fn2) {
            return this.on(types4, null, data, fn2);
          },
          unbind: function(types4, fn2) {
            return this.off(types4, null, fn2);
          },
          delegate: function(selector, types4, data, fn2) {
            return this.on(types4, selector, data, fn2);
          },
          undelegate: function(selector, types4, fn2) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types4, selector || "**", fn2);
          },
          hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
          }
        });
        jQuery.each(
          "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
          function(_i, name) {
            jQuery.fn[name] = function(data, fn2) {
              return arguments.length > 0 ? this.on(name, null, data, fn2) : this.trigger(name);
            };
          }
        );
        var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
        jQuery.proxy = function(fn2, context) {
          var tmp, args, proxy;
          if (typeof context === "string") {
            tmp = fn2[context];
            context = fn2;
            fn2 = tmp;
          }
          if (!isFunction(fn2)) {
            return void 0;
          }
          args = slice.call(arguments, 2);
          proxy = function() {
            return fn2.apply(context || this, args.concat(slice.call(arguments)));
          };
          proxy.guid = fn2.guid = fn2.guid || jQuery.guid++;
          return proxy;
        };
        jQuery.holdReady = function(hold) {
          if (hold) {
            jQuery.readyWait++;
          } else {
            jQuery.ready(true);
          }
        };
        jQuery.isArray = Array.isArray;
        jQuery.parseJSON = JSON.parse;
        jQuery.nodeName = nodeName;
        jQuery.isFunction = isFunction;
        jQuery.isWindow = isWindow;
        jQuery.camelCase = camelCase;
        jQuery.type = toType2;
        jQuery.now = Date.now;
        jQuery.isNumeric = function(obj) {
          var type = jQuery.type(obj);
          return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
          // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
          // subtraction forces infinities to NaN
          !isNaN(obj - parseFloat(obj));
        };
        jQuery.trim = function(text) {
          return text == null ? "" : (text + "").replace(rtrim, "$1");
        };
        if (typeof define === "function" && define.amd) {
          define("jquery", [], function() {
            return jQuery;
          });
        }
        var _jQuery = window2.jQuery, _$ = window2.$;
        jQuery.noConflict = function(deep) {
          if (window2.$ === jQuery) {
            window2.$ = _$;
          }
          if (deep && window2.jQuery === jQuery) {
            window2.jQuery = _jQuery;
          }
          return jQuery;
        };
        if (typeof noGlobal === "undefined") {
          window2.jQuery = window2.$ = jQuery;
        }
        return jQuery;
      });
    }
  });

  // node_modules/@react-awesome-query-builder/core/node_modules/immutable/dist/immutable.js
  var require_immutable = __commonJS({
    "node_modules/@react-awesome-query-builder/core/node_modules/immutable/dist/immutable.js"(exports, module) {
      (function(global2, factory15) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory15() : typeof define === "function" && define.amd ? define(factory15) : global2.Immutable = factory15();
      })(exports, function() {
        "use strict";
        var SLICE$0 = Array.prototype.slice;
        function createClass(ctor, superClass) {
          if (superClass) {
            ctor.prototype = Object.create(superClass.prototype);
          }
          ctor.prototype.constructor = ctor;
        }
        function Iterable(value) {
          return isIterable(value) ? value : Seq(value);
        }
        createClass(KeyedIterable, Iterable);
        function KeyedIterable(value) {
          return isKeyed(value) ? value : KeyedSeq(value);
        }
        createClass(IndexedIterable, Iterable);
        function IndexedIterable(value) {
          return isIndexed(value) ? value : IndexedSeq(value);
        }
        createClass(SetIterable, Iterable);
        function SetIterable(value) {
          return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
        }
        function isIterable(maybeIterable) {
          return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
        }
        function isKeyed(maybeKeyed) {
          return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
        }
        function isIndexed(maybeIndexed) {
          return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
        }
        function isAssociative(maybeAssociative) {
          return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
        }
        function isOrdered(maybeOrdered) {
          return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
        }
        Iterable.isIterable = isIterable;
        Iterable.isKeyed = isKeyed;
        Iterable.isIndexed = isIndexed;
        Iterable.isAssociative = isAssociative;
        Iterable.isOrdered = isOrdered;
        Iterable.Keyed = KeyedIterable;
        Iterable.Indexed = IndexedIterable;
        Iterable.Set = SetIterable;
        var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
        var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
        var IS_INDEXED_SENTINEL = "@@__IMMUTABLE_INDEXED__@@";
        var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
        var DELETE = "delete";
        var SHIFT = 5;
        var SIZE = 1 << SHIFT;
        var MASK = SIZE - 1;
        var NOT_SET = {};
        var CHANGE_LENGTH = { value: false };
        var DID_ALTER = { value: false };
        function MakeRef(ref) {
          ref.value = false;
          return ref;
        }
        function SetRef(ref) {
          ref && (ref.value = true);
        }
        function OwnerID() {
        }
        function arrCopy(arr, offset2) {
          offset2 = offset2 || 0;
          var len = Math.max(0, arr.length - offset2);
          var newArr = new Array(len);
          for (var ii = 0; ii < len; ii++) {
            newArr[ii] = arr[ii + offset2];
          }
          return newArr;
        }
        function ensureSize(iter) {
          if (iter.size === void 0) {
            iter.size = iter.__iterate(returnTrue);
          }
          return iter.size;
        }
        function wrapIndex(iter, index) {
          if (typeof index !== "number") {
            var uint32Index = index >>> 0;
            if ("" + uint32Index !== index || uint32Index === 4294967295) {
              return NaN;
            }
            index = uint32Index;
          }
          return index < 0 ? ensureSize(iter) + index : index;
        }
        function returnTrue() {
          return true;
        }
        function wholeSlice(begin, end2, size) {
          return (begin === 0 || size !== void 0 && begin <= -size) && (end2 === void 0 || size !== void 0 && end2 >= size);
        }
        function resolveBegin(begin, size) {
          return resolveIndex(begin, size, 0);
        }
        function resolveEnd(end2, size) {
          return resolveIndex(end2, size, size);
        }
        function resolveIndex(index, size, defaultIndex) {
          return index === void 0 ? defaultIndex : index < 0 ? Math.max(0, size + index) : size === void 0 ? index : Math.min(size, index);
        }
        var ITERATE_KEYS = 0;
        var ITERATE_VALUES = 1;
        var ITERATE_ENTRIES = 2;
        var REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
        function Iterator(next) {
          this.next = next;
        }
        Iterator.prototype.toString = function() {
          return "[Iterator]";
        };
        Iterator.KEYS = ITERATE_KEYS;
        Iterator.VALUES = ITERATE_VALUES;
        Iterator.ENTRIES = ITERATE_ENTRIES;
        Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
          return this.toString();
        };
        Iterator.prototype[ITERATOR_SYMBOL] = function() {
          return this;
        };
        function iteratorValue(type, k, v, iteratorResult) {
          var value = type === 0 ? k : type === 1 ? v : [k, v];
          iteratorResult ? iteratorResult.value = value : iteratorResult = {
            value,
            done: false
          };
          return iteratorResult;
        }
        function iteratorDone() {
          return { value: void 0, done: true };
        }
        function hasIterator(maybeIterable) {
          return !!getIteratorFn(maybeIterable);
        }
        function isIterator(maybeIterator) {
          return maybeIterator && typeof maybeIterator.next === "function";
        }
        function getIterator(iterable) {
          var iteratorFn = getIteratorFn(iterable);
          return iteratorFn && iteratorFn.call(iterable);
        }
        function getIteratorFn(iterable) {
          var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === "function") {
            return iteratorFn;
          }
        }
        function isArrayLike(value) {
          return value && typeof value.length === "number";
        }
        createClass(Seq, Iterable);
        function Seq(value) {
          return value === null || value === void 0 ? emptySequence() : isIterable(value) ? value.toSeq() : seqFromValue(value);
        }
        Seq.of = function() {
          return Seq(arguments);
        };
        Seq.prototype.toSeq = function() {
          return this;
        };
        Seq.prototype.toString = function() {
          return this.__toString("Seq {", "}");
        };
        Seq.prototype.cacheResult = function() {
          if (!this._cache && this.__iterateUncached) {
            this._cache = this.entrySeq().toArray();
            this.size = this._cache.length;
          }
          return this;
        };
        Seq.prototype.__iterate = function(fn2, reverse) {
          return seqIterate(this, fn2, reverse, true);
        };
        Seq.prototype.__iterator = function(type, reverse) {
          return seqIterator(this, type, reverse, true);
        };
        createClass(KeyedSeq, Seq);
        function KeyedSeq(value) {
          return value === null || value === void 0 ? emptySequence().toKeyedSeq() : isIterable(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : keyedSeqFromValue(value);
        }
        KeyedSeq.prototype.toKeyedSeq = function() {
          return this;
        };
        createClass(IndexedSeq, Seq);
        function IndexedSeq(value) {
          return value === null || value === void 0 ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
        }
        IndexedSeq.of = function() {
          return IndexedSeq(arguments);
        };
        IndexedSeq.prototype.toIndexedSeq = function() {
          return this;
        };
        IndexedSeq.prototype.toString = function() {
          return this.__toString("Seq [", "]");
        };
        IndexedSeq.prototype.__iterate = function(fn2, reverse) {
          return seqIterate(this, fn2, reverse, false);
        };
        IndexedSeq.prototype.__iterator = function(type, reverse) {
          return seqIterator(this, type, reverse, false);
        };
        createClass(SetSeq, Seq);
        function SetSeq(value) {
          return (value === null || value === void 0 ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value).toSetSeq();
        }
        SetSeq.of = function() {
          return SetSeq(arguments);
        };
        SetSeq.prototype.toSetSeq = function() {
          return this;
        };
        Seq.isSeq = isSeq;
        Seq.Keyed = KeyedSeq;
        Seq.Set = SetSeq;
        Seq.Indexed = IndexedSeq;
        var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
        Seq.prototype[IS_SEQ_SENTINEL] = true;
        createClass(ArraySeq, IndexedSeq);
        function ArraySeq(array) {
          this._array = array;
          this.size = array.length;
        }
        ArraySeq.prototype.get = function(index, notSetValue) {
          return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
        };
        ArraySeq.prototype.__iterate = function(fn2, reverse) {
          var array = this._array;
          var maxIndex = array.length - 1;
          for (var ii = 0; ii <= maxIndex; ii++) {
            if (fn2(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
              return ii + 1;
            }
          }
          return ii;
        };
        ArraySeq.prototype.__iterator = function(type, reverse) {
          var array = this._array;
          var maxIndex = array.length - 1;
          var ii = 0;
          return new Iterator(
            function() {
              return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++]);
            }
          );
        };
        createClass(ObjectSeq, KeyedSeq);
        function ObjectSeq(object) {
          var keys5 = Object.keys(object);
          this._object = object;
          this._keys = keys5;
          this.size = keys5.length;
        }
        ObjectSeq.prototype.get = function(key, notSetValue) {
          if (notSetValue !== void 0 && !this.has(key)) {
            return notSetValue;
          }
          return this._object[key];
        };
        ObjectSeq.prototype.has = function(key) {
          return this._object.hasOwnProperty(key);
        };
        ObjectSeq.prototype.__iterate = function(fn2, reverse) {
          var object = this._object;
          var keys5 = this._keys;
          var maxIndex = keys5.length - 1;
          for (var ii = 0; ii <= maxIndex; ii++) {
            var key = keys5[reverse ? maxIndex - ii : ii];
            if (fn2(object[key], key, this) === false) {
              return ii + 1;
            }
          }
          return ii;
        };
        ObjectSeq.prototype.__iterator = function(type, reverse) {
          var object = this._object;
          var keys5 = this._keys;
          var maxIndex = keys5.length - 1;
          var ii = 0;
          return new Iterator(function() {
            var key = keys5[reverse ? maxIndex - ii : ii];
            return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, key, object[key]);
          });
        };
        ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
        createClass(IterableSeq, IndexedSeq);
        function IterableSeq(iterable) {
          this._iterable = iterable;
          this.size = iterable.length || iterable.size;
        }
        IterableSeq.prototype.__iterateUncached = function(fn2, reverse) {
          if (reverse) {
            return this.cacheResult().__iterate(fn2, reverse);
          }
          var iterable = this._iterable;
          var iterator = getIterator(iterable);
          var iterations = 0;
          if (isIterator(iterator)) {
            var step;
            while (!(step = iterator.next()).done) {
              if (fn2(step.value, iterations++, this) === false) {
                break;
              }
            }
          }
          return iterations;
        };
        IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
          if (reverse) {
            return this.cacheResult().__iterator(type, reverse);
          }
          var iterable = this._iterable;
          var iterator = getIterator(iterable);
          if (!isIterator(iterator)) {
            return new Iterator(iteratorDone);
          }
          var iterations = 0;
          return new Iterator(function() {
            var step = iterator.next();
            return step.done ? step : iteratorValue(type, iterations++, step.value);
          });
        };
        createClass(IteratorSeq, IndexedSeq);
        function IteratorSeq(iterator) {
          this._iterator = iterator;
          this._iteratorCache = [];
        }
        IteratorSeq.prototype.__iterateUncached = function(fn2, reverse) {
          if (reverse) {
            return this.cacheResult().__iterate(fn2, reverse);
          }
          var iterator = this._iterator;
          var cache2 = this._iteratorCache;
          var iterations = 0;
          while (iterations < cache2.length) {
            if (fn2(cache2[iterations], iterations++, this) === false) {
              return iterations;
            }
          }
          var step;
          while (!(step = iterator.next()).done) {
            var val = step.value;
            cache2[iterations] = val;
            if (fn2(val, iterations++, this) === false) {
              break;
            }
          }
          return iterations;
        };
        IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
          if (reverse) {
            return this.cacheResult().__iterator(type, reverse);
          }
          var iterator = this._iterator;
          var cache2 = this._iteratorCache;
          var iterations = 0;
          return new Iterator(function() {
            if (iterations >= cache2.length) {
              var step = iterator.next();
              if (step.done) {
                return step;
              }
              cache2[iterations] = step.value;
            }
            return iteratorValue(type, iterations, cache2[iterations++]);
          });
        };
        function isSeq(maybeSeq) {
          return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
        }
        var EMPTY_SEQ;
        function emptySequence() {
          return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
        }
        function keyedSeqFromValue(value) {
          var seq = Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() : isIterator(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator(value) ? new IterableSeq(value).fromEntrySeq() : typeof value === "object" ? new ObjectSeq(value) : void 0;
          if (!seq) {
            throw new TypeError(
              "Expected Array or iterable object of [k, v] entries, or keyed object: " + value
            );
          }
          return seq;
        }
        function indexedSeqFromValue(value) {
          var seq = maybeIndexedSeqFromValue(value);
          if (!seq) {
            throw new TypeError(
              "Expected Array or iterable object of values: " + value
            );
          }
          return seq;
        }
        function seqFromValue(value) {
          var seq = maybeIndexedSeqFromValue(value) || typeof value === "object" && new ObjectSeq(value);
          if (!seq) {
            throw new TypeError(
              "Expected Array or iterable object of values, or keyed object: " + value
            );
          }
          return seq;
        }
        function maybeIndexedSeqFromValue(value) {
          return isArrayLike(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new IterableSeq(value) : void 0;
        }
        function seqIterate(seq, fn2, reverse, useKeys) {
          var cache2 = seq._cache;
          if (cache2) {
            var maxIndex = cache2.length - 1;
            for (var ii = 0; ii <= maxIndex; ii++) {
              var entry = cache2[reverse ? maxIndex - ii : ii];
              if (fn2(entry[1], useKeys ? entry[0] : ii, seq) === false) {
                return ii + 1;
              }
            }
            return ii;
          }
          return seq.__iterateUncached(fn2, reverse);
        }
        function seqIterator(seq, type, reverse, useKeys) {
          var cache2 = seq._cache;
          if (cache2) {
            var maxIndex = cache2.length - 1;
            var ii = 0;
            return new Iterator(function() {
              var entry = cache2[reverse ? maxIndex - ii : ii];
              return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
            });
          }
          return seq.__iteratorUncached(type, reverse);
        }
        function fromJS2(json, converter) {
          return converter ? fromJSWith(converter, json, "", { "": json }) : fromJSDefault(json);
        }
        function fromJSWith(converter, json, key, parentJSON) {
          if (Array.isArray(json)) {
            return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k) {
              return fromJSWith(converter, v, k, json);
            }));
          }
          if (isPlainObj(json)) {
            return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k) {
              return fromJSWith(converter, v, k, json);
            }));
          }
          return json;
        }
        function fromJSDefault(json) {
          if (Array.isArray(json)) {
            return IndexedSeq(json).map(fromJSDefault).toList();
          }
          if (isPlainObj(json)) {
            return KeyedSeq(json).map(fromJSDefault).toMap();
          }
          return json;
        }
        function isPlainObj(value) {
          return value && (value.constructor === Object || value.constructor === void 0);
        }
        function is2(valueA, valueB) {
          if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
            return true;
          }
          if (!valueA || !valueB) {
            return false;
          }
          if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
            valueA = valueA.valueOf();
            valueB = valueB.valueOf();
            if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
              return true;
            }
            if (!valueA || !valueB) {
              return false;
            }
          }
          if (typeof valueA.equals === "function" && typeof valueB.equals === "function" && valueA.equals(valueB)) {
            return true;
          }
          return false;
        }
        function deepEqual2(a, b) {
          if (a === b) {
            return true;
          }
          if (!isIterable(b) || a.size !== void 0 && b.size !== void 0 && a.size !== b.size || a.__hash !== void 0 && b.__hash !== void 0 && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
            return false;
          }
          if (a.size === 0 && b.size === 0) {
            return true;
          }
          var notAssociative = !isAssociative(a);
          if (isOrdered(a)) {
            var entries = a.entries();
            return b.every(function(v, k) {
              var entry = entries.next().value;
              return entry && is2(entry[1], v) && (notAssociative || is2(entry[0], k));
            }) && entries.next().done;
          }
          var flipped = false;
          if (a.size === void 0) {
            if (b.size === void 0) {
              if (typeof a.cacheResult === "function") {
                a.cacheResult();
              }
            } else {
              flipped = true;
              var _ = a;
              a = b;
              b = _;
            }
          }
          var allEqual = true;
          var bSize = b.__iterate(function(v, k) {
            if (notAssociative ? !a.has(v) : flipped ? !is2(v, a.get(k, NOT_SET)) : !is2(a.get(k, NOT_SET), v)) {
              allEqual = false;
              return false;
            }
          });
          return allEqual && a.size === bSize;
        }
        createClass(Repeat, IndexedSeq);
        function Repeat(value, times) {
          if (!(this instanceof Repeat)) {
            return new Repeat(value, times);
          }
          this._value = value;
          this.size = times === void 0 ? Infinity : Math.max(0, times);
          if (this.size === 0) {
            if (EMPTY_REPEAT) {
              return EMPTY_REPEAT;
            }
            EMPTY_REPEAT = this;
          }
        }
        Repeat.prototype.toString = function() {
          if (this.size === 0) {
            return "Repeat []";
          }
          return "Repeat [ " + this._value + " " + this.size + " times ]";
        };
        Repeat.prototype.get = function(index, notSetValue) {
          return this.has(index) ? this._value : notSetValue;
        };
        Repeat.prototype.includes = function(searchValue) {
          return is2(this._value, searchValue);
        };
        Repeat.prototype.slice = function(begin, end2) {
          var size = this.size;
          return wholeSlice(begin, end2, size) ? this : new Repeat(this._value, resolveEnd(end2, size) - resolveBegin(begin, size));
        };
        Repeat.prototype.reverse = function() {
          return this;
        };
        Repeat.prototype.indexOf = function(searchValue) {
          if (is2(this._value, searchValue)) {
            return 0;
          }
          return -1;
        };
        Repeat.prototype.lastIndexOf = function(searchValue) {
          if (is2(this._value, searchValue)) {
            return this.size;
          }
          return -1;
        };
        Repeat.prototype.__iterate = function(fn2, reverse) {
          for (var ii = 0; ii < this.size; ii++) {
            if (fn2(this._value, ii, this) === false) {
              return ii + 1;
            }
          }
          return ii;
        };
        Repeat.prototype.__iterator = function(type, reverse) {
          var this$0 = this;
          var ii = 0;
          return new Iterator(
            function() {
              return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone();
            }
          );
        };
        Repeat.prototype.equals = function(other) {
          return other instanceof Repeat ? is2(this._value, other._value) : deepEqual2(other);
        };
        var EMPTY_REPEAT;
        function invariant(condition, error2) {
          if (!condition)
            throw new Error(error2);
        }
        createClass(Range, IndexedSeq);
        function Range(start3, end2, step) {
          if (!(this instanceof Range)) {
            return new Range(start3, end2, step);
          }
          invariant(step !== 0, "Cannot step a Range by 0");
          start3 = start3 || 0;
          if (end2 === void 0) {
            end2 = Infinity;
          }
          step = step === void 0 ? 1 : Math.abs(step);
          if (end2 < start3) {
            step = -step;
          }
          this._start = start3;
          this._end = end2;
          this._step = step;
          this.size = Math.max(0, Math.ceil((end2 - start3) / step - 1) + 1);
          if (this.size === 0) {
            if (EMPTY_RANGE) {
              return EMPTY_RANGE;
            }
            EMPTY_RANGE = this;
          }
        }
        Range.prototype.toString = function() {
          if (this.size === 0) {
            return "Range []";
          }
          return "Range [ " + this._start + "..." + this._end + (this._step !== 1 ? " by " + this._step : "") + " ]";
        };
        Range.prototype.get = function(index, notSetValue) {
          return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
        };
        Range.prototype.includes = function(searchValue) {
          var possibleIndex = (searchValue - this._start) / this._step;
          return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
        };
        Range.prototype.slice = function(begin, end2) {
          if (wholeSlice(begin, end2, this.size)) {
            return this;
          }
          begin = resolveBegin(begin, this.size);
          end2 = resolveEnd(end2, this.size);
          if (end2 <= begin) {
            return new Range(0, 0);
          }
          return new Range(this.get(begin, this._end), this.get(end2, this._end), this._step);
        };
        Range.prototype.indexOf = function(searchValue) {
          var offsetValue = searchValue - this._start;
          if (offsetValue % this._step === 0) {
            var index = offsetValue / this._step;
            if (index >= 0 && index < this.size) {
              return index;
            }
          }
          return -1;
        };
        Range.prototype.lastIndexOf = function(searchValue) {
          return this.indexOf(searchValue);
        };
        Range.prototype.__iterate = function(fn2, reverse) {
          var maxIndex = this.size - 1;
          var step = this._step;
          var value = reverse ? this._start + maxIndex * step : this._start;
          for (var ii = 0; ii <= maxIndex; ii++) {
            if (fn2(value, ii, this) === false) {
              return ii + 1;
            }
            value += reverse ? -step : step;
          }
          return ii;
        };
        Range.prototype.__iterator = function(type, reverse) {
          var maxIndex = this.size - 1;
          var step = this._step;
          var value = reverse ? this._start + maxIndex * step : this._start;
          var ii = 0;
          return new Iterator(function() {
            var v = value;
            value += reverse ? -step : step;
            return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
          });
        };
        Range.prototype.equals = function(other) {
          return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual2(this, other);
        };
        var EMPTY_RANGE;
        createClass(Collection, Iterable);
        function Collection() {
          throw TypeError("Abstract");
        }
        createClass(KeyedCollection, Collection);
        function KeyedCollection() {
        }
        createClass(IndexedCollection, Collection);
        function IndexedCollection() {
        }
        createClass(SetCollection, Collection);
        function SetCollection() {
        }
        Collection.Keyed = KeyedCollection;
        Collection.Indexed = IndexedCollection;
        Collection.Set = SetCollection;
        var imul = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul2(a, b) {
          a = a | 0;
          b = b | 0;
          var c = a & 65535;
          var d = b & 65535;
          return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0;
        };
        function smi(i32) {
          return i32 >>> 1 & 1073741824 | i32 & 3221225471;
        }
        function hash3(o) {
          if (o === false || o === null || o === void 0) {
            return 0;
          }
          if (typeof o.valueOf === "function") {
            o = o.valueOf();
            if (o === false || o === null || o === void 0) {
              return 0;
            }
          }
          if (o === true) {
            return 1;
          }
          var type = typeof o;
          if (type === "number") {
            if (o !== o || o === Infinity) {
              return 0;
            }
            var h = o | 0;
            if (h !== o) {
              h ^= o * 4294967295;
            }
            while (o > 4294967295) {
              o /= 4294967295;
              h ^= o;
            }
            return smi(h);
          }
          if (type === "string") {
            return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
          }
          if (typeof o.hashCode === "function") {
            return o.hashCode();
          }
          if (type === "object") {
            return hashJSObj(o);
          }
          if (typeof o.toString === "function") {
            return hashString(o.toString());
          }
          throw new Error("Value type " + type + " cannot be hashed.");
        }
        function cachedHashString(string) {
          var hash4 = stringHashCache[string];
          if (hash4 === void 0) {
            hash4 = hashString(string);
            if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
              STRING_HASH_CACHE_SIZE = 0;
              stringHashCache = {};
            }
            STRING_HASH_CACHE_SIZE++;
            stringHashCache[string] = hash4;
          }
          return hash4;
        }
        function hashString(string) {
          var hash4 = 0;
          for (var ii = 0; ii < string.length; ii++) {
            hash4 = 31 * hash4 + string.charCodeAt(ii) | 0;
          }
          return smi(hash4);
        }
        function hashJSObj(obj) {
          var hash4;
          if (usingWeakMap) {
            hash4 = weakMap.get(obj);
            if (hash4 !== void 0) {
              return hash4;
            }
          }
          hash4 = obj[UID_HASH_KEY];
          if (hash4 !== void 0) {
            return hash4;
          }
          if (!canDefineProperty) {
            hash4 = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
            if (hash4 !== void 0) {
              return hash4;
            }
            hash4 = getIENodeHash(obj);
            if (hash4 !== void 0) {
              return hash4;
            }
          }
          hash4 = ++objHashUID;
          if (objHashUID & 1073741824) {
            objHashUID = 0;
          }
          if (usingWeakMap) {
            weakMap.set(obj, hash4);
          } else if (isExtensible !== void 0 && isExtensible(obj) === false) {
            throw new Error("Non-extensible objects are not allowed as keys.");
          } else if (canDefineProperty) {
            Object.defineProperty(obj, UID_HASH_KEY, {
              "enumerable": false,
              "configurable": false,
              "writable": false,
              "value": hash4
            });
          } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
            obj.propertyIsEnumerable = function() {
              return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
            };
            obj.propertyIsEnumerable[UID_HASH_KEY] = hash4;
          } else if (obj.nodeType !== void 0) {
            obj[UID_HASH_KEY] = hash4;
          } else {
            throw new Error("Unable to set a non-enumerable property on object.");
          }
          return hash4;
        }
        var isExtensible = Object.isExtensible;
        var canDefineProperty = function() {
          try {
            Object.defineProperty({}, "@", {});
            return true;
          } catch (e) {
            return false;
          }
        }();
        function getIENodeHash(node) {
          if (node && node.nodeType > 0) {
            switch (node.nodeType) {
              case 1:
                return node.uniqueID;
              case 9:
                return node.documentElement && node.documentElement.uniqueID;
            }
          }
        }
        var usingWeakMap = typeof WeakMap === "function";
        var weakMap;
        if (usingWeakMap) {
          weakMap = /* @__PURE__ */ new WeakMap();
        }
        var objHashUID = 0;
        var UID_HASH_KEY = "__immutablehash__";
        if (typeof Symbol === "function") {
          UID_HASH_KEY = Symbol(UID_HASH_KEY);
        }
        var STRING_HASH_CACHE_MIN_STRLEN = 16;
        var STRING_HASH_CACHE_MAX_SIZE = 255;
        var STRING_HASH_CACHE_SIZE = 0;
        var stringHashCache = {};
        function assertNotInfinite(size) {
          invariant(
            size !== Infinity,
            "Cannot perform this action with an infinite size."
          );
        }
        createClass(Map10, KeyedCollection);
        function Map10(value) {
          return value === null || value === void 0 ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function(map) {
            var iter = KeyedIterable(value);
            assertNotInfinite(iter.size);
            iter.forEach(function(v, k) {
              return map.set(k, v);
            });
          });
        }
        Map10.of = function() {
          var keyValues = SLICE$0.call(arguments, 0);
          return emptyMap().withMutations(function(map) {
            for (var i = 0; i < keyValues.length; i += 2) {
              if (i + 1 >= keyValues.length) {
                throw new Error("Missing value for key: " + keyValues[i]);
              }
              map.set(keyValues[i], keyValues[i + 1]);
            }
          });
        };
        Map10.prototype.toString = function() {
          return this.__toString("Map {", "}");
        };
        Map10.prototype.get = function(k, notSetValue) {
          return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
        };
        Map10.prototype.set = function(k, v) {
          return updateMap(this, k, v);
        };
        Map10.prototype.setIn = function(keyPath, v) {
          return this.updateIn(keyPath, NOT_SET, function() {
            return v;
          });
        };
        Map10.prototype.remove = function(k) {
          return updateMap(this, k, NOT_SET);
        };
        Map10.prototype.deleteIn = function(keyPath) {
          return this.updateIn(keyPath, function() {
            return NOT_SET;
          });
        };
        Map10.prototype.update = function(k, notSetValue, updater) {
          return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);
        };
        Map10.prototype.updateIn = function(keyPath, notSetValue, updater) {
          if (!updater) {
            updater = notSetValue;
            notSetValue = void 0;
          }
          var updatedValue = updateInDeepMap(
            this,
            forceIterator(keyPath),
            notSetValue,
            updater
          );
          return updatedValue === NOT_SET ? void 0 : updatedValue;
        };
        Map10.prototype.clear = function() {
          if (this.size === 0) {
            return this;
          }
          if (this.__ownerID) {
            this.size = 0;
            this._root = null;
            this.__hash = void 0;
            this.__altered = true;
            return this;
          }
          return emptyMap();
        };
        Map10.prototype.merge = function() {
          return mergeIntoMapWith(this, void 0, arguments);
        };
        Map10.prototype.mergeWith = function(merger) {
          var iters = SLICE$0.call(arguments, 1);
          return mergeIntoMapWith(this, merger, iters);
        };
        Map10.prototype.mergeIn = function(keyPath) {
          var iters = SLICE$0.call(arguments, 1);
          return this.updateIn(
            keyPath,
            emptyMap(),
            function(m) {
              return typeof m.merge === "function" ? m.merge.apply(m, iters) : iters[iters.length - 1];
            }
          );
        };
        Map10.prototype.mergeDeep = function() {
          return mergeIntoMapWith(this, deepMerger, arguments);
        };
        Map10.prototype.mergeDeepWith = function(merger) {
          var iters = SLICE$0.call(arguments, 1);
          return mergeIntoMapWith(this, deepMergerWith(merger), iters);
        };
        Map10.prototype.mergeDeepIn = function(keyPath) {
          var iters = SLICE$0.call(arguments, 1);
          return this.updateIn(
            keyPath,
            emptyMap(),
            function(m) {
              return typeof m.mergeDeep === "function" ? m.mergeDeep.apply(m, iters) : iters[iters.length - 1];
            }
          );
        };
        Map10.prototype.sort = function(comparator) {
          return OrderedMap(sortFactory(this, comparator));
        };
        Map10.prototype.sortBy = function(mapper, comparator) {
          return OrderedMap(sortFactory(this, comparator, mapper));
        };
        Map10.prototype.withMutations = function(fn2) {
          var mutable = this.asMutable();
          fn2(mutable);
          return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
        };
        Map10.prototype.asMutable = function() {
          return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
        };
        Map10.prototype.asImmutable = function() {
          return this.__ensureOwner();
        };
        Map10.prototype.wasAltered = function() {
          return this.__altered;
        };
        Map10.prototype.__iterator = function(type, reverse) {
          return new MapIterator(this, type, reverse);
        };
        Map10.prototype.__iterate = function(fn2, reverse) {
          var this$0 = this;
          var iterations = 0;
          this._root && this._root.iterate(function(entry) {
            iterations++;
            return fn2(entry[1], entry[0], this$0);
          }, reverse);
          return iterations;
        };
        Map10.prototype.__ensureOwner = function(ownerID) {
          if (ownerID === this.__ownerID) {
            return this;
          }
          if (!ownerID) {
            this.__ownerID = ownerID;
            this.__altered = false;
            return this;
          }
          return makeMap(this.size, this._root, ownerID, this.__hash);
        };
        function isMap(maybeMap) {
          return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
        }
        Map10.isMap = isMap;
        var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
        var MapPrototype = Map10.prototype;
        MapPrototype[IS_MAP_SENTINEL] = true;
        MapPrototype[DELETE] = MapPrototype.remove;
        MapPrototype.removeIn = MapPrototype.deleteIn;
        function ArrayMapNode(ownerID, entries) {
          this.ownerID = ownerID;
          this.entries = entries;
        }
        ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
          var entries = this.entries;
          for (var ii = 0, len = entries.length; ii < len; ii++) {
            if (is2(key, entries[ii][0])) {
              return entries[ii][1];
            }
          }
          return notSetValue;
        };
        ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          var removed = value === NOT_SET;
          var entries = this.entries;
          var idx = 0;
          for (var len = entries.length; idx < len; idx++) {
            if (is2(key, entries[idx][0])) {
              break;
            }
          }
          var exists = idx < len;
          if (exists ? entries[idx][1] === value : removed) {
            return this;
          }
          SetRef(didAlter);
          (removed || !exists) && SetRef(didChangeSize);
          if (removed && entries.length === 1) {
            return;
          }
          if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
            return createNodes(ownerID, entries, key, value);
          }
          var isEditable = ownerID && ownerID === this.ownerID;
          var newEntries = isEditable ? entries : arrCopy(entries);
          if (exists) {
            if (removed) {
              idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
            } else {
              newEntries[idx] = [key, value];
            }
          } else {
            newEntries.push([key, value]);
          }
          if (isEditable) {
            this.entries = newEntries;
            return this;
          }
          return new ArrayMapNode(ownerID, newEntries);
        };
        function BitmapIndexedNode(ownerID, bitmap, nodes) {
          this.ownerID = ownerID;
          this.bitmap = bitmap;
          this.nodes = nodes;
        }
        BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
          if (keyHash === void 0) {
            keyHash = hash3(key);
          }
          var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
          var bitmap = this.bitmap;
          return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
        };
        BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (keyHash === void 0) {
            keyHash = hash3(key);
          }
          var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var bit = 1 << keyHashFrag;
          var bitmap = this.bitmap;
          var exists = (bitmap & bit) !== 0;
          if (!exists && value === NOT_SET) {
            return this;
          }
          var idx = popCount(bitmap & bit - 1);
          var nodes = this.nodes;
          var node = exists ? nodes[idx] : void 0;
          var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
          if (newNode === node) {
            return this;
          }
          if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
            return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
          }
          if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
            return nodes[idx ^ 1];
          }
          if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
            return newNode;
          }
          var isEditable = ownerID && ownerID === this.ownerID;
          var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
          var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
          if (isEditable) {
            this.bitmap = newBitmap;
            this.nodes = newNodes;
            return this;
          }
          return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
        };
        function HashArrayMapNode(ownerID, count, nodes) {
          this.ownerID = ownerID;
          this.count = count;
          this.nodes = nodes;
        }
        HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
          if (keyHash === void 0) {
            keyHash = hash3(key);
          }
          var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var node = this.nodes[idx];
          return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
        };
        HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (keyHash === void 0) {
            keyHash = hash3(key);
          }
          var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var removed = value === NOT_SET;
          var nodes = this.nodes;
          var node = nodes[idx];
          if (removed && !node) {
            return this;
          }
          var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
          if (newNode === node) {
            return this;
          }
          var newCount = this.count;
          if (!node) {
            newCount++;
          } else if (!newNode) {
            newCount--;
            if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
              return packNodes(ownerID, nodes, newCount, idx);
            }
          }
          var isEditable = ownerID && ownerID === this.ownerID;
          var newNodes = setIn(nodes, idx, newNode, isEditable);
          if (isEditable) {
            this.count = newCount;
            this.nodes = newNodes;
            return this;
          }
          return new HashArrayMapNode(ownerID, newCount, newNodes);
        };
        function HashCollisionNode(ownerID, keyHash, entries) {
          this.ownerID = ownerID;
          this.keyHash = keyHash;
          this.entries = entries;
        }
        HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
          var entries = this.entries;
          for (var ii = 0, len = entries.length; ii < len; ii++) {
            if (is2(key, entries[ii][0])) {
              return entries[ii][1];
            }
          }
          return notSetValue;
        };
        HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (keyHash === void 0) {
            keyHash = hash3(key);
          }
          var removed = value === NOT_SET;
          if (keyHash !== this.keyHash) {
            if (removed) {
              return this;
            }
            SetRef(didAlter);
            SetRef(didChangeSize);
            return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
          }
          var entries = this.entries;
          var idx = 0;
          for (var len = entries.length; idx < len; idx++) {
            if (is2(key, entries[idx][0])) {
              break;
            }
          }
          var exists = idx < len;
          if (exists ? entries[idx][1] === value : removed) {
            return this;
          }
          SetRef(didAlter);
          (removed || !exists) && SetRef(didChangeSize);
          if (removed && len === 2) {
            return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
          }
          var isEditable = ownerID && ownerID === this.ownerID;
          var newEntries = isEditable ? entries : arrCopy(entries);
          if (exists) {
            if (removed) {
              idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
            } else {
              newEntries[idx] = [key, value];
            }
          } else {
            newEntries.push([key, value]);
          }
          if (isEditable) {
            this.entries = newEntries;
            return this;
          }
          return new HashCollisionNode(ownerID, this.keyHash, newEntries);
        };
        function ValueNode(ownerID, keyHash, entry) {
          this.ownerID = ownerID;
          this.keyHash = keyHash;
          this.entry = entry;
        }
        ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
          return is2(key, this.entry[0]) ? this.entry[1] : notSetValue;
        };
        ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          var removed = value === NOT_SET;
          var keyMatch = is2(key, this.entry[0]);
          if (keyMatch ? value === this.entry[1] : removed) {
            return this;
          }
          SetRef(didAlter);
          if (removed) {
            SetRef(didChangeSize);
            return;
          }
          if (keyMatch) {
            if (ownerID && ownerID === this.ownerID) {
              this.entry[1] = value;
              return this;
            }
            return new ValueNode(ownerID, this.keyHash, [key, value]);
          }
          SetRef(didChangeSize);
          return mergeIntoNode(this, ownerID, shift, hash3(key), [key, value]);
        };
        ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn2, reverse) {
          var entries = this.entries;
          for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
            if (fn2(entries[reverse ? maxIndex - ii : ii]) === false) {
              return false;
            }
          }
        };
        BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn2, reverse) {
          var nodes = this.nodes;
          for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
            var node = nodes[reverse ? maxIndex - ii : ii];
            if (node && node.iterate(fn2, reverse) === false) {
              return false;
            }
          }
        };
        ValueNode.prototype.iterate = function(fn2, reverse) {
          return fn2(this.entry);
        };
        createClass(MapIterator, Iterator);
        function MapIterator(map, type, reverse) {
          this._type = type;
          this._reverse = reverse;
          this._stack = map._root && mapIteratorFrame(map._root);
        }
        MapIterator.prototype.next = function() {
          var type = this._type;
          var stack = this._stack;
          while (stack) {
            var node = stack.node;
            var index = stack.index++;
            var maxIndex;
            if (node.entry) {
              if (index === 0) {
                return mapIteratorValue(type, node.entry);
              }
            } else if (node.entries) {
              maxIndex = node.entries.length - 1;
              if (index <= maxIndex) {
                return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
              }
            } else {
              maxIndex = node.nodes.length - 1;
              if (index <= maxIndex) {
                var subNode = node.nodes[this._reverse ? maxIndex - index : index];
                if (subNode) {
                  if (subNode.entry) {
                    return mapIteratorValue(type, subNode.entry);
                  }
                  stack = this._stack = mapIteratorFrame(subNode, stack);
                }
                continue;
              }
            }
            stack = this._stack = this._stack.__prev;
          }
          return iteratorDone();
        };
        function mapIteratorValue(type, entry) {
          return iteratorValue(type, entry[0], entry[1]);
        }
        function mapIteratorFrame(node, prev) {
          return {
            node,
            index: 0,
            __prev: prev
          };
        }
        function makeMap(size, root, ownerID, hash4) {
          var map = Object.create(MapPrototype);
          map.size = size;
          map._root = root;
          map.__ownerID = ownerID;
          map.__hash = hash4;
          map.__altered = false;
          return map;
        }
        var EMPTY_MAP;
        function emptyMap() {
          return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
        }
        function updateMap(map, k, v) {
          var newRoot;
          var newSize;
          if (!map._root) {
            if (v === NOT_SET) {
              return map;
            }
            newSize = 1;
            newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
          } else {
            var didChangeSize = MakeRef(CHANGE_LENGTH);
            var didAlter = MakeRef(DID_ALTER);
            newRoot = updateNode(map._root, map.__ownerID, 0, void 0, k, v, didChangeSize, didAlter);
            if (!didAlter.value) {
              return map;
            }
            newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
          }
          if (map.__ownerID) {
            map.size = newSize;
            map._root = newRoot;
            map.__hash = void 0;
            map.__altered = true;
            return map;
          }
          return newRoot ? makeMap(newSize, newRoot) : emptyMap();
        }
        function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
          if (!node) {
            if (value === NOT_SET) {
              return node;
            }
            SetRef(didAlter);
            SetRef(didChangeSize);
            return new ValueNode(ownerID, keyHash, [key, value]);
          }
          return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
        }
        function isLeafNode(node) {
          return node.constructor === ValueNode || node.constructor === HashCollisionNode;
        }
        function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
          if (node.keyHash === keyHash) {
            return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
          }
          var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
          var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
          var newNode;
          var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
          return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
        }
        function createNodes(ownerID, entries, key, value) {
          if (!ownerID) {
            ownerID = new OwnerID();
          }
          var node = new ValueNode(ownerID, hash3(key), [key, value]);
          for (var ii = 0; ii < entries.length; ii++) {
            var entry = entries[ii];
            node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
          }
          return node;
        }
        function packNodes(ownerID, nodes, count, excluding) {
          var bitmap = 0;
          var packedII = 0;
          var packedNodes = new Array(count);
          for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
            var node = nodes[ii];
            if (node !== void 0 && ii !== excluding) {
              bitmap |= bit;
              packedNodes[packedII++] = node;
            }
          }
          return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
        }
        function expandNodes(ownerID, nodes, bitmap, including, node) {
          var count = 0;
          var expandedNodes = new Array(SIZE);
          for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
            expandedNodes[ii] = bitmap & 1 ? nodes[count++] : void 0;
          }
          expandedNodes[including] = node;
          return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
        }
        function mergeIntoMapWith(map, merger, iterables) {
          var iters = [];
          for (var ii = 0; ii < iterables.length; ii++) {
            var value = iterables[ii];
            var iter = KeyedIterable(value);
            if (!isIterable(value)) {
              iter = iter.map(function(v) {
                return fromJS2(v);
              });
            }
            iters.push(iter);
          }
          return mergeIntoCollectionWith(map, merger, iters);
        }
        function deepMerger(existing, value, key) {
          return existing && existing.mergeDeep && isIterable(value) ? existing.mergeDeep(value) : is2(existing, value) ? existing : value;
        }
        function deepMergerWith(merger) {
          return function(existing, value, key) {
            if (existing && existing.mergeDeepWith && isIterable(value)) {
              return existing.mergeDeepWith(merger, value);
            }
            var nextValue = merger(existing, value, key);
            return is2(existing, nextValue) ? existing : nextValue;
          };
        }
        function mergeIntoCollectionWith(collection, merger, iters) {
          iters = iters.filter(function(x) {
            return x.size !== 0;
          });
          if (iters.length === 0) {
            return collection;
          }
          if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
            return collection.constructor(iters[0]);
          }
          return collection.withMutations(function(collection2) {
            var mergeIntoMap = merger ? function(value, key) {
              collection2.update(
                key,
                NOT_SET,
                function(existing) {
                  return existing === NOT_SET ? value : merger(existing, value, key);
                }
              );
            } : function(value, key) {
              collection2.set(key, value);
            };
            for (var ii = 0; ii < iters.length; ii++) {
              iters[ii].forEach(mergeIntoMap);
            }
          });
        }
        function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
          var isNotSet = existing === NOT_SET;
          var step = keyPathIter.next();
          if (step.done) {
            var existingValue = isNotSet ? notSetValue : existing;
            var newValue = updater(existingValue);
            return newValue === existingValue ? existing : newValue;
          }
          invariant(
            isNotSet || existing && existing.set,
            "invalid keyPath"
          );
          var key = step.value;
          var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
          var nextUpdated = updateInDeepMap(
            nextExisting,
            keyPathIter,
            notSetValue,
            updater
          );
          return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? existing.remove(key) : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
        }
        function popCount(x) {
          x = x - (x >> 1 & 1431655765);
          x = (x & 858993459) + (x >> 2 & 858993459);
          x = x + (x >> 4) & 252645135;
          x = x + (x >> 8);
          x = x + (x >> 16);
          return x & 127;
        }
        function setIn(array, idx, val, canEdit) {
          var newArray = canEdit ? array : arrCopy(array);
          newArray[idx] = val;
          return newArray;
        }
        function spliceIn(array, idx, val, canEdit) {
          var newLen = array.length + 1;
          if (canEdit && idx + 1 === newLen) {
            array[idx] = val;
            return array;
          }
          var newArray = new Array(newLen);
          var after = 0;
          for (var ii = 0; ii < newLen; ii++) {
            if (ii === idx) {
              newArray[ii] = val;
              after = -1;
            } else {
              newArray[ii] = array[ii + after];
            }
          }
          return newArray;
        }
        function spliceOut(array, idx, canEdit) {
          var newLen = array.length - 1;
          if (canEdit && idx === newLen) {
            array.pop();
            return array;
          }
          var newArray = new Array(newLen);
          var after = 0;
          for (var ii = 0; ii < newLen; ii++) {
            if (ii === idx) {
              after = 1;
            }
            newArray[ii] = array[ii + after];
          }
          return newArray;
        }
        var MAX_ARRAY_MAP_SIZE = SIZE / 4;
        var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
        var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
        createClass(List7, IndexedCollection);
        function List7(value) {
          var empty = emptyList();
          if (value === null || value === void 0) {
            return empty;
          }
          if (isList(value)) {
            return value;
          }
          var iter = IndexedIterable(value);
          var size = iter.size;
          if (size === 0) {
            return empty;
          }
          assertNotInfinite(size);
          if (size > 0 && size < SIZE) {
            return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
          }
          return empty.withMutations(function(list) {
            list.setSize(size);
            iter.forEach(function(v, i) {
              return list.set(i, v);
            });
          });
        }
        List7.of = function() {
          return this(arguments);
        };
        List7.prototype.toString = function() {
          return this.__toString("List [", "]");
        };
        List7.prototype.get = function(index, notSetValue) {
          index = wrapIndex(this, index);
          if (index >= 0 && index < this.size) {
            index += this._origin;
            var node = listNodeFor(this, index);
            return node && node.array[index & MASK];
          }
          return notSetValue;
        };
        List7.prototype.set = function(index, value) {
          return updateList(this, index, value);
        };
        List7.prototype.remove = function(index) {
          return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
        };
        List7.prototype.insert = function(index, value) {
          return this.splice(index, 0, value);
        };
        List7.prototype.clear = function() {
          if (this.size === 0) {
            return this;
          }
          if (this.__ownerID) {
            this.size = this._origin = this._capacity = 0;
            this._level = SHIFT;
            this._root = this._tail = null;
            this.__hash = void 0;
            this.__altered = true;
            return this;
          }
          return emptyList();
        };
        List7.prototype.push = function() {
          var values = arguments;
          var oldSize = this.size;
          return this.withMutations(function(list) {
            setListBounds(list, 0, oldSize + values.length);
            for (var ii = 0; ii < values.length; ii++) {
              list.set(oldSize + ii, values[ii]);
            }
          });
        };
        List7.prototype.pop = function() {
          return setListBounds(this, 0, -1);
        };
        List7.prototype.unshift = function() {
          var values = arguments;
          return this.withMutations(function(list) {
            setListBounds(list, -values.length);
            for (var ii = 0; ii < values.length; ii++) {
              list.set(ii, values[ii]);
            }
          });
        };
        List7.prototype.shift = function() {
          return setListBounds(this, 1);
        };
        List7.prototype.merge = function() {
          return mergeIntoListWith(this, void 0, arguments);
        };
        List7.prototype.mergeWith = function(merger) {
          var iters = SLICE$0.call(arguments, 1);
          return mergeIntoListWith(this, merger, iters);
        };
        List7.prototype.mergeDeep = function() {
          return mergeIntoListWith(this, deepMerger, arguments);
        };
        List7.prototype.mergeDeepWith = function(merger) {
          var iters = SLICE$0.call(arguments, 1);
          return mergeIntoListWith(this, deepMergerWith(merger), iters);
        };
        List7.prototype.setSize = function(size) {
          return setListBounds(this, 0, size);
        };
        List7.prototype.slice = function(begin, end2) {
          var size = this.size;
          if (wholeSlice(begin, end2, size)) {
            return this;
          }
          return setListBounds(
            this,
            resolveBegin(begin, size),
            resolveEnd(end2, size)
          );
        };
        List7.prototype.__iterator = function(type, reverse) {
          var index = 0;
          var values = iterateList(this, reverse);
          return new Iterator(function() {
            var value = values();
            return value === DONE ? iteratorDone() : iteratorValue(type, index++, value);
          });
        };
        List7.prototype.__iterate = function(fn2, reverse) {
          var index = 0;
          var values = iterateList(this, reverse);
          var value;
          while ((value = values()) !== DONE) {
            if (fn2(value, index++, this) === false) {
              break;
            }
          }
          return index;
        };
        List7.prototype.__ensureOwner = function(ownerID) {
          if (ownerID === this.__ownerID) {
            return this;
          }
          if (!ownerID) {
            this.__ownerID = ownerID;
            return this;
          }
          return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
        };
        function isList(maybeList) {
          return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
        }
        List7.isList = isList;
        var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
        var ListPrototype = List7.prototype;
        ListPrototype[IS_LIST_SENTINEL] = true;
        ListPrototype[DELETE] = ListPrototype.remove;
        ListPrototype.setIn = MapPrototype.setIn;
        ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;
        ListPrototype.update = MapPrototype.update;
        ListPrototype.updateIn = MapPrototype.updateIn;
        ListPrototype.mergeIn = MapPrototype.mergeIn;
        ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
        ListPrototype.withMutations = MapPrototype.withMutations;
        ListPrototype.asMutable = MapPrototype.asMutable;
        ListPrototype.asImmutable = MapPrototype.asImmutable;
        ListPrototype.wasAltered = MapPrototype.wasAltered;
        function VNode(array, ownerID) {
          this.array = array;
          this.ownerID = ownerID;
        }
        VNode.prototype.removeBefore = function(ownerID, level, index) {
          if (index === level ? 1 << level : this.array.length === 0) {
            return this;
          }
          var originIndex = index >>> level & MASK;
          if (originIndex >= this.array.length) {
            return new VNode([], ownerID);
          }
          var removingFirst = originIndex === 0;
          var newChild;
          if (level > 0) {
            var oldChild = this.array[originIndex];
            newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
            if (newChild === oldChild && removingFirst) {
              return this;
            }
          }
          if (removingFirst && !newChild) {
            return this;
          }
          var editable = editableVNode(this, ownerID);
          if (!removingFirst) {
            for (var ii = 0; ii < originIndex; ii++) {
              editable.array[ii] = void 0;
            }
          }
          if (newChild) {
            editable.array[originIndex] = newChild;
          }
          return editable;
        };
        VNode.prototype.removeAfter = function(ownerID, level, index) {
          if (index === (level ? 1 << level : 0) || this.array.length === 0) {
            return this;
          }
          var sizeIndex = index - 1 >>> level & MASK;
          if (sizeIndex >= this.array.length) {
            return this;
          }
          var newChild;
          if (level > 0) {
            var oldChild = this.array[sizeIndex];
            newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
            if (newChild === oldChild && sizeIndex === this.array.length - 1) {
              return this;
            }
          }
          var editable = editableVNode(this, ownerID);
          editable.array.splice(sizeIndex + 1);
          if (newChild) {
            editable.array[sizeIndex] = newChild;
          }
          return editable;
        };
        var DONE = {};
        function iterateList(list, reverse) {
          var left2 = list._origin;
          var right2 = list._capacity;
          var tailPos = getTailOffset(right2);
          var tail = list._tail;
          return iterateNodeOrLeaf(list._root, list._level, 0);
          function iterateNodeOrLeaf(node, level, offset2) {
            return level === 0 ? iterateLeaf(node, offset2) : iterateNode(node, level, offset2);
          }
          function iterateLeaf(node, offset2) {
            var array = offset2 === tailPos ? tail && tail.array : node && node.array;
            var from = offset2 > left2 ? 0 : left2 - offset2;
            var to = right2 - offset2;
            if (to > SIZE) {
              to = SIZE;
            }
            return function() {
              if (from === to) {
                return DONE;
              }
              var idx = reverse ? --to : from++;
              return array && array[idx];
            };
          }
          function iterateNode(node, level, offset2) {
            var values;
            var array = node && node.array;
            var from = offset2 > left2 ? 0 : left2 - offset2 >> level;
            var to = (right2 - offset2 >> level) + 1;
            if (to > SIZE) {
              to = SIZE;
            }
            return function() {
              do {
                if (values) {
                  var value = values();
                  if (value !== DONE) {
                    return value;
                  }
                  values = null;
                }
                if (from === to) {
                  return DONE;
                }
                var idx = reverse ? --to : from++;
                values = iterateNodeOrLeaf(
                  array && array[idx],
                  level - SHIFT,
                  offset2 + (idx << level)
                );
              } while (true);
            };
          }
        }
        function makeList(origin, capacity, level, root, tail, ownerID, hash4) {
          var list = Object.create(ListPrototype);
          list.size = capacity - origin;
          list._origin = origin;
          list._capacity = capacity;
          list._level = level;
          list._root = root;
          list._tail = tail;
          list.__ownerID = ownerID;
          list.__hash = hash4;
          list.__altered = false;
          return list;
        }
        var EMPTY_LIST;
        function emptyList() {
          return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
        }
        function updateList(list, index, value) {
          index = wrapIndex(list, index);
          if (index !== index) {
            return list;
          }
          if (index >= list.size || index < 0) {
            return list.withMutations(function(list2) {
              index < 0 ? setListBounds(list2, index).set(0, value) : setListBounds(list2, 0, index + 1).set(index, value);
            });
          }
          index += list._origin;
          var newTail = list._tail;
          var newRoot = list._root;
          var didAlter = MakeRef(DID_ALTER);
          if (index >= getTailOffset(list._capacity)) {
            newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
          } else {
            newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
          }
          if (!didAlter.value) {
            return list;
          }
          if (list.__ownerID) {
            list._root = newRoot;
            list._tail = newTail;
            list.__hash = void 0;
            list.__altered = true;
            return list;
          }
          return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
        }
        function updateVNode(node, ownerID, level, index, value, didAlter) {
          var idx = index >>> level & MASK;
          var nodeHas = node && idx < node.array.length;
          if (!nodeHas && value === void 0) {
            return node;
          }
          var newNode;
          if (level > 0) {
            var lowerNode = node && node.array[idx];
            var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
            if (newLowerNode === lowerNode) {
              return node;
            }
            newNode = editableVNode(node, ownerID);
            newNode.array[idx] = newLowerNode;
            return newNode;
          }
          if (nodeHas && node.array[idx] === value) {
            return node;
          }
          SetRef(didAlter);
          newNode = editableVNode(node, ownerID);
          if (value === void 0 && idx === newNode.array.length - 1) {
            newNode.array.pop();
          } else {
            newNode.array[idx] = value;
          }
          return newNode;
        }
        function editableVNode(node, ownerID) {
          if (ownerID && node && ownerID === node.ownerID) {
            return node;
          }
          return new VNode(node ? node.array.slice() : [], ownerID);
        }
        function listNodeFor(list, rawIndex) {
          if (rawIndex >= getTailOffset(list._capacity)) {
            return list._tail;
          }
          if (rawIndex < 1 << list._level + SHIFT) {
            var node = list._root;
            var level = list._level;
            while (node && level > 0) {
              node = node.array[rawIndex >>> level & MASK];
              level -= SHIFT;
            }
            return node;
          }
        }
        function setListBounds(list, begin, end2) {
          if (begin !== void 0) {
            begin = begin | 0;
          }
          if (end2 !== void 0) {
            end2 = end2 | 0;
          }
          var owner = list.__ownerID || new OwnerID();
          var oldOrigin = list._origin;
          var oldCapacity = list._capacity;
          var newOrigin = oldOrigin + begin;
          var newCapacity = end2 === void 0 ? oldCapacity : end2 < 0 ? oldCapacity + end2 : oldOrigin + end2;
          if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
            return list;
          }
          if (newOrigin >= newCapacity) {
            return list.clear();
          }
          var newLevel = list._level;
          var newRoot = list._root;
          var offsetShift = 0;
          while (newOrigin + offsetShift < 0) {
            newRoot = new VNode(newRoot && newRoot.array.length ? [void 0, newRoot] : [], owner);
            newLevel += SHIFT;
            offsetShift += 1 << newLevel;
          }
          if (offsetShift) {
            newOrigin += offsetShift;
            oldOrigin += offsetShift;
            newCapacity += offsetShift;
            oldCapacity += offsetShift;
          }
          var oldTailOffset = getTailOffset(oldCapacity);
          var newTailOffset = getTailOffset(newCapacity);
          while (newTailOffset >= 1 << newLevel + SHIFT) {
            newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
            newLevel += SHIFT;
          }
          var oldTail = list._tail;
          var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
          if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
            newRoot = editableVNode(newRoot, owner);
            var node = newRoot;
            for (var level = newLevel; level > SHIFT; level -= SHIFT) {
              var idx = oldTailOffset >>> level & MASK;
              node = node.array[idx] = editableVNode(node.array[idx], owner);
            }
            node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
          }
          if (newCapacity < oldCapacity) {
            newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
          }
          if (newOrigin >= newTailOffset) {
            newOrigin -= newTailOffset;
            newCapacity -= newTailOffset;
            newLevel = SHIFT;
            newRoot = null;
            newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
          } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
            offsetShift = 0;
            while (newRoot) {
              var beginIndex = newOrigin >>> newLevel & MASK;
              if (beginIndex !== newTailOffset >>> newLevel & MASK) {
                break;
              }
              if (beginIndex) {
                offsetShift += (1 << newLevel) * beginIndex;
              }
              newLevel -= SHIFT;
              newRoot = newRoot.array[beginIndex];
            }
            if (newRoot && newOrigin > oldOrigin) {
              newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
            }
            if (newRoot && newTailOffset < oldTailOffset) {
              newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
            }
            if (offsetShift) {
              newOrigin -= offsetShift;
              newCapacity -= offsetShift;
            }
          }
          if (list.__ownerID) {
            list.size = newCapacity - newOrigin;
            list._origin = newOrigin;
            list._capacity = newCapacity;
            list._level = newLevel;
            list._root = newRoot;
            list._tail = newTail;
            list.__hash = void 0;
            list.__altered = true;
            return list;
          }
          return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
        }
        function mergeIntoListWith(list, merger, iterables) {
          var iters = [];
          var maxSize = 0;
          for (var ii = 0; ii < iterables.length; ii++) {
            var value = iterables[ii];
            var iter = IndexedIterable(value);
            if (iter.size > maxSize) {
              maxSize = iter.size;
            }
            if (!isIterable(value)) {
              iter = iter.map(function(v) {
                return fromJS2(v);
              });
            }
            iters.push(iter);
          }
          if (maxSize > list.size) {
            list = list.setSize(maxSize);
          }
          return mergeIntoCollectionWith(list, merger, iters);
        }
        function getTailOffset(size) {
          return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
        }
        createClass(OrderedMap, Map10);
        function OrderedMap(value) {
          return value === null || value === void 0 ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map) {
            var iter = KeyedIterable(value);
            assertNotInfinite(iter.size);
            iter.forEach(function(v, k) {
              return map.set(k, v);
            });
          });
        }
        OrderedMap.of = function() {
          return this(arguments);
        };
        OrderedMap.prototype.toString = function() {
          return this.__toString("OrderedMap {", "}");
        };
        OrderedMap.prototype.get = function(k, notSetValue) {
          var index = this._map.get(k);
          return index !== void 0 ? this._list.get(index)[1] : notSetValue;
        };
        OrderedMap.prototype.clear = function() {
          if (this.size === 0) {
            return this;
          }
          if (this.__ownerID) {
            this.size = 0;
            this._map.clear();
            this._list.clear();
            return this;
          }
          return emptyOrderedMap();
        };
        OrderedMap.prototype.set = function(k, v) {
          return updateOrderedMap(this, k, v);
        };
        OrderedMap.prototype.remove = function(k) {
          return updateOrderedMap(this, k, NOT_SET);
        };
        OrderedMap.prototype.wasAltered = function() {
          return this._map.wasAltered() || this._list.wasAltered();
        };
        OrderedMap.prototype.__iterate = function(fn2, reverse) {
          var this$0 = this;
          return this._list.__iterate(
            function(entry) {
              return entry && fn2(entry[1], entry[0], this$0);
            },
            reverse
          );
        };
        OrderedMap.prototype.__iterator = function(type, reverse) {
          return this._list.fromEntrySeq().__iterator(type, reverse);
        };
        OrderedMap.prototype.__ensureOwner = function(ownerID) {
          if (ownerID === this.__ownerID) {
            return this;
          }
          var newMap = this._map.__ensureOwner(ownerID);
          var newList = this._list.__ensureOwner(ownerID);
          if (!ownerID) {
            this.__ownerID = ownerID;
            this._map = newMap;
            this._list = newList;
            return this;
          }
          return makeOrderedMap(newMap, newList, ownerID, this.__hash);
        };
        function isOrderedMap(maybeOrderedMap) {
          return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
        }
        OrderedMap.isOrderedMap = isOrderedMap;
        OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
        OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
        function makeOrderedMap(map, list, ownerID, hash4) {
          var omap = Object.create(OrderedMap.prototype);
          omap.size = map ? map.size : 0;
          omap._map = map;
          omap._list = list;
          omap.__ownerID = ownerID;
          omap.__hash = hash4;
          return omap;
        }
        var EMPTY_ORDERED_MAP;
        function emptyOrderedMap() {
          return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
        }
        function updateOrderedMap(omap, k, v) {
          var map = omap._map;
          var list = omap._list;
          var i = map.get(k);
          var has = i !== void 0;
          var newMap;
          var newList;
          if (v === NOT_SET) {
            if (!has) {
              return omap;
            }
            if (list.size >= SIZE && list.size >= map.size * 2) {
              newList = list.filter(function(entry, idx) {
                return entry !== void 0 && i !== idx;
              });
              newMap = newList.toKeyedSeq().map(function(entry) {
                return entry[0];
              }).flip().toMap();
              if (omap.__ownerID) {
                newMap.__ownerID = newList.__ownerID = omap.__ownerID;
              }
            } else {
              newMap = map.remove(k);
              newList = i === list.size - 1 ? list.pop() : list.set(i, void 0);
            }
          } else {
            if (has) {
              if (v === list.get(i)[1]) {
                return omap;
              }
              newMap = map;
              newList = list.set(i, [k, v]);
            } else {
              newMap = map.set(k, list.size);
              newList = list.set(list.size, [k, v]);
            }
          }
          if (omap.__ownerID) {
            omap.size = newMap.size;
            omap._map = newMap;
            omap._list = newList;
            omap.__hash = void 0;
            return omap;
          }
          return makeOrderedMap(newMap, newList);
        }
        createClass(ToKeyedSequence, KeyedSeq);
        function ToKeyedSequence(indexed, useKeys) {
          this._iter = indexed;
          this._useKeys = useKeys;
          this.size = indexed.size;
        }
        ToKeyedSequence.prototype.get = function(key, notSetValue) {
          return this._iter.get(key, notSetValue);
        };
        ToKeyedSequence.prototype.has = function(key) {
          return this._iter.has(key);
        };
        ToKeyedSequence.prototype.valueSeq = function() {
          return this._iter.valueSeq();
        };
        ToKeyedSequence.prototype.reverse = function() {
          var this$0 = this;
          var reversedSequence = reverseFactory(this, true);
          if (!this._useKeys) {
            reversedSequence.valueSeq = function() {
              return this$0._iter.toSeq().reverse();
            };
          }
          return reversedSequence;
        };
        ToKeyedSequence.prototype.map = function(mapper, context) {
          var this$0 = this;
          var mappedSequence = mapFactory(this, mapper, context);
          if (!this._useKeys) {
            mappedSequence.valueSeq = function() {
              return this$0._iter.toSeq().map(mapper, context);
            };
          }
          return mappedSequence;
        };
        ToKeyedSequence.prototype.__iterate = function(fn2, reverse) {
          var this$0 = this;
          var ii;
          return this._iter.__iterate(
            this._useKeys ? function(v, k) {
              return fn2(v, k, this$0);
            } : (ii = reverse ? resolveSize(this) : 0, function(v) {
              return fn2(v, reverse ? --ii : ii++, this$0);
            }),
            reverse
          );
        };
        ToKeyedSequence.prototype.__iterator = function(type, reverse) {
          if (this._useKeys) {
            return this._iter.__iterator(type, reverse);
          }
          var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
          var ii = reverse ? resolveSize(this) : 0;
          return new Iterator(function() {
            var step = iterator.next();
            return step.done ? step : iteratorValue(type, reverse ? --ii : ii++, step.value, step);
          });
        };
        ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
        createClass(ToIndexedSequence, IndexedSeq);
        function ToIndexedSequence(iter) {
          this._iter = iter;
          this.size = iter.size;
        }
        ToIndexedSequence.prototype.includes = function(value) {
          return this._iter.includes(value);
        };
        ToIndexedSequence.prototype.__iterate = function(fn2, reverse) {
          var this$0 = this;
          var iterations = 0;
          return this._iter.__iterate(function(v) {
            return fn2(v, iterations++, this$0);
          }, reverse);
        };
        ToIndexedSequence.prototype.__iterator = function(type, reverse) {
          var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
          var iterations = 0;
          return new Iterator(function() {
            var step = iterator.next();
            return step.done ? step : iteratorValue(type, iterations++, step.value, step);
          });
        };
        createClass(ToSetSequence, SetSeq);
        function ToSetSequence(iter) {
          this._iter = iter;
          this.size = iter.size;
        }
        ToSetSequence.prototype.has = function(key) {
          return this._iter.includes(key);
        };
        ToSetSequence.prototype.__iterate = function(fn2, reverse) {
          var this$0 = this;
          return this._iter.__iterate(function(v) {
            return fn2(v, v, this$0);
          }, reverse);
        };
        ToSetSequence.prototype.__iterator = function(type, reverse) {
          var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
          return new Iterator(function() {
            var step = iterator.next();
            return step.done ? step : iteratorValue(type, step.value, step.value, step);
          });
        };
        createClass(FromEntriesSequence, KeyedSeq);
        function FromEntriesSequence(entries) {
          this._iter = entries;
          this.size = entries.size;
        }
        FromEntriesSequence.prototype.entrySeq = function() {
          return this._iter.toSeq();
        };
        FromEntriesSequence.prototype.__iterate = function(fn2, reverse) {
          var this$0 = this;
          return this._iter.__iterate(function(entry) {
            if (entry) {
              validateEntry(entry);
              var indexedIterable = isIterable(entry);
              return fn2(
                indexedIterable ? entry.get(1) : entry[1],
                indexedIterable ? entry.get(0) : entry[0],
                this$0
              );
            }
          }, reverse);
        };
        FromEntriesSequence.prototype.__iterator = function(type, reverse) {
          var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
          return new Iterator(function() {
            while (true) {
              var step = iterator.next();
              if (step.done) {
                return step;
              }
              var entry = step.value;
              if (entry) {
                validateEntry(entry);
                var indexedIterable = isIterable(entry);
                return iteratorValue(
                  type,
                  indexedIterable ? entry.get(0) : entry[0],
                  indexedIterable ? entry.get(1) : entry[1],
                  step
                );
              }
            }
          });
        };
        ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
        function flipFactory(iterable) {
          var flipSequence = makeSequence(iterable);
          flipSequence._iter = iterable;
          flipSequence.size = iterable.size;
          flipSequence.flip = function() {
            return iterable;
          };
          flipSequence.reverse = function() {
            var reversedSequence = iterable.reverse.apply(this);
            reversedSequence.flip = function() {
              return iterable.reverse();
            };
            return reversedSequence;
          };
          flipSequence.has = function(key) {
            return iterable.includes(key);
          };
          flipSequence.includes = function(key) {
            return iterable.has(key);
          };
          flipSequence.cacheResult = cacheResultThrough;
          flipSequence.__iterateUncached = function(fn2, reverse) {
            var this$0 = this;
            return iterable.__iterate(function(v, k) {
              return fn2(k, v, this$0) !== false;
            }, reverse);
          };
          flipSequence.__iteratorUncached = function(type, reverse) {
            if (type === ITERATE_ENTRIES) {
              var iterator = iterable.__iterator(type, reverse);
              return new Iterator(function() {
                var step = iterator.next();
                if (!step.done) {
                  var k = step.value[0];
                  step.value[0] = step.value[1];
                  step.value[1] = k;
                }
                return step;
              });
            }
            return iterable.__iterator(
              type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
              reverse
            );
          };
          return flipSequence;
        }
        function mapFactory(iterable, mapper, context) {
          var mappedSequence = makeSequence(iterable);
          mappedSequence.size = iterable.size;
          mappedSequence.has = function(key) {
            return iterable.has(key);
          };
          mappedSequence.get = function(key, notSetValue) {
            var v = iterable.get(key, NOT_SET);
            return v === NOT_SET ? notSetValue : mapper.call(context, v, key, iterable);
          };
          mappedSequence.__iterateUncached = function(fn2, reverse) {
            var this$0 = this;
            return iterable.__iterate(
              function(v, k, c) {
                return fn2(mapper.call(context, v, k, c), k, this$0) !== false;
              },
              reverse
            );
          };
          mappedSequence.__iteratorUncached = function(type, reverse) {
            var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
            return new Iterator(function() {
              var step = iterator.next();
              if (step.done) {
                return step;
              }
              var entry = step.value;
              var key = entry[0];
              return iteratorValue(
                type,
                key,
                mapper.call(context, entry[1], key, iterable),
                step
              );
            });
          };
          return mappedSequence;
        }
        function reverseFactory(iterable, useKeys) {
          var reversedSequence = makeSequence(iterable);
          reversedSequence._iter = iterable;
          reversedSequence.size = iterable.size;
          reversedSequence.reverse = function() {
            return iterable;
          };
          if (iterable.flip) {
            reversedSequence.flip = function() {
              var flipSequence = flipFactory(iterable);
              flipSequence.reverse = function() {
                return iterable.flip();
              };
              return flipSequence;
            };
          }
          reversedSequence.get = function(key, notSetValue) {
            return iterable.get(useKeys ? key : -1 - key, notSetValue);
          };
          reversedSequence.has = function(key) {
            return iterable.has(useKeys ? key : -1 - key);
          };
          reversedSequence.includes = function(value) {
            return iterable.includes(value);
          };
          reversedSequence.cacheResult = cacheResultThrough;
          reversedSequence.__iterate = function(fn2, reverse) {
            var this$0 = this;
            return iterable.__iterate(function(v, k) {
              return fn2(v, k, this$0);
            }, !reverse);
          };
          reversedSequence.__iterator = function(type, reverse) {
            return iterable.__iterator(type, !reverse);
          };
          return reversedSequence;
        }
        function filterFactory(iterable, predicate, context, useKeys) {
          var filterSequence = makeSequence(iterable);
          if (useKeys) {
            filterSequence.has = function(key) {
              var v = iterable.get(key, NOT_SET);
              return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
            };
            filterSequence.get = function(key, notSetValue) {
              var v = iterable.get(key, NOT_SET);
              return v !== NOT_SET && predicate.call(context, v, key, iterable) ? v : notSetValue;
            };
          }
          filterSequence.__iterateUncached = function(fn2, reverse) {
            var this$0 = this;
            var iterations = 0;
            iterable.__iterate(function(v, k, c) {
              if (predicate.call(context, v, k, c)) {
                iterations++;
                return fn2(v, useKeys ? k : iterations - 1, this$0);
              }
            }, reverse);
            return iterations;
          };
          filterSequence.__iteratorUncached = function(type, reverse) {
            var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
            var iterations = 0;
            return new Iterator(function() {
              while (true) {
                var step = iterator.next();
                if (step.done) {
                  return step;
                }
                var entry = step.value;
                var key = entry[0];
                var value = entry[1];
                if (predicate.call(context, value, key, iterable)) {
                  return iteratorValue(type, useKeys ? key : iterations++, value, step);
                }
              }
            });
          };
          return filterSequence;
        }
        function countByFactory(iterable, grouper, context) {
          var groups = Map10().asMutable();
          iterable.__iterate(function(v, k) {
            groups.update(
              grouper.call(context, v, k, iterable),
              0,
              function(a) {
                return a + 1;
              }
            );
          });
          return groups.asImmutable();
        }
        function groupByFactory(iterable, grouper, context) {
          var isKeyedIter = isKeyed(iterable);
          var groups = (isOrdered(iterable) ? OrderedMap() : Map10()).asMutable();
          iterable.__iterate(function(v, k) {
            groups.update(
              grouper.call(context, v, k, iterable),
              function(a) {
                return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
              }
            );
          });
          var coerce = iterableClass(iterable);
          return groups.map(function(arr) {
            return reify(iterable, coerce(arr));
          });
        }
        function sliceFactory(iterable, begin, end2, useKeys) {
          var originalSize = iterable.size;
          if (begin !== void 0) {
            begin = begin | 0;
          }
          if (end2 !== void 0) {
            if (end2 === Infinity) {
              end2 = originalSize;
            } else {
              end2 = end2 | 0;
            }
          }
          if (wholeSlice(begin, end2, originalSize)) {
            return iterable;
          }
          var resolvedBegin = resolveBegin(begin, originalSize);
          var resolvedEnd = resolveEnd(end2, originalSize);
          if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
            return sliceFactory(iterable.toSeq().cacheResult(), begin, end2, useKeys);
          }
          var resolvedSize = resolvedEnd - resolvedBegin;
          var sliceSize;
          if (resolvedSize === resolvedSize) {
            sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
          }
          var sliceSeq = makeSequence(iterable);
          sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || void 0;
          if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
            sliceSeq.get = function(index, notSetValue) {
              index = wrapIndex(this, index);
              return index >= 0 && index < sliceSize ? iterable.get(index + resolvedBegin, notSetValue) : notSetValue;
            };
          }
          sliceSeq.__iterateUncached = function(fn2, reverse) {
            var this$0 = this;
            if (sliceSize === 0) {
              return 0;
            }
            if (reverse) {
              return this.cacheResult().__iterate(fn2, reverse);
            }
            var skipped = 0;
            var isSkipping = true;
            var iterations = 0;
            iterable.__iterate(function(v, k) {
              if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
                iterations++;
                return fn2(v, useKeys ? k : iterations - 1, this$0) !== false && iterations !== sliceSize;
              }
            });
            return iterations;
          };
          sliceSeq.__iteratorUncached = function(type, reverse) {
            if (sliceSize !== 0 && reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
            var skipped = 0;
            var iterations = 0;
            return new Iterator(function() {
              while (skipped++ < resolvedBegin) {
                iterator.next();
              }
              if (++iterations > sliceSize) {
                return iteratorDone();
              }
              var step = iterator.next();
              if (useKeys || type === ITERATE_VALUES) {
                return step;
              } else if (type === ITERATE_KEYS) {
                return iteratorValue(type, iterations - 1, void 0, step);
              } else {
                return iteratorValue(type, iterations - 1, step.value[1], step);
              }
            });
          };
          return sliceSeq;
        }
        function takeWhileFactory(iterable, predicate, context) {
          var takeSequence = makeSequence(iterable);
          takeSequence.__iterateUncached = function(fn2, reverse) {
            var this$0 = this;
            if (reverse) {
              return this.cacheResult().__iterate(fn2, reverse);
            }
            var iterations = 0;
            iterable.__iterate(
              function(v, k, c) {
                return predicate.call(context, v, k, c) && ++iterations && fn2(v, k, this$0);
              }
            );
            return iterations;
          };
          takeSequence.__iteratorUncached = function(type, reverse) {
            var this$0 = this;
            if (reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
            var iterating = true;
            return new Iterator(function() {
              if (!iterating) {
                return iteratorDone();
              }
              var step = iterator.next();
              if (step.done) {
                return step;
              }
              var entry = step.value;
              var k = entry[0];
              var v = entry[1];
              if (!predicate.call(context, v, k, this$0)) {
                iterating = false;
                return iteratorDone();
              }
              return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
            });
          };
          return takeSequence;
        }
        function skipWhileFactory(iterable, predicate, context, useKeys) {
          var skipSequence = makeSequence(iterable);
          skipSequence.__iterateUncached = function(fn2, reverse) {
            var this$0 = this;
            if (reverse) {
              return this.cacheResult().__iterate(fn2, reverse);
            }
            var isSkipping = true;
            var iterations = 0;
            iterable.__iterate(function(v, k, c) {
              if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
                iterations++;
                return fn2(v, useKeys ? k : iterations - 1, this$0);
              }
            });
            return iterations;
          };
          skipSequence.__iteratorUncached = function(type, reverse) {
            var this$0 = this;
            if (reverse) {
              return this.cacheResult().__iterator(type, reverse);
            }
            var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
            var skipping = true;
            var iterations = 0;
            return new Iterator(function() {
              var step, k, v;
              do {
                step = iterator.next();
                if (step.done) {
                  if (useKeys || type === ITERATE_VALUES) {
                    return step;
                  } else if (type === ITERATE_KEYS) {
                    return iteratorValue(type, iterations++, void 0, step);
                  } else {
                    return iteratorValue(type, iterations++, step.value[1], step);
                  }
                }
                var entry = step.value;
                k = entry[0];
                v = entry[1];
                skipping && (skipping = predicate.call(context, v, k, this$0));
              } while (skipping);
              return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
            });
          };
          return skipSequence;
        }
        function concatFactory(iterable, values) {
          var isKeyedIterable = isKeyed(iterable);
          var iters = [iterable].concat(values).map(function(v) {
            if (!isIterable(v)) {
              v = isKeyedIterable ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
            } else if (isKeyedIterable) {
              v = KeyedIterable(v);
            }
            return v;
          }).filter(function(v) {
            return v.size !== 0;
          });
          if (iters.length === 0) {
            return iterable;
          }
          if (iters.length === 1) {
            var singleton = iters[0];
            if (singleton === iterable || isKeyedIterable && isKeyed(singleton) || isIndexed(iterable) && isIndexed(singleton)) {
              return singleton;
            }
          }
          var concatSeq = new ArraySeq(iters);
          if (isKeyedIterable) {
            concatSeq = concatSeq.toKeyedSeq();
          } else if (!isIndexed(iterable)) {
            concatSeq = concatSeq.toSetSeq();
          }
          concatSeq = concatSeq.flatten(true);
          concatSeq.size = iters.reduce(
            function(sum, seq) {
              if (sum !== void 0) {
                var size = seq.size;
                if (size !== void 0) {
                  return sum + size;
                }
              }
            },
            0
          );
          return concatSeq;
        }
        function flattenFactory(iterable, depth, useKeys) {
          var flatSequence = makeSequence(iterable);
          flatSequence.__iterateUncached = function(fn2, reverse) {
            var iterations = 0;
            var stopped = false;
            function flatDeep(iter, currentDepth) {
              var this$0 = this;
              iter.__iterate(function(v, k) {
                if ((!depth || currentDepth < depth) && isIterable(v)) {
                  flatDeep(v, currentDepth + 1);
                } else if (fn2(v, useKeys ? k : iterations++, this$0) === false) {
                  stopped = true;
                }
                return !stopped;
              }, reverse);
            }
            flatDeep(iterable, 0);
            return iterations;
          };
          flatSequence.__iteratorUncached = function(type, reverse) {
            var iterator = iterable.__iterator(type, reverse);
            var stack = [];
            var iterations = 0;
            return new Iterator(function() {
              while (iterator) {
                var step = iterator.next();
                if (step.done !== false) {
                  iterator = stack.pop();
                  continue;
                }
                var v = step.value;
                if (type === ITERATE_ENTRIES) {
                  v = v[1];
                }
                if ((!depth || stack.length < depth) && isIterable(v)) {
                  stack.push(iterator);
                  iterator = v.__iterator(type, reverse);
                } else {
                  return useKeys ? step : iteratorValue(type, iterations++, v, step);
                }
              }
              return iteratorDone();
            });
          };
          return flatSequence;
        }
        function flatMapFactory(iterable, mapper, context) {
          var coerce = iterableClass(iterable);
          return iterable.toSeq().map(
            function(v, k) {
              return coerce(mapper.call(context, v, k, iterable));
            }
          ).flatten(true);
        }
        function interposeFactory(iterable, separator) {
          var interposedSequence = makeSequence(iterable);
          interposedSequence.size = iterable.size && iterable.size * 2 - 1;
          interposedSequence.__iterateUncached = function(fn2, reverse) {
            var this$0 = this;
            var iterations = 0;
            iterable.__iterate(
              function(v, k) {
                return (!iterations || fn2(separator, iterations++, this$0) !== false) && fn2(v, iterations++, this$0) !== false;
              },
              reverse
            );
            return iterations;
          };
          interposedSequence.__iteratorUncached = function(type, reverse) {
            var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
            var iterations = 0;
            var step;
            return new Iterator(function() {
              if (!step || iterations % 2) {
                step = iterator.next();
                if (step.done) {
                  return step;
                }
              }
              return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
            });
          };
          return interposedSequence;
        }
        function sortFactory(iterable, comparator, mapper) {
          if (!comparator) {
            comparator = defaultComparator;
          }
          var isKeyedIterable = isKeyed(iterable);
          var index = 0;
          var entries = iterable.toSeq().map(
            function(v, k) {
              return [k, v, index++, mapper ? mapper(v, k, iterable) : v];
            }
          ).toArray();
          entries.sort(function(a, b) {
            return comparator(a[3], b[3]) || a[2] - b[2];
          }).forEach(
            isKeyedIterable ? function(v, i) {
              entries[i].length = 2;
            } : function(v, i) {
              entries[i] = v[1];
            }
          );
          return isKeyedIterable ? KeyedSeq(entries) : isIndexed(iterable) ? IndexedSeq(entries) : SetSeq(entries);
        }
        function maxFactory(iterable, comparator, mapper) {
          if (!comparator) {
            comparator = defaultComparator;
          }
          if (mapper) {
            var entry = iterable.toSeq().map(function(v, k) {
              return [v, mapper(v, k, iterable)];
            }).reduce(function(a, b) {
              return maxCompare(comparator, a[1], b[1]) ? b : a;
            });
            return entry && entry[0];
          } else {
            return iterable.reduce(function(a, b) {
              return maxCompare(comparator, a, b) ? b : a;
            });
          }
        }
        function maxCompare(comparator, a, b) {
          var comp = comparator(b, a);
          return comp === 0 && b !== a && (b === void 0 || b === null || b !== b) || comp > 0;
        }
        function zipWithFactory(keyIter, zipper, iters) {
          var zipSequence = makeSequence(keyIter);
          zipSequence.size = new ArraySeq(iters).map(function(i) {
            return i.size;
          }).min();
          zipSequence.__iterate = function(fn2, reverse) {
            var iterator = this.__iterator(ITERATE_VALUES, reverse);
            var step;
            var iterations = 0;
            while (!(step = iterator.next()).done) {
              if (fn2(step.value, iterations++, this) === false) {
                break;
              }
            }
            return iterations;
          };
          zipSequence.__iteratorUncached = function(type, reverse) {
            var iterators = iters.map(
              function(i) {
                return i = Iterable(i), getIterator(reverse ? i.reverse() : i);
              }
            );
            var iterations = 0;
            var isDone = false;
            return new Iterator(function() {
              var steps;
              if (!isDone) {
                steps = iterators.map(function(i) {
                  return i.next();
                });
                isDone = steps.some(function(s) {
                  return s.done;
                });
              }
              if (isDone) {
                return iteratorDone();
              }
              return iteratorValue(
                type,
                iterations++,
                zipper.apply(null, steps.map(function(s) {
                  return s.value;
                }))
              );
            });
          };
          return zipSequence;
        }
        function reify(iter, seq) {
          return isSeq(iter) ? seq : iter.constructor(seq);
        }
        function validateEntry(entry) {
          if (entry !== Object(entry)) {
            throw new TypeError("Expected [K, V] tuple: " + entry);
          }
        }
        function resolveSize(iter) {
          assertNotInfinite(iter.size);
          return ensureSize(iter);
        }
        function iterableClass(iterable) {
          return isKeyed(iterable) ? KeyedIterable : isIndexed(iterable) ? IndexedIterable : SetIterable;
        }
        function makeSequence(iterable) {
          return Object.create(
            (isKeyed(iterable) ? KeyedSeq : isIndexed(iterable) ? IndexedSeq : SetSeq).prototype
          );
        }
        function cacheResultThrough() {
          if (this._iter.cacheResult) {
            this._iter.cacheResult();
            this.size = this._iter.size;
            return this;
          } else {
            return Seq.prototype.cacheResult.call(this);
          }
        }
        function defaultComparator(a, b) {
          return a > b ? 1 : a < b ? -1 : 0;
        }
        function forceIterator(keyPath) {
          var iter = getIterator(keyPath);
          if (!iter) {
            if (!isArrayLike(keyPath)) {
              throw new TypeError("Expected iterable or array-like: " + keyPath);
            }
            iter = getIterator(Iterable(keyPath));
          }
          return iter;
        }
        createClass(Record, KeyedCollection);
        function Record(defaultValues, name) {
          var hasInitialized;
          var RecordType = function Record2(values) {
            if (values instanceof RecordType) {
              return values;
            }
            if (!(this instanceof RecordType)) {
              return new RecordType(values);
            }
            if (!hasInitialized) {
              hasInitialized = true;
              var keys5 = Object.keys(defaultValues);
              setProps(RecordTypePrototype, keys5);
              RecordTypePrototype.size = keys5.length;
              RecordTypePrototype._name = name;
              RecordTypePrototype._keys = keys5;
              RecordTypePrototype._defaultValues = defaultValues;
            }
            this._map = Map10(values);
          };
          var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
          RecordTypePrototype.constructor = RecordType;
          return RecordType;
        }
        Record.prototype.toString = function() {
          return this.__toString(recordName(this) + " {", "}");
        };
        Record.prototype.has = function(k) {
          return this._defaultValues.hasOwnProperty(k);
        };
        Record.prototype.get = function(k, notSetValue) {
          if (!this.has(k)) {
            return notSetValue;
          }
          var defaultVal = this._defaultValues[k];
          return this._map ? this._map.get(k, defaultVal) : defaultVal;
        };
        Record.prototype.clear = function() {
          if (this.__ownerID) {
            this._map && this._map.clear();
            return this;
          }
          var RecordType = this.constructor;
          return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
        };
        Record.prototype.set = function(k, v) {
          if (!this.has(k)) {
            throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
          }
          if (this._map && !this._map.has(k)) {
            var defaultVal = this._defaultValues[k];
            if (v === defaultVal) {
              return this;
            }
          }
          var newMap = this._map && this._map.set(k, v);
          if (this.__ownerID || newMap === this._map) {
            return this;
          }
          return makeRecord(this, newMap);
        };
        Record.prototype.remove = function(k) {
          if (!this.has(k)) {
            return this;
          }
          var newMap = this._map && this._map.remove(k);
          if (this.__ownerID || newMap === this._map) {
            return this;
          }
          return makeRecord(this, newMap);
        };
        Record.prototype.wasAltered = function() {
          return this._map.wasAltered();
        };
        Record.prototype.__iterator = function(type, reverse) {
          var this$0 = this;
          return KeyedIterable(this._defaultValues).map(function(_, k) {
            return this$0.get(k);
          }).__iterator(type, reverse);
        };
        Record.prototype.__iterate = function(fn2, reverse) {
          var this$0 = this;
          return KeyedIterable(this._defaultValues).map(function(_, k) {
            return this$0.get(k);
          }).__iterate(fn2, reverse);
        };
        Record.prototype.__ensureOwner = function(ownerID) {
          if (ownerID === this.__ownerID) {
            return this;
          }
          var newMap = this._map && this._map.__ensureOwner(ownerID);
          if (!ownerID) {
            this.__ownerID = ownerID;
            this._map = newMap;
            return this;
          }
          return makeRecord(this, newMap, ownerID);
        };
        var RecordPrototype = Record.prototype;
        RecordPrototype[DELETE] = RecordPrototype.remove;
        RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn;
        RecordPrototype.merge = MapPrototype.merge;
        RecordPrototype.mergeWith = MapPrototype.mergeWith;
        RecordPrototype.mergeIn = MapPrototype.mergeIn;
        RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
        RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
        RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
        RecordPrototype.setIn = MapPrototype.setIn;
        RecordPrototype.update = MapPrototype.update;
        RecordPrototype.updateIn = MapPrototype.updateIn;
        RecordPrototype.withMutations = MapPrototype.withMutations;
        RecordPrototype.asMutable = MapPrototype.asMutable;
        RecordPrototype.asImmutable = MapPrototype.asImmutable;
        function makeRecord(likeRecord, map, ownerID) {
          var record = Object.create(Object.getPrototypeOf(likeRecord));
          record._map = map;
          record.__ownerID = ownerID;
          return record;
        }
        function recordName(record) {
          return record._name || record.constructor.name || "Record";
        }
        function setProps(prototype, names) {
          try {
            names.forEach(setProp.bind(void 0, prototype));
          } catch (error2) {
          }
        }
        function setProp(prototype, name) {
          Object.defineProperty(prototype, name, {
            get: function() {
              return this.get(name);
            },
            set: function(value) {
              invariant(this.__ownerID, "Cannot set on an immutable record.");
              this.set(name, value);
            }
          });
        }
        createClass(Set2, SetCollection);
        function Set2(value) {
          return value === null || value === void 0 ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function(set3) {
            var iter = SetIterable(value);
            assertNotInfinite(iter.size);
            iter.forEach(function(v) {
              return set3.add(v);
            });
          });
        }
        Set2.of = function() {
          return this(arguments);
        };
        Set2.fromKeys = function(value) {
          return this(KeyedIterable(value).keySeq());
        };
        Set2.prototype.toString = function() {
          return this.__toString("Set {", "}");
        };
        Set2.prototype.has = function(value) {
          return this._map.has(value);
        };
        Set2.prototype.add = function(value) {
          return updateSet(this, this._map.set(value, true));
        };
        Set2.prototype.remove = function(value) {
          return updateSet(this, this._map.remove(value));
        };
        Set2.prototype.clear = function() {
          return updateSet(this, this._map.clear());
        };
        Set2.prototype.union = function() {
          var iters = SLICE$0.call(arguments, 0);
          iters = iters.filter(function(x) {
            return x.size !== 0;
          });
          if (iters.length === 0) {
            return this;
          }
          if (this.size === 0 && !this.__ownerID && iters.length === 1) {
            return this.constructor(iters[0]);
          }
          return this.withMutations(function(set3) {
            for (var ii = 0; ii < iters.length; ii++) {
              SetIterable(iters[ii]).forEach(function(value) {
                return set3.add(value);
              });
            }
          });
        };
        Set2.prototype.intersect = function() {
          var iters = SLICE$0.call(arguments, 0);
          if (iters.length === 0) {
            return this;
          }
          iters = iters.map(function(iter) {
            return SetIterable(iter);
          });
          var originalSet = this;
          return this.withMutations(function(set3) {
            originalSet.forEach(function(value) {
              if (!iters.every(function(iter) {
                return iter.includes(value);
              })) {
                set3.remove(value);
              }
            });
          });
        };
        Set2.prototype.subtract = function() {
          var iters = SLICE$0.call(arguments, 0);
          if (iters.length === 0) {
            return this;
          }
          iters = iters.map(function(iter) {
            return SetIterable(iter);
          });
          var originalSet = this;
          return this.withMutations(function(set3) {
            originalSet.forEach(function(value) {
              if (iters.some(function(iter) {
                return iter.includes(value);
              })) {
                set3.remove(value);
              }
            });
          });
        };
        Set2.prototype.merge = function() {
          return this.union.apply(this, arguments);
        };
        Set2.prototype.mergeWith = function(merger) {
          var iters = SLICE$0.call(arguments, 1);
          return this.union.apply(this, iters);
        };
        Set2.prototype.sort = function(comparator) {
          return OrderedSet(sortFactory(this, comparator));
        };
        Set2.prototype.sortBy = function(mapper, comparator) {
          return OrderedSet(sortFactory(this, comparator, mapper));
        };
        Set2.prototype.wasAltered = function() {
          return this._map.wasAltered();
        };
        Set2.prototype.__iterate = function(fn2, reverse) {
          var this$0 = this;
          return this._map.__iterate(function(_, k) {
            return fn2(k, k, this$0);
          }, reverse);
        };
        Set2.prototype.__iterator = function(type, reverse) {
          return this._map.map(function(_, k) {
            return k;
          }).__iterator(type, reverse);
        };
        Set2.prototype.__ensureOwner = function(ownerID) {
          if (ownerID === this.__ownerID) {
            return this;
          }
          var newMap = this._map.__ensureOwner(ownerID);
          if (!ownerID) {
            this.__ownerID = ownerID;
            this._map = newMap;
            return this;
          }
          return this.__make(newMap, ownerID);
        };
        function isSet(maybeSet) {
          return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
        }
        Set2.isSet = isSet;
        var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
        var SetPrototype = Set2.prototype;
        SetPrototype[IS_SET_SENTINEL] = true;
        SetPrototype[DELETE] = SetPrototype.remove;
        SetPrototype.mergeDeep = SetPrototype.merge;
        SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
        SetPrototype.withMutations = MapPrototype.withMutations;
        SetPrototype.asMutable = MapPrototype.asMutable;
        SetPrototype.asImmutable = MapPrototype.asImmutable;
        SetPrototype.__empty = emptySet;
        SetPrototype.__make = makeSet;
        function updateSet(set3, newMap) {
          if (set3.__ownerID) {
            set3.size = newMap.size;
            set3._map = newMap;
            return set3;
          }
          return newMap === set3._map ? set3 : newMap.size === 0 ? set3.__empty() : set3.__make(newMap);
        }
        function makeSet(map, ownerID) {
          var set3 = Object.create(SetPrototype);
          set3.size = map ? map.size : 0;
          set3._map = map;
          set3.__ownerID = ownerID;
          return set3;
        }
        var EMPTY_SET;
        function emptySet() {
          return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
        }
        createClass(OrderedSet, Set2);
        function OrderedSet(value) {
          return value === null || value === void 0 ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set3) {
            var iter = SetIterable(value);
            assertNotInfinite(iter.size);
            iter.forEach(function(v) {
              return set3.add(v);
            });
          });
        }
        OrderedSet.of = function() {
          return this(arguments);
        };
        OrderedSet.fromKeys = function(value) {
          return this(KeyedIterable(value).keySeq());
        };
        OrderedSet.prototype.toString = function() {
          return this.__toString("OrderedSet {", "}");
        };
        function isOrderedSet(maybeOrderedSet) {
          return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
        }
        OrderedSet.isOrderedSet = isOrderedSet;
        var OrderedSetPrototype = OrderedSet.prototype;
        OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
        OrderedSetPrototype.__empty = emptyOrderedSet;
        OrderedSetPrototype.__make = makeOrderedSet;
        function makeOrderedSet(map, ownerID) {
          var set3 = Object.create(OrderedSetPrototype);
          set3.size = map ? map.size : 0;
          set3._map = map;
          set3.__ownerID = ownerID;
          return set3;
        }
        var EMPTY_ORDERED_SET;
        function emptyOrderedSet() {
          return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
        }
        createClass(Stack2, IndexedCollection);
        function Stack2(value) {
          return value === null || value === void 0 ? emptyStack() : isStack(value) ? value : emptyStack().unshiftAll(value);
        }
        Stack2.of = function() {
          return this(arguments);
        };
        Stack2.prototype.toString = function() {
          return this.__toString("Stack [", "]");
        };
        Stack2.prototype.get = function(index, notSetValue) {
          var head = this._head;
          index = wrapIndex(this, index);
          while (head && index--) {
            head = head.next;
          }
          return head ? head.value : notSetValue;
        };
        Stack2.prototype.peek = function() {
          return this._head && this._head.value;
        };
        Stack2.prototype.push = function() {
          if (arguments.length === 0) {
            return this;
          }
          var newSize = this.size + arguments.length;
          var head = this._head;
          for (var ii = arguments.length - 1; ii >= 0; ii--) {
            head = {
              value: arguments[ii],
              next: head
            };
          }
          if (this.__ownerID) {
            this.size = newSize;
            this._head = head;
            this.__hash = void 0;
            this.__altered = true;
            return this;
          }
          return makeStack(newSize, head);
        };
        Stack2.prototype.pushAll = function(iter) {
          iter = IndexedIterable(iter);
          if (iter.size === 0) {
            return this;
          }
          assertNotInfinite(iter.size);
          var newSize = this.size;
          var head = this._head;
          iter.reverse().forEach(function(value) {
            newSize++;
            head = {
              value,
              next: head
            };
          });
          if (this.__ownerID) {
            this.size = newSize;
            this._head = head;
            this.__hash = void 0;
            this.__altered = true;
            return this;
          }
          return makeStack(newSize, head);
        };
        Stack2.prototype.pop = function() {
          return this.slice(1);
        };
        Stack2.prototype.unshift = function() {
          return this.push.apply(this, arguments);
        };
        Stack2.prototype.unshiftAll = function(iter) {
          return this.pushAll(iter);
        };
        Stack2.prototype.shift = function() {
          return this.pop.apply(this, arguments);
        };
        Stack2.prototype.clear = function() {
          if (this.size === 0) {
            return this;
          }
          if (this.__ownerID) {
            this.size = 0;
            this._head = void 0;
            this.__hash = void 0;
            this.__altered = true;
            return this;
          }
          return emptyStack();
        };
        Stack2.prototype.slice = function(begin, end2) {
          if (wholeSlice(begin, end2, this.size)) {
            return this;
          }
          var resolvedBegin = resolveBegin(begin, this.size);
          var resolvedEnd = resolveEnd(end2, this.size);
          if (resolvedEnd !== this.size) {
            return IndexedCollection.prototype.slice.call(this, begin, end2);
          }
          var newSize = this.size - resolvedBegin;
          var head = this._head;
          while (resolvedBegin--) {
            head = head.next;
          }
          if (this.__ownerID) {
            this.size = newSize;
            this._head = head;
            this.__hash = void 0;
            this.__altered = true;
            return this;
          }
          return makeStack(newSize, head);
        };
        Stack2.prototype.__ensureOwner = function(ownerID) {
          if (ownerID === this.__ownerID) {
            return this;
          }
          if (!ownerID) {
            this.__ownerID = ownerID;
            this.__altered = false;
            return this;
          }
          return makeStack(this.size, this._head, ownerID, this.__hash);
        };
        Stack2.prototype.__iterate = function(fn2, reverse) {
          if (reverse) {
            return this.reverse().__iterate(fn2);
          }
          var iterations = 0;
          var node = this._head;
          while (node) {
            if (fn2(node.value, iterations++, this) === false) {
              break;
            }
            node = node.next;
          }
          return iterations;
        };
        Stack2.prototype.__iterator = function(type, reverse) {
          if (reverse) {
            return this.reverse().__iterator(type);
          }
          var iterations = 0;
          var node = this._head;
          return new Iterator(function() {
            if (node) {
              var value = node.value;
              node = node.next;
              return iteratorValue(type, iterations++, value);
            }
            return iteratorDone();
          });
        };
        function isStack(maybeStack) {
          return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
        }
        Stack2.isStack = isStack;
        var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
        var StackPrototype = Stack2.prototype;
        StackPrototype[IS_STACK_SENTINEL] = true;
        StackPrototype.withMutations = MapPrototype.withMutations;
        StackPrototype.asMutable = MapPrototype.asMutable;
        StackPrototype.asImmutable = MapPrototype.asImmutable;
        StackPrototype.wasAltered = MapPrototype.wasAltered;
        function makeStack(size, head, ownerID, hash4) {
          var map = Object.create(StackPrototype);
          map.size = size;
          map._head = head;
          map.__ownerID = ownerID;
          map.__hash = hash4;
          map.__altered = false;
          return map;
        }
        var EMPTY_STACK;
        function emptyStack() {
          return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
        }
        function mixin(ctor, methods) {
          var keyCopier = function(key) {
            ctor.prototype[key] = methods[key];
          };
          Object.keys(methods).forEach(keyCopier);
          Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
          return ctor;
        }
        Iterable.Iterator = Iterator;
        mixin(Iterable, {
          // ### Conversion to other types
          toArray: function() {
            assertNotInfinite(this.size);
            var array = new Array(this.size || 0);
            this.valueSeq().__iterate(function(v, i) {
              array[i] = v;
            });
            return array;
          },
          toIndexedSeq: function() {
            return new ToIndexedSequence(this);
          },
          toJS: function() {
            return this.toSeq().map(
              function(value) {
                return value && typeof value.toJS === "function" ? value.toJS() : value;
              }
            ).__toJS();
          },
          toJSON: function() {
            return this.toSeq().map(
              function(value) {
                return value && typeof value.toJSON === "function" ? value.toJSON() : value;
              }
            ).__toJS();
          },
          toKeyedSeq: function() {
            return new ToKeyedSequence(this, true);
          },
          toMap: function() {
            return Map10(this.toKeyedSeq());
          },
          toObject: function() {
            assertNotInfinite(this.size);
            var object = {};
            this.__iterate(function(v, k) {
              object[k] = v;
            });
            return object;
          },
          toOrderedMap: function() {
            return OrderedMap(this.toKeyedSeq());
          },
          toOrderedSet: function() {
            return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
          },
          toSet: function() {
            return Set2(isKeyed(this) ? this.valueSeq() : this);
          },
          toSetSeq: function() {
            return new ToSetSequence(this);
          },
          toSeq: function() {
            return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
          },
          toStack: function() {
            return Stack2(isKeyed(this) ? this.valueSeq() : this);
          },
          toList: function() {
            return List7(isKeyed(this) ? this.valueSeq() : this);
          },
          // ### Common JavaScript methods and properties
          toString: function() {
            return "[Iterable]";
          },
          __toString: function(head, tail) {
            if (this.size === 0) {
              return head + tail;
            }
            return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
          },
          // ### ES6 Collection methods (ES6 Array and Map)
          concat: function() {
            var values = SLICE$0.call(arguments, 0);
            return reify(this, concatFactory(this, values));
          },
          includes: function(searchValue) {
            return this.some(function(value) {
              return is2(value, searchValue);
            });
          },
          entries: function() {
            return this.__iterator(ITERATE_ENTRIES);
          },
          every: function(predicate, context) {
            assertNotInfinite(this.size);
            var returnValue = true;
            this.__iterate(function(v, k, c) {
              if (!predicate.call(context, v, k, c)) {
                returnValue = false;
                return false;
              }
            });
            return returnValue;
          },
          filter: function(predicate, context) {
            return reify(this, filterFactory(this, predicate, context, true));
          },
          find: function(predicate, context, notSetValue) {
            var entry = this.findEntry(predicate, context);
            return entry ? entry[1] : notSetValue;
          },
          forEach: function(sideEffect, context) {
            assertNotInfinite(this.size);
            return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
          },
          join: function(separator) {
            assertNotInfinite(this.size);
            separator = separator !== void 0 ? "" + separator : ",";
            var joined = "";
            var isFirst = true;
            this.__iterate(function(v) {
              isFirst ? isFirst = false : joined += separator;
              joined += v !== null && v !== void 0 ? v.toString() : "";
            });
            return joined;
          },
          keys: function() {
            return this.__iterator(ITERATE_KEYS);
          },
          map: function(mapper, context) {
            return reify(this, mapFactory(this, mapper, context));
          },
          reduce: function(reducer, initialReduction, context) {
            assertNotInfinite(this.size);
            var reduction;
            var useFirst;
            if (arguments.length < 2) {
              useFirst = true;
            } else {
              reduction = initialReduction;
            }
            this.__iterate(function(v, k, c) {
              if (useFirst) {
                useFirst = false;
                reduction = v;
              } else {
                reduction = reducer.call(context, reduction, v, k, c);
              }
            });
            return reduction;
          },
          reduceRight: function(reducer, initialReduction, context) {
            var reversed = this.toKeyedSeq().reverse();
            return reversed.reduce.apply(reversed, arguments);
          },
          reverse: function() {
            return reify(this, reverseFactory(this, true));
          },
          slice: function(begin, end2) {
            return reify(this, sliceFactory(this, begin, end2, true));
          },
          some: function(predicate, context) {
            return !this.every(not(predicate), context);
          },
          sort: function(comparator) {
            return reify(this, sortFactory(this, comparator));
          },
          values: function() {
            return this.__iterator(ITERATE_VALUES);
          },
          // ### More sequential methods
          butLast: function() {
            return this.slice(0, -1);
          },
          isEmpty: function() {
            return this.size !== void 0 ? this.size === 0 : !this.some(function() {
              return true;
            });
          },
          count: function(predicate, context) {
            return ensureSize(
              predicate ? this.toSeq().filter(predicate, context) : this
            );
          },
          countBy: function(grouper, context) {
            return countByFactory(this, grouper, context);
          },
          equals: function(other) {
            return deepEqual2(this, other);
          },
          entrySeq: function() {
            var iterable = this;
            if (iterable._cache) {
              return new ArraySeq(iterable._cache);
            }
            var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
            entriesSequence.fromEntrySeq = function() {
              return iterable.toSeq();
            };
            return entriesSequence;
          },
          filterNot: function(predicate, context) {
            return this.filter(not(predicate), context);
          },
          findEntry: function(predicate, context, notSetValue) {
            var found = notSetValue;
            this.__iterate(function(v, k, c) {
              if (predicate.call(context, v, k, c)) {
                found = [k, v];
                return false;
              }
            });
            return found;
          },
          findKey: function(predicate, context) {
            var entry = this.findEntry(predicate, context);
            return entry && entry[0];
          },
          findLast: function(predicate, context, notSetValue) {
            return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
          },
          findLastEntry: function(predicate, context, notSetValue) {
            return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
          },
          findLastKey: function(predicate, context) {
            return this.toKeyedSeq().reverse().findKey(predicate, context);
          },
          first: function() {
            return this.find(returnTrue);
          },
          flatMap: function(mapper, context) {
            return reify(this, flatMapFactory(this, mapper, context));
          },
          flatten: function(depth) {
            return reify(this, flattenFactory(this, depth, true));
          },
          fromEntrySeq: function() {
            return new FromEntriesSequence(this);
          },
          get: function(searchKey, notSetValue) {
            return this.find(function(_, key) {
              return is2(key, searchKey);
            }, void 0, notSetValue);
          },
          getIn: function(searchKeyPath, notSetValue) {
            var nested = this;
            var iter = forceIterator(searchKeyPath);
            var step;
            while (!(step = iter.next()).done) {
              var key = step.value;
              nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
              if (nested === NOT_SET) {
                return notSetValue;
              }
            }
            return nested;
          },
          groupBy: function(grouper, context) {
            return groupByFactory(this, grouper, context);
          },
          has: function(searchKey) {
            return this.get(searchKey, NOT_SET) !== NOT_SET;
          },
          hasIn: function(searchKeyPath) {
            return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
          },
          isSubset: function(iter) {
            iter = typeof iter.includes === "function" ? iter : Iterable(iter);
            return this.every(function(value) {
              return iter.includes(value);
            });
          },
          isSuperset: function(iter) {
            iter = typeof iter.isSubset === "function" ? iter : Iterable(iter);
            return iter.isSubset(this);
          },
          keyOf: function(searchValue) {
            return this.findKey(function(value) {
              return is2(value, searchValue);
            });
          },
          keySeq: function() {
            return this.toSeq().map(keyMapper).toIndexedSeq();
          },
          last: function() {
            return this.toSeq().reverse().first();
          },
          lastKeyOf: function(searchValue) {
            return this.toKeyedSeq().reverse().keyOf(searchValue);
          },
          max: function(comparator) {
            return maxFactory(this, comparator);
          },
          maxBy: function(mapper, comparator) {
            return maxFactory(this, comparator, mapper);
          },
          min: function(comparator) {
            return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
          },
          minBy: function(mapper, comparator) {
            return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
          },
          rest: function() {
            return this.slice(1);
          },
          skip: function(amount) {
            return this.slice(Math.max(0, amount));
          },
          skipLast: function(amount) {
            return reify(this, this.toSeq().reverse().skip(amount).reverse());
          },
          skipWhile: function(predicate, context) {
            return reify(this, skipWhileFactory(this, predicate, context, true));
          },
          skipUntil: function(predicate, context) {
            return this.skipWhile(not(predicate), context);
          },
          sortBy: function(mapper, comparator) {
            return reify(this, sortFactory(this, comparator, mapper));
          },
          take: function(amount) {
            return this.slice(0, Math.max(0, amount));
          },
          takeLast: function(amount) {
            return reify(this, this.toSeq().reverse().take(amount).reverse());
          },
          takeWhile: function(predicate, context) {
            return reify(this, takeWhileFactory(this, predicate, context));
          },
          takeUntil: function(predicate, context) {
            return this.takeWhile(not(predicate), context);
          },
          valueSeq: function() {
            return this.toIndexedSeq();
          },
          // ### Hashable Object
          hashCode: function() {
            return this.__hash || (this.__hash = hashIterable(this));
          }
          // ### Internal
          // abstract __iterate(fn, reverse)
          // abstract __iterator(type, reverse)
        });
        var IterablePrototype = Iterable.prototype;
        IterablePrototype[IS_ITERABLE_SENTINEL] = true;
        IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
        IterablePrototype.__toJS = IterablePrototype.toArray;
        IterablePrototype.__toStringMapper = quoteString;
        IterablePrototype.inspect = IterablePrototype.toSource = function() {
          return this.toString();
        };
        IterablePrototype.chain = IterablePrototype.flatMap;
        IterablePrototype.contains = IterablePrototype.includes;
        mixin(KeyedIterable, {
          // ### More sequential methods
          flip: function() {
            return reify(this, flipFactory(this));
          },
          mapEntries: function(mapper, context) {
            var this$0 = this;
            var iterations = 0;
            return reify(
              this,
              this.toSeq().map(
                function(v, k) {
                  return mapper.call(context, [k, v], iterations++, this$0);
                }
              ).fromEntrySeq()
            );
          },
          mapKeys: function(mapper, context) {
            var this$0 = this;
            return reify(
              this,
              this.toSeq().flip().map(
                function(k, v) {
                  return mapper.call(context, k, v, this$0);
                }
              ).flip()
            );
          }
        });
        var KeyedIterablePrototype = KeyedIterable.prototype;
        KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
        KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
        KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
        KeyedIterablePrototype.__toStringMapper = function(v, k) {
          return JSON.stringify(k) + ": " + quoteString(v);
        };
        mixin(IndexedIterable, {
          // ### Conversion to other types
          toKeyedSeq: function() {
            return new ToKeyedSequence(this, false);
          },
          // ### ES6 Collection methods (ES6 Array and Map)
          filter: function(predicate, context) {
            return reify(this, filterFactory(this, predicate, context, false));
          },
          findIndex: function(predicate, context) {
            var entry = this.findEntry(predicate, context);
            return entry ? entry[0] : -1;
          },
          indexOf: function(searchValue) {
            var key = this.keyOf(searchValue);
            return key === void 0 ? -1 : key;
          },
          lastIndexOf: function(searchValue) {
            var key = this.lastKeyOf(searchValue);
            return key === void 0 ? -1 : key;
          },
          reverse: function() {
            return reify(this, reverseFactory(this, false));
          },
          slice: function(begin, end2) {
            return reify(this, sliceFactory(this, begin, end2, false));
          },
          splice: function(index, removeNum) {
            var numArgs = arguments.length;
            removeNum = Math.max(removeNum | 0, 0);
            if (numArgs === 0 || numArgs === 2 && !removeNum) {
              return this;
            }
            index = resolveBegin(index, index < 0 ? this.count() : this.size);
            var spliced = this.slice(0, index);
            return reify(
              this,
              numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
            );
          },
          // ### More collection methods
          findLastIndex: function(predicate, context) {
            var entry = this.findLastEntry(predicate, context);
            return entry ? entry[0] : -1;
          },
          first: function() {
            return this.get(0);
          },
          flatten: function(depth) {
            return reify(this, flattenFactory(this, depth, false));
          },
          get: function(index, notSetValue) {
            index = wrapIndex(this, index);
            return index < 0 || (this.size === Infinity || this.size !== void 0 && index > this.size) ? notSetValue : this.find(function(_, key) {
              return key === index;
            }, void 0, notSetValue);
          },
          has: function(index) {
            index = wrapIndex(this, index);
            return index >= 0 && (this.size !== void 0 ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
          },
          interpose: function(separator) {
            return reify(this, interposeFactory(this, separator));
          },
          interleave: function() {
            var iterables = [this].concat(arrCopy(arguments));
            var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
            var interleaved = zipped.flatten(true);
            if (zipped.size) {
              interleaved.size = zipped.size * iterables.length;
            }
            return reify(this, interleaved);
          },
          keySeq: function() {
            return Range(0, this.size);
          },
          last: function() {
            return this.get(-1);
          },
          skipWhile: function(predicate, context) {
            return reify(this, skipWhileFactory(this, predicate, context, false));
          },
          zip: function() {
            var iterables = [this].concat(arrCopy(arguments));
            return reify(this, zipWithFactory(this, defaultZipper, iterables));
          },
          zipWith: function(zipper) {
            var iterables = arrCopy(arguments);
            iterables[0] = this;
            return reify(this, zipWithFactory(this, zipper, iterables));
          }
        });
        IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
        IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
        mixin(SetIterable, {
          // ### ES6 Collection methods (ES6 Array and Map)
          get: function(value, notSetValue) {
            return this.has(value) ? value : notSetValue;
          },
          includes: function(value) {
            return this.has(value);
          },
          // ### More sequential methods
          keySeq: function() {
            return this.valueSeq();
          }
        });
        SetIterable.prototype.has = IterablePrototype.includes;
        SetIterable.prototype.contains = SetIterable.prototype.includes;
        mixin(KeyedSeq, KeyedIterable.prototype);
        mixin(IndexedSeq, IndexedIterable.prototype);
        mixin(SetSeq, SetIterable.prototype);
        mixin(KeyedCollection, KeyedIterable.prototype);
        mixin(IndexedCollection, IndexedIterable.prototype);
        mixin(SetCollection, SetIterable.prototype);
        function keyMapper(v, k) {
          return k;
        }
        function entryMapper(v, k) {
          return [k, v];
        }
        function not(predicate) {
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
        function neg(predicate) {
          return function() {
            return -predicate.apply(this, arguments);
          };
        }
        function quoteString(value) {
          return typeof value === "string" ? JSON.stringify(value) : String(value);
        }
        function defaultZipper() {
          return arrCopy(arguments);
        }
        function defaultNegComparator(a, b) {
          return a < b ? 1 : a > b ? -1 : 0;
        }
        function hashIterable(iterable) {
          if (iterable.size === Infinity) {
            return 0;
          }
          var ordered = isOrdered(iterable);
          var keyed = isKeyed(iterable);
          var h = ordered ? 1 : 0;
          var size = iterable.__iterate(
            keyed ? ordered ? function(v, k) {
              h = 31 * h + hashMerge(hash3(v), hash3(k)) | 0;
            } : function(v, k) {
              h = h + hashMerge(hash3(v), hash3(k)) | 0;
            } : ordered ? function(v) {
              h = 31 * h + hash3(v) | 0;
            } : function(v) {
              h = h + hash3(v) | 0;
            }
          );
          return murmurHashOfSize(size, h);
        }
        function murmurHashOfSize(size, h) {
          h = imul(h, 3432918353);
          h = imul(h << 15 | h >>> -15, 461845907);
          h = imul(h << 13 | h >>> -13, 5);
          h = (h + 3864292196 | 0) ^ size;
          h = imul(h ^ h >>> 16, 2246822507);
          h = imul(h ^ h >>> 13, 3266489909);
          h = smi(h ^ h >>> 16);
          return h;
        }
        function hashMerge(a, b) {
          return a ^ b + 2654435769 + (a << 6) + (a >> 2) | 0;
        }
        var Immutable9 = {
          Iterable,
          Seq,
          Collection,
          Map: Map10,
          OrderedMap,
          List: List7,
          Stack: Stack2,
          Set: Set2,
          OrderedSet,
          Record,
          Range,
          Repeat,
          is: is2,
          fromJS: fromJS2
        };
        return Immutable9;
      });
    }
  });

  // node_modules/lodash/_listCacheClear.js
  var require_listCacheClear = __commonJS({
    "node_modules/lodash/_listCacheClear.js"(exports, module) {
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      module.exports = listCacheClear;
    }
  });

  // node_modules/lodash/eq.js
  var require_eq = __commonJS({
    "node_modules/lodash/eq.js"(exports, module) {
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      module.exports = eq;
    }
  });

  // node_modules/lodash/_assocIndexOf.js
  var require_assocIndexOf = __commonJS({
    "node_modules/lodash/_assocIndexOf.js"(exports, module) {
      var eq = require_eq();
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      module.exports = assocIndexOf;
    }
  });

  // node_modules/lodash/_listCacheDelete.js
  var require_listCacheDelete = __commonJS({
    "node_modules/lodash/_listCacheDelete.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      module.exports = listCacheDelete;
    }
  });

  // node_modules/lodash/_listCacheGet.js
  var require_listCacheGet = __commonJS({
    "node_modules/lodash/_listCacheGet.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      module.exports = listCacheGet;
    }
  });

  // node_modules/lodash/_listCacheHas.js
  var require_listCacheHas = __commonJS({
    "node_modules/lodash/_listCacheHas.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      module.exports = listCacheHas;
    }
  });

  // node_modules/lodash/_listCacheSet.js
  var require_listCacheSet = __commonJS({
    "node_modules/lodash/_listCacheSet.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      module.exports = listCacheSet;
    }
  });

  // node_modules/lodash/_ListCache.js
  var require_ListCache = __commonJS({
    "node_modules/lodash/_ListCache.js"(exports, module) {
      var listCacheClear = require_listCacheClear();
      var listCacheDelete = require_listCacheDelete();
      var listCacheGet = require_listCacheGet();
      var listCacheHas = require_listCacheHas();
      var listCacheSet = require_listCacheSet();
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      module.exports = ListCache;
    }
  });

  // node_modules/lodash/_stackClear.js
  var require_stackClear = __commonJS({
    "node_modules/lodash/_stackClear.js"(exports, module) {
      var ListCache = require_ListCache();
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      module.exports = stackClear;
    }
  });

  // node_modules/lodash/_stackDelete.js
  var require_stackDelete = __commonJS({
    "node_modules/lodash/_stackDelete.js"(exports, module) {
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      module.exports = stackDelete;
    }
  });

  // node_modules/lodash/_stackGet.js
  var require_stackGet = __commonJS({
    "node_modules/lodash/_stackGet.js"(exports, module) {
      function stackGet(key) {
        return this.__data__.get(key);
      }
      module.exports = stackGet;
    }
  });

  // node_modules/lodash/_stackHas.js
  var require_stackHas = __commonJS({
    "node_modules/lodash/_stackHas.js"(exports, module) {
      function stackHas(key) {
        return this.__data__.has(key);
      }
      module.exports = stackHas;
    }
  });

  // node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "node_modules/lodash/_freeGlobal.js"(exports, module) {
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      module.exports = freeGlobal;
    }
  });

  // node_modules/lodash/_root.js
  var require_root = __commonJS({
    "node_modules/lodash/_root.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      module.exports = root;
    }
  });

  // node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "node_modules/lodash/_Symbol.js"(exports, module) {
      var root = require_root();
      var Symbol2 = root.Symbol;
      module.exports = Symbol2;
    }
  });

  // node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "node_modules/lodash/_getRawTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module.exports = getRawTag;
    }
  });

  // node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "node_modules/lodash/_objectToString.js"(exports, module) {
      var objectProto = Object.prototype;
      var nativeObjectToString = objectProto.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      module.exports = objectToString;
    }
  });

  // node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "node_modules/lodash/_baseGetTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      module.exports = baseGetTag;
    }
  });

  // node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "node_modules/lodash/isObject.js"(exports, module) {
      function isObject8(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      module.exports = isObject8;
    }
  });

  // node_modules/lodash/isFunction.js
  var require_isFunction = __commonJS({
    "node_modules/lodash/isFunction.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObject8 = require_isObject();
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject8(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      module.exports = isFunction;
    }
  });

  // node_modules/lodash/_coreJsData.js
  var require_coreJsData = __commonJS({
    "node_modules/lodash/_coreJsData.js"(exports, module) {
      var root = require_root();
      var coreJsData = root["__core-js_shared__"];
      module.exports = coreJsData;
    }
  });

  // node_modules/lodash/_isMasked.js
  var require_isMasked = __commonJS({
    "node_modules/lodash/_isMasked.js"(exports, module) {
      var coreJsData = require_coreJsData();
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      module.exports = isMasked;
    }
  });

  // node_modules/lodash/_toSource.js
  var require_toSource = __commonJS({
    "node_modules/lodash/_toSource.js"(exports, module) {
      var funcProto = Function.prototype;
      var funcToString = funcProto.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      module.exports = toSource;
    }
  });

  // node_modules/lodash/_baseIsNative.js
  var require_baseIsNative = __commonJS({
    "node_modules/lodash/_baseIsNative.js"(exports, module) {
      var isFunction = require_isFunction();
      var isMasked = require_isMasked();
      var isObject8 = require_isObject();
      var toSource = require_toSource();
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject8(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      module.exports = baseIsNative;
    }
  });

  // node_modules/lodash/_getValue.js
  var require_getValue = __commonJS({
    "node_modules/lodash/_getValue.js"(exports, module) {
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      module.exports = getValue;
    }
  });

  // node_modules/lodash/_getNative.js
  var require_getNative = __commonJS({
    "node_modules/lodash/_getNative.js"(exports, module) {
      var baseIsNative = require_baseIsNative();
      var getValue = require_getValue();
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      module.exports = getNative;
    }
  });

  // node_modules/lodash/_Map.js
  var require_Map = __commonJS({
    "node_modules/lodash/_Map.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var Map10 = getNative(root, "Map");
      module.exports = Map10;
    }
  });

  // node_modules/lodash/_nativeCreate.js
  var require_nativeCreate = __commonJS({
    "node_modules/lodash/_nativeCreate.js"(exports, module) {
      var getNative = require_getNative();
      var nativeCreate = getNative(Object, "create");
      module.exports = nativeCreate;
    }
  });

  // node_modules/lodash/_hashClear.js
  var require_hashClear = __commonJS({
    "node_modules/lodash/_hashClear.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      module.exports = hashClear;
    }
  });

  // node_modules/lodash/_hashDelete.js
  var require_hashDelete = __commonJS({
    "node_modules/lodash/_hashDelete.js"(exports, module) {
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = hashDelete;
    }
  });

  // node_modules/lodash/_hashGet.js
  var require_hashGet = __commonJS({
    "node_modules/lodash/_hashGet.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }
      module.exports = hashGet;
    }
  });

  // node_modules/lodash/_hashHas.js
  var require_hashHas = __commonJS({
    "node_modules/lodash/_hashHas.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
      }
      module.exports = hashHas;
    }
  });

  // node_modules/lodash/_hashSet.js
  var require_hashSet = __commonJS({
    "node_modules/lodash/_hashSet.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      module.exports = hashSet;
    }
  });

  // node_modules/lodash/_Hash.js
  var require_Hash = __commonJS({
    "node_modules/lodash/_Hash.js"(exports, module) {
      var hashClear = require_hashClear();
      var hashDelete = require_hashDelete();
      var hashGet = require_hashGet();
      var hashHas = require_hashHas();
      var hashSet = require_hashSet();
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      module.exports = Hash;
    }
  });

  // node_modules/lodash/_mapCacheClear.js
  var require_mapCacheClear = __commonJS({
    "node_modules/lodash/_mapCacheClear.js"(exports, module) {
      var Hash = require_Hash();
      var ListCache = require_ListCache();
      var Map10 = require_Map();
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map10 || ListCache)(),
          "string": new Hash()
        };
      }
      module.exports = mapCacheClear;
    }
  });

  // node_modules/lodash/_isKeyable.js
  var require_isKeyable = __commonJS({
    "node_modules/lodash/_isKeyable.js"(exports, module) {
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      module.exports = isKeyable;
    }
  });

  // node_modules/lodash/_getMapData.js
  var require_getMapData = __commonJS({
    "node_modules/lodash/_getMapData.js"(exports, module) {
      var isKeyable = require_isKeyable();
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      module.exports = getMapData;
    }
  });

  // node_modules/lodash/_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS({
    "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = mapCacheDelete;
    }
  });

  // node_modules/lodash/_mapCacheGet.js
  var require_mapCacheGet = __commonJS({
    "node_modules/lodash/_mapCacheGet.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      module.exports = mapCacheGet;
    }
  });

  // node_modules/lodash/_mapCacheHas.js
  var require_mapCacheHas = __commonJS({
    "node_modules/lodash/_mapCacheHas.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      module.exports = mapCacheHas;
    }
  });

  // node_modules/lodash/_mapCacheSet.js
  var require_mapCacheSet = __commonJS({
    "node_modules/lodash/_mapCacheSet.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      module.exports = mapCacheSet;
    }
  });

  // node_modules/lodash/_MapCache.js
  var require_MapCache = __commonJS({
    "node_modules/lodash/_MapCache.js"(exports, module) {
      var mapCacheClear = require_mapCacheClear();
      var mapCacheDelete = require_mapCacheDelete();
      var mapCacheGet = require_mapCacheGet();
      var mapCacheHas = require_mapCacheHas();
      var mapCacheSet = require_mapCacheSet();
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      module.exports = MapCache;
    }
  });

  // node_modules/lodash/_stackSet.js
  var require_stackSet = __commonJS({
    "node_modules/lodash/_stackSet.js"(exports, module) {
      var ListCache = require_ListCache();
      var Map10 = require_Map();
      var MapCache = require_MapCache();
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map10 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      module.exports = stackSet;
    }
  });

  // node_modules/lodash/_Stack.js
  var require_Stack = __commonJS({
    "node_modules/lodash/_Stack.js"(exports, module) {
      var ListCache = require_ListCache();
      var stackClear = require_stackClear();
      var stackDelete = require_stackDelete();
      var stackGet = require_stackGet();
      var stackHas = require_stackHas();
      var stackSet = require_stackSet();
      function Stack2(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack2.prototype.clear = stackClear;
      Stack2.prototype["delete"] = stackDelete;
      Stack2.prototype.get = stackGet;
      Stack2.prototype.has = stackHas;
      Stack2.prototype.set = stackSet;
      module.exports = Stack2;
    }
  });

  // node_modules/lodash/_defineProperty.js
  var require_defineProperty = __commonJS({
    "node_modules/lodash/_defineProperty.js"(exports, module) {
      var getNative = require_getNative();
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      module.exports = defineProperty;
    }
  });

  // node_modules/lodash/_baseAssignValue.js
  var require_baseAssignValue = __commonJS({
    "node_modules/lodash/_baseAssignValue.js"(exports, module) {
      var defineProperty = require_defineProperty();
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      module.exports = baseAssignValue;
    }
  });

  // node_modules/lodash/_assignMergeValue.js
  var require_assignMergeValue = __commonJS({
    "node_modules/lodash/_assignMergeValue.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var eq = require_eq();
      function assignMergeValue(object, key, value) {
        if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      module.exports = assignMergeValue;
    }
  });

  // node_modules/lodash/_createBaseFor.js
  var require_createBaseFor = __commonJS({
    "node_modules/lodash/_createBaseFor.js"(exports, module) {
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      module.exports = createBaseFor;
    }
  });

  // node_modules/lodash/_baseFor.js
  var require_baseFor = __commonJS({
    "node_modules/lodash/_baseFor.js"(exports, module) {
      var createBaseFor = require_createBaseFor();
      var baseFor = createBaseFor();
      module.exports = baseFor;
    }
  });

  // node_modules/lodash/_cloneBuffer.js
  var require_cloneBuffer = __commonJS({
    "node_modules/lodash/_cloneBuffer.js"(exports, module) {
      var root = require_root();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      module.exports = cloneBuffer;
    }
  });

  // node_modules/lodash/_Uint8Array.js
  var require_Uint8Array = __commonJS({
    "node_modules/lodash/_Uint8Array.js"(exports, module) {
      var root = require_root();
      var Uint8Array2 = root.Uint8Array;
      module.exports = Uint8Array2;
    }
  });

  // node_modules/lodash/_cloneArrayBuffer.js
  var require_cloneArrayBuffer = __commonJS({
    "node_modules/lodash/_cloneArrayBuffer.js"(exports, module) {
      var Uint8Array2 = require_Uint8Array();
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
        return result;
      }
      module.exports = cloneArrayBuffer;
    }
  });

  // node_modules/lodash/_cloneTypedArray.js
  var require_cloneTypedArray = __commonJS({
    "node_modules/lodash/_cloneTypedArray.js"(exports, module) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      module.exports = cloneTypedArray;
    }
  });

  // node_modules/lodash/_copyArray.js
  var require_copyArray = __commonJS({
    "node_modules/lodash/_copyArray.js"(exports, module) {
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      module.exports = copyArray;
    }
  });

  // node_modules/lodash/_baseCreate.js
  var require_baseCreate = __commonJS({
    "node_modules/lodash/_baseCreate.js"(exports, module) {
      var isObject8 = require_isObject();
      var objectCreate = Object.create;
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject8(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      module.exports = baseCreate;
    }
  });

  // node_modules/lodash/_overArg.js
  var require_overArg = __commonJS({
    "node_modules/lodash/_overArg.js"(exports, module) {
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      module.exports = overArg;
    }
  });

  // node_modules/lodash/_getPrototype.js
  var require_getPrototype = __commonJS({
    "node_modules/lodash/_getPrototype.js"(exports, module) {
      var overArg = require_overArg();
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      module.exports = getPrototype;
    }
  });

  // node_modules/lodash/_isPrototype.js
  var require_isPrototype = __commonJS({
    "node_modules/lodash/_isPrototype.js"(exports, module) {
      var objectProto = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      module.exports = isPrototype;
    }
  });

  // node_modules/lodash/_initCloneObject.js
  var require_initCloneObject = __commonJS({
    "node_modules/lodash/_initCloneObject.js"(exports, module) {
      var baseCreate = require_baseCreate();
      var getPrototype = require_getPrototype();
      var isPrototype = require_isPrototype();
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      module.exports = initCloneObject;
    }
  });

  // node_modules/lodash/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "node_modules/lodash/isObjectLike.js"(exports, module) {
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      module.exports = isObjectLike;
    }
  });

  // node_modules/lodash/_baseIsArguments.js
  var require_baseIsArguments = __commonJS({
    "node_modules/lodash/_baseIsArguments.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      module.exports = baseIsArguments;
    }
  });

  // node_modules/lodash/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/lodash/isArguments.js"(exports, module) {
      var baseIsArguments = require_baseIsArguments();
      var isObjectLike = require_isObjectLike();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      module.exports = isArguments;
    }
  });

  // node_modules/lodash/isArray.js
  var require_isArray = __commonJS({
    "node_modules/lodash/isArray.js"(exports, module) {
      var isArray = Array.isArray;
      module.exports = isArray;
    }
  });

  // node_modules/lodash/isLength.js
  var require_isLength = __commonJS({
    "node_modules/lodash/isLength.js"(exports, module) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      module.exports = isLength;
    }
  });

  // node_modules/lodash/isArrayLike.js
  var require_isArrayLike = __commonJS({
    "node_modules/lodash/isArrayLike.js"(exports, module) {
      var isFunction = require_isFunction();
      var isLength = require_isLength();
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      module.exports = isArrayLike;
    }
  });

  // node_modules/lodash/isArrayLikeObject.js
  var require_isArrayLikeObject = __commonJS({
    "node_modules/lodash/isArrayLikeObject.js"(exports, module) {
      var isArrayLike = require_isArrayLike();
      var isObjectLike = require_isObjectLike();
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      module.exports = isArrayLikeObject;
    }
  });

  // node_modules/lodash/stubFalse.js
  var require_stubFalse = __commonJS({
    "node_modules/lodash/stubFalse.js"(exports, module) {
      function stubFalse() {
        return false;
      }
      module.exports = stubFalse;
    }
  });

  // node_modules/lodash/isBuffer.js
  var require_isBuffer = __commonJS({
    "node_modules/lodash/isBuffer.js"(exports, module) {
      var root = require_root();
      var stubFalse = require_stubFalse();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      module.exports = isBuffer;
    }
  });

  // node_modules/lodash/isPlainObject.js
  var require_isPlainObject = __commonJS({
    "node_modules/lodash/isPlainObject.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var getPrototype = require_getPrototype();
      var isObjectLike = require_isObjectLike();
      var objectTag = "[object Object]";
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      function isPlainObject3(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      module.exports = isPlainObject3;
    }
  });

  // node_modules/lodash/_baseIsTypedArray.js
  var require_baseIsTypedArray = __commonJS({
    "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isLength = require_isLength();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      module.exports = baseIsTypedArray;
    }
  });

  // node_modules/lodash/_baseUnary.js
  var require_baseUnary = __commonJS({
    "node_modules/lodash/_baseUnary.js"(exports, module) {
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      module.exports = baseUnary;
    }
  });

  // node_modules/lodash/_nodeUtil.js
  var require_nodeUtil = __commonJS({
    "node_modules/lodash/_nodeUtil.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types4 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types4) {
            return types4;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      module.exports = nodeUtil;
    }
  });

  // node_modules/lodash/isTypedArray.js
  var require_isTypedArray = __commonJS({
    "node_modules/lodash/isTypedArray.js"(exports, module) {
      var baseIsTypedArray = require_baseIsTypedArray();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      module.exports = isTypedArray;
    }
  });

  // node_modules/lodash/_safeGet.js
  var require_safeGet = __commonJS({
    "node_modules/lodash/_safeGet.js"(exports, module) {
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      module.exports = safeGet;
    }
  });

  // node_modules/lodash/_assignValue.js
  var require_assignValue = __commonJS({
    "node_modules/lodash/_assignValue.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var eq = require_eq();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      module.exports = assignValue;
    }
  });

  // node_modules/lodash/_copyObject.js
  var require_copyObject = __commonJS({
    "node_modules/lodash/_copyObject.js"(exports, module) {
      var assignValue = require_assignValue();
      var baseAssignValue = require_baseAssignValue();
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      module.exports = copyObject;
    }
  });

  // node_modules/lodash/_baseTimes.js
  var require_baseTimes = __commonJS({
    "node_modules/lodash/_baseTimes.js"(exports, module) {
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      module.exports = baseTimes;
    }
  });

  // node_modules/lodash/_isIndex.js
  var require_isIndex = __commonJS({
    "node_modules/lodash/_isIndex.js"(exports, module) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      module.exports = isIndex;
    }
  });

  // node_modules/lodash/_arrayLikeKeys.js
  var require_arrayLikeKeys = __commonJS({
    "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
      var baseTimes = require_baseTimes();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isIndex = require_isIndex();
      var isTypedArray = require_isTypedArray();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = arrayLikeKeys;
    }
  });

  // node_modules/lodash/_nativeKeysIn.js
  var require_nativeKeysIn = __commonJS({
    "node_modules/lodash/_nativeKeysIn.js"(exports, module) {
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = nativeKeysIn;
    }
  });

  // node_modules/lodash/_baseKeysIn.js
  var require_baseKeysIn = __commonJS({
    "node_modules/lodash/_baseKeysIn.js"(exports, module) {
      var isObject8 = require_isObject();
      var isPrototype = require_isPrototype();
      var nativeKeysIn = require_nativeKeysIn();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseKeysIn(object) {
        if (!isObject8(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = baseKeysIn;
    }
  });

  // node_modules/lodash/keysIn.js
  var require_keysIn = __commonJS({
    "node_modules/lodash/keysIn.js"(exports, module) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeysIn = require_baseKeysIn();
      var isArrayLike = require_isArrayLike();
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      module.exports = keysIn;
    }
  });

  // node_modules/lodash/toPlainObject.js
  var require_toPlainObject = __commonJS({
    "node_modules/lodash/toPlainObject.js"(exports, module) {
      var copyObject = require_copyObject();
      var keysIn = require_keysIn();
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      module.exports = toPlainObject;
    }
  });

  // node_modules/lodash/_baseMergeDeep.js
  var require_baseMergeDeep = __commonJS({
    "node_modules/lodash/_baseMergeDeep.js"(exports, module) {
      var assignMergeValue = require_assignMergeValue();
      var cloneBuffer = require_cloneBuffer();
      var cloneTypedArray = require_cloneTypedArray();
      var copyArray = require_copyArray();
      var initCloneObject = require_initCloneObject();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isArrayLikeObject = require_isArrayLikeObject();
      var isBuffer = require_isBuffer();
      var isFunction = require_isFunction();
      var isObject8 = require_isObject();
      var isPlainObject3 = require_isPlainObject();
      var isTypedArray = require_isTypedArray();
      var safeGet = require_safeGet();
      var toPlainObject = require_toPlainObject();
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject3(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject8(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      module.exports = baseMergeDeep;
    }
  });

  // node_modules/lodash/_baseMerge.js
  var require_baseMerge = __commonJS({
    "node_modules/lodash/_baseMerge.js"(exports, module) {
      var Stack2 = require_Stack();
      var assignMergeValue = require_assignMergeValue();
      var baseFor = require_baseFor();
      var baseMergeDeep = require_baseMergeDeep();
      var isObject8 = require_isObject();
      var keysIn = require_keysIn();
      var safeGet = require_safeGet();
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack2());
          if (isObject8(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      module.exports = baseMerge;
    }
  });

  // node_modules/lodash/identity.js
  var require_identity = __commonJS({
    "node_modules/lodash/identity.js"(exports, module) {
      function identity(value) {
        return value;
      }
      module.exports = identity;
    }
  });

  // node_modules/lodash/_apply.js
  var require_apply = __commonJS({
    "node_modules/lodash/_apply.js"(exports, module) {
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      module.exports = apply;
    }
  });

  // node_modules/lodash/_overRest.js
  var require_overRest = __commonJS({
    "node_modules/lodash/_overRest.js"(exports, module) {
      var apply = require_apply();
      var nativeMax = Math.max;
      function overRest(func, start3, transform) {
        start3 = nativeMax(start3 === void 0 ? func.length - 1 : start3, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start3, 0), array = Array(length);
          while (++index < length) {
            array[index] = args[start3 + index];
          }
          index = -1;
          var otherArgs = Array(start3 + 1);
          while (++index < start3) {
            otherArgs[index] = args[index];
          }
          otherArgs[start3] = transform(array);
          return apply(func, this, otherArgs);
        };
      }
      module.exports = overRest;
    }
  });

  // node_modules/lodash/constant.js
  var require_constant = __commonJS({
    "node_modules/lodash/constant.js"(exports, module) {
      function constant(value) {
        return function() {
          return value;
        };
      }
      module.exports = constant;
    }
  });

  // node_modules/lodash/_baseSetToString.js
  var require_baseSetToString = __commonJS({
    "node_modules/lodash/_baseSetToString.js"(exports, module) {
      var constant = require_constant();
      var defineProperty = require_defineProperty();
      var identity = require_identity();
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      module.exports = baseSetToString;
    }
  });

  // node_modules/lodash/_shortOut.js
  var require_shortOut = __commonJS({
    "node_modules/lodash/_shortOut.js"(exports, module) {
      var HOT_COUNT = 800;
      var HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      module.exports = shortOut;
    }
  });

  // node_modules/lodash/_setToString.js
  var require_setToString = __commonJS({
    "node_modules/lodash/_setToString.js"(exports, module) {
      var baseSetToString = require_baseSetToString();
      var shortOut = require_shortOut();
      var setToString = shortOut(baseSetToString);
      module.exports = setToString;
    }
  });

  // node_modules/lodash/_baseRest.js
  var require_baseRest = __commonJS({
    "node_modules/lodash/_baseRest.js"(exports, module) {
      var identity = require_identity();
      var overRest = require_overRest();
      var setToString = require_setToString();
      function baseRest(func, start3) {
        return setToString(overRest(func, start3, identity), func + "");
      }
      module.exports = baseRest;
    }
  });

  // node_modules/lodash/_isIterateeCall.js
  var require_isIterateeCall = __commonJS({
    "node_modules/lodash/_isIterateeCall.js"(exports, module) {
      var eq = require_eq();
      var isArrayLike = require_isArrayLike();
      var isIndex = require_isIndex();
      var isObject8 = require_isObject();
      function isIterateeCall(value, index, object) {
        if (!isObject8(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      module.exports = isIterateeCall;
    }
  });

  // node_modules/lodash/_createAssigner.js
  var require_createAssigner = __commonJS({
    "node_modules/lodash/_createAssigner.js"(exports, module) {
      var baseRest = require_baseRest();
      var isIterateeCall = require_isIterateeCall();
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      module.exports = createAssigner;
    }
  });

  // node_modules/lodash/merge.js
  var require_merge = __commonJS({
    "node_modules/lodash/merge.js"(exports, module) {
      var baseMerge = require_baseMerge();
      var createAssigner = require_createAssigner();
      var merge2 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      module.exports = merge2;
    }
  });

  // node_modules/lodash/mergeWith.js
  var require_mergeWith = __commonJS({
    "node_modules/lodash/mergeWith.js"(exports, module) {
      var baseMerge = require_baseMerge();
      var createAssigner = require_createAssigner();
      var mergeWith2 = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      module.exports = mergeWith2;
    }
  });

  // node_modules/moment/moment.js
  var require_moment = __commonJS({
    "node_modules/moment/moment.js"(exports, module) {
      (function(global2, factory15) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory15() : typeof define === "function" && define.amd ? define(factory15) : global2.moment = factory15();
      })(exports, function() {
        "use strict";
        var hookCallback;
        function hooks() {
          return hookCallback.apply(null, arguments);
        }
        function setHookCallback(callback) {
          hookCallback = callback;
        }
        function isArray(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
        }
        function isObject8(input) {
          return input != null && Object.prototype.toString.call(input) === "[object Object]";
        }
        function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
        }
        function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
          } else {
            var k;
            for (k in obj) {
              if (hasOwnProp(obj, k)) {
                return false;
              }
            }
            return true;
          }
        }
        function isUndefined(input) {
          return input === void 0;
        }
        function isNumber(input) {
          return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
        }
        function isDate2(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
        }
        function map(arr, fn2) {
          var res = [], i, arrLen = arr.length;
          for (i = 0; i < arrLen; ++i) {
            res.push(fn2(arr[i], i));
          }
          return res;
        }
        function extend23(a, b) {
          for (var i in b) {
            if (hasOwnProp(b, i)) {
              a[i] = b[i];
            }
          }
          if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
          }
          if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
          }
          return a;
        }
        function createUTC(input, format5, locale2, strict) {
          return createLocalOrUTC(input, format5, locale2, strict, true).utc();
        }
        function defaultParsingFlags() {
          return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
          };
        }
        function getParsingFlags(m) {
          if (m._pf == null) {
            m._pf = defaultParsingFlags();
          }
          return m._pf;
        }
        var some;
        if (Array.prototype.some) {
          some = Array.prototype.some;
        } else {
          some = function(fun) {
            var t = Object(this), len = t.length >>> 0, i;
            for (i = 0; i < len; i++) {
              if (i in t && fun.call(this, t[i], i, t)) {
                return true;
              }
            }
            return false;
          };
        }
        function isValid(m) {
          if (m._isValid == null) {
            var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
              return i != null;
            }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
              isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
              m._isValid = isNowValid;
            } else {
              return isNowValid;
            }
          }
          return m._isValid;
        }
        function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
            extend23(getParsingFlags(m), flags);
          } else {
            getParsingFlags(m).userInvalidated = true;
          }
          return m;
        }
        var momentProperties = hooks.momentProperties = [], updateInProgress = false;
        function copyConfig(to2, from2) {
          var i, prop, val, momentPropertiesLen = momentProperties.length;
          if (!isUndefined(from2._isAMomentObject)) {
            to2._isAMomentObject = from2._isAMomentObject;
          }
          if (!isUndefined(from2._i)) {
            to2._i = from2._i;
          }
          if (!isUndefined(from2._f)) {
            to2._f = from2._f;
          }
          if (!isUndefined(from2._l)) {
            to2._l = from2._l;
          }
          if (!isUndefined(from2._strict)) {
            to2._strict = from2._strict;
          }
          if (!isUndefined(from2._tzm)) {
            to2._tzm = from2._tzm;
          }
          if (!isUndefined(from2._isUTC)) {
            to2._isUTC = from2._isUTC;
          }
          if (!isUndefined(from2._offset)) {
            to2._offset = from2._offset;
          }
          if (!isUndefined(from2._pf)) {
            to2._pf = getParsingFlags(from2);
          }
          if (!isUndefined(from2._locale)) {
            to2._locale = from2._locale;
          }
          if (momentPropertiesLen > 0) {
            for (i = 0; i < momentPropertiesLen; i++) {
              prop = momentProperties[i];
              val = from2[prop];
              if (!isUndefined(val)) {
                to2[prop] = val;
              }
            }
          }
          return to2;
        }
        function Moment(config2) {
          copyConfig(this, config2);
          this._d = new Date(config2._d != null ? config2._d.getTime() : NaN);
          if (!this.isValid()) {
            this._d = /* @__PURE__ */ new Date(NaN);
          }
          if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
          }
        }
        function isMoment(obj) {
          return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
        }
        function warn(msg) {
          if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
          }
        }
        function deprecate(msg, fn2) {
          var firstTime = true;
          return extend23(function() {
            if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
              var args = [], arg, i, key, argLen = arguments.length;
              for (i = 0; i < argLen; i++) {
                arg = "";
                if (typeof arguments[i] === "object") {
                  arg += "\n[" + i + "] ";
                  for (key in arguments[0]) {
                    if (hasOwnProp(arguments[0], key)) {
                      arg += key + ": " + arguments[0][key] + ", ";
                    }
                  }
                  arg = arg.slice(0, -2);
                } else {
                  arg = arguments[i];
                }
                args.push(arg);
              }
              warn(
                msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
              );
              firstTime = false;
            }
            return fn2.apply(this, arguments);
          }, fn2);
        }
        var deprecations = {};
        function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
          }
        }
        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;
        function isFunction(input) {
          return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
        }
        function set3(config2) {
          var prop, i;
          for (i in config2) {
            if (hasOwnProp(config2, i)) {
              prop = config2[i];
              if (isFunction(prop)) {
                this[i] = prop;
              } else {
                this["_" + i] = prop;
              }
            }
          }
          this._config = config2;
          this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
          );
        }
        function mergeConfigs(parentConfig, childConfig) {
          var res = extend23({}, parentConfig), prop;
          for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
              if (isObject8(parentConfig[prop]) && isObject8(childConfig[prop])) {
                res[prop] = {};
                extend23(res[prop], parentConfig[prop]);
                extend23(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
              } else {
                delete res[prop];
              }
            }
          }
          for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject8(parentConfig[prop])) {
              res[prop] = extend23({}, res[prop]);
            }
          }
          return res;
        }
        function Locale(config2) {
          if (config2 != null) {
            this.set(config2);
          }
        }
        var keys5;
        if (Object.keys) {
          keys5 = Object.keys;
        } else {
          keys5 = function(obj) {
            var i, res = [];
            for (i in obj) {
              if (hasOwnProp(obj, i)) {
                res.push(i);
              }
            }
            return res;
          };
        }
        var defaultCalendar = {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        };
        function calendar(key, mom, now3) {
          var output = this._calendar[key] || this._calendar["sameElse"];
          return isFunction(output) ? output.call(mom, now3) : output;
        }
        function zeroFill(number, targetLength, forceSign) {
          var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
          return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
        }
        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
        function addFormatToken(token2, padded, ordinal2, callback) {
          var func = callback;
          if (typeof callback === "string") {
            func = function() {
              return this[callback]();
            };
          }
          if (token2) {
            formatTokenFunctions[token2] = func;
          }
          if (padded) {
            formatTokenFunctions[padded[0]] = function() {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
          }
          if (ordinal2) {
            formatTokenFunctions[ordinal2] = function() {
              return this.localeData().ordinal(
                func.apply(this, arguments),
                token2
              );
            };
          }
        }
        function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
          }
          return input.replace(/\\/g, "");
        }
        function makeFormatFunction(format5) {
          var array = format5.match(formattingTokens), i, length;
          for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
              array[i] = formatTokenFunctions[array[i]];
            } else {
              array[i] = removeFormattingTokens(array[i]);
            }
          }
          return function(mom) {
            var output = "", i2;
            for (i2 = 0; i2 < length; i2++) {
              output += isFunction(array[i2]) ? array[i2].call(mom, format5) : array[i2];
            }
            return output;
          };
        }
        function formatMoment(m, format5) {
          if (!m.isValid()) {
            return m.localeData().invalidDate();
          }
          format5 = expandFormat(format5, m.localeData());
          formatFunctions[format5] = formatFunctions[format5] || makeFormatFunction(format5);
          return formatFunctions[format5](m);
        }
        function expandFormat(format5, locale2) {
          var i = 5;
          function replaceLongDateFormatTokens(input) {
            return locale2.longDateFormat(input) || input;
          }
          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format5)) {
            format5 = format5.replace(
              localFormattingTokens,
              replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
          }
          return format5;
        }
        var defaultLongDateFormat = {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A"
        };
        function longDateFormat(key) {
          var format5 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
          if (format5 || !formatUpper) {
            return format5;
          }
          this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
            if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
              return tok.slice(1);
            }
            return tok;
          }).join("");
          return this._longDateFormat[key];
        }
        var defaultInvalidDate = "Invalid date";
        function invalidDate() {
          return this._invalidDate;
        }
        var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
        function ordinal(number) {
          return this._ordinal.replace("%d", number);
        }
        var defaultRelativeTime = {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          w: "a week",
          ww: "%d weeks",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        };
        function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        }
        function pastFuture(diff2, output) {
          var format5 = this._relativeTime[diff2 > 0 ? "future" : "past"];
          return isFunction(format5) ? format5(output) : format5.replace(/%s/i, output);
        }
        var aliases = {};
        function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
        }
        function normalizeUnits(units) {
          return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
        }
        function normalizeObjectUnits(inputObject) {
          var normalizedInput = {}, normalizedProp, prop;
          for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
              }
            }
          }
          return normalizedInput;
        }
        var priorities = {};
        function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
        }
        function getPrioritizedUnits(unitsObj) {
          var units = [], u;
          for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
              units.push({ unit: u, priority: priorities[u] });
            }
          }
          units.sort(function(a, b) {
            return a.priority - b.priority;
          });
          return units;
        }
        function isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
        function absFloor(number) {
          if (number < 0) {
            return Math.ceil(number) || 0;
          } else {
            return Math.floor(number);
          }
        }
        function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion, value = 0;
          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
          }
          return value;
        }
        function makeGetSet(unit, keepTime) {
          return function(value) {
            if (value != null) {
              set$1(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
            } else {
              return get2(this, unit);
            }
          };
        }
        function get2(mom, unit) {
          return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
        }
        function set$1(mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
            if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
              value = toInt(value);
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
                value,
                mom.month(),
                daysInMonth(value, mom.month())
              );
            } else {
              mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
            }
          }
        }
        function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units]();
          }
          return this;
        }
        function stringSet(units, value) {
          if (typeof units === "object") {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
            for (i = 0; i < prioritizedLen; i++) {
              this[prioritized[i].unit](units[prioritized[i].unit]);
            }
          } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
              return this[units](value);
            }
          }
          return this;
        }
        var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
        regexes = {};
        function addRegexToken(token2, regex, strictRegex) {
          regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
            return isStrict && strictRegex ? strictRegex : regex;
          };
        }
        function getParseRegexForToken(token2, config2) {
          if (!hasOwnProp(regexes, token2)) {
            return new RegExp(unescapeFormat(token2));
          }
          return regexes[token2](config2._strict, config2._locale);
        }
        function unescapeFormat(s) {
          return regexEscape(
            s.replace("\\", "").replace(
              /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
              function(matched, p1, p2, p3, p4) {
                return p1 || p2 || p3 || p4;
              }
            )
          );
        }
        function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        var tokens = {};
        function addParseToken(token2, callback) {
          var i, func = callback, tokenLen;
          if (typeof token2 === "string") {
            token2 = [token2];
          }
          if (isNumber(callback)) {
            func = function(input, array) {
              array[callback] = toInt(input);
            };
          }
          tokenLen = token2.length;
          for (i = 0; i < tokenLen; i++) {
            tokens[token2[i]] = func;
          }
        }
        function addWeekParseToken(token2, callback) {
          addParseToken(token2, function(input, array, config2, token3) {
            config2._w = config2._w || {};
            callback(input, config2._w, config2, token3);
          });
        }
        function addTimeToArrayFromToken(token2, input, config2) {
          if (input != null && hasOwnProp(tokens, token2)) {
            tokens[token2](input, config2._a, config2, token2);
          }
        }
        var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
        function mod(n, x) {
          return (n % x + x) % x;
        }
        var indexOf2;
        if (Array.prototype.indexOf) {
          indexOf2 = Array.prototype.indexOf;
        } else {
          indexOf2 = function(o) {
            var i;
            for (i = 0; i < this.length; ++i) {
              if (this[i] === o) {
                return i;
              }
            }
            return -1;
          };
        }
        function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
            return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
        }
        addFormatToken("M", ["MM", 2], "Mo", function() {
          return this.month() + 1;
        });
        addFormatToken("MMM", 0, 0, function(format5) {
          return this.localeData().monthsShort(this, format5);
        });
        addFormatToken("MMMM", 0, 0, function(format5) {
          return this.localeData().months(this, format5);
        });
        addUnitAlias("month", "M");
        addUnitPriority("month", 8);
        addRegexToken("M", match1to2);
        addRegexToken("MM", match1to2, match2);
        addRegexToken("MMM", function(isStrict, locale2) {
          return locale2.monthsShortRegex(isStrict);
        });
        addRegexToken("MMMM", function(isStrict, locale2) {
          return locale2.monthsRegex(isStrict);
        });
        addParseToken(["M", "MM"], function(input, array) {
          array[MONTH] = toInt(input) - 1;
        });
        addParseToken(["MMM", "MMMM"], function(input, array, config2, token2) {
          var month = config2._locale.monthsParse(input, token2, config2._strict);
          if (month != null) {
            array[MONTH] = month;
          } else {
            getParsingFlags(config2).invalidMonth = input;
          }
        });
        var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
          "_"
        ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
        function localeMonths(m, format5) {
          if (!m) {
            return isArray(this._months) ? this._months : this._months["standalone"];
          }
          return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format5) ? "format" : "standalone"][m.month()];
        }
        function localeMonthsShort(m, format5) {
          if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
          }
          return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format5) ? "format" : "standalone"][m.month()];
        }
        function handleStrictParse(monthName, format5, strict) {
          var i, ii, mom, llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
              mom = createUTC([2e3, i]);
              this._shortMonthsParse[i] = this.monthsShort(
                mom,
                ""
              ).toLocaleLowerCase();
              this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format5 === "MMM") {
              ii = indexOf2.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf2.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format5 === "MMM") {
              ii = indexOf2.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf2.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeMonthsParse(monthName, format5, strict) {
          var i, mom, regex;
          if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format5, strict);
          }
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          }
          for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp(
                "^" + this.months(mom, "").replace(".", "") + "$",
                "i"
              );
              this._shortMonthsParse[i] = new RegExp(
                "^" + this.monthsShort(mom, "").replace(".", "") + "$",
                "i"
              );
            }
            if (!strict && !this._monthsParse[i]) {
              regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
              this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format5 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
              return i;
            } else if (strict && format5 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
              return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
            }
          }
        }
        function setMonth(mom, value) {
          var dayOfMonth;
          if (!mom.isValid()) {
            return mom;
          }
          if (typeof value === "string") {
            if (/^\d+$/.test(value)) {
              value = toInt(value);
            } else {
              value = mom.localeData().monthsParse(value);
              if (!isNumber(value)) {
                return mom;
              }
            }
          }
          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
          return mom;
        }
        function getSetMonth(value) {
          if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
          } else {
            return get2(this, "Month");
          }
        }
        function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
        }
        function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsShortStrictRegex;
            } else {
              return this._monthsShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsShortRegex")) {
              this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
          }
        }
        function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
              computeMonthsParse.call(this);
            }
            if (isStrict) {
              return this._monthsStrictRegex;
            } else {
              return this._monthsRegex;
            }
          } else {
            if (!hasOwnProp(this, "_monthsRegex")) {
              this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
          }
        }
        function computeMonthsParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
          for (i = 0; i < 12; i++) {
            mom = createUTC([2e3, i]);
            shortPieces.push(this.monthsShort(mom, ""));
            longPieces.push(this.months(mom, ""));
            mixedPieces.push(this.months(mom, ""));
            mixedPieces.push(this.monthsShort(mom, ""));
          }
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
          }
          this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp(
            "^(" + longPieces.join("|") + ")",
            "i"
          );
          this._monthsShortStrictRegex = new RegExp(
            "^(" + shortPieces.join("|") + ")",
            "i"
          );
        }
        addFormatToken("Y", 0, 0, function() {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : "+" + y;
        });
        addFormatToken(0, ["YY", 2], 0, function() {
          return this.year() % 100;
        });
        addFormatToken(0, ["YYYY", 4], 0, "year");
        addFormatToken(0, ["YYYYY", 5], 0, "year");
        addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
        addUnitAlias("year", "y");
        addUnitPriority("year", 1);
        addRegexToken("Y", matchSigned);
        addRegexToken("YY", match1to2, match2);
        addRegexToken("YYYY", match1to4, match4);
        addRegexToken("YYYYY", match1to6, match6);
        addRegexToken("YYYYYY", match1to6, match6);
        addParseToken(["YYYYY", "YYYYYY"], YEAR);
        addParseToken("YYYY", function(input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken("YY", function(input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken("Y", function(input, array) {
          array[YEAR] = parseInt(input, 10);
        });
        function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
        }
        hooks.parseTwoDigitYear = function(input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
        };
        var getSetYear = makeGetSet("FullYear", true);
        function getIsLeapYear() {
          return isLeapYear(this.year());
        }
        function createDate(y, m, d, h, M, s, ms) {
          var date;
          if (y < 100 && y >= 0) {
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
            }
          } else {
            date = new Date(y, m, d, h, M, s, ms);
          }
          return date;
        }
        function createUTCDate(y) {
          var date, args;
          if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
            }
          } else {
            date = new Date(Date.UTC.apply(null, arguments));
          }
          return date;
        }
        function firstWeekOffset(year, dow, doy) {
          var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        }
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
          if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
          } else {
            resYear = year;
            resDayOfYear = dayOfYear;
          }
          return {
            year: resYear,
            dayOfYear: resDayOfYear
          };
        }
        function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
          if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
          } else {
            resYear = mom.year();
            resWeek = week;
          }
          return {
            week: resWeek,
            year: resYear
          };
        }
        function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }
        addFormatToken("w", ["ww", 2], "wo", "week");
        addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
        addUnitAlias("week", "w");
        addUnitAlias("isoWeek", "W");
        addUnitPriority("week", 5);
        addUnitPriority("isoWeek", 5);
        addRegexToken("w", match1to2);
        addRegexToken("ww", match1to2, match2);
        addRegexToken("W", match1to2);
        addRegexToken("WW", match1to2, match2);
        addWeekParseToken(
          ["w", "ww", "W", "WW"],
          function(input, week, config2, token2) {
            week[token2.substr(0, 1)] = toInt(input);
          }
        );
        function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }
        var defaultLocaleWeek = {
          dow: 0,
          // Sunday is the first day of the week.
          doy: 6
          // The week that contains Jan 6th is the first week of the year.
        };
        function localeFirstDayOfWeek() {
          return this._week.dow;
        }
        function localeFirstDayOfYear() {
          return this._week.doy;
        }
        function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, "d");
        }
        addFormatToken("d", 0, "do", "day");
        addFormatToken("dd", 0, 0, function(format5) {
          return this.localeData().weekdaysMin(this, format5);
        });
        addFormatToken("ddd", 0, 0, function(format5) {
          return this.localeData().weekdaysShort(this, format5);
        });
        addFormatToken("dddd", 0, 0, function(format5) {
          return this.localeData().weekdays(this, format5);
        });
        addFormatToken("e", 0, 0, "weekday");
        addFormatToken("E", 0, 0, "isoWeekday");
        addUnitAlias("day", "d");
        addUnitAlias("weekday", "e");
        addUnitAlias("isoWeekday", "E");
        addUnitPriority("day", 11);
        addUnitPriority("weekday", 11);
        addUnitPriority("isoWeekday", 11);
        addRegexToken("d", match1to2);
        addRegexToken("e", match1to2);
        addRegexToken("E", match1to2);
        addRegexToken("dd", function(isStrict, locale2) {
          return locale2.weekdaysMinRegex(isStrict);
        });
        addRegexToken("ddd", function(isStrict, locale2) {
          return locale2.weekdaysShortRegex(isStrict);
        });
        addRegexToken("dddd", function(isStrict, locale2) {
          return locale2.weekdaysRegex(isStrict);
        });
        addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config2, token2) {
          var weekday = config2._locale.weekdaysParse(input, token2, config2._strict);
          if (weekday != null) {
            week.d = weekday;
          } else {
            getParsingFlags(config2).invalidWeekday = input;
          }
        });
        addWeekParseToken(["d", "e", "E"], function(input, week, config2, token2) {
          week[token2] = toInt(input);
        });
        function parseWeekday(input, locale2) {
          if (typeof input !== "string") {
            return input;
          }
          if (!isNaN(input)) {
            return parseInt(input, 10);
          }
          input = locale2.weekdaysParse(input);
          if (typeof input === "number") {
            return input;
          }
          return null;
        }
        function parseIsoWeekday(input, locale2) {
          if (typeof input === "string") {
            return locale2.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
        }
        function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
        }
        var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
        function localeWeekdays(m, format5) {
          var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format5) ? "format" : "standalone"];
          return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
        }
        function localeWeekdaysShort(m) {
          return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
        }
        function localeWeekdaysMin(m) {
          return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
        }
        function handleStrictParse$1(weekdayName, format5, strict) {
          var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
              mom = createUTC([2e3, 1]).day(i);
              this._minWeekdaysParse[i] = this.weekdaysMin(
                mom,
                ""
              ).toLocaleLowerCase();
              this._shortWeekdaysParse[i] = this.weekdaysShort(
                mom,
                ""
              ).toLocaleLowerCase();
              this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
            }
          }
          if (strict) {
            if (format5 === "dddd") {
              ii = indexOf2.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format5 === "ddd") {
              ii = indexOf2.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf2.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          } else {
            if (format5 === "dddd") {
              ii = indexOf2.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else if (format5 === "ddd") {
              ii = indexOf2.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            } else {
              ii = indexOf2.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                return ii;
              }
              ii = indexOf2.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
            }
          }
        }
        function localeWeekdaysParse(weekdayName, format5, strict) {
          var i, mom, regex;
          if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format5, strict);
          }
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
          }
          for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
              this._fullWeekdaysParse[i] = new RegExp(
                "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
              this._shortWeekdaysParse[i] = new RegExp(
                "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
              this._minWeekdaysParse[i] = new RegExp(
                "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
                "i"
              );
            }
            if (!this._weekdaysParse[i]) {
              regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
              this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format5 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format5 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (strict && format5 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
              return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
              return i;
            }
          }
        }
        function getSetDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
          } else {
            return day;
          }
        }
        function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, "d");
        }
        function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
            return this.day() || 7;
          }
        }
        function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysStrictRegex;
            } else {
              return this._weekdaysRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
          }
        }
        function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysShortStrictRegex;
            } else {
              return this._weekdaysShortRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysShortRegex")) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
        }
        function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
              computeWeekdaysParse.call(this);
            }
            if (isStrict) {
              return this._weekdaysMinStrictRegex;
            } else {
              return this._weekdaysMinRegex;
            }
          } else {
            if (!hasOwnProp(this, "_weekdaysMinRegex")) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
        }
        function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
            return b.length - a.length;
          }
          var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
          for (i = 0; i < 7; i++) {
            mom = createUTC([2e3, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ""));
            shortp = regexEscape(this.weekdaysShort(mom, ""));
            longp = regexEscape(this.weekdays(mom, ""));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
          }
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;
          this._weekdaysStrictRegex = new RegExp(
            "^(" + longPieces.join("|") + ")",
            "i"
          );
          this._weekdaysShortStrictRegex = new RegExp(
            "^(" + shortPieces.join("|") + ")",
            "i"
          );
          this._weekdaysMinStrictRegex = new RegExp(
            "^(" + minPieces.join("|") + ")",
            "i"
          );
        }
        function hFormat() {
          return this.hours() % 12 || 12;
        }
        function kFormat() {
          return this.hours() || 24;
        }
        addFormatToken("H", ["HH", 2], 0, "hour");
        addFormatToken("h", ["hh", 2], 0, hFormat);
        addFormatToken("k", ["kk", 2], 0, kFormat);
        addFormatToken("hmm", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });
        addFormatToken("hmmss", 0, 0, function() {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        addFormatToken("Hmm", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2);
        });
        addFormatToken("Hmmss", 0, 0, function() {
          return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
        });
        function meridiem(token2, lowercase) {
          addFormatToken(token2, 0, 0, function() {
            return this.localeData().meridiem(
              this.hours(),
              this.minutes(),
              lowercase
            );
          });
        }
        meridiem("a", true);
        meridiem("A", false);
        addUnitAlias("hour", "h");
        addUnitPriority("hour", 13);
        function matchMeridiem(isStrict, locale2) {
          return locale2._meridiemParse;
        }
        addRegexToken("a", matchMeridiem);
        addRegexToken("A", matchMeridiem);
        addRegexToken("H", match1to2);
        addRegexToken("h", match1to2);
        addRegexToken("k", match1to2);
        addRegexToken("HH", match1to2, match2);
        addRegexToken("hh", match1to2, match2);
        addRegexToken("kk", match1to2, match2);
        addRegexToken("hmm", match3to4);
        addRegexToken("hmmss", match5to6);
        addRegexToken("Hmm", match3to4);
        addRegexToken("Hmmss", match5to6);
        addParseToken(["H", "HH"], HOUR);
        addParseToken(["k", "kk"], function(input, array, config2) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(["a", "A"], function(input, array, config2) {
          config2._isPm = config2._locale.isPM(input);
          config2._meridiem = input;
        });
        addParseToken(["h", "hh"], function(input, array, config2) {
          array[HOUR] = toInt(input);
          getParsingFlags(config2).bigHour = true;
        });
        addParseToken("hmm", function(input, array, config2) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config2).bigHour = true;
        });
        addParseToken("hmmss", function(input, array, config2) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config2).bigHour = true;
        });
        addParseToken("Hmm", function(input, array, config2) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken("Hmmss", function(input, array, config2) {
          var pos1 = input.length - 4, pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
        });
        function localeIsPM(input) {
          return (input + "").toLowerCase().charAt(0) === "p";
        }
        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
        function localeMeridiem(hours2, minutes2, isLower) {
          if (hours2 > 11) {
            return isLower ? "pm" : "PM";
          } else {
            return isLower ? "am" : "AM";
          }
        }
        var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,
          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,
          week: defaultLocaleWeek,
          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,
          meridiemParse: defaultLocaleMeridiemParse
        };
        var locales = {}, localeFamilies = {}, globalLocale;
        function commonPrefix(arr1, arr2) {
          var i, minl = Math.min(arr1.length, arr2.length);
          for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
              return i;
            }
          }
          return minl;
        }
        function normalizeLocale(key) {
          return key ? key.toLowerCase().replace("_", "-") : key;
        }
        function chooseLocale(names) {
          var i = 0, j, next, locale2, split;
          while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
              locale2 = loadLocale(split.slice(0, j).join("-"));
              if (locale2) {
                return locale2;
              }
              if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                break;
              }
              j--;
            }
            i++;
          }
          return globalLocale;
        }
        function isLocaleNameSane(name) {
          return name.match("^[^/\\\\]*$") != null;
        }
        function loadLocale(name) {
          var oldLocale = null, aliasedRequire;
          if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
            try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = __require;
              aliasedRequire("./locale/" + name);
              getSetGlobalLocale(oldLocale);
            } catch (e) {
              locales[name] = null;
            }
          }
          return locales[name];
        }
        function getSetGlobalLocale(key, values) {
          var data;
          if (key) {
            if (isUndefined(values)) {
              data = getLocale(key);
            } else {
              data = defineLocale(key, values);
            }
            if (data) {
              globalLocale = data;
            } else {
              if (typeof console !== "undefined" && console.warn) {
                console.warn(
                  "Locale " + key + " not found. Did you forget to load it?"
                );
              }
            }
          }
          return globalLocale._abbr;
        }
        function defineLocale(name, config2) {
          if (config2 !== null) {
            var locale2, parentConfig = baseConfig;
            config2.abbr = name;
            if (locales[name] != null) {
              deprecateSimple(
                "defineLocaleOverride",
                "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
              );
              parentConfig = locales[name]._config;
            } else if (config2.parentLocale != null) {
              if (locales[config2.parentLocale] != null) {
                parentConfig = locales[config2.parentLocale]._config;
              } else {
                locale2 = loadLocale(config2.parentLocale);
                if (locale2 != null) {
                  parentConfig = locale2._config;
                } else {
                  if (!localeFamilies[config2.parentLocale]) {
                    localeFamilies[config2.parentLocale] = [];
                  }
                  localeFamilies[config2.parentLocale].push({
                    name,
                    config: config2
                  });
                  return null;
                }
              }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config2));
            if (localeFamilies[name]) {
              localeFamilies[name].forEach(function(x) {
                defineLocale(x.name, x.config);
              });
            }
            getSetGlobalLocale(name);
            return locales[name];
          } else {
            delete locales[name];
            return null;
          }
        }
        function updateLocale(name, config2) {
          if (config2 != null) {
            var locale2, tmpLocale, parentConfig = baseConfig;
            if (locales[name] != null && locales[name].parentLocale != null) {
              locales[name].set(mergeConfigs(locales[name]._config, config2));
            } else {
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
              }
              config2 = mergeConfigs(parentConfig, config2);
              if (tmpLocale == null) {
                config2.abbr = name;
              }
              locale2 = new Locale(config2);
              locale2.parentLocale = locales[name];
              locales[name] = locale2;
            }
            getSetGlobalLocale(name);
          } else {
            if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
                if (name === getSetGlobalLocale()) {
                  getSetGlobalLocale(name);
                }
              } else if (locales[name] != null) {
                delete locales[name];
              }
            }
          }
          return locales[name];
        }
        function getLocale(key) {
          var locale2;
          if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
          }
          if (!key) {
            return globalLocale;
          }
          if (!isArray(key)) {
            locale2 = loadLocale(key);
            if (locale2) {
              return locale2;
            }
            key = [key];
          }
          return chooseLocale(key);
        }
        function listLocales() {
          return keys5(locales);
        }
        function checkOverflow(m) {
          var overflow, a = m._a;
          if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
          }
          return m;
        }
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
          ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
          ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
          ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
          ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
          ["YYYY-DDD", /\d{4}-\d{3}/],
          ["YYYY-MM", /\d{4}-\d\d/, false],
          ["YYYYYYMMDD", /[+-]\d{10}/],
          ["YYYYMMDD", /\d{8}/],
          ["GGGG[W]WWE", /\d{4}W\d{3}/],
          ["GGGG[W]WW", /\d{4}W\d{2}/, false],
          ["YYYYDDD", /\d{7}/],
          ["YYYYMM", /\d{6}/, false],
          ["YYYY", /\d{4}/, false]
        ], isoTimes = [
          ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
          ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
          ["HH:mm:ss", /\d\d:\d\d:\d\d/],
          ["HH:mm", /\d\d:\d\d/],
          ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
          ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
          ["HHmmss", /\d\d\d\d\d\d/],
          ["HHmm", /\d\d\d\d/],
          ["HH", /\d\d/]
        ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
          UT: 0,
          GMT: 0,
          EDT: -4 * 60,
          EST: -5 * 60,
          CDT: -5 * 60,
          CST: -6 * 60,
          MDT: -6 * 60,
          MST: -7 * 60,
          PDT: -7 * 60,
          PST: -8 * 60
        };
        function configFromISO(config2) {
          var i, l, string = config2._i, match5 = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
          if (match5) {
            getParsingFlags(config2).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
              if (isoDates[i][1].exec(match5[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
              }
            }
            if (dateFormat == null) {
              config2._isValid = false;
              return;
            }
            if (match5[3]) {
              for (i = 0, l = isoTimesLen; i < l; i++) {
                if (isoTimes[i][1].exec(match5[3])) {
                  timeFormat = (match5[2] || " ") + isoTimes[i][0];
                  break;
                }
              }
              if (timeFormat == null) {
                config2._isValid = false;
                return;
              }
            }
            if (!allowTime && timeFormat != null) {
              config2._isValid = false;
              return;
            }
            if (match5[4]) {
              if (tzRegex.exec(match5[4])) {
                tzFormat = "Z";
              } else {
                config2._isValid = false;
                return;
              }
            }
            config2._f = dateFormat + (timeFormat || "") + (tzFormat || "");
            configFromStringAndFormat(config2);
          } else {
            config2._isValid = false;
          }
        }
        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
          ];
          if (secondStr) {
            result.push(parseInt(secondStr, 10));
          }
          return result;
        }
        function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
            return 2e3 + year;
          } else if (year <= 999) {
            return 1900 + year;
          }
          return year;
        }
        function preprocessRFC2822(s) {
          return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        }
        function checkWeekday(weekdayStr, parsedInput, config2) {
          if (weekdayStr) {
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
              parsedInput[0],
              parsedInput[1],
              parsedInput[2]
            ).getDay();
            if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config2).weekdayMismatch = true;
              config2._isValid = false;
              return false;
            }
          }
          return true;
        }
        function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
            return obsOffsets[obsOffset];
          } else if (militaryOffset) {
            return 0;
          } else {
            var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
          }
        }
        function configFromRFC2822(config2) {
          var match5 = rfc2822.exec(preprocessRFC2822(config2._i)), parsedArray;
          if (match5) {
            parsedArray = extractFromRFC2822Strings(
              match5[4],
              match5[3],
              match5[2],
              match5[5],
              match5[6],
              match5[7]
            );
            if (!checkWeekday(match5[1], parsedArray, config2)) {
              return;
            }
            config2._a = parsedArray;
            config2._tzm = calculateOffset(match5[8], match5[9], match5[10]);
            config2._d = createUTCDate.apply(null, config2._a);
            config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
            getParsingFlags(config2).rfc2822 = true;
          } else {
            config2._isValid = false;
          }
        }
        function configFromString(config2) {
          var matched = aspNetJsonRegex.exec(config2._i);
          if (matched !== null) {
            config2._d = /* @__PURE__ */ new Date(+matched[1]);
            return;
          }
          configFromISO(config2);
          if (config2._isValid === false) {
            delete config2._isValid;
          } else {
            return;
          }
          configFromRFC2822(config2);
          if (config2._isValid === false) {
            delete config2._isValid;
          } else {
            return;
          }
          if (config2._strict) {
            config2._isValid = false;
          } else {
            hooks.createFromInputFallback(config2);
          }
        }
        hooks.createFromInputFallback = deprecate(
          "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
          function(config2) {
            config2._d = /* @__PURE__ */ new Date(config2._i + (config2._useUTC ? " UTC" : ""));
          }
        );
        function defaults(a, b, c) {
          if (a != null) {
            return a;
          }
          if (b != null) {
            return b;
          }
          return c;
        }
        function currentDateArray(config2) {
          var nowValue = new Date(hooks.now());
          if (config2._useUTC) {
            return [
              nowValue.getUTCFullYear(),
              nowValue.getUTCMonth(),
              nowValue.getUTCDate()
            ];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }
        function configFromArray(config2) {
          var i, date, input = [], currentDate, expectedWeekday, yearToUse;
          if (config2._d) {
            return;
          }
          currentDate = currentDateArray(config2);
          if (config2._w && config2._a[DATE] == null && config2._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config2);
          }
          if (config2._dayOfYear != null) {
            yearToUse = defaults(config2._a[YEAR], currentDate[YEAR]);
            if (config2._dayOfYear > daysInYear(yearToUse) || config2._dayOfYear === 0) {
              getParsingFlags(config2)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config2._dayOfYear);
            config2._a[MONTH] = date.getUTCMonth();
            config2._a[DATE] = date.getUTCDate();
          }
          for (i = 0; i < 3 && config2._a[i] == null; ++i) {
            config2._a[i] = input[i] = currentDate[i];
          }
          for (; i < 7; i++) {
            config2._a[i] = input[i] = config2._a[i] == null ? i === 2 ? 1 : 0 : config2._a[i];
          }
          if (config2._a[HOUR] === 24 && config2._a[MINUTE] === 0 && config2._a[SECOND] === 0 && config2._a[MILLISECOND] === 0) {
            config2._nextDay = true;
            config2._a[HOUR] = 0;
          }
          config2._d = (config2._useUTC ? createUTCDate : createDate).apply(
            null,
            input
          );
          expectedWeekday = config2._useUTC ? config2._d.getUTCDay() : config2._d.getDay();
          if (config2._tzm != null) {
            config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
          }
          if (config2._nextDay) {
            config2._a[HOUR] = 24;
          }
          if (config2._w && typeof config2._w.d !== "undefined" && config2._w.d !== expectedWeekday) {
            getParsingFlags(config2).weekdayMismatch = true;
          }
        }
        function dayOfYearFromWeekInfo(config2) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
          w = config2._w;
          if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(
              w.GG,
              config2._a[YEAR],
              weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
            }
          } else {
            dow = config2._locale._week.dow;
            doy = config2._locale._week.doy;
            curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config2._a[YEAR], curWeek.year);
            week = defaults(w.w, curWeek.week);
            if (w.d != null) {
              weekday = w.d;
              if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
              }
            } else if (w.e != null) {
              weekday = w.e + dow;
              if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
              }
            } else {
              weekday = dow;
            }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config2)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
            getParsingFlags(config2)._overflowWeekday = true;
          } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config2._a[YEAR] = temp.year;
            config2._dayOfYear = temp.dayOfYear;
          }
        }
        hooks.ISO_8601 = function() {
        };
        hooks.RFC_2822 = function() {
        };
        function configFromStringAndFormat(config2) {
          if (config2._f === hooks.ISO_8601) {
            configFromISO(config2);
            return;
          }
          if (config2._f === hooks.RFC_2822) {
            configFromRFC2822(config2);
            return;
          }
          config2._a = [];
          getParsingFlags(config2).empty = true;
          var string = "" + config2._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
          tokens2 = expandFormat(config2._f, config2._locale).match(formattingTokens) || [];
          tokenLen = tokens2.length;
          for (i = 0; i < tokenLen; i++) {
            token2 = tokens2[i];
            parsedInput = (string.match(getParseRegexForToken(token2, config2)) || [])[0];
            if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));
              if (skipped.length > 0) {
                getParsingFlags(config2).unusedInput.push(skipped);
              }
              string = string.slice(
                string.indexOf(parsedInput) + parsedInput.length
              );
              totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token2]) {
              if (parsedInput) {
                getParsingFlags(config2).empty = false;
              } else {
                getParsingFlags(config2).unusedTokens.push(token2);
              }
              addTimeToArrayFromToken(token2, parsedInput, config2);
            } else if (config2._strict && !parsedInput) {
              getParsingFlags(config2).unusedTokens.push(token2);
            }
          }
          getParsingFlags(config2).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
            getParsingFlags(config2).unusedInput.push(string);
          }
          if (config2._a[HOUR] <= 12 && getParsingFlags(config2).bigHour === true && config2._a[HOUR] > 0) {
            getParsingFlags(config2).bigHour = void 0;
          }
          getParsingFlags(config2).parsedDateParts = config2._a.slice(0);
          getParsingFlags(config2).meridiem = config2._meridiem;
          config2._a[HOUR] = meridiemFixWrap(
            config2._locale,
            config2._a[HOUR],
            config2._meridiem
          );
          era = getParsingFlags(config2).era;
          if (era !== null) {
            config2._a[YEAR] = config2._locale.erasConvertYear(era, config2._a[YEAR]);
          }
          configFromArray(config2);
          checkOverflow(config2);
        }
        function meridiemFixWrap(locale2, hour, meridiem2) {
          var isPm;
          if (meridiem2 == null) {
            return hour;
          }
          if (locale2.meridiemHour != null) {
            return locale2.meridiemHour(hour, meridiem2);
          } else if (locale2.isPM != null) {
            isPm = locale2.isPM(meridiem2);
            if (isPm && hour < 12) {
              hour += 12;
            }
            if (!isPm && hour === 12) {
              hour = 0;
            }
            return hour;
          } else {
            return hour;
          }
        }
        function configFromStringAndArray(config2) {
          var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config2._f.length;
          if (configfLen === 0) {
            getParsingFlags(config2).invalidFormat = true;
            config2._d = /* @__PURE__ */ new Date(NaN);
            return;
          }
          for (i = 0; i < configfLen; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config2);
            if (config2._useUTC != null) {
              tempConfig._useUTC = config2._useUTC;
            }
            tempConfig._f = config2._f[i];
            configFromStringAndFormat(tempConfig);
            if (isValid(tempConfig)) {
              validFormatFound = true;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (!bestFormatIsValid) {
              if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
                if (validFormatFound) {
                  bestFormatIsValid = true;
                }
              }
            } else {
              if (currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
              }
            }
          }
          extend23(config2, bestMoment || tempConfig);
        }
        function configFromObject(config2) {
          if (config2._d) {
            return;
          }
          var i = normalizeObjectUnits(config2._i), dayOrDate = i.day === void 0 ? i.date : i.day;
          config2._a = map(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function(obj) {
              return obj && parseInt(obj, 10);
            }
          );
          configFromArray(config2);
        }
        function createFromConfig(config2) {
          var res = new Moment(checkOverflow(prepareConfig(config2)));
          if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = void 0;
          }
          return res;
        }
        function prepareConfig(config2) {
          var input = config2._i, format5 = config2._f;
          config2._locale = config2._locale || getLocale(config2._l);
          if (input === null || format5 === void 0 && input === "") {
            return createInvalid({ nullInput: true });
          }
          if (typeof input === "string") {
            config2._i = input = config2._locale.preparse(input);
          }
          if (isMoment(input)) {
            return new Moment(checkOverflow(input));
          } else if (isDate2(input)) {
            config2._d = input;
          } else if (isArray(format5)) {
            configFromStringAndArray(config2);
          } else if (format5) {
            configFromStringAndFormat(config2);
          } else {
            configFromInput(config2);
          }
          if (!isValid(config2)) {
            config2._d = null;
          }
          return config2;
        }
        function configFromInput(config2) {
          var input = config2._i;
          if (isUndefined(input)) {
            config2._d = new Date(hooks.now());
          } else if (isDate2(input)) {
            config2._d = new Date(input.valueOf());
          } else if (typeof input === "string") {
            configFromString(config2);
          } else if (isArray(input)) {
            config2._a = map(input.slice(0), function(obj) {
              return parseInt(obj, 10);
            });
            configFromArray(config2);
          } else if (isObject8(input)) {
            configFromObject(config2);
          } else if (isNumber(input)) {
            config2._d = new Date(input);
          } else {
            hooks.createFromInputFallback(config2);
          }
        }
        function createLocalOrUTC(input, format5, locale2, strict, isUTC) {
          var c = {};
          if (format5 === true || format5 === false) {
            strict = format5;
            format5 = void 0;
          }
          if (locale2 === true || locale2 === false) {
            strict = locale2;
            locale2 = void 0;
          }
          if (isObject8(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
            input = void 0;
          }
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale2;
          c._i = input;
          c._f = format5;
          c._strict = strict;
          return createFromConfig(c);
        }
        function createLocal(input, format5, locale2, strict) {
          return createLocalOrUTC(input, format5, locale2, strict, false);
        }
        var prototypeMin = deprecate(
          "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
          function() {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other < this ? this : other;
            } else {
              return createInvalid();
            }
          }
        ), prototypeMax = deprecate(
          "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
          function() {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
              return other > this ? this : other;
            } else {
              return createInvalid();
            }
          }
        );
        function pickBy2(fn2, moments) {
          var res, i;
          if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
          }
          if (!moments.length) {
            return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn2](res)) {
              res = moments[i];
            }
          }
          return res;
        }
        function min2() {
          var args = [].slice.call(arguments, 0);
          return pickBy2("isBefore", args);
        }
        function max2() {
          var args = [].slice.call(arguments, 0);
          return pickBy2("isAfter", args);
        }
        var now2 = function() {
          return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
        };
        var ordering = [
          "year",
          "quarter",
          "month",
          "week",
          "day",
          "hour",
          "minute",
          "second",
          "millisecond"
        ];
        function isDurationValid(m) {
          var key, unitHasDecimal = false, i, orderLen = ordering.length;
          for (key in m) {
            if (hasOwnProp(m, key) && !(indexOf2.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
            }
          }
          for (i = 0; i < orderLen; ++i) {
            if (m[ordering[i]]) {
              if (unitHasDecimal) {
                return false;
              }
              if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
              }
            }
          }
          return true;
        }
        function isValid$1() {
          return this._isValid;
        }
        function createInvalid$1() {
          return createDuration(NaN);
        }
        function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
          this._isValid = isDurationValid(normalizedInput);
          this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
          minutes2 * 6e4 + // 1000 * 60
          hours2 * 1e3 * 60 * 60;
          this._days = +days2 + weeks2 * 7;
          this._months = +months2 + quarters * 3 + years2 * 12;
          this._data = {};
          this._locale = getLocale();
          this._bubble();
        }
        function isDuration(obj) {
          return obj instanceof Duration;
        }
        function absRound(number) {
          if (number < 0) {
            return Math.round(-1 * number) * -1;
          } else {
            return Math.round(number);
          }
        }
        function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
          for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
              diffs++;
            }
          }
          return diffs + lengthDiff;
        }
        function offset2(token2, separator) {
          addFormatToken(token2, 0, 0, function() {
            var offset3 = this.utcOffset(), sign2 = "+";
            if (offset3 < 0) {
              offset3 = -offset3;
              sign2 = "-";
            }
            return sign2 + zeroFill(~~(offset3 / 60), 2) + separator + zeroFill(~~offset3 % 60, 2);
          });
        }
        offset2("Z", ":");
        offset2("ZZ", "");
        addRegexToken("Z", matchShortOffset);
        addRegexToken("ZZ", matchShortOffset);
        addParseToken(["Z", "ZZ"], function(input, array, config2) {
          config2._useUTC = true;
          config2._tzm = offsetFromString(matchShortOffset, input);
        });
        var chunkOffset = /([\+\-]|\d\d)/gi;
        function offsetFromString(matcher, string) {
          var matches = (string || "").match(matcher), chunk, parts2, minutes2;
          if (matches === null) {
            return null;
          }
          chunk = matches[matches.length - 1] || [];
          parts2 = (chunk + "").match(chunkOffset) || ["-", 0, 0];
          minutes2 = +(parts2[1] * 60) + toInt(parts2[2]);
          return minutes2 === 0 ? 0 : parts2[0] === "+" ? minutes2 : -minutes2;
        }
        function cloneWithOffset(input, model) {
          var res, diff2;
          if (model._isUTC) {
            res = model.clone();
            diff2 = (isMoment(input) || isDate2(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff2);
            hooks.updateOffset(res, false);
            return res;
          } else {
            return createLocal(input).local();
          }
        }
        function getDateOffset(m) {
          return -Math.round(m._d.getTimezoneOffset());
        }
        hooks.updateOffset = function() {
        };
        function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset3 = this._offset || 0, localAdjust;
          if (!this.isValid()) {
            return input != null ? this : NaN;
          }
          if (input != null) {
            if (typeof input === "string") {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                return this;
              }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
              this.add(localAdjust, "m");
            }
            if (offset3 !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addSubtract(
                  this,
                  createDuration(input - offset3, "m"),
                  1,
                  false
                );
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }
            return this;
          } else {
            return this._isUTC ? offset3 : getDateOffset(this);
          }
        }
        function getSetZone(input, keepLocalTime) {
          if (input != null) {
            if (typeof input !== "string") {
              input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
          } else {
            return -this.utcOffset();
          }
        }
        function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
        }
        function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
              this.subtract(getDateOffset(this), "m");
            }
          }
          return this;
        }
        function setOffsetToParsedOffset() {
          if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === "string") {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
              this.utcOffset(tZone);
            } else {
              this.utcOffset(0, true);
            }
          }
          return this;
        }
        function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
            return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;
          return (this.utcOffset() - input) % 60 === 0;
        }
        function isDaylightSavingTime() {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        }
        function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
          }
          var c = {}, other;
          copyConfig(c, this);
          c = prepareConfig(c);
          if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
            this._isDSTShifted = false;
          }
          return this._isDSTShifted;
        }
        function isLocal() {
          return this.isValid() ? !this._isUTC : false;
        }
        function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
        }
        function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        function createDuration(input, key) {
          var duration = input, match5 = null, sign2, ret, diffRes;
          if (isDuration(input)) {
            duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months
            };
          } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
              duration[key] = +input;
            } else {
              duration.milliseconds = +input;
            }
          } else if (match5 = aspNetRegex.exec(input)) {
            sign2 = match5[1] === "-" ? -1 : 1;
            duration = {
              y: 0,
              d: toInt(match5[DATE]) * sign2,
              h: toInt(match5[HOUR]) * sign2,
              m: toInt(match5[MINUTE]) * sign2,
              s: toInt(match5[SECOND]) * sign2,
              ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign2
              // the millisecond decimal point is included in the match
            };
          } else if (match5 = isoRegex.exec(input)) {
            sign2 = match5[1] === "-" ? -1 : 1;
            duration = {
              y: parseIso(match5[2], sign2),
              M: parseIso(match5[3], sign2),
              w: parseIso(match5[4], sign2),
              d: parseIso(match5[5], sign2),
              h: parseIso(match5[6], sign2),
              m: parseIso(match5[7], sign2),
              s: parseIso(match5[8], sign2)
            };
          } else if (duration == null) {
            duration = {};
          } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(
              createLocal(duration.from),
              createLocal(duration.to)
            );
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
          }
          ret = new Duration(duration);
          if (isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
          }
          if (isDuration(input) && hasOwnProp(input, "_isValid")) {
            ret._isValid = input._isValid;
          }
          return ret;
        }
        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;
        function parseIso(inp, sign2) {
          var res = inp && parseFloat(inp.replace(",", "."));
          return (isNaN(res) ? 0 : res) * sign2;
        }
        function positiveMomentsDifference(base3, other) {
          var res = {};
          res.months = other.month() - base3.month() + (other.year() - base3.year()) * 12;
          if (base3.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
          }
          res.milliseconds = +other - +base3.clone().add(res.months, "M");
          return res;
        }
        function momentsDifference(base3, other) {
          var res;
          if (!(base3.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
          }
          other = cloneWithOffset(other, base3);
          if (base3.isBefore(other)) {
            res = positiveMomentsDifference(base3, other);
          } else {
            res = positiveMomentsDifference(other, base3);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
          }
          return res;
        }
        function createAdder(direction, name) {
          return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
              deprecateSimple(
                name,
                "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
              );
              tmp = val;
              val = period;
              period = tmp;
            }
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
          };
        }
        function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
          if (!mom.isValid()) {
            return;
          }
          updateOffset = updateOffset == null ? true : updateOffset;
          if (months2) {
            setMonth(mom, get2(mom, "Month") + months2 * isAdding);
          }
          if (days2) {
            set$1(mom, "Date", get2(mom, "Date") + days2 * isAdding);
          }
          if (milliseconds2) {
            mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
          }
          if (updateOffset) {
            hooks.updateOffset(mom, days2 || months2);
          }
        }
        var add2 = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
        function isString(input) {
          return typeof input === "string" || input instanceof String;
        }
        function isMomentInput(input) {
          return isMoment(input) || isDate2(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
        }
        function isMomentInputObject(input) {
          var objectTest = isObject8(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "years",
            "year",
            "y",
            "months",
            "month",
            "M",
            "days",
            "day",
            "d",
            "dates",
            "date",
            "D",
            "hours",
            "hour",
            "h",
            "minutes",
            "minute",
            "m",
            "seconds",
            "second",
            "s",
            "milliseconds",
            "millisecond",
            "ms"
          ], i, property, propertyLen = properties.length;
          for (i = 0; i < propertyLen; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function isNumberOrStringArray(input) {
          var arrayTest = isArray(input), dataTypeTest = false;
          if (arrayTest) {
            dataTypeTest = input.filter(function(item) {
              return !isNumber(item) && isString(input);
            }).length === 0;
          }
          return arrayTest && dataTypeTest;
        }
        function isCalendarSpec(input) {
          var objectTest = isObject8(input) && !isObjectEmpty(input), propertyTest = false, properties = [
            "sameDay",
            "nextDay",
            "lastDay",
            "nextWeek",
            "lastWeek",
            "sameElse"
          ], i, property;
          for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
          }
          return objectTest && propertyTest;
        }
        function getCalendarFormat(myMoment, now3) {
          var diff2 = myMoment.diff(now3, "days", true);
          return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
        }
        function calendar$1(time, formats) {
          if (arguments.length === 1) {
            if (!arguments[0]) {
              time = void 0;
              formats = void 0;
            } else if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = void 0;
            } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = void 0;
            }
          }
          var now3 = time || createLocal(), sod = cloneWithOffset(now3, this).startOf("day"), format5 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format5]) ? formats[format5].call(this, now3) : formats[format5]);
          return this.format(
            output || this.localeData().calendar(format5, this, createLocal(now3))
          );
        }
        function clone5() {
          return new Moment(this);
        }
        function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() > localInput.valueOf();
          } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
        }
        function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() < localInput.valueOf();
          } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
        }
        function isBetween(from2, to2, units, inclusivity) {
          var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
          }
          inclusivity = inclusivity || "()";
          return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
        }
        function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input), inputMs;
          if (!(this.isValid() && localInput.isValid())) {
            return false;
          }
          units = normalizeUnits(units) || "millisecond";
          if (units === "millisecond") {
            return this.valueOf() === localInput.valueOf();
          } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
        }
        function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
        }
        function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
        }
        function diff(input, units, asFloat) {
          var that, zoneDelta, output;
          if (!this.isValid()) {
            return NaN;
          }
          that = cloneWithOffset(input, this);
          if (!that.isValid()) {
            return NaN;
          }
          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
          units = normalizeUnits(units);
          switch (units) {
            case "year":
              output = monthDiff(this, that) / 12;
              break;
            case "month":
              output = monthDiff(this, that);
              break;
            case "quarter":
              output = monthDiff(this, that) / 3;
              break;
            case "second":
              output = (this - that) / 1e3;
              break;
            case "minute":
              output = (this - that) / 6e4;
              break;
            case "hour":
              output = (this - that) / 36e5;
              break;
            case "day":
              output = (this - that - zoneDelta) / 864e5;
              break;
            case "week":
              output = (this - that - zoneDelta) / 6048e5;
              break;
            default:
              output = this - that;
          }
          return asFloat ? output : absFloor(output);
        }
        function monthDiff(a, b) {
          if (a.date() < b.date()) {
            return -monthDiff(b, a);
          }
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
          if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2);
          } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor);
          }
          return -(wholeMonthDiff + adjust) || 0;
        }
        hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
        hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
        function toString() {
          return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        }
        function toISOString(keepOffset) {
          if (!this.isValid()) {
            return null;
          }
          var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
              m,
              utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
            );
          }
          if (isFunction(Date.prototype.toISOString)) {
            if (utc) {
              return this.toDate().toISOString();
            } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
            }
          }
          return formatMoment(
            m,
            utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        function inspect() {
          if (!this.isValid()) {
            return "moment.invalid(/* " + this._i + " */)";
          }
          var func = "moment", zone = "", prefix, year, datetime, suffix;
          if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
            zone = "Z";
          }
          prefix = "[" + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
          datetime = "-MM-DD[T]HH:mm:ss.SSS";
          suffix = zone + '[")]';
          return this.format(prefix + year + datetime + suffix);
        }
        function format4(inputString) {
          if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
        }
        function from(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
        }
        function to(time, withoutSuffix) {
          if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
            return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
          } else {
            return this.localeData().invalidDate();
          }
        }
        function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
        }
        function locale(key) {
          var newLocaleData;
          if (key === void 0) {
            return this._locale._abbr;
          } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }
            return this;
          }
        }
        var lang = deprecate(
          "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
          function(key) {
            if (key === void 0) {
              return this.localeData();
            } else {
              return this.locale(key);
            }
          }
        );
        function localeData() {
          return this._locale;
        }
        var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
        function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
        }
        function localStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return new Date(y, m, d).valueOf();
          }
        }
        function utcStartOfDate(y, m, d) {
          if (y < 100 && y >= 0) {
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
            return Date.UTC(y, m, d);
          }
        }
        function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year(), 0, 1);
              break;
            case "quarter":
              time = startOfDate(
                this.year(),
                this.month() - this.month() % 3,
                1
              );
              break;
            case "month":
              time = startOfDate(this.year(), this.month(), 1);
              break;
            case "week":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - this.weekday()
              );
              break;
            case "isoWeek":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - (this.isoWeekday() - 1)
              );
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date());
              break;
            case "hour":
              time = this._d.valueOf();
              time -= mod$1(
                time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                MS_PER_HOUR
              );
              break;
            case "minute":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
            case "second":
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === void 0 || units === "millisecond" || !this.isValid()) {
            return this;
          }
          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
          switch (units) {
            case "year":
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
            case "quarter":
              time = startOfDate(
                this.year(),
                this.month() - this.month() % 3 + 3,
                1
              ) - 1;
              break;
            case "month":
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
            case "week":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - this.weekday() + 7
              ) - 1;
              break;
            case "isoWeek":
              time = startOfDate(
                this.year(),
                this.month(),
                this.date() - (this.isoWeekday() - 1) + 7
              ) - 1;
              break;
            case "day":
            case "date":
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
            case "hour":
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(
                time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                MS_PER_HOUR
              ) - 1;
              break;
            case "minute":
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
            case "second":
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
          }
          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
        }
        function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 6e4;
        }
        function unix() {
          return Math.floor(this.valueOf() / 1e3);
        }
        function toDate() {
          return new Date(this.valueOf());
        }
        function toArray() {
          var m = this;
          return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond()
          ];
        }
        function toObject() {
          var m = this;
          return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
          };
        }
        function toJSON() {
          return this.isValid() ? this.toISOString() : null;
        }
        function isValid$2() {
          return isValid(this);
        }
        function parsingFlags() {
          return extend23({}, getParsingFlags(this));
        }
        function invalidAt() {
          return getParsingFlags(this).overflow;
        }
        function creationData() {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          };
        }
        addFormatToken("N", 0, 0, "eraAbbr");
        addFormatToken("NN", 0, 0, "eraAbbr");
        addFormatToken("NNN", 0, 0, "eraAbbr");
        addFormatToken("NNNN", 0, 0, "eraName");
        addFormatToken("NNNNN", 0, 0, "eraNarrow");
        addFormatToken("y", ["y", 1], "yo", "eraYear");
        addFormatToken("y", ["yy", 2], 0, "eraYear");
        addFormatToken("y", ["yyy", 3], 0, "eraYear");
        addFormatToken("y", ["yyyy", 4], 0, "eraYear");
        addRegexToken("N", matchEraAbbr);
        addRegexToken("NN", matchEraAbbr);
        addRegexToken("NNN", matchEraAbbr);
        addRegexToken("NNNN", matchEraName);
        addRegexToken("NNNNN", matchEraNarrow);
        addParseToken(
          ["N", "NN", "NNN", "NNNN", "NNNNN"],
          function(input, array, config2, token2) {
            var era = config2._locale.erasParse(input, token2, config2._strict);
            if (era) {
              getParsingFlags(config2).era = era;
            } else {
              getParsingFlags(config2).invalidEra = input;
            }
          }
        );
        addRegexToken("y", matchUnsigned);
        addRegexToken("yy", matchUnsigned);
        addRegexToken("yyy", matchUnsigned);
        addRegexToken("yyyy", matchUnsigned);
        addRegexToken("yo", matchEraYearOrdinal);
        addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
        addParseToken(["yo"], function(input, array, config2, token2) {
          var match5;
          if (config2._locale._eraYearOrdinalRegex) {
            match5 = input.match(config2._locale._eraYearOrdinalRegex);
          }
          if (config2._locale.eraYearOrdinalParse) {
            array[YEAR] = config2._locale.eraYearOrdinalParse(input, match5);
          } else {
            array[YEAR] = parseInt(input, 10);
          }
        });
        function localeEras(m, format5) {
          var i, l, date, eras = this._eras || getLocale("en")._eras;
          for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
              case "string":
                date = hooks(eras[i].since).startOf("day");
                eras[i].since = date.valueOf();
                break;
            }
            switch (typeof eras[i].until) {
              case "undefined":
                eras[i].until = Infinity;
                break;
              case "string":
                date = hooks(eras[i].until).startOf("day").valueOf();
                eras[i].until = date.valueOf();
                break;
            }
          }
          return eras;
        }
        function localeErasParse(eraName, format5, strict) {
          var i, l, eras = this.eras(), name, abbr, narrow;
          eraName = eraName.toUpperCase();
          for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();
            if (strict) {
              switch (format5) {
                case "N":
                case "NN":
                case "NNN":
                  if (abbr === eraName) {
                    return eras[i];
                  }
                  break;
                case "NNNN":
                  if (name === eraName) {
                    return eras[i];
                  }
                  break;
                case "NNNNN":
                  if (narrow === eraName) {
                    return eras[i];
                  }
                  break;
              }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i];
            }
          }
        }
        function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? 1 : -1;
          if (year === void 0) {
            return hooks(era.since).year();
          } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
          }
        }
        function getEraName() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].name;
            }
          }
          return "";
        }
        function getEraNarrow() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].narrow;
            }
          }
          return "";
        }
        function getEraAbbr() {
          var i, l, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].abbr;
            }
          }
          return "";
        }
        function getEraYear() {
          var i, l, dir, val, eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? 1 : -1;
            val = this.clone().startOf("day").valueOf();
            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
              return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
            }
          }
          return this.year();
        }
        function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNameRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
        }
        function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, "_erasAbbrRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }
        function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, "_erasNarrowRegex")) {
            computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }
        function matchEraAbbr(isStrict, locale2) {
          return locale2.erasAbbrRegex(isStrict);
        }
        function matchEraName(isStrict, locale2) {
          return locale2.erasNameRegex(isStrict);
        }
        function matchEraNarrow(isStrict, locale2) {
          return locale2.erasNarrowRegex(isStrict);
        }
        function matchEraYearOrdinal(isStrict, locale2) {
          return locale2._eraYearOrdinalRegex || matchUnsigned;
        }
        function computeErasParse() {
          var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
          for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));
            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
          }
          this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
          this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
          this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
          this._erasNarrowRegex = new RegExp(
            "^(" + narrowPieces.join("|") + ")",
            "i"
          );
        }
        addFormatToken(0, ["gg", 2], 0, function() {
          return this.weekYear() % 100;
        });
        addFormatToken(0, ["GG", 2], 0, function() {
          return this.isoWeekYear() % 100;
        });
        function addWeekYearFormatToken(token2, getter) {
          addFormatToken(0, [token2, token2.length], 0, getter);
        }
        addWeekYearFormatToken("gggg", "weekYear");
        addWeekYearFormatToken("ggggg", "weekYear");
        addWeekYearFormatToken("GGGG", "isoWeekYear");
        addWeekYearFormatToken("GGGGG", "isoWeekYear");
        addUnitAlias("weekYear", "gg");
        addUnitAlias("isoWeekYear", "GG");
        addUnitPriority("weekYear", 1);
        addUnitPriority("isoWeekYear", 1);
        addRegexToken("G", matchSigned);
        addRegexToken("g", matchSigned);
        addRegexToken("GG", match1to2, match2);
        addRegexToken("gg", match1to2, match2);
        addRegexToken("GGGG", match1to4, match4);
        addRegexToken("gggg", match1to4, match4);
        addRegexToken("GGGGG", match1to6, match6);
        addRegexToken("ggggg", match1to6, match6);
        addWeekParseToken(
          ["gggg", "ggggg", "GGGG", "GGGGG"],
          function(input, week, config2, token2) {
            week[token2.substr(0, 2)] = toInt(input);
          }
        );
        addWeekParseToken(["gg", "GG"], function(input, week, config2, token2) {
          week[token2] = hooks.parseTwoDigitYear(input);
        });
        function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy
          );
        }
        function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
          );
        }
        function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
        }
        function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
        }
        function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }
        function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }
        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
            return weekOfYear(this, dow, doy).year;
          } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
              week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
        }
        function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
        }
        addFormatToken("Q", 0, "Qo", "quarter");
        addUnitAlias("quarter", "Q");
        addUnitPriority("quarter", 7);
        addRegexToken("Q", match1);
        addParseToken("Q", function(input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
        });
        function getSetQuarter(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        }
        addFormatToken("D", ["DD", 2], "Do", "date");
        addUnitAlias("date", "D");
        addUnitPriority("date", 9);
        addRegexToken("D", match1to2);
        addRegexToken("DD", match1to2, match2);
        addRegexToken("Do", function(isStrict, locale2) {
          return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
        });
        addParseToken(["D", "DD"], DATE);
        addParseToken("Do", function(input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
        });
        var getSetDayOfMonth = makeGetSet("Date", true);
        addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
        addUnitAlias("dayOfYear", "DDD");
        addUnitPriority("dayOfYear", 4);
        addRegexToken("DDD", match1to3);
        addRegexToken("DDDD", match3);
        addParseToken(["DDD", "DDDD"], function(input, array, config2) {
          config2._dayOfYear = toInt(input);
        });
        function getSetDayOfYear(input) {
          var dayOfYear = Math.round(
            (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
          ) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
        }
        addFormatToken("m", ["mm", 2], 0, "minute");
        addUnitAlias("minute", "m");
        addUnitPriority("minute", 14);
        addRegexToken("m", match1to2);
        addRegexToken("mm", match1to2, match2);
        addParseToken(["m", "mm"], MINUTE);
        var getSetMinute = makeGetSet("Minutes", false);
        addFormatToken("s", ["ss", 2], 0, "second");
        addUnitAlias("second", "s");
        addUnitPriority("second", 15);
        addRegexToken("s", match1to2);
        addRegexToken("ss", match1to2, match2);
        addParseToken(["s", "ss"], SECOND);
        var getSetSecond = makeGetSet("Seconds", false);
        addFormatToken("S", 0, 0, function() {
          return ~~(this.millisecond() / 100);
        });
        addFormatToken(0, ["SS", 2], 0, function() {
          return ~~(this.millisecond() / 10);
        });
        addFormatToken(0, ["SSS", 3], 0, "millisecond");
        addFormatToken(0, ["SSSS", 4], 0, function() {
          return this.millisecond() * 10;
        });
        addFormatToken(0, ["SSSSS", 5], 0, function() {
          return this.millisecond() * 100;
        });
        addFormatToken(0, ["SSSSSS", 6], 0, function() {
          return this.millisecond() * 1e3;
        });
        addFormatToken(0, ["SSSSSSS", 7], 0, function() {
          return this.millisecond() * 1e4;
        });
        addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
          return this.millisecond() * 1e5;
        });
        addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
          return this.millisecond() * 1e6;
        });
        addUnitAlias("millisecond", "ms");
        addUnitPriority("millisecond", 16);
        addRegexToken("S", match1to3, match1);
        addRegexToken("SS", match1to3, match2);
        addRegexToken("SSS", match1to3, match3);
        var token, getSetMillisecond;
        for (token = "SSSS"; token.length <= 9; token += "S") {
          addRegexToken(token, matchUnsigned);
        }
        function parseMs(input, array) {
          array[MILLISECOND] = toInt(("0." + input) * 1e3);
        }
        for (token = "S"; token.length <= 9; token += "S") {
          addParseToken(token, parseMs);
        }
        getSetMillisecond = makeGetSet("Milliseconds", false);
        addFormatToken("z", 0, 0, "zoneAbbr");
        addFormatToken("zz", 0, 0, "zoneName");
        function getZoneAbbr() {
          return this._isUTC ? "UTC" : "";
        }
        function getZoneName() {
          return this._isUTC ? "Coordinated Universal Time" : "";
        }
        var proto = Moment.prototype;
        proto.add = add2;
        proto.calendar = calendar$1;
        proto.clone = clone5;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format4;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== "undefined" && Symbol.for != null) {
          proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
            return "Moment<" + this.format() + ">";
          };
        }
        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate(
          "dates accessor is deprecated. Use date instead.",
          getSetDayOfMonth
        );
        proto.months = deprecate(
          "months accessor is deprecated. Use month instead",
          getSetMonth
        );
        proto.years = deprecate(
          "years accessor is deprecated. Use year instead",
          getSetYear
        );
        proto.zone = deprecate(
          "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
          getSetZone
        );
        proto.isDSTShifted = deprecate(
          "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
          isDaylightSavingTimeShifted
        );
        function createUnix(input) {
          return createLocal(input * 1e3);
        }
        function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
        }
        function preParsePostFormat(string) {
          return string;
        }
        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set3;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;
        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;
        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;
        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;
        function get$1(format5, index, field, setter) {
          var locale2 = getLocale(), utc = createUTC().set(setter, index);
          return locale2[field](utc, format5);
        }
        function listMonthsImpl(format5, index, field) {
          if (isNumber(format5)) {
            index = format5;
            format5 = void 0;
          }
          format5 = format5 || "";
          if (index != null) {
            return get$1(format5, index, field, "month");
          }
          var i, out = [];
          for (i = 0; i < 12; i++) {
            out[i] = get$1(format5, i, field, "month");
          }
          return out;
        }
        function listWeekdaysImpl(localeSorted, format5, index, field) {
          if (typeof localeSorted === "boolean") {
            if (isNumber(format5)) {
              index = format5;
              format5 = void 0;
            }
            format5 = format5 || "";
          } else {
            format5 = localeSorted;
            index = format5;
            localeSorted = false;
            if (isNumber(format5)) {
              index = format5;
              format5 = void 0;
            }
            format5 = format5 || "";
          }
          var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
          if (index != null) {
            return get$1(format5, (index + shift) % 7, field, "day");
          }
          for (i = 0; i < 7; i++) {
            out[i] = get$1(format5, (i + shift) % 7, field, "day");
          }
          return out;
        }
        function listMonths(format5, index) {
          return listMonthsImpl(format5, index, "months");
        }
        function listMonthsShort(format5, index) {
          return listMonthsImpl(format5, index, "monthsShort");
        }
        function listWeekdays(localeSorted, format5, index) {
          return listWeekdaysImpl(localeSorted, format5, index, "weekdays");
        }
        function listWeekdaysShort(localeSorted, format5, index) {
          return listWeekdaysImpl(localeSorted, format5, index, "weekdaysShort");
        }
        function listWeekdaysMin(localeSorted, format5, index) {
          return listWeekdaysImpl(localeSorted, format5, index, "weekdaysMin");
        }
        getSetGlobalLocale("en", {
          eras: [
            {
              since: "0001-01-01",
              until: Infinity,
              offset: 1,
              name: "Anno Domini",
              narrow: "AD",
              abbr: "AD"
            },
            {
              since: "0000-12-31",
              until: -Infinity,
              offset: 1,
              name: "Before Christ",
              narrow: "BC",
              abbr: "BC"
            }
          ],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
          }
        });
        hooks.lang = deprecate(
          "moment.lang is deprecated. Use moment.locale instead.",
          getSetGlobalLocale
        );
        hooks.langData = deprecate(
          "moment.langData is deprecated. Use moment.localeData instead.",
          getLocale
        );
        var mathAbs = Math.abs;
        function abs() {
          var data = this._data;
          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);
          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);
          return this;
        }
        function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);
          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;
          return duration._bubble();
        }
        function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
        }
        function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
        }
        function absCeil(number) {
          if (number < 0) {
            return Math.floor(number);
          } else {
            return Math.ceil(number);
          }
        }
        function bubble() {
          var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
          if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
            milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
            days2 = 0;
            months2 = 0;
          }
          data.milliseconds = milliseconds2 % 1e3;
          seconds2 = absFloor(milliseconds2 / 1e3);
          data.seconds = seconds2 % 60;
          minutes2 = absFloor(seconds2 / 60);
          data.minutes = minutes2 % 60;
          hours2 = absFloor(minutes2 / 60);
          data.hours = hours2 % 24;
          days2 += absFloor(hours2 / 24);
          monthsFromDays = absFloor(daysToMonths(days2));
          months2 += monthsFromDays;
          days2 -= absCeil(monthsToDays(monthsFromDays));
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          data.days = days2;
          data.months = months2;
          data.years = years2;
          return this;
        }
        function daysToMonths(days2) {
          return days2 * 4800 / 146097;
        }
        function monthsToDays(months2) {
          return months2 * 146097 / 4800;
        }
        function as(units) {
          if (!this.isValid()) {
            return NaN;
          }
          var days2, months2, milliseconds2 = this._milliseconds;
          units = normalizeUnits(units);
          if (units === "month" || units === "quarter" || units === "year") {
            days2 = this._days + milliseconds2 / 864e5;
            months2 = this._months + daysToMonths(days2);
            switch (units) {
              case "month":
                return months2;
              case "quarter":
                return months2 / 3;
              case "year":
                return months2 / 12;
            }
          } else {
            days2 = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case "week":
                return days2 / 7 + milliseconds2 / 6048e5;
              case "day":
                return days2 + milliseconds2 / 864e5;
              case "hour":
                return days2 * 24 + milliseconds2 / 36e5;
              case "minute":
                return days2 * 1440 + milliseconds2 / 6e4;
              case "second":
                return days2 * 86400 + milliseconds2 / 1e3;
              case "millisecond":
                return Math.floor(days2 * 864e5) + milliseconds2;
              default:
                throw new Error("Unknown unit " + units);
            }
          }
        }
        function valueOf$1() {
          if (!this.isValid()) {
            return NaN;
          }
          return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        }
        function makeAs(alias) {
          return function() {
            return this.as(alias);
          };
        }
        var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
        function clone$1() {
          return createDuration(this);
        }
        function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + "s"]() : NaN;
        }
        function makeGetter(name) {
          return function() {
            return this.isValid() ? this._data[name] : NaN;
          };
        }
        var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
        function weeks() {
          return absFloor(this.days() / 7);
        }
        var round2 = Math.round, thresholds = {
          ss: 44,
          // a few seconds to seconds
          s: 45,
          // seconds to minute
          m: 45,
          // minutes to hour
          h: 22,
          // hours to day
          d: 26,
          // days to month/week
          w: null,
          // weeks to month
          M: 11
          // months to year
        };
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
          return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }
        function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
          var duration = createDuration(posNegDuration).abs(), seconds2 = round2(duration.as("s")), minutes2 = round2(duration.as("m")), hours2 = round2(duration.as("h")), days2 = round2(duration.as("d")), months2 = round2(duration.as("M")), weeks2 = round2(duration.as("w")), years2 = round2(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
          if (thresholds2.w != null) {
            a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
          }
          a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale2;
          return substituteTimeAgo.apply(null, a);
        }
        function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === void 0) {
            return round2;
          }
          if (typeof roundingFunction === "function") {
            round2 = roundingFunction;
            return true;
          }
          return false;
        }
        function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === void 0) {
            return false;
          }
          if (limit === void 0) {
            return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === "s") {
            thresholds.ss = limit - 1;
          }
          return true;
        }
        function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var withSuffix = false, th = thresholds, locale2, output;
          if (typeof argWithSuffix === "object") {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
          }
          if (typeof argWithSuffix === "boolean") {
            withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === "object") {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
            }
          }
          locale2 = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale2);
          if (withSuffix) {
            output = locale2.pastFuture(+this, output);
          }
          return locale2.postformat(output);
        }
        var abs$1 = Math.abs;
        function sign(x) {
          return (x > 0) - (x < 0) || +x;
        }
        function toISOString$1() {
          if (!this.isValid()) {
            return this.localeData().invalidDate();
          }
          var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
          if (!total) {
            return "P0D";
          }
          minutes2 = absFloor(seconds2 / 60);
          hours2 = absFloor(minutes2 / 60);
          seconds2 %= 60;
          minutes2 %= 60;
          years2 = absFloor(months2 / 12);
          months2 %= 12;
          s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
          totalSign = total < 0 ? "-" : "";
          ymSign = sign(this._months) !== sign(total) ? "-" : "";
          daysSign = sign(this._days) !== sign(total) ? "-" : "";
          hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
          return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
        }
        var proto$2 = Duration.prototype;
        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;
        proto$2.toIsoString = deprecate(
          "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
          toISOString$1
        );
        proto$2.lang = lang;
        addFormatToken("X", 0, 0, "unix");
        addFormatToken("x", 0, 0, "valueOf");
        addRegexToken("x", matchSigned);
        addRegexToken("X", matchTimestamp);
        addParseToken("X", function(input, array, config2) {
          config2._d = new Date(parseFloat(input) * 1e3);
        });
        addParseToken("x", function(input, array, config2) {
          config2._d = new Date(toInt(input));
        });
        hooks.version = "2.29.4";
        setHookCallback(createLocal);
        hooks.fn = proto;
        hooks.min = min2;
        hooks.max = max2;
        hooks.now = now2;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate2;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;
        hooks.HTML5_FMT = {
          DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
          // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
          // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
          // <input type="datetime-local" step="0.001" />
          DATE: "YYYY-MM-DD",
          // <input type="date" />
          TIME: "HH:mm",
          // <input type="time" />
          TIME_SECONDS: "HH:mm:ss",
          // <input type="time" step="1" />
          TIME_MS: "HH:mm:ss.SSS",
          // <input type="time" step="0.001" />
          WEEK: "GGGG-[W]WW",
          // <input type="week" />
          MONTH: "YYYY-MM"
          // <input type="month" />
        };
        return hooks;
      });
    }
  });

  // node_modules/lodash/_arrayMap.js
  var require_arrayMap = __commonJS({
    "node_modules/lodash/_arrayMap.js"(exports, module) {
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      module.exports = arrayMap;
    }
  });

  // node_modules/lodash/_arrayEach.js
  var require_arrayEach = __commonJS({
    "node_modules/lodash/_arrayEach.js"(exports, module) {
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      module.exports = arrayEach;
    }
  });

  // node_modules/lodash/_nativeKeys.js
  var require_nativeKeys = __commonJS({
    "node_modules/lodash/_nativeKeys.js"(exports, module) {
      var overArg = require_overArg();
      var nativeKeys = overArg(Object.keys, Object);
      module.exports = nativeKeys;
    }
  });

  // node_modules/lodash/_baseKeys.js
  var require_baseKeys = __commonJS({
    "node_modules/lodash/_baseKeys.js"(exports, module) {
      var isPrototype = require_isPrototype();
      var nativeKeys = require_nativeKeys();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = baseKeys;
    }
  });

  // node_modules/lodash/keys.js
  var require_keys = __commonJS({
    "node_modules/lodash/keys.js"(exports, module) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeys = require_baseKeys();
      var isArrayLike = require_isArrayLike();
      function keys5(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      module.exports = keys5;
    }
  });

  // node_modules/lodash/_baseAssign.js
  var require_baseAssign = __commonJS({
    "node_modules/lodash/_baseAssign.js"(exports, module) {
      var copyObject = require_copyObject();
      var keys5 = require_keys();
      function baseAssign(object, source) {
        return object && copyObject(source, keys5(source), object);
      }
      module.exports = baseAssign;
    }
  });

  // node_modules/lodash/_baseAssignIn.js
  var require_baseAssignIn = __commonJS({
    "node_modules/lodash/_baseAssignIn.js"(exports, module) {
      var copyObject = require_copyObject();
      var keysIn = require_keysIn();
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      module.exports = baseAssignIn;
    }
  });

  // node_modules/lodash/_arrayFilter.js
  var require_arrayFilter = __commonJS({
    "node_modules/lodash/_arrayFilter.js"(exports, module) {
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module.exports = arrayFilter;
    }
  });

  // node_modules/lodash/stubArray.js
  var require_stubArray = __commonJS({
    "node_modules/lodash/stubArray.js"(exports, module) {
      function stubArray() {
        return [];
      }
      module.exports = stubArray;
    }
  });

  // node_modules/lodash/_getSymbols.js
  var require_getSymbols = __commonJS({
    "node_modules/lodash/_getSymbols.js"(exports, module) {
      var arrayFilter = require_arrayFilter();
      var stubArray = require_stubArray();
      var objectProto = Object.prototype;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      module.exports = getSymbols;
    }
  });

  // node_modules/lodash/_copySymbols.js
  var require_copySymbols = __commonJS({
    "node_modules/lodash/_copySymbols.js"(exports, module) {
      var copyObject = require_copyObject();
      var getSymbols = require_getSymbols();
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      module.exports = copySymbols;
    }
  });

  // node_modules/lodash/_arrayPush.js
  var require_arrayPush = __commonJS({
    "node_modules/lodash/_arrayPush.js"(exports, module) {
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset2 = array.length;
        while (++index < length) {
          array[offset2 + index] = values[index];
        }
        return array;
      }
      module.exports = arrayPush;
    }
  });

  // node_modules/lodash/_getSymbolsIn.js
  var require_getSymbolsIn = __commonJS({
    "node_modules/lodash/_getSymbolsIn.js"(exports, module) {
      var arrayPush = require_arrayPush();
      var getPrototype = require_getPrototype();
      var getSymbols = require_getSymbols();
      var stubArray = require_stubArray();
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result = [];
        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype(object);
        }
        return result;
      };
      module.exports = getSymbolsIn;
    }
  });

  // node_modules/lodash/_copySymbolsIn.js
  var require_copySymbolsIn = __commonJS({
    "node_modules/lodash/_copySymbolsIn.js"(exports, module) {
      var copyObject = require_copyObject();
      var getSymbolsIn = require_getSymbolsIn();
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      module.exports = copySymbolsIn;
    }
  });

  // node_modules/lodash/_baseGetAllKeys.js
  var require_baseGetAllKeys = __commonJS({
    "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
      var arrayPush = require_arrayPush();
      var isArray = require_isArray();
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      module.exports = baseGetAllKeys;
    }
  });

  // node_modules/lodash/_getAllKeys.js
  var require_getAllKeys = __commonJS({
    "node_modules/lodash/_getAllKeys.js"(exports, module) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbols = require_getSymbols();
      var keys5 = require_keys();
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys5, getSymbols);
      }
      module.exports = getAllKeys;
    }
  });

  // node_modules/lodash/_getAllKeysIn.js
  var require_getAllKeysIn = __commonJS({
    "node_modules/lodash/_getAllKeysIn.js"(exports, module) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbolsIn = require_getSymbolsIn();
      var keysIn = require_keysIn();
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      module.exports = getAllKeysIn;
    }
  });

  // node_modules/lodash/_DataView.js
  var require_DataView = __commonJS({
    "node_modules/lodash/_DataView.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var DataView3 = getNative(root, "DataView");
      module.exports = DataView3;
    }
  });

  // node_modules/lodash/_Promise.js
  var require_Promise = __commonJS({
    "node_modules/lodash/_Promise.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var Promise2 = getNative(root, "Promise");
      module.exports = Promise2;
    }
  });

  // node_modules/lodash/_Set.js
  var require_Set = __commonJS({
    "node_modules/lodash/_Set.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var Set2 = getNative(root, "Set");
      module.exports = Set2;
    }
  });

  // node_modules/lodash/_WeakMap.js
  var require_WeakMap = __commonJS({
    "node_modules/lodash/_WeakMap.js"(exports, module) {
      var getNative = require_getNative();
      var root = require_root();
      var WeakMap2 = getNative(root, "WeakMap");
      module.exports = WeakMap2;
    }
  });

  // node_modules/lodash/_getTag.js
  var require_getTag = __commonJS({
    "node_modules/lodash/_getTag.js"(exports, module) {
      var DataView3 = require_DataView();
      var Map10 = require_Map();
      var Promise2 = require_Promise();
      var Set2 = require_Set();
      var WeakMap2 = require_WeakMap();
      var baseGetTag = require_baseGetTag();
      var toSource = require_toSource();
      var mapTag = "[object Map]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var setTag = "[object Set]";
      var weakMapTag = "[object WeakMap]";
      var dataViewTag = "[object DataView]";
      var dataViewCtorString = toSource(DataView3);
      var mapCtorString = toSource(Map10);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap2);
      var getTag = baseGetTag;
      if (DataView3 && getTag(new DataView3(new ArrayBuffer(1))) != dataViewTag || Map10 && getTag(new Map10()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      module.exports = getTag;
    }
  });

  // node_modules/lodash/_initCloneArray.js
  var require_initCloneArray = __commonJS({
    "node_modules/lodash/_initCloneArray.js"(exports, module) {
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function initCloneArray(array) {
        var length = array.length, result = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      module.exports = initCloneArray;
    }
  });

  // node_modules/lodash/_cloneDataView.js
  var require_cloneDataView = __commonJS({
    "node_modules/lodash/_cloneDataView.js"(exports, module) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      module.exports = cloneDataView;
    }
  });

  // node_modules/lodash/_cloneRegExp.js
  var require_cloneRegExp = __commonJS({
    "node_modules/lodash/_cloneRegExp.js"(exports, module) {
      var reFlags = /\w*$/;
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      module.exports = cloneRegExp;
    }
  });

  // node_modules/lodash/_cloneSymbol.js
  var require_cloneSymbol = __commonJS({
    "node_modules/lodash/_cloneSymbol.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
      }
      module.exports = cloneSymbol;
    }
  });

  // node_modules/lodash/_initCloneByTag.js
  var require_initCloneByTag = __commonJS({
    "node_modules/lodash/_initCloneByTag.js"(exports, module) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      var cloneDataView = require_cloneDataView();
      var cloneRegExp = require_cloneRegExp();
      var cloneSymbol = require_cloneSymbol();
      var cloneTypedArray = require_cloneTypedArray();
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      module.exports = initCloneByTag;
    }
  });

  // node_modules/lodash/_baseIsMap.js
  var require_baseIsMap = __commonJS({
    "node_modules/lodash/_baseIsMap.js"(exports, module) {
      var getTag = require_getTag();
      var isObjectLike = require_isObjectLike();
      var mapTag = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      module.exports = baseIsMap;
    }
  });

  // node_modules/lodash/isMap.js
  var require_isMap = __commonJS({
    "node_modules/lodash/isMap.js"(exports, module) {
      var baseIsMap = require_baseIsMap();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsMap = nodeUtil && nodeUtil.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      module.exports = isMap;
    }
  });

  // node_modules/lodash/_baseIsSet.js
  var require_baseIsSet = __commonJS({
    "node_modules/lodash/_baseIsSet.js"(exports, module) {
      var getTag = require_getTag();
      var isObjectLike = require_isObjectLike();
      var setTag = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      module.exports = baseIsSet;
    }
  });

  // node_modules/lodash/isSet.js
  var require_isSet = __commonJS({
    "node_modules/lodash/isSet.js"(exports, module) {
      var baseIsSet = require_baseIsSet();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsSet = nodeUtil && nodeUtil.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      module.exports = isSet;
    }
  });

  // node_modules/lodash/_baseClone.js
  var require_baseClone = __commonJS({
    "node_modules/lodash/_baseClone.js"(exports, module) {
      var Stack2 = require_Stack();
      var arrayEach = require_arrayEach();
      var assignValue = require_assignValue();
      var baseAssign = require_baseAssign();
      var baseAssignIn = require_baseAssignIn();
      var cloneBuffer = require_cloneBuffer();
      var copyArray = require_copyArray();
      var copySymbols = require_copySymbols();
      var copySymbolsIn = require_copySymbolsIn();
      var getAllKeys = require_getAllKeys();
      var getAllKeysIn = require_getAllKeysIn();
      var getTag = require_getTag();
      var initCloneArray = require_initCloneArray();
      var initCloneByTag = require_initCloneByTag();
      var initCloneObject = require_initCloneObject();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isMap = require_isMap();
      var isObject8 = require_isObject();
      var isSet = require_isSet();
      var keys5 = require_keys();
      var keysIn = require_keysIn();
      var CLONE_DEEP_FLAG = 1;
      var CLONE_FLAT_FLAG = 2;
      var CLONE_SYMBOLS_FLAG = 4;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject8(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack2());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys5;
        var props = isArr ? void 0 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      module.exports = baseClone;
    }
  });

  // node_modules/lodash/isSymbol.js
  var require_isSymbol = __commonJS({
    "node_modules/lodash/isSymbol.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var symbolTag = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      module.exports = isSymbol;
    }
  });

  // node_modules/lodash/_isKey.js
  var require_isKey = __commonJS({
    "node_modules/lodash/_isKey.js"(exports, module) {
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var reIsPlainProp = /^\w*$/;
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      module.exports = isKey;
    }
  });

  // node_modules/lodash/memoize.js
  var require_memoize = __commonJS({
    "node_modules/lodash/memoize.js"(exports, module) {
      var MapCache = require_MapCache();
      var FUNC_ERROR_TEXT = "Expected a function";
      function memoize2(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache2.set(key, result) || cache2;
          return result;
        };
        memoized.cache = new (memoize2.Cache || MapCache)();
        return memoized;
      }
      memoize2.Cache = MapCache;
      module.exports = memoize2;
    }
  });

  // node_modules/lodash/_memoizeCapped.js
  var require_memoizeCapped = __commonJS({
    "node_modules/lodash/_memoizeCapped.js"(exports, module) {
      var memoize2 = require_memoize();
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize2(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result.cache;
        return result;
      }
      module.exports = memoizeCapped;
    }
  });

  // node_modules/lodash/_stringToPath.js
  var require_stringToPath = __commonJS({
    "node_modules/lodash/_stringToPath.js"(exports, module) {
      var memoizeCapped = require_memoizeCapped();
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string) {
        var result = [];
        if (string.charCodeAt(0) === 46) {
          result.push("");
        }
        string.replace(rePropName, function(match2, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
        });
        return result;
      });
      module.exports = stringToPath;
    }
  });

  // node_modules/lodash/_baseToString.js
  var require_baseToString = __commonJS({
    "node_modules/lodash/_baseToString.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var arrayMap = require_arrayMap();
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString = symbolProto ? symbolProto.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module.exports = baseToString;
    }
  });

  // node_modules/lodash/toString.js
  var require_toString = __commonJS({
    "node_modules/lodash/toString.js"(exports, module) {
      var baseToString = require_baseToString();
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      module.exports = toString;
    }
  });

  // node_modules/lodash/_castPath.js
  var require_castPath = __commonJS({
    "node_modules/lodash/_castPath.js"(exports, module) {
      var isArray = require_isArray();
      var isKey = require_isKey();
      var stringToPath = require_stringToPath();
      var toString = require_toString();
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      module.exports = castPath;
    }
  });

  // node_modules/lodash/last.js
  var require_last = __commonJS({
    "node_modules/lodash/last.js"(exports, module) {
      function last5(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : void 0;
      }
      module.exports = last5;
    }
  });

  // node_modules/lodash/_toKey.js
  var require_toKey = __commonJS({
    "node_modules/lodash/_toKey.js"(exports, module) {
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module.exports = toKey;
    }
  });

  // node_modules/lodash/_baseGet.js
  var require_baseGet = __commonJS({
    "node_modules/lodash/_baseGet.js"(exports, module) {
      var castPath = require_castPath();
      var toKey = require_toKey();
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      module.exports = baseGet;
    }
  });

  // node_modules/lodash/_baseSlice.js
  var require_baseSlice = __commonJS({
    "node_modules/lodash/_baseSlice.js"(exports, module) {
      function baseSlice(array, start3, end2) {
        var index = -1, length = array.length;
        if (start3 < 0) {
          start3 = -start3 > length ? 0 : length + start3;
        }
        end2 = end2 > length ? length : end2;
        if (end2 < 0) {
          end2 += length;
        }
        length = start3 > end2 ? 0 : end2 - start3 >>> 0;
        start3 >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array[index + start3];
        }
        return result;
      }
      module.exports = baseSlice;
    }
  });

  // node_modules/lodash/_parent.js
  var require_parent = __commonJS({
    "node_modules/lodash/_parent.js"(exports, module) {
      var baseGet = require_baseGet();
      var baseSlice = require_baseSlice();
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      module.exports = parent;
    }
  });

  // node_modules/lodash/_baseUnset.js
  var require_baseUnset = __commonJS({
    "node_modules/lodash/_baseUnset.js"(exports, module) {
      var castPath = require_castPath();
      var last5 = require_last();
      var parent = require_parent();
      var toKey = require_toKey();
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last5(path))];
      }
      module.exports = baseUnset;
    }
  });

  // node_modules/lodash/_customOmitClone.js
  var require_customOmitClone = __commonJS({
    "node_modules/lodash/_customOmitClone.js"(exports, module) {
      var isPlainObject3 = require_isPlainObject();
      function customOmitClone(value) {
        return isPlainObject3(value) ? void 0 : value;
      }
      module.exports = customOmitClone;
    }
  });

  // node_modules/lodash/_isFlattenable.js
  var require_isFlattenable = __commonJS({
    "node_modules/lodash/_isFlattenable.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      module.exports = isFlattenable;
    }
  });

  // node_modules/lodash/_baseFlatten.js
  var require_baseFlatten = __commonJS({
    "node_modules/lodash/_baseFlatten.js"(exports, module) {
      var arrayPush = require_arrayPush();
      var isFlattenable = require_isFlattenable();
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      module.exports = baseFlatten;
    }
  });

  // node_modules/lodash/flatten.js
  var require_flatten = __commonJS({
    "node_modules/lodash/flatten.js"(exports, module) {
      var baseFlatten = require_baseFlatten();
      function flatten3(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      module.exports = flatten3;
    }
  });

  // node_modules/lodash/_flatRest.js
  var require_flatRest = __commonJS({
    "node_modules/lodash/_flatRest.js"(exports, module) {
      var flatten3 = require_flatten();
      var overRest = require_overRest();
      var setToString = require_setToString();
      function flatRest(func) {
        return setToString(overRest(func, void 0, flatten3), func + "");
      }
      module.exports = flatRest;
    }
  });

  // node_modules/lodash/omit.js
  var require_omit = __commonJS({
    "node_modules/lodash/omit.js"(exports, module) {
      var arrayMap = require_arrayMap();
      var baseClone = require_baseClone();
      var baseUnset = require_baseUnset();
      var castPath = require_castPath();
      var copyObject = require_copyObject();
      var customOmitClone = require_customOmitClone();
      var flatRest = require_flatRest();
      var getAllKeysIn = require_getAllKeysIn();
      var CLONE_DEEP_FLAG = 1;
      var CLONE_FLAT_FLAG = 2;
      var CLONE_SYMBOLS_FLAG = 4;
      var omit10 = flatRest(function(object, paths) {
        var result = {};
        if (object == null) {
          return result;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result);
        if (isDeep) {
          result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result, paths[length]);
        }
        return result;
      });
      module.exports = omit10;
    }
  });

  // node_modules/clone/clone.js
  var require_clone = __commonJS({
    "node_modules/clone/clone.js"(exports, module) {
      var clone5 = function() {
        "use strict";
        function _instanceof(obj, type) {
          return type != null && obj instanceof type;
        }
        var nativeMap;
        try {
          nativeMap = Map;
        } catch (_) {
          nativeMap = function() {
          };
        }
        var nativeSet;
        try {
          nativeSet = Set;
        } catch (_) {
          nativeSet = function() {
          };
        }
        var nativePromise;
        try {
          nativePromise = Promise;
        } catch (_) {
          nativePromise = function() {
          };
        }
        function clone6(parent, circular, depth, prototype, includeNonEnumerable) {
          if (typeof circular === "object") {
            depth = circular.depth;
            prototype = circular.prototype;
            includeNonEnumerable = circular.includeNonEnumerable;
            circular = circular.circular;
          }
          var allParents = [];
          var allChildren = [];
          var useBuffer = typeof Buffer != "undefined";
          if (typeof circular == "undefined")
            circular = true;
          if (typeof depth == "undefined")
            depth = Infinity;
          function _clone(parent2, depth2) {
            if (parent2 === null)
              return null;
            if (depth2 === 0)
              return parent2;
            var child;
            var proto;
            if (typeof parent2 != "object") {
              return parent2;
            }
            if (_instanceof(parent2, nativeMap)) {
              child = new nativeMap();
            } else if (_instanceof(parent2, nativeSet)) {
              child = new nativeSet();
            } else if (_instanceof(parent2, nativePromise)) {
              child = new nativePromise(function(resolve, reject) {
                parent2.then(function(value) {
                  resolve(_clone(value, depth2 - 1));
                }, function(err) {
                  reject(_clone(err, depth2 - 1));
                });
              });
            } else if (clone6.__isArray(parent2)) {
              child = [];
            } else if (clone6.__isRegExp(parent2)) {
              child = new RegExp(parent2.source, __getRegExpFlags(parent2));
              if (parent2.lastIndex)
                child.lastIndex = parent2.lastIndex;
            } else if (clone6.__isDate(parent2)) {
              child = new Date(parent2.getTime());
            } else if (useBuffer && Buffer.isBuffer(parent2)) {
              if (Buffer.allocUnsafe) {
                child = Buffer.allocUnsafe(parent2.length);
              } else {
                child = new Buffer(parent2.length);
              }
              parent2.copy(child);
              return child;
            } else if (_instanceof(parent2, Error)) {
              child = Object.create(parent2);
            } else {
              if (typeof prototype == "undefined") {
                proto = Object.getPrototypeOf(parent2);
                child = Object.create(proto);
              } else {
                child = Object.create(prototype);
                proto = prototype;
              }
            }
            if (circular) {
              var index = allParents.indexOf(parent2);
              if (index != -1) {
                return allChildren[index];
              }
              allParents.push(parent2);
              allChildren.push(child);
            }
            if (_instanceof(parent2, nativeMap)) {
              parent2.forEach(function(value, key) {
                var keyChild = _clone(key, depth2 - 1);
                var valueChild = _clone(value, depth2 - 1);
                child.set(keyChild, valueChild);
              });
            }
            if (_instanceof(parent2, nativeSet)) {
              parent2.forEach(function(value) {
                var entryChild = _clone(value, depth2 - 1);
                child.add(entryChild);
              });
            }
            for (var i in parent2) {
              var attrs;
              if (proto) {
                attrs = Object.getOwnPropertyDescriptor(proto, i);
              }
              if (attrs && attrs.set == null) {
                continue;
              }
              child[i] = _clone(parent2[i], depth2 - 1);
            }
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(parent2);
              for (var i = 0; i < symbols.length; i++) {
                var symbol = symbols[i];
                var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
                if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                  continue;
                }
                child[symbol] = _clone(parent2[symbol], depth2 - 1);
                if (!descriptor.enumerable) {
                  Object.defineProperty(child, symbol, {
                    enumerable: false
                  });
                }
              }
            }
            if (includeNonEnumerable) {
              var allPropertyNames = Object.getOwnPropertyNames(parent2);
              for (var i = 0; i < allPropertyNames.length; i++) {
                var propertyName = allPropertyNames[i];
                var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
                if (descriptor && descriptor.enumerable) {
                  continue;
                }
                child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
                Object.defineProperty(child, propertyName, {
                  enumerable: false
                });
              }
            }
            return child;
          }
          return _clone(parent, depth);
        }
        clone6.clonePrototype = function clonePrototype(parent) {
          if (parent === null)
            return null;
          var c = function() {
          };
          c.prototype = parent;
          return new c();
        };
        function __objToStr(o) {
          return Object.prototype.toString.call(o);
        }
        clone6.__objToStr = __objToStr;
        function __isDate(o) {
          return typeof o === "object" && __objToStr(o) === "[object Date]";
        }
        clone6.__isDate = __isDate;
        function __isArray(o) {
          return typeof o === "object" && __objToStr(o) === "[object Array]";
        }
        clone6.__isArray = __isArray;
        function __isRegExp(o) {
          return typeof o === "object" && __objToStr(o) === "[object RegExp]";
        }
        clone6.__isRegExp = __isRegExp;
        function __getRegExpFlags(re) {
          var flags = "";
          if (re.global)
            flags += "g";
          if (re.ignoreCase)
            flags += "i";
          if (re.multiline)
            flags += "m";
          return flags;
        }
        clone6.__getRegExpFlags = __getRegExpFlags;
        return clone6;
      }();
      if (typeof module === "object" && module.exports) {
        module.exports = clone5;
      }
    }
  });

  // node_modules/lodash/_baseSet.js
  var require_baseSet = __commonJS({
    "node_modules/lodash/_baseSet.js"(exports, module) {
      var assignValue = require_assignValue();
      var castPath = require_castPath();
      var isIndex = require_isIndex();
      var isObject8 = require_isObject();
      var toKey = require_toKey();
      function baseSet(object, path, value, customizer) {
        if (!isObject8(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
              newValue = isObject8(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      module.exports = baseSet;
    }
  });

  // node_modules/lodash/_basePickBy.js
  var require_basePickBy = __commonJS({
    "node_modules/lodash/_basePickBy.js"(exports, module) {
      var baseGet = require_baseGet();
      var baseSet = require_baseSet();
      var castPath = require_castPath();
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result, castPath(path, object), value);
          }
        }
        return result;
      }
      module.exports = basePickBy;
    }
  });

  // node_modules/lodash/_baseHasIn.js
  var require_baseHasIn = __commonJS({
    "node_modules/lodash/_baseHasIn.js"(exports, module) {
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      module.exports = baseHasIn;
    }
  });

  // node_modules/lodash/_hasPath.js
  var require_hasPath = __commonJS({
    "node_modules/lodash/_hasPath.js"(exports, module) {
      var castPath = require_castPath();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isIndex = require_isIndex();
      var isLength = require_isLength();
      var toKey = require_toKey();
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      module.exports = hasPath;
    }
  });

  // node_modules/lodash/hasIn.js
  var require_hasIn = __commonJS({
    "node_modules/lodash/hasIn.js"(exports, module) {
      var baseHasIn = require_baseHasIn();
      var hasPath = require_hasPath();
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      module.exports = hasIn;
    }
  });

  // node_modules/lodash/_basePick.js
  var require_basePick = __commonJS({
    "node_modules/lodash/_basePick.js"(exports, module) {
      var basePickBy = require_basePickBy();
      var hasIn = require_hasIn();
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      module.exports = basePick;
    }
  });

  // node_modules/lodash/pick.js
  var require_pick = __commonJS({
    "node_modules/lodash/pick.js"(exports, module) {
      var basePick = require_basePick();
      var flatRest = require_flatRest();
      var pick8 = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      module.exports = pick8;
    }
  });

  // node_modules/sqlstring/lib/SqlString.js
  var require_SqlString = __commonJS({
    "node_modules/sqlstring/lib/SqlString.js"(exports) {
      var SqlString2 = exports;
      var ID_GLOBAL_REGEXP = /`/g;
      var QUAL_GLOBAL_REGEXP = /\./g;
      var CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g;
      var CHARS_ESCAPE_MAP = {
        "\0": "\\0",
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\r": "\\r",
        "": "\\Z",
        '"': '\\"',
        "'": "\\'",
        "\\": "\\\\"
      };
      SqlString2.escapeId = function escapeId(val, forbidQualified) {
        if (Array.isArray(val)) {
          var sql = "";
          for (var i = 0; i < val.length; i++) {
            sql += (i === 0 ? "" : ", ") + SqlString2.escapeId(val[i], forbidQualified);
          }
          return sql;
        } else if (forbidQualified) {
          return "`" + String(val).replace(ID_GLOBAL_REGEXP, "``") + "`";
        } else {
          return "`" + String(val).replace(ID_GLOBAL_REGEXP, "``").replace(QUAL_GLOBAL_REGEXP, "`.`") + "`";
        }
      };
      SqlString2.escape = function escape(val, stringifyObjects, timeZone) {
        if (val === void 0 || val === null) {
          return "NULL";
        }
        switch (typeof val) {
          case "boolean":
            return val ? "true" : "false";
          case "number":
            return val + "";
          case "object":
            if (Object.prototype.toString.call(val) === "[object Date]") {
              return SqlString2.dateToString(val, timeZone || "local");
            } else if (Array.isArray(val)) {
              return SqlString2.arrayToList(val, timeZone);
            } else if (Buffer.isBuffer(val)) {
              return SqlString2.bufferToString(val);
            } else if (typeof val.toSqlString === "function") {
              return String(val.toSqlString());
            } else if (stringifyObjects) {
              return escapeString(val.toString());
            } else {
              return SqlString2.objectToValues(val, timeZone);
            }
          default:
            return escapeString(val);
        }
      };
      SqlString2.arrayToList = function arrayToList(array, timeZone) {
        var sql = "";
        for (var i = 0; i < array.length; i++) {
          var val = array[i];
          if (Array.isArray(val)) {
            sql += (i === 0 ? "" : ", ") + "(" + SqlString2.arrayToList(val, timeZone) + ")";
          } else {
            sql += (i === 0 ? "" : ", ") + SqlString2.escape(val, true, timeZone);
          }
        }
        return sql;
      };
      SqlString2.format = function format4(sql, values, stringifyObjects, timeZone) {
        if (values == null) {
          return sql;
        }
        if (!Array.isArray(values)) {
          values = [values];
        }
        var chunkIndex = 0;
        var placeholdersRegex = /\?+/g;
        var result = "";
        var valuesIndex = 0;
        var match2;
        while (valuesIndex < values.length && (match2 = placeholdersRegex.exec(sql))) {
          var len = match2[0].length;
          if (len > 2) {
            continue;
          }
          var value = len === 2 ? SqlString2.escapeId(values[valuesIndex]) : SqlString2.escape(values[valuesIndex], stringifyObjects, timeZone);
          result += sql.slice(chunkIndex, match2.index) + value;
          chunkIndex = placeholdersRegex.lastIndex;
          valuesIndex++;
        }
        if (chunkIndex === 0) {
          return sql;
        }
        if (chunkIndex < sql.length) {
          return result + sql.slice(chunkIndex);
        }
        return result;
      };
      SqlString2.dateToString = function dateToString(date, timeZone) {
        var dt = new Date(date);
        if (isNaN(dt.getTime())) {
          return "NULL";
        }
        var year;
        var month;
        var day;
        var hour;
        var minute;
        var second;
        var millisecond;
        if (timeZone === "local") {
          year = dt.getFullYear();
          month = dt.getMonth() + 1;
          day = dt.getDate();
          hour = dt.getHours();
          minute = dt.getMinutes();
          second = dt.getSeconds();
          millisecond = dt.getMilliseconds();
        } else {
          var tz = convertTimezone(timeZone);
          if (tz !== false && tz !== 0) {
            dt.setTime(dt.getTime() + tz * 6e4);
          }
          year = dt.getUTCFullYear();
          month = dt.getUTCMonth() + 1;
          day = dt.getUTCDate();
          hour = dt.getUTCHours();
          minute = dt.getUTCMinutes();
          second = dt.getUTCSeconds();
          millisecond = dt.getUTCMilliseconds();
        }
        var str = zeroPad(year, 4) + "-" + zeroPad(month, 2) + "-" + zeroPad(day, 2) + " " + zeroPad(hour, 2) + ":" + zeroPad(minute, 2) + ":" + zeroPad(second, 2) + "." + zeroPad(millisecond, 3);
        return escapeString(str);
      };
      SqlString2.bufferToString = function bufferToString(buffer) {
        return "X" + escapeString(buffer.toString("hex"));
      };
      SqlString2.objectToValues = function objectToValues(object, timeZone) {
        var sql = "";
        for (var key in object) {
          var val = object[key];
          if (typeof val === "function") {
            continue;
          }
          sql += (sql.length === 0 ? "" : ", ") + SqlString2.escapeId(key) + " = " + SqlString2.escape(val, true, timeZone);
        }
        return sql;
      };
      SqlString2.raw = function raw(sql) {
        if (typeof sql !== "string") {
          throw new TypeError("argument sql must be a string");
        }
        return {
          toSqlString: function toSqlString() {
            return sql;
          }
        };
      };
      function escapeString(val) {
        var chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
        var escapedVal = "";
        var match2;
        while (match2 = CHARS_GLOBAL_REGEXP.exec(val)) {
          escapedVal += val.slice(chunkIndex, match2.index) + CHARS_ESCAPE_MAP[match2[0]];
          chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
        }
        if (chunkIndex === 0) {
          return "'" + val + "'";
        }
        if (chunkIndex < val.length) {
          return "'" + escapedVal + val.slice(chunkIndex) + "'";
        }
        return "'" + escapedVal + "'";
      }
      function zeroPad(number, length) {
        number = number.toString();
        while (number.length < length) {
          number = "0" + number;
        }
        return number;
      }
      function convertTimezone(tz) {
        if (tz === "Z") {
          return 0;
        }
        var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
        if (m) {
          return (m[1] === "-" ? -1 : 1) * (parseInt(m[2], 10) + (m[3] ? parseInt(m[3], 10) : 0) / 60) * 60;
        }
        return false;
      }
    }
  });

  // node_modules/sqlstring/index.js
  var require_sqlstring = __commonJS({
    "node_modules/sqlstring/index.js"(exports, module) {
      module.exports = require_SqlString();
    }
  });

  // node_modules/spel2js/dist/spel2js.js
  var require_spel2js = __commonJS({
    "node_modules/spel2js/dist/spel2js.js"(exports, module) {
      (function webpackUniversalModuleDefinition(root, factory15) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory15();
        else if (typeof define === "function" && define.amd)
          define([], factory15);
        else if (typeof exports === "object")
          exports["spel2js"] = factory15();
        else
          root["spel2js"] = factory15();
      })(exports, function() {
        return (
          /******/
          function(modules) {
            var installedModules = {};
            function __webpack_require__(moduleId) {
              if (installedModules[moduleId]) {
                return installedModules[moduleId].exports;
              }
              var module2 = installedModules[moduleId] = {
                /******/
                i: moduleId,
                /******/
                l: false,
                /******/
                exports: {}
                /******/
              };
              modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
              module2.l = true;
              return module2.exports;
            }
            __webpack_require__.m = modules;
            __webpack_require__.c = installedModules;
            __webpack_require__.d = function(exports2, name, getter) {
              if (!__webpack_require__.o(exports2, name)) {
                Object.defineProperty(exports2, name, {
                  /******/
                  configurable: false,
                  /******/
                  enumerable: true,
                  /******/
                  get: getter
                  /******/
                });
              }
            };
            __webpack_require__.n = function(module2) {
              var getter = module2 && module2.__esModule ? (
                /******/
                function getDefault() {
                  return module2["default"];
                }
              ) : (
                /******/
                function getModuleExports() {
                  return module2;
                }
              );
              __webpack_require__.d(getter, "a", getter);
              return getter;
            };
            __webpack_require__.o = function(object, property) {
              return Object.prototype.hasOwnProperty.call(object, property);
            };
            __webpack_require__.p = "";
            return __webpack_require__(__webpack_require__.s = 3);
          }([
            /* 0 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              function createSpelNode(nodeType, position) {
                var node = {}, type = nodeType || "Abstract", children = [], parent = null, activeContext;
                node._type = type;
                node.getType = function() {
                  return type;
                };
                node.setType = function(nodeType2) {
                  type = nodeType2;
                };
                node.getChildren = function() {
                  return children;
                };
                node.addChild = function(childNode) {
                  if (!childNode) {
                    return;
                  }
                  if (!childNode.setParent) {
                    throw {
                      name: "Error",
                      message: "Trying to add a child which is not a node: " + JSON.stringify(childNode)
                    };
                  }
                  childNode.setParent(node);
                  children.push(childNode);
                };
                node.getParent = function() {
                  return parent;
                };
                node.setParent = function(parentNode) {
                  parent = parentNode;
                };
                node.getContext = function(state) {
                  return activeContext || state.activeContext.peek();
                };
                node.setContext = function(nodeContext) {
                  activeContext = nodeContext;
                };
                node.getStartPosition = function() {
                  return position >> 16;
                };
                node.getEndPosition = function() {
                  return position & 65535;
                };
                node.getValue = function() {
                  throw {
                    name: "MethodNotImplementedException",
                    message: "SpelNode#getValue() must be overridden."
                  };
                };
                node.toString = function() {
                  var s = "Kind: " + node.getType();
                  s += ", Children: [";
                  for (var i = 0, l = node.getChildren().length; i < l; i += 1) {
                    s += "{" + node.getChildren()[i] + "}, ";
                  }
                  s += "]";
                  return s;
                };
                if (position === 0) {
                  throw {
                    name: "Error",
                    message: "Position cannot be 0"
                  };
                }
                for (var _len = arguments.length, operands = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                  operands[_key - 2] = arguments[_key];
                }
                if (operands) {
                  operands.forEach(function(operand) {
                    node.addChild(operand);
                  });
                }
                return node;
              }
              var SpelNode = exports2.SpelNode = {
                create: createSpelNode
              };
            },
            /* 1 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Stack = Stack2;
              function Stack2(startingElements) {
                this.elements = startingElements || [];
              }
              Stack2.prototype.push = function(el) {
                this.elements.push(el);
                return el;
              };
              Stack2.prototype.pop = function() {
                return this.elements.pop();
              };
              Stack2.prototype.peek = function() {
                return this.elements[this.elements.length - 1];
              };
              Stack2.prototype.empty = function() {
                return this.elements.length > 0;
              };
              Stack2.prototype.search = function(el) {
                return this.elements.length - this.elements.indexOf(el);
              };
            },
            /* 2 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              var types4 = {
                LITERAL_INT: 1,
                //tested
                LITERAL_LONG: 2,
                //tested
                LITERAL_HEXINT: 3,
                //tested
                LITERAL_HEXLONG: 4,
                //tested
                LITERAL_STRING: 5,
                //tested
                LITERAL_REAL: 6,
                //tested
                LITERAL_REAL_FLOAT: 7,
                //tested
                LPAREN: "(",
                //tested
                RPAREN: ")",
                //tested
                COMMA: ",",
                //tested
                IDENTIFIER: 0,
                //tested
                COLON: ":",
                //tested
                HASH: "#",
                //tested
                RSQUARE: "]",
                //tested
                LSQUARE: "[",
                //tested
                LCURLY: "{",
                //tested
                RCURLY: "}",
                //tested
                DOT: ".",
                //tested
                PLUS: "+",
                //tested
                STAR: "*",
                //tested
                MINUS: "-",
                //tested
                SELECT_FIRST: "^[",
                //tested
                SELECT_LAST: "$[",
                //tested
                QMARK: "?",
                //tested
                PROJECT: "![",
                //tested
                DIV: "/",
                //tested
                GE: ">=",
                //tested
                GT: ">",
                //tested
                LE: "<=",
                //tested
                LT: "<",
                //tested
                EQ: "==",
                //tested
                NE: "!=",
                //tested
                MOD: "%",
                //tested
                NOT: "!",
                //tested
                ASSIGN: "=",
                //tested
                INSTANCEOF: "instanceof",
                //test fails
                MATCHES: "matches",
                //test fails
                BETWEEN: "between",
                //test fails
                SELECT: "?[",
                //tested
                POWER: "^",
                //tested
                ELVIS: "?:",
                //tested
                SAFE_NAVI: "?.",
                //tested
                BEAN_REF: "@",
                //tested
                SYMBOLIC_OR: "||",
                //tested
                SYMBOLIC_AND: "&&",
                //tested
                INC: "++",
                //tested
                DEC: "--"
                //tested
              };
              function TokenKind(type) {
                this.type = type;
                this.tokenChars = types4[type];
                this._hasPayload = typeof types4[type] !== "string";
                if (typeof types4[type] === "number") {
                  this._ordinal = types4[type];
                }
              }
              for (var t in types4) {
                if (types4.hasOwnProperty(t)) {
                  TokenKind[t] = new TokenKind(t);
                }
              }
              TokenKind.prototype.toString = function() {
                return this.type + (this.tokenChars.length !== 0 ? "(" + this.tokenChars + ")" : "");
              };
              TokenKind.prototype.getLength = function() {
                return this.tokenChars.length;
              };
              TokenKind.prototype.hasPayload = function() {
                return this._hasPayload;
              };
              TokenKind.prototype.valueOf = function(id) {
                for (var t2 in types4) {
                  if (types4.hasOwnProperty(t2) && types4[t2] === id) {
                    return TokenKind[t2];
                  }
                }
              };
              TokenKind.prototype.ordinal = function() {
                return this._ordinal;
              };
              exports2.TokenKind = TokenKind;
            },
            /* 3 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StandardContext = exports2.SpelExpressionEvaluator = void 0;
              var _SpelExpressionEvaluator = __webpack_require__(4);
              var _StandardContext = __webpack_require__(50);
              exports2.SpelExpressionEvaluator = _SpelExpressionEvaluator.SpelExpressionEvaluator;
              exports2.StandardContext = _StandardContext.StandardContext;
            },
            /* 4 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SpelExpressionEvaluator = void 0;
              var _SpelExpressionParser = __webpack_require__(5);
              var _Stack = __webpack_require__(1);
              var spelExpressionEvaluator = {};
              function evalCompiled(compiledExpression, context, locals) {
                var activeContext = new _Stack.Stack(), state;
                if (!context) {
                  context = {};
                }
                activeContext.push(context);
                state = {
                  rootContext: context,
                  activeContext,
                  locals
                };
                return compiledExpression.getValue(state);
              }
              spelExpressionEvaluator.compile = function(expression) {
                var compiledExpression = (0, _SpelExpressionParser.SpelExpressionParser)().parse(expression);
                return {
                  eval: function _eval(context, locals) {
                    return evalCompiled(compiledExpression, context, locals);
                  },
                  _compiledExpression: compiledExpression
                };
              };
              spelExpressionEvaluator.eval = function(expression, context, locals) {
                return spelExpressionEvaluator.compile(expression).eval(context, locals);
              };
              exports2.SpelExpressionEvaluator = spelExpressionEvaluator;
            },
            /* 5 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SpelExpressionParser = void 0;
              var _TokenKind = __webpack_require__(2);
              var _Tokenizer = __webpack_require__(6);
              var _BooleanLiteral = __webpack_require__(8);
              var _NumberLiteral = __webpack_require__(9);
              var _StringLiteral = __webpack_require__(10);
              var _NullLiteral = __webpack_require__(11);
              var _FunctionReference = __webpack_require__(12);
              var _MethodReference = __webpack_require__(13);
              var _PropertyReference = __webpack_require__(14);
              var _VariableReference = __webpack_require__(15);
              var _CompoundExpression = __webpack_require__(16);
              var _Indexer = __webpack_require__(17);
              var _Assign = __webpack_require__(18);
              var _OpEQ = __webpack_require__(19);
              var _OpNE = __webpack_require__(20);
              var _OpGE = __webpack_require__(21);
              var _OpGT = __webpack_require__(22);
              var _OpLE = __webpack_require__(23);
              var _OpLT = __webpack_require__(24);
              var _OpPlus = __webpack_require__(25);
              var _OpMinus = __webpack_require__(26);
              var _OpMultiply = __webpack_require__(27);
              var _OpDivide = __webpack_require__(28);
              var _OpModulus = __webpack_require__(29);
              var _OpPower = __webpack_require__(30);
              var _OpInc = __webpack_require__(31);
              var _OpDec = __webpack_require__(32);
              var _OpNot = __webpack_require__(33);
              var _OpAnd = __webpack_require__(34);
              var _OpOr = __webpack_require__(35);
              var _OpMatches = __webpack_require__(36);
              var _Ternary = __webpack_require__(37);
              var _Elvis = __webpack_require__(38);
              var _InlineList = __webpack_require__(39);
              var _InlineMap = __webpack_require__(40);
              var _Selection = __webpack_require__(41);
              var _Projection = __webpack_require__(42);
              var _OpInstanceof = __webpack_require__(43);
              var _OpBetween = __webpack_require__(44);
              var _TypeReference = __webpack_require__(45);
              var _BeanReference = __webpack_require__(46);
              var _Identifier = __webpack_require__(47);
              var _QualifiedIdentifier = __webpack_require__(48);
              var _ConstructorReference = __webpack_require__(49);
              var SpelExpressionParser = exports2.SpelExpressionParser = function SpelExpressionParser2() {
                var VALID_QUALIFIED_ID_PATTERN = new RegExp("[\\p{L}\\p{N}_$]+");
                var configuration;
                var constructedNodes = [];
                var expressionString;
                var tokenStream;
                var tokenStreamLength;
                var tokenStreamPointer;
                function setConfiguration(config2) {
                  configuration = config2;
                }
                function parse(expression, context) {
                  try {
                    expressionString = expression;
                    tokenStream = _Tokenizer.Tokenizer.tokenize(expression);
                    tokenStreamLength = tokenStream.length;
                    tokenStreamPointer = 0;
                    constructedNodes = [];
                    var ast = eatExpression();
                    if (moreTokens()) {
                      raiseInternalException(peekToken().startPos, "MORE_INPUT", nextToken().toString());
                    }
                    return ast;
                  } catch (e) {
                    throw e.message;
                  }
                }
                function eatExpression() {
                  var expr = eatLogicalOrExpression();
                  if (moreTokens()) {
                    var token = peekToken();
                    if (token.getKind() === _TokenKind.TokenKind.ASSIGN) {
                      if (expr === null) {
                        expr = _NullLiteral.NullLiteral.create(toPosBounds(token.startPos - 1, token.endPos - 1));
                      }
                      nextToken();
                      var assignedValue = eatLogicalOrExpression();
                      return _Assign.Assign.create(toPosToken(token), expr, assignedValue);
                    }
                    if (token.getKind() === _TokenKind.TokenKind.ELVIS) {
                      if (expr === null) {
                        expr = _NullLiteral.NullLiteral.create(toPosBounds(token.startPos - 1, token.endPos - 2));
                      }
                      nextToken();
                      var valueIfNull = eatExpression();
                      if (valueIfNull === null) {
                        valueIfNull = _NullLiteral.NullLiteral.create(toPosBounds(token.startPos + 1, token.endPos + 1));
                      }
                      return _Elvis.Elvis.create(toPosToken(token), expr, valueIfNull);
                    }
                    if (token.getKind() === _TokenKind.TokenKind.QMARK) {
                      if (expr === null) {
                        expr = _NullLiteral.NullLiteral.create(toPosBounds(token.startPos - 1, token.endPos - 1));
                      }
                      nextToken();
                      var ifTrueExprValue = eatExpression();
                      eatToken(_TokenKind.TokenKind.COLON);
                      var ifFalseExprValue = eatExpression();
                      return _Ternary.Ternary.create(toPosToken(token), expr, ifTrueExprValue, ifFalseExprValue);
                    }
                  }
                  return expr;
                }
                function eatLogicalOrExpression() {
                  var expr = eatLogicalAndExpression();
                  while (peekIdentifierToken("or") || peekTokenOne(_TokenKind.TokenKind.SYMBOLIC_OR)) {
                    var token = nextToken();
                    var rhExpr = eatLogicalAndExpression();
                    checkOperands(token, expr, rhExpr);
                    expr = _OpOr.OpOr.create(toPosToken(token), expr, rhExpr);
                  }
                  return expr;
                }
                function eatLogicalAndExpression() {
                  var expr = eatRelationalExpression();
                  while (peekIdentifierToken("and") || peekTokenOne(_TokenKind.TokenKind.SYMBOLIC_AND)) {
                    var token = nextToken();
                    var rhExpr = eatRelationalExpression();
                    checkOperands(token, expr, rhExpr);
                    expr = _OpAnd.OpAnd.create(toPosToken(token), expr, rhExpr);
                  }
                  return expr;
                }
                function eatRelationalExpression() {
                  var expr = eatSumExpression();
                  var relationalOperatorToken = maybeEatRelationalOperator();
                  if (relationalOperatorToken !== null) {
                    var token = nextToken();
                    var rhExpr = eatSumExpression();
                    checkOperands(token, expr, rhExpr);
                    var tk = relationalOperatorToken.kind;
                    if (relationalOperatorToken.isNumericRelationalOperator()) {
                      var pos = toPosToken(token);
                      if (tk === _TokenKind.TokenKind.GT) {
                        return _OpGT.OpGT.create(pos, expr, rhExpr);
                      }
                      if (tk === _TokenKind.TokenKind.LT) {
                        return _OpLT.OpLT.create(pos, expr, rhExpr);
                      }
                      if (tk === _TokenKind.TokenKind.LE) {
                        return _OpLE.OpLE.create(pos, expr, rhExpr);
                      }
                      if (tk === _TokenKind.TokenKind.GE) {
                        return _OpGE.OpGE.create(pos, expr, rhExpr);
                      }
                      if (tk === _TokenKind.TokenKind.EQ) {
                        return _OpEQ.OpEQ.create(pos, expr, rhExpr);
                      }
                      return _OpNE.OpNE.create(pos, expr, rhExpr);
                    }
                    if (tk === _TokenKind.TokenKind.INSTANCEOF) {
                      return _OpInstanceof.OpInstanceof.create(toPosToken(token), expr, rhExpr);
                    }
                    if (tk === _TokenKind.TokenKind.MATCHES) {
                      return _OpMatches.OpMatches.create(toPosToken(token), expr, rhExpr);
                    }
                    return _OpBetween.OpBetween.create(toPosToken(token), expr, rhExpr);
                  }
                  return expr;
                }
                function eatSumExpression() {
                  var expr = eatProductExpression();
                  while (peekTokenAny(_TokenKind.TokenKind.PLUS, _TokenKind.TokenKind.MINUS, _TokenKind.TokenKind.INC)) {
                    var token = nextToken();
                    var rhExpr = eatProductExpression();
                    checkRightOperand(token, rhExpr);
                    if (token.getKind() === _TokenKind.TokenKind.PLUS) {
                      expr = _OpPlus.OpPlus.create(toPosToken(token), expr, rhExpr);
                    } else if (token.getKind() === _TokenKind.TokenKind.MINUS) {
                      expr = _OpMinus.OpMinus.create(toPosToken(token), expr, rhExpr);
                    }
                  }
                  return expr;
                }
                function eatProductExpression() {
                  var expr = eatPowerIncDecExpression();
                  while (peekTokenAny(_TokenKind.TokenKind.STAR, _TokenKind.TokenKind.DIV, _TokenKind.TokenKind.MOD)) {
                    var token = nextToken();
                    var rhExpr = eatPowerIncDecExpression();
                    checkOperands(token, expr, rhExpr);
                    if (token.getKind() === _TokenKind.TokenKind.STAR) {
                      expr = _OpMultiply.OpMultiply.create(toPosToken(token), expr, rhExpr);
                    } else if (token.getKind() === _TokenKind.TokenKind.DIV) {
                      expr = _OpDivide.OpDivide.create(toPosToken(token), expr, rhExpr);
                    } else {
                      expr = _OpModulus.OpModulus.create(toPosToken(token), expr, rhExpr);
                    }
                  }
                  return expr;
                }
                function eatPowerIncDecExpression() {
                  var expr = eatUnaryExpression(), token;
                  if (peekTokenOne(_TokenKind.TokenKind.POWER)) {
                    token = nextToken();
                    var rhExpr = eatUnaryExpression();
                    checkRightOperand(token, rhExpr);
                    return _OpPower.OpPower.create(toPosToken(token), expr, rhExpr);
                  }
                  if (expr !== null && peekTokenAny(_TokenKind.TokenKind.INC, _TokenKind.TokenKind.DEC)) {
                    token = nextToken();
                    if (token.getKind() === _TokenKind.TokenKind.INC) {
                      return _OpInc.OpInc.create(toPosToken(token), true, expr);
                    }
                    return _OpDec.OpDec.create(toPosToken(token), true, expr);
                  }
                  return expr;
                }
                function eatUnaryExpression() {
                  var token, expr;
                  if (peekTokenAny(_TokenKind.TokenKind.PLUS, _TokenKind.TokenKind.MINUS, _TokenKind.TokenKind.NOT)) {
                    token = nextToken();
                    expr = eatUnaryExpression();
                    if (token.getKind() === _TokenKind.TokenKind.NOT) {
                      return _OpNot.OpNot.create(toPosToken(token), expr);
                    }
                    if (token.getKind() === _TokenKind.TokenKind.PLUS) {
                      return _OpPlus.OpPlus.create(toPosToken(token), expr);
                    }
                    return _OpMinus.OpMinus.create(toPosToken(token), expr);
                  }
                  if (peekTokenAny(_TokenKind.TokenKind.INC, _TokenKind.TokenKind.DEC)) {
                    token = nextToken();
                    expr = eatUnaryExpression();
                    if (token.getKind() === _TokenKind.TokenKind.INC) {
                      return _OpInc.OpInc.create(toPosToken(token), false, expr);
                    }
                    return _OpDec.OpDec.create(toPosToken(token), false, expr);
                  }
                  return eatPrimaryExpression();
                }
                function eatPrimaryExpression() {
                  var nodes = [];
                  var start3 = eatStartNode();
                  nodes.push(start3);
                  while (maybeEatNode()) {
                    nodes.push(pop());
                  }
                  if (nodes.length === 1) {
                    return nodes[0];
                  }
                  return _CompoundExpression.CompoundExpression.create(toPosBounds(start3.getStartPosition(), nodes[nodes.length - 1].getEndPosition()), nodes);
                }
                function maybeEatNode() {
                  var expr = null;
                  if (peekTokenAny(_TokenKind.TokenKind.DOT, _TokenKind.TokenKind.SAFE_NAVI)) {
                    expr = eatDottedNode();
                  } else {
                    expr = maybeEatNonDottedNode();
                  }
                  if (expr === null) {
                    return false;
                  } else {
                    push(expr);
                    return true;
                  }
                }
                function maybeEatNonDottedNode() {
                  if (peekTokenOne(_TokenKind.TokenKind.LSQUARE)) {
                    if (maybeEatIndexer()) {
                      return pop();
                    }
                  }
                  return null;
                }
                function eatDottedNode() {
                  var token = nextToken();
                  var nullSafeNavigation = token.getKind() === _TokenKind.TokenKind.SAFE_NAVI;
                  if (maybeEatMethodOrProperty(nullSafeNavigation) || maybeEatFunctionOrVar() || maybeEatProjection(nullSafeNavigation) || maybeEatSelection(nullSafeNavigation)) {
                    return pop();
                  }
                  if (peekToken() === null) {
                    raiseInternalException(token.startPos, "OOD");
                  } else {
                    raiseInternalException(token.startPos, "UNEXPECTED_DATA_AFTER_DOT", toString(peekToken()));
                  }
                  return null;
                }
                function maybeEatFunctionOrVar() {
                  if (!peekTokenOne(_TokenKind.TokenKind.HASH)) {
                    return false;
                  }
                  var token = nextToken();
                  var functionOrVariableName = eatToken(_TokenKind.TokenKind.IDENTIFIER);
                  var args = maybeEatMethodArgs();
                  if (args === null) {
                    push(_VariableReference.VariableReference.create(functionOrVariableName.data, toPosBounds(token.startPos, functionOrVariableName.endPos)));
                    return true;
                  }
                  push(_FunctionReference.FunctionReference.create(functionOrVariableName.data, toPosBounds(token.startPos, functionOrVariableName.endPos), args));
                  return true;
                }
                function maybeEatMethodArgs() {
                  if (!peekTokenOne(_TokenKind.TokenKind.LPAREN)) {
                    return null;
                  }
                  var args = [];
                  consumeArguments(args);
                  eatToken(_TokenKind.TokenKind.RPAREN);
                  return args;
                }
                function eatConstructorArgs(accumulatedArguments) {
                  if (!peekTokenOne(_TokenKind.TokenKind.LPAREN)) {
                    raiseInternalException(toPosToken(peekToken()), "MISSING_CONSTRUCTOR_ARGS");
                  }
                  consumeArguments(accumulatedArguments);
                  eatToken(_TokenKind.TokenKind.RPAREN);
                }
                function consumeArguments(accumulatedArguments) {
                  var pos = peekToken().startPos;
                  var next;
                  do {
                    nextToken();
                    var token = peekToken();
                    if (token === null) {
                      raiseInternalException(pos, "RUN_OUT_OF_ARGUMENTS");
                    }
                    if (token.getKind() !== _TokenKind.TokenKind.RPAREN) {
                      accumulatedArguments.push(eatExpression());
                    }
                    next = peekToken();
                  } while (next !== null && next.kind === _TokenKind.TokenKind.COMMA);
                  if (next === null) {
                    raiseInternalException(pos, "RUN_OUT_OF_ARGUMENTS");
                  }
                }
                function positionOf(token) {
                  if (token === null) {
                    return expressionString.length;
                  }
                  return token.startPos;
                }
                function eatStartNode() {
                  if (maybeEatLiteral()) {
                    return pop();
                  } else if (maybeEatParenExpression()) {
                    return pop();
                  } else if (maybeEatTypeReference() || maybeEatNullReference() || maybeEatConstructorReference() || maybeEatMethodOrProperty(false) || maybeEatFunctionOrVar()) {
                    return pop();
                  } else if (maybeEatBeanReference()) {
                    return pop();
                  } else if (maybeEatProjection(false) || maybeEatSelection(false) || maybeEatIndexer()) {
                    return pop();
                  } else if (maybeEatInlineListOrMap()) {
                    return pop();
                  } else {
                    return null;
                  }
                }
                function maybeEatBeanReference() {
                  if (peekTokenOne(_TokenKind.TokenKind.BEAN_REF)) {
                    var beanRefToken = nextToken();
                    var beanNameToken = null;
                    var beanName = null;
                    if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                      beanNameToken = eatToken(_TokenKind.TokenKind.IDENTIFIER);
                      beanName = beanNameToken.data;
                    } else if (peekTokenOne(_TokenKind.TokenKind.LITERAL_STRING)) {
                      beanNameToken = eatToken(_TokenKind.TokenKind.LITERAL_STRING);
                      beanName = beanNameToken.stringValue();
                      beanName = beanName.substring(1, beanName.length() - 1);
                    } else {
                      raiseInternalException(beanRefToken.startPos, "INVALID_BEAN_REFERENCE");
                    }
                    var beanReference = _BeanReference.BeanReference.create(toPosToken(beanNameToken), beanName);
                    push(beanReference);
                    return true;
                  }
                  return false;
                }
                function maybeEatTypeReference() {
                  if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                    var typeName = peekToken();
                    if (typeName.stringValue() !== "T") {
                      return false;
                    }
                    var token = nextToken();
                    if (peekTokenOne(_TokenKind.TokenKind.RSQUARE)) {
                      push(_PropertyReference.PropertyReference.create(token.stringValue(), toPosToken(token)));
                      return true;
                    }
                    eatToken(_TokenKind.TokenKind.LPAREN);
                    var node = eatPossiblyQualifiedId();
                    var dims = 0;
                    while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.LSQUARE, true)) {
                      eatToken(_TokenKind.TokenKind.RSQUARE);
                      dims++;
                    }
                    eatToken(_TokenKind.TokenKind.RPAREN);
                    push(_TypeReference.TypeReference.create(toPosToken(typeName), node, dims));
                    return true;
                  }
                  return false;
                }
                function maybeEatNullReference() {
                  if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                    var nullToken = peekToken();
                    if (nullToken.stringValue().toLowerCase() !== "null") {
                      return false;
                    }
                    nextToken();
                    push(_NullLiteral.NullLiteral.create(toPosToken(nullToken)));
                    return true;
                  }
                  return false;
                }
                function maybeEatProjection(nullSafeNavigation) {
                  var token = peekToken();
                  if (!peekTokenConsumeIfMatched(_TokenKind.TokenKind.PROJECT, true)) {
                    return false;
                  }
                  var expr = eatExpression();
                  eatToken(_TokenKind.TokenKind.RSQUARE);
                  push(_Projection.Projection.create(nullSafeNavigation, toPosToken(token), expr));
                  return true;
                }
                function maybeEatInlineListOrMap() {
                  var token = peekToken(), listElements = [];
                  if (!peekTokenConsumeIfMatched(_TokenKind.TokenKind.LCURLY, true)) {
                    return false;
                  }
                  var expr = null;
                  var closingCurly = peekToken();
                  if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.RCURLY, true)) {
                    expr = _InlineList.InlineList.create(toPosBounds(token.startPos, closingCurly.endPos));
                  } else if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COLON, true)) {
                    closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                    expr = _InlineMap.InlineMap.create(toPosBounds(token.startPos, closingCurly.endPos));
                  } else {
                    var firstExpression = eatExpression();
                    if (peekTokenOne(_TokenKind.TokenKind.RCURLY)) {
                      listElements.push(firstExpression);
                      closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                      expr = _InlineList.InlineList.create(toPosBounds(token.startPos, closingCurly.endPos), listElements);
                    } else if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COMMA, true)) {
                      listElements.push(firstExpression);
                      do {
                        listElements.push(eatExpression());
                      } while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COMMA, true));
                      closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                      expr = _InlineList.InlineList.create(toPosToken(token.startPos, closingCurly.endPos), listElements);
                    } else if (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COLON, true)) {
                      var mapElements = [];
                      mapElements.push(firstExpression);
                      mapElements.push(eatExpression());
                      while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.COMMA, true)) {
                        mapElements.push(eatExpression());
                        eatToken(_TokenKind.TokenKind.COLON);
                        mapElements.push(eatExpression());
                      }
                      closingCurly = eatToken(_TokenKind.TokenKind.RCURLY);
                      expr = _InlineMap.InlineMap.create(toPosBounds(token.startPos, closingCurly.endPos), mapElements);
                    } else {
                      raiseInternalException(token.startPos, "OOD");
                    }
                  }
                  push(expr);
                  return true;
                }
                function maybeEatIndexer() {
                  var token = peekToken();
                  if (!peekTokenConsumeIfMatched(_TokenKind.TokenKind.LSQUARE, true)) {
                    return false;
                  }
                  var expr = eatExpression();
                  eatToken(_TokenKind.TokenKind.RSQUARE);
                  push(_Indexer.Indexer.create(toPosToken(token), expr));
                  return true;
                }
                function maybeEatSelection(nullSafeNavigation) {
                  var token = peekToken();
                  if (!peekSelectToken()) {
                    return false;
                  }
                  nextToken();
                  var expr = eatExpression();
                  if (expr === null) {
                    raiseInternalException(toPosToken(token), "MISSING_SELECTION_EXPRESSION");
                  }
                  eatToken(_TokenKind.TokenKind.RSQUARE);
                  if (token.getKind() === _TokenKind.TokenKind.SELECT_FIRST) {
                    push(_Selection.Selection.create(nullSafeNavigation, _Selection.Selection.FIRST, toPosToken(token), expr));
                  } else if (token.getKind() === _TokenKind.TokenKind.SELECT_LAST) {
                    push(_Selection.Selection.create(nullSafeNavigation, _Selection.Selection.LAST, toPosToken(token), expr));
                  } else {
                    push(_Selection.Selection.create(nullSafeNavigation, _Selection.Selection.ALL, toPosToken(token), expr));
                  }
                  return true;
                }
                function eatPossiblyQualifiedId() {
                  var qualifiedIdPieces = [];
                  var node = peekToken();
                  while (isValidQualifiedId(node)) {
                    nextToken();
                    if (node.kind !== _TokenKind.TokenKind.DOT) {
                      qualifiedIdPieces.push(_Identifier.Identifier.create(node.stringValue(), toPosToken(node)));
                    }
                    node = peekToken();
                  }
                  if (!qualifiedIdPieces.length) {
                    if (node === null) {
                      raiseInternalException(expressionString.length(), "OOD");
                    }
                    raiseInternalException(node.startPos, "NOT_EXPECTED_TOKEN", "qualified ID", node.getKind().toString().toLowerCase());
                  }
                  var pos = toPosBounds(qualifiedIdPieces[0].getStartPosition(), qualifiedIdPieces[qualifiedIdPieces.length - 1].getEndPosition());
                  return _QualifiedIdentifier.QualifiedIdentifier.create(pos, qualifiedIdPieces);
                }
                function isValidQualifiedId(node) {
                  if (node === null || node.kind === _TokenKind.TokenKind.LITERAL_STRING) {
                    return false;
                  }
                  if (node.kind === _TokenKind.TokenKind.DOT || node.kind === _TokenKind.TokenKind.IDENTIFIER) {
                    return true;
                  }
                  var value = node.stringValue();
                  return value && value.length && VALID_QUALIFIED_ID_PATTERN.test(value);
                }
                function maybeEatMethodOrProperty(nullSafeNavigation) {
                  if (peekTokenOne(_TokenKind.TokenKind.IDENTIFIER)) {
                    var methodOrPropertyName = nextToken();
                    var args = maybeEatMethodArgs();
                    if (args === null) {
                      push(_PropertyReference.PropertyReference.create(nullSafeNavigation, methodOrPropertyName.stringValue(), toPosToken(methodOrPropertyName)));
                      return true;
                    }
                    push(_MethodReference.MethodReference.create(nullSafeNavigation, methodOrPropertyName.stringValue(), toPosToken(methodOrPropertyName), args));
                    return true;
                  }
                  return false;
                }
                function maybeEatConstructorReference() {
                  if (peekIdentifierToken("new")) {
                    var newToken = nextToken();
                    if (peekTokenOne(_TokenKind.TokenKind.RSQUARE)) {
                      push(_PropertyReference.PropertyReference.create(newToken.stringValue(), toPosToken(newToken)));
                      return true;
                    }
                    var possiblyQualifiedConstructorName = eatPossiblyQualifiedId();
                    var nodes = [];
                    nodes.push(possiblyQualifiedConstructorName);
                    if (peekTokenOne(_TokenKind.TokenKind.LSQUARE)) {
                      var dimensions = [];
                      while (peekTokenConsumeIfMatched(_TokenKind.TokenKind.LSQUARE, true)) {
                        if (!peekTokenOne(_TokenKind.TokenKind.RSQUARE)) {
                          dimensions.push(eatExpression());
                        } else {
                          dimensions.push(null);
                        }
                        eatToken(_TokenKind.TokenKind.RSQUARE);
                      }
                      if (maybeEatInlineListOrMap()) {
                        nodes.push(pop());
                      }
                      push(_ConstructorReference.ConstructorReference.create(toPosToken(newToken), dimensions, nodes));
                    } else {
                      eatConstructorArgs(nodes);
                      push(_ConstructorReference.ConstructorReference.create(toPosToken(newToken), nodes));
                    }
                    return true;
                  }
                  return false;
                }
                function push(newNode) {
                  constructedNodes.push(newNode);
                }
                function pop() {
                  return constructedNodes.pop();
                }
                function maybeEatLiteral() {
                  var token = peekToken();
                  if (token === null) {
                    return false;
                  }
                  if (token.getKind() === _TokenKind.TokenKind.LITERAL_INT || token.getKind() === _TokenKind.TokenKind.LITERAL_LONG) {
                    push(_NumberLiteral.NumberLiteral.create(parseInt(token.stringValue(), 10), toPosToken(token)));
                  } else if (token.getKind() === _TokenKind.TokenKind.LITERAL_REAL || token.getKind() === _TokenKind.TokenKind.LITERAL_REAL_FLOAT) {
                    push(_NumberLiteral.NumberLiteral.create(parseFloat(token.stringValue()), toPosToken(token)));
                  } else if (token.getKind() === _TokenKind.TokenKind.LITERAL_HEXINT || token.getKind() === _TokenKind.TokenKind.LITERAL_HEXLONG) {
                    push(_NumberLiteral.NumberLiteral.create(parseInt(token.stringValue(), 16), toPosToken(token)));
                  } else if (peekIdentifierToken("true")) {
                    push(_BooleanLiteral.BooleanLiteral.create(true, toPosToken(token)));
                  } else if (peekIdentifierToken("false")) {
                    push(_BooleanLiteral.BooleanLiteral.create(false, toPosToken(token)));
                  } else if (token.getKind() === _TokenKind.TokenKind.LITERAL_STRING) {
                    push(_StringLiteral.StringLiteral.create(token.stringValue(), toPosToken(token)));
                  } else {
                    return false;
                  }
                  nextToken();
                  return true;
                }
                function maybeEatParenExpression() {
                  if (peekTokenOne(_TokenKind.TokenKind.LPAREN)) {
                    nextToken();
                    var expr = eatExpression();
                    eatToken(_TokenKind.TokenKind.RPAREN);
                    push(expr);
                    return true;
                  } else {
                    return false;
                  }
                }
                function maybeEatRelationalOperator() {
                  var token = peekToken();
                  if (token === null) {
                    return null;
                  }
                  if (token.isNumericRelationalOperator()) {
                    return token;
                  }
                  if (token.isIdentifier()) {
                    var idString = token.stringValue();
                    if (idString.toLowerCase() === "instanceof") {
                      return token.asInstanceOfToken();
                    }
                    if (idString.toLowerCase() === "matches") {
                      return token.asMatchesToken();
                    }
                    if (idString.toLowerCase() === "between") {
                      return token.asBetweenToken();
                    }
                  }
                  return null;
                }
                function eatToken(expectedKind) {
                  var token = nextToken();
                  if (token === null) {
                    raiseInternalException(expressionString.length, "OOD");
                  }
                  if (token.getKind() !== expectedKind) {
                    raiseInternalException(token.startPos, "NOT_EXPECTED_TOKEN", expectedKind.toString().toLowerCase(), token.getKind().toString().toLowerCase());
                  }
                  return token;
                }
                function peekTokenOne(desiredTokenKind) {
                  return peekTokenConsumeIfMatched(desiredTokenKind, false);
                }
                function peekTokenConsumeIfMatched(desiredTokenKind, consumeIfMatched) {
                  if (!moreTokens()) {
                    return false;
                  }
                  var token = peekToken();
                  if (token.getKind() === desiredTokenKind) {
                    if (consumeIfMatched) {
                      tokenStreamPointer++;
                    }
                    return true;
                  }
                  if (desiredTokenKind === _TokenKind.TokenKind.IDENTIFIER) {
                    if (token.getKind().ordinal() >= _TokenKind.TokenKind.DIV.ordinal() && token.getKind().ordinal() <= _TokenKind.TokenKind.NOT.ordinal() && token.data !== null) {
                      return true;
                    }
                  }
                  return false;
                }
                function peekTokenAny() {
                  if (!moreTokens()) {
                    return false;
                  }
                  var token = peekToken();
                  var args = Array.prototype.slice.call(arguments);
                  for (var i = 0, l = args.length; i < l; i += 1) {
                    if (token.getKind() === args[i]) {
                      return true;
                    }
                  }
                  return false;
                }
                function peekIdentifierToken(identifierString) {
                  if (!moreTokens()) {
                    return false;
                  }
                  var token = peekToken();
                  return token.getKind() === _TokenKind.TokenKind.IDENTIFIER && token.stringValue().toLowerCase() === identifierString.toLowerCase();
                }
                function peekSelectToken() {
                  if (!moreTokens()) {
                    return false;
                  }
                  var token = peekToken();
                  return token.getKind() === _TokenKind.TokenKind.SELECT || token.getKind() === _TokenKind.TokenKind.SELECT_FIRST || token.getKind() === _TokenKind.TokenKind.SELECT_LAST;
                }
                function moreTokens() {
                  return tokenStreamPointer < tokenStream.length;
                }
                function nextToken() {
                  if (tokenStreamPointer >= tokenStreamLength) {
                    return null;
                  }
                  return tokenStream[tokenStreamPointer++];
                }
                function peekToken() {
                  if (tokenStreamPointer >= tokenStreamLength) {
                    return null;
                  }
                  return tokenStream[tokenStreamPointer];
                }
                function raiseInternalException(pos, message, expected, actual) {
                  if (expected) {
                    message += "\nExpected: " + expected;
                  }
                  if (actual) {
                    message += "\nActual: " + actual;
                  }
                  throw {
                    name: "InternalParseException",
                    message: "Error occurred while attempting to parse expression '" + expressionString + "' at position " + pos + ". Message: " + message
                  };
                }
                function toString(token) {
                  if (token.getKind().hasPayload()) {
                    return token.stringValue();
                  }
                  return token.getKind().toString().toLowerCase();
                }
                function checkOperands(token, left2, right2) {
                  checkLeftOperand(token, left2);
                  checkRightOperand(token, right2);
                }
                function checkLeftOperand(token, operandExpression) {
                  if (operandExpression === null) {
                    raiseInternalException(token.startPos, "LEFT_OPERAND_PROBLEM");
                  }
                }
                function checkRightOperand(token, operandExpression) {
                  if (operandExpression === null) {
                    raiseInternalException(token.startPos, "RIGHT_OPERAND_PROBLEM");
                  }
                }
                function toPosToken(token) {
                  return (token.startPos << 16) + token.endPos;
                }
                function toPosBounds(start3, end2) {
                  return (start3 << 16) + end2;
                }
                return {
                  setConfiguration,
                  parse
                };
              };
            },
            /* 6 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Tokenizer = void 0;
              var _Token = __webpack_require__(7);
              var _TokenKind = __webpack_require__(2);
              var ALTERNATIVE_OPERATOR_NAMES = ["DIV", "EQ", "GE", "GT", "LE", "LT", "MOD", "NE", "NOT"], FLAGS = [], IS_DIGIT = 1, IS_HEXDIGIT = 2, IS_ALPHA = 4;
              function init() {
                var ch;
                for (ch = "0".charCodeAt(0); ch <= "9".charCodeAt(0); ch += 1) {
                  FLAGS[ch] |= IS_DIGIT | IS_HEXDIGIT;
                }
                for (ch = "A".charCodeAt(0); ch <= "F".charCodeAt(0); ch += 1) {
                  FLAGS[ch] |= IS_HEXDIGIT;
                }
                for (ch = "a".charCodeAt(0); ch <= "f".charCodeAt(0); ch += 1) {
                  FLAGS[ch] |= IS_HEXDIGIT;
                }
                for (ch = "A".charCodeAt(0); ch <= "Z".charCodeAt(0); ch += 1) {
                  FLAGS[ch] |= IS_ALPHA;
                }
                for (ch = "a".charCodeAt(0); ch <= "z".charCodeAt(0); ch += 1) {
                  FLAGS[ch] |= IS_ALPHA;
                }
              }
              init();
              function tokenize2(inputData) {
                var expressionString = inputData, toProcess = inputData + "\0", max2 = toProcess.length, pos = 0, tokens = [];
                function process2() {
                  var ch;
                  while (pos < max2) {
                    ch = toProcess[pos];
                    if (isAlphabetic(ch)) {
                      lexIdentifier();
                    } else {
                      switch (ch) {
                        case "+":
                          if (isTwoCharToken(_TokenKind.TokenKind.INC)) {
                            pushPairToken(_TokenKind.TokenKind.INC);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.PLUS);
                          }
                          break;
                        case "_":
                          lexIdentifier();
                          break;
                        case "-":
                          if (isTwoCharToken(_TokenKind.TokenKind.DEC)) {
                            pushPairToken(_TokenKind.TokenKind.DEC);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.MINUS);
                          }
                          break;
                        case ":":
                          pushCharToken(_TokenKind.TokenKind.COLON);
                          break;
                        case ".":
                          pushCharToken(_TokenKind.TokenKind.DOT);
                          break;
                        case ",":
                          pushCharToken(_TokenKind.TokenKind.COMMA);
                          break;
                        case "*":
                          pushCharToken(_TokenKind.TokenKind.STAR);
                          break;
                        case "/":
                          pushCharToken(_TokenKind.TokenKind.DIV);
                          break;
                        case "%":
                          pushCharToken(_TokenKind.TokenKind.MOD);
                          break;
                        case "(":
                          pushCharToken(_TokenKind.TokenKind.LPAREN);
                          break;
                        case ")":
                          pushCharToken(_TokenKind.TokenKind.RPAREN);
                          break;
                        case "[":
                          pushCharToken(_TokenKind.TokenKind.LSQUARE);
                          break;
                        case "#":
                          pushCharToken(_TokenKind.TokenKind.HASH);
                          break;
                        case "]":
                          pushCharToken(_TokenKind.TokenKind.RSQUARE);
                          break;
                        case "{":
                          pushCharToken(_TokenKind.TokenKind.LCURLY);
                          break;
                        case "}":
                          pushCharToken(_TokenKind.TokenKind.RCURLY);
                          break;
                        case "@":
                          pushCharToken(_TokenKind.TokenKind.BEAN_REF);
                          break;
                        case "^":
                          if (isTwoCharToken(_TokenKind.TokenKind.SELECT_FIRST)) {
                            pushPairToken(_TokenKind.TokenKind.SELECT_FIRST);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.POWER);
                          }
                          break;
                        case "!":
                          if (isTwoCharToken(_TokenKind.TokenKind.NE)) {
                            pushPairToken(_TokenKind.TokenKind.NE);
                          } else if (isTwoCharToken(_TokenKind.TokenKind.PROJECT)) {
                            pushPairToken(_TokenKind.TokenKind.PROJECT);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.NOT);
                          }
                          break;
                        case "=":
                          if (isTwoCharToken(_TokenKind.TokenKind.EQ)) {
                            pushPairToken(_TokenKind.TokenKind.EQ);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.ASSIGN);
                          }
                          break;
                        case "&":
                          if (!isTwoCharToken(_TokenKind.TokenKind.SYMBOLIC_AND)) {
                            throw {
                              name: "SpelParseException",
                              message: "Missing character '&' in expression (" + expressionString + ") at position " + pos
                            };
                          }
                          pushPairToken(_TokenKind.TokenKind.SYMBOLIC_AND);
                          break;
                        case "|":
                          if (!isTwoCharToken(_TokenKind.TokenKind.SYMBOLIC_OR)) {
                            throw {
                              name: "SpelParseException",
                              message: "Missing character '|' in expression (" + expressionString + ") at position " + pos
                            };
                          }
                          pushPairToken(_TokenKind.TokenKind.SYMBOLIC_OR);
                          break;
                        case "?":
                          if (isTwoCharToken(_TokenKind.TokenKind.SELECT)) {
                            pushPairToken(_TokenKind.TokenKind.SELECT);
                          } else if (isTwoCharToken(_TokenKind.TokenKind.ELVIS)) {
                            pushPairToken(_TokenKind.TokenKind.ELVIS);
                          } else if (isTwoCharToken(_TokenKind.TokenKind.SAFE_NAVI)) {
                            pushPairToken(_TokenKind.TokenKind.SAFE_NAVI);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.QMARK);
                          }
                          break;
                        case "$":
                          if (isTwoCharToken(_TokenKind.TokenKind.SELECT_LAST)) {
                            pushPairToken(_TokenKind.TokenKind.SELECT_LAST);
                          } else {
                            lexIdentifier();
                          }
                          break;
                        case ">":
                          if (isTwoCharToken(_TokenKind.TokenKind.GE)) {
                            pushPairToken(_TokenKind.TokenKind.GE);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.GT);
                          }
                          break;
                        case "<":
                          if (isTwoCharToken(_TokenKind.TokenKind.LE)) {
                            pushPairToken(_TokenKind.TokenKind.LE);
                          } else {
                            pushCharToken(_TokenKind.TokenKind.LT);
                          }
                          break;
                        case "0":
                        case "1":
                        case "2":
                        case "3":
                        case "4":
                        case "5":
                        case "6":
                        case "7":
                        case "8":
                        case "9":
                          lexNumericLiteral(ch === "0");
                          break;
                        case " ":
                        case "	":
                        case "\r":
                        case "\n":
                          pos += 1;
                          break;
                        case "'":
                          lexQuotedStringLiteral();
                          break;
                        case '"':
                          lexDoubleQuotedStringLiteral();
                          break;
                        case "\0":
                          pos += 1;
                          break;
                        case "\\":
                          throw {
                            name: "SpelParseException",
                            message: "Unexpected escape character in expression (" + expressionString + ") at position " + pos
                          };
                        default:
                          throw {
                            name: "SpelParseException",
                            message: "Cannot handle character '" + ch + "' in expression (" + expressionString + ") at position " + pos
                          };
                      }
                    }
                  }
                }
                function lexQuotedStringLiteral() {
                  var start3 = pos, terminated = false, ch;
                  while (!terminated) {
                    pos += 1;
                    ch = toProcess[pos];
                    if (ch === "'") {
                      if (toProcess[pos + 1] === "'") {
                        pos += 1;
                      } else {
                        terminated = true;
                      }
                    }
                    if (ch.charCodeAt(0) === 0) {
                      throw {
                        name: "SpelParseException",
                        message: "Non-terminating quoted string in expression (" + expressionString + ") at position " + pos
                      };
                    }
                  }
                  pos += 1;
                  tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_STRING, subarray(start3, pos), start3, pos));
                }
                function lexDoubleQuotedStringLiteral() {
                  var start3 = pos, terminated = false, ch;
                  while (!terminated) {
                    pos += 1;
                    ch = toProcess[pos];
                    if (ch === '"') {
                      if (toProcess[pos + 1] === '"') {
                        pos += 1;
                      } else {
                        terminated = true;
                      }
                    }
                    if (ch.charCodeAt(0) === 0) {
                      throw {
                        name: "SpelParseException",
                        message: "Non-terminating double-quoted string in expression (" + expressionString + ") at position " + pos
                      };
                    }
                  }
                  pos += 1;
                  tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_STRING, subarray(start3, pos), start3, pos));
                }
                function lexNumericLiteral(firstCharIsZero) {
                  var isReal = false, start3 = pos, ch = toProcess[pos + 1], isHex = ch === "x" || ch === "X", dotpos, endOfNumber, possibleSign, isFloat;
                  if (firstCharIsZero && isHex) {
                    pos = pos + 1;
                    do {
                      pos += 1;
                    } while (isHexadecimalDigit(toProcess[pos]));
                    if (isChar("L", "l")) {
                      pushHexIntToken(subarray(start3 + 2, pos), true, start3, pos);
                      pos += 1;
                    } else {
                      pushHexIntToken(subarray(start3 + 2, pos), false, start3, pos);
                    }
                    return;
                  }
                  do {
                    pos += 1;
                  } while (isDigit(toProcess[pos]));
                  ch = toProcess[pos];
                  if (ch === ".") {
                    isReal = true;
                    dotpos = pos;
                    do {
                      pos += 1;
                    } while (isDigit(toProcess[pos]));
                    if (pos === dotpos + 1) {
                      pos = dotpos;
                      pushIntToken(subarray(start3, pos), false, start3, pos);
                      return;
                    }
                  }
                  endOfNumber = pos;
                  if (isChar("L", "l")) {
                    if (isReal) {
                      throw {
                        name: "SpelParseException",
                        message: "Real cannot be long in expression (" + expressionString + ") at position " + pos
                      };
                    }
                    pushIntToken(subarray(start3, endOfNumber), true, start3, endOfNumber);
                    pos += 1;
                  } else if (isExponentChar(toProcess[pos])) {
                    isReal = true;
                    pos += 1;
                    possibleSign = toProcess[pos];
                    if (isSign(possibleSign)) {
                      pos += 1;
                    }
                    do {
                      pos += 1;
                    } while (isDigit(toProcess[pos]));
                    isFloat = false;
                    if (isFloatSuffix(toProcess[pos])) {
                      isFloat = true;
                      pos += 1;
                      endOfNumber = pos;
                    } else if (isDoubleSuffix(toProcess[pos])) {
                      pos += 1;
                      endOfNumber = pos;
                    }
                    pushRealToken(subarray(start3, pos), isFloat, start3, pos);
                  } else {
                    ch = toProcess[pos];
                    isFloat = false;
                    if (isFloatSuffix(ch)) {
                      isReal = true;
                      isFloat = true;
                      pos += 1;
                      endOfNumber = pos;
                    } else if (isDoubleSuffix(ch)) {
                      isReal = true;
                      pos += 1;
                      endOfNumber = pos;
                    }
                    if (isReal) {
                      pushRealToken(subarray(start3, endOfNumber), isFloat, start3, endOfNumber);
                    } else {
                      pushIntToken(subarray(start3, endOfNumber), false, start3, endOfNumber);
                    }
                  }
                }
                function lexIdentifier() {
                  var start3 = pos, substring, asString, idx;
                  do {
                    pos += 1;
                  } while (isIdentifier(toProcess[pos]));
                  substring = subarray(start3, pos);
                  if (pos - start3 === 2 || pos - start3 === 3) {
                    asString = substring.toUpperCase();
                    idx = ALTERNATIVE_OPERATOR_NAMES.indexOf(asString);
                    if (idx >= 0) {
                      pushOneCharOrTwoCharToken(_TokenKind.TokenKind.valueOf(asString), start3, substring);
                      return;
                    }
                  }
                  tokens.push(new _Token.Token(_TokenKind.TokenKind.IDENTIFIER, substring.replace("\0", ""), start3, pos));
                }
                function pushIntToken(data, isLong, start3, end2) {
                  if (isLong) {
                    tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_LONG, data, start3, end2));
                  } else {
                    tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_INT, data, start3, end2));
                  }
                }
                function pushHexIntToken(data, isLong, start3, end2) {
                  if (data.length === 0) {
                    if (isLong) {
                      throw {
                        name: "SpelParseException",
                        message: "Not a long in expression (" + expressionString + ") at position " + pos
                      };
                    } else {
                      throw {
                        name: "SpelParseException",
                        message: "Not an int in expression (" + expressionString + ") at position " + pos
                      };
                    }
                  }
                  if (isLong) {
                    tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_HEXLONG, data, start3, end2));
                  } else {
                    tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_HEXINT, data, start3, end2));
                  }
                }
                function pushRealToken(data, isFloat, start3, end2) {
                  if (isFloat) {
                    tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_REAL_FLOAT, data, start3, end2));
                  } else {
                    tokens.push(new _Token.Token(_TokenKind.TokenKind.LITERAL_REAL, data, start3, end2));
                  }
                }
                function subarray(start3, end2) {
                  return toProcess.substring(start3, end2);
                }
                function isTwoCharToken(kind) {
                  if (kind.tokenChars.length === 2 && toProcess[pos] === kind.tokenChars[0]) {
                    return toProcess[pos + 1] === kind.tokenChars[1];
                  }
                  return false;
                }
                function pushCharToken(kind) {
                  tokens.push(new _Token.Token(kind, null, pos, pos + 1));
                  pos += 1;
                }
                function pushPairToken(kind) {
                  tokens.push(new _Token.Token(kind, null, pos, pos + 2));
                  pos += 2;
                }
                function pushOneCharOrTwoCharToken(kind, pos2, data) {
                  tokens.push(new _Token.Token(kind, data, pos2, pos2 + kind.getLength()));
                }
                function isIdentifier(ch) {
                  return isAlphabetic(ch) || isDigit(ch) || ch === "_" || ch === "$";
                }
                function isChar(a, b) {
                  var ch = toProcess[pos];
                  return ch === a || ch === b;
                }
                function isExponentChar(ch) {
                  return ch === "e" || ch === "E";
                }
                function isFloatSuffix(ch) {
                  return ch === "f" || ch === "F";
                }
                function isDoubleSuffix(ch) {
                  return ch === "d" || ch === "D";
                }
                function isSign(ch) {
                  return ch === "+" || ch === "-";
                }
                function isDigit(ch) {
                  if (ch.charCodeAt(0) > 255) {
                    return false;
                  }
                  return (FLAGS[ch.charCodeAt(0)] & IS_DIGIT) !== 0;
                }
                function isAlphabetic(ch) {
                  if (ch.charCodeAt(0) > 255) {
                    return false;
                  }
                  return (FLAGS[ch.charCodeAt(0)] & IS_ALPHA) !== 0;
                }
                function isHexadecimalDigit(ch) {
                  if (ch.charCodeAt(0) > 255) {
                    return false;
                  }
                  return (FLAGS[ch.charCodeAt(0)] & IS_HEXDIGIT) !== 0;
                }
                process2();
                return tokens;
              }
              var Tokenizer = exports2.Tokenizer = {
                tokenize: tokenize2
              };
            },
            /* 7 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Token = void 0;
              var _TokenKind = __webpack_require__(2);
              function Token(tokenKind, tokenData, startPos, endPos) {
                this.kind = tokenKind;
                this.startPos = startPos;
                this.endPos = endPos;
                if (tokenData) {
                  this.data = tokenData;
                }
              }
              Token.prototype.getKind = function() {
                return this.kind;
              };
              Token.prototype.toString = function() {
                var s = "[";
                s += this.kind.toString();
                if (this.kind.hasPayload()) {
                  s += ":" + this.data;
                }
                s += "]";
                s += "(" + this.startPos + "," + this.endPos + ")";
                return s;
              };
              Token.prototype.isIdentifier = function() {
                return this.kind === _TokenKind.TokenKind.IDENTIFIER;
              };
              Token.prototype.isNumericRelationalOperator = function() {
                return this.kind === _TokenKind.TokenKind.GT || this.kind === _TokenKind.TokenKind.GE || this.kind === _TokenKind.TokenKind.LT || this.kind === _TokenKind.TokenKind.LE || this.kind === _TokenKind.TokenKind.EQ || this.kind === _TokenKind.TokenKind.NE;
              };
              Token.prototype.stringValue = function() {
                return this.data;
              };
              Token.prototype.asInstanceOfToken = function() {
                return new Token(_TokenKind.TokenKind.INSTANCEOF, this.startPos, this.endPos);
              };
              Token.prototype.asMatchesToken = function() {
                return new Token(_TokenKind.TokenKind.MATCHES, this.startPos, this.endPos);
              };
              Token.prototype.asBetweenToken = function() {
                return new Token(_TokenKind.TokenKind.BETWEEN, this.startPos, this.endPos);
              };
              Token.prototype.getStartPosition = function() {
                return this.startPos;
              };
              Token.prototype.getEndPosition = function() {
                return this.endPos;
              };
              exports2.Token = Token;
            },
            /* 8 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.BooleanLiteral = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(value, position) {
                var node = _SpelNode.SpelNode.create("boolean", position);
                node.getValue = function() {
                  return value;
                };
                node.setValue = function(newValue) {
                  return value = newValue;
                };
                return node;
              }
              var BooleanLiteral = exports2.BooleanLiteral = {
                create: createNode
              };
            },
            /* 9 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NumberLiteral = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(value, position) {
                var node = _SpelNode.SpelNode.create("number", position);
                node.getValue = function() {
                  return value;
                };
                node.setValue = function(newValue) {
                  return value = newValue;
                };
                return node;
              }
              var NumberLiteral = exports2.NumberLiteral = {
                create: createNode
              };
            },
            /* 10 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StringLiteral = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(value, position) {
                var node = _SpelNode.SpelNode.create("string", position);
                function stripQuotes(value2) {
                  if (value2[0] === "'" && value2[value2.length - 1] === "'" || value2[0] === '"' && value2[value2.length - 1] === '"') {
                    value2 = value2.substring(1, value2.length - 1);
                  }
                  return value2.replace(/''/g, "'").replace(/""/g, '"');
                }
                value = stripQuotes(value);
                node.getValue = function() {
                  return value;
                };
                node.setValue = function(newValue) {
                  return value = newValue;
                };
                return node;
              }
              var StringLiteral = exports2.StringLiteral = {
                create: createNode
              };
            },
            /* 11 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NullLiteral = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(value, position) {
                var node = _SpelNode.SpelNode.create("null", position);
                node.getValue = function() {
                  return null;
                };
                return node;
              }
              var NullLiteral = exports2.NullLiteral = {
                create: createNode
              };
            },
            /* 12 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FunctionReference = void 0;
              var _SpelNode = __webpack_require__(0);
              var _Stack = __webpack_require__(1);
              function createNode(functionName, position, args) {
                var node = _SpelNode.SpelNode.create("function", position);
                node.getRaw = function() {
                  return {
                    functionName,
                    args
                  };
                };
                node.getValue = function(state) {
                  var locals = state.locals || {}, context = state.rootContext, compiledArgs = [];
                  args.forEach(function(arg) {
                    var currentActiveContext = state.activeContext;
                    state.activeContext = new _Stack.Stack();
                    state.activeContext.push(state.rootContext);
                    compiledArgs.push(arg.getValue(state));
                    state.activeContext = currentActiveContext;
                  });
                  if (locals[functionName]) {
                    return locals[functionName].apply(context, compiledArgs);
                  }
                  throw {
                    name: "FunctionDoesNotExistException",
                    message: "Function '" + functionName + "' does not exist."
                  };
                };
                return node;
              }
              var FunctionReference = exports2.FunctionReference = {
                create: createNode
              };
            },
            /* 13 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MethodReference = void 0;
              var _SpelNode = __webpack_require__(0);
              var _Stack = __webpack_require__(1);
              function createNode(nullSafeNavigation, methodName, position, args) {
                var node = _SpelNode.SpelNode.create("method", position);
                node.getRaw = function() {
                  return {
                    methodName,
                    args
                  };
                };
                node.getValue = function(state) {
                  var context = state.activeContext.peek(), compiledArgs = [], method;
                  if (!context) {
                    throw {
                      name: "ContextDoesNotExistException",
                      message: "Attempting to look up property '" + methodName + "' for an undefined context."
                    };
                  }
                  function maybeHandleNullSafeNavigation(member) {
                    if (member === void 0 || member === null) {
                      if (nullSafeNavigation) {
                        return null;
                      }
                      throw {
                        name: "NullPointerException",
                        message: "Method " + methodName + " does not exist."
                      };
                    }
                    return member;
                  }
                  args.forEach(function(arg) {
                    var currentActiveContext = state.activeContext;
                    state.activeContext = new _Stack.Stack();
                    state.activeContext.push(state.rootContext);
                    compiledArgs.push(arg.getValue(state));
                    state.activeContext = currentActiveContext;
                  });
                  if (methodName.substr(0, 3) === "get" && !context[methodName]) {
                    return maybeHandleNullSafeNavigation(context[methodName.charAt(3).toLowerCase() + methodName.substring(4)]);
                  }
                  if (methodName.substr(0, 3) === "set" && !context[methodName]) {
                    return context[methodName.charAt(3).toLowerCase() + methodName.substring(4)] = compiledArgs[0];
                  }
                  if (Array.isArray(context)) {
                    if (methodName === "size") {
                      return context.length;
                    }
                    if (methodName === "contains") {
                      return context.includes(compiledArgs[0]);
                    }
                  }
                  method = maybeHandleNullSafeNavigation(context[methodName]);
                  if (method) {
                    return method.apply(context, compiledArgs);
                  }
                  return null;
                };
                return node;
              }
              var MethodReference = exports2.MethodReference = {
                create: createNode
              };
            },
            /* 14 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PropertyReference = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(nullSafeNavigation, propertyName, position) {
                var node = _SpelNode.SpelNode.create("property", position);
                node.getRaw = function() {
                  return propertyName;
                };
                node.getValue = function(state) {
                  var context = state.activeContext.peek();
                  if (!context) {
                    if (nullSafeNavigation) {
                      return null;
                    }
                    throw {
                      name: "ContextDoesNotExistException",
                      message: "Attempting to look up property '" + propertyName + "' for an undefined context."
                    };
                  }
                  if (context[propertyName] === void 0 || context[propertyName] === null) {
                    if (nullSafeNavigation) {
                      return null;
                    }
                    if (propertyName === "size" && Array.isArray(context)) {
                      return context.length;
                    }
                    throw {
                      name: "NullPointerException",
                      message: "Property '" + propertyName + "' does not exist."
                    };
                  }
                  return context[propertyName];
                };
                node.setValue = function(value, state) {
                  var context = state.activeContext.peek();
                  if (!context) {
                    throw {
                      name: "ContextDoesNotExistException",
                      message: "Attempting to assign property '" + propertyName + "' for an undefined context."
                    };
                  }
                  return context[propertyName] = value;
                };
                node.getName = function() {
                  return propertyName;
                };
                return node;
              }
              var PropertyReference = exports2.PropertyReference = {
                create: createNode
              };
            },
            /* 15 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.VariableReference = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(variableName, position) {
                var node = _SpelNode.SpelNode.create("variable", position);
                node.getRaw = function() {
                  return variableName;
                };
                node.getValue = function(state) {
                  var context = state.activeContext.peek(), locals = state.locals;
                  if (!context) {
                    throw {
                      name: "ContextDoesNotExistException",
                      message: "Attempting to look up variable '" + variableName + "' for an undefined context."
                    };
                  }
                  if (variableName === "this") {
                    return context;
                  }
                  if (variableName === "root") {
                    return state.rootContext;
                  }
                  return locals[variableName];
                };
                node.setValue = function(value, state) {
                  var locals = state.locals;
                  return locals[variableName] = value;
                };
                return node;
              }
              var VariableReference = exports2.VariableReference = {
                create: createNode
              };
            },
            /* 16 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CompoundExpression = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, expressionComponents) {
                var node = _SpelNode.SpelNode.create.apply(null, ["compound", position].concat(expressionComponents));
                function buildContextStack(state) {
                  var childrenCount = node.getChildren().length, i;
                  for (i = 0; i < childrenCount; i += 1) {
                    if (node.getChildren()[i].getType() === "indexer") {
                      state.activeContext.push(state.activeContext.peek()[node.getChildren()[i].getValue(state)]);
                    } else {
                      state.activeContext.push(node.getChildren()[i].getValue(state));
                    }
                  }
                  return function unbuildContextStack() {
                    for (i = 0; i < childrenCount; i += 1) {
                      state.activeContext.pop();
                    }
                  };
                }
                node.getValue = function(state) {
                  var context = state.activeContext.peek(), value;
                  if (!context) {
                    throw {
                      name: "ContextDoesNotExistException",
                      message: "Attempting to evaluate compound expression with an undefined context."
                    };
                  }
                  var unbuildContextStack = buildContextStack(state);
                  value = state.activeContext.peek();
                  unbuildContextStack();
                  return value;
                };
                node.setValue = function(value, state) {
                  var unbuildContextStack = buildContextStack(state), childCount = node.getChildren().length;
                  state.activeContext.pop();
                  value = node.getChildren()[childCount - 1].setValue(value, state);
                  state.activeContext.push(null);
                  unbuildContextStack();
                  return value;
                };
                return node;
              }
              var CompoundExpression = exports2.CompoundExpression = {
                create: createNode
              };
            },
            /* 17 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Indexer = void 0;
              var _SpelNode = __webpack_require__(0);
              var _Stack = __webpack_require__(1);
              function createNode(position, expressionComponents) {
                var node = _SpelNode.SpelNode.create.apply(null, ["indexer", position].concat(expressionComponents));
                node.getValue = function(state) {
                  var activeContext = state.activeContext, context, childrenCount = node.getChildren().length, i, value;
                  state.activeContext = new _Stack.Stack();
                  state.activeContext.push(state.rootContext);
                  context = state.activeContext.peek();
                  if (!context) {
                    throw {
                      name: "ContextDoesNotExistException",
                      message: "Attempting to evaluate compound expression with an undefined context."
                    };
                  }
                  for (i = 0; i < childrenCount; i += 1) {
                    state.activeContext.push(node.getChildren()[i].getValue(state));
                  }
                  value = state.activeContext.peek();
                  for (i = 0; i < childrenCount; i += 1) {
                    state.activeContext.pop();
                  }
                  state.activeContext = activeContext;
                  return value;
                };
                return node;
              }
              var Indexer = exports2.Indexer = {
                create: createNode
              };
            },
            /* 18 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Assign = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, property, assignedValue) {
                var node = _SpelNode.SpelNode.create("assign", position, property, assignedValue);
                node.getValue = function(state) {
                  var context = state.activeContext.peek();
                  if (!context) {
                    throw {
                      name: "ContextDoesNotExistException",
                      message: "Attempting to assign property '" + property.getValue(state) + "' for an undefined context."
                    };
                  }
                  return property.setValue(assignedValue.getValue(state), state);
                };
                return node;
              }
              var Assign = exports2.Assign = {
                create: createNode
              };
            },
            /* 19 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpEQ = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("op-eq", position, left2, right2);
                node.getValue = function(state) {
                  return left2.getValue(state) === right2.getValue(state);
                };
                return node;
              }
              var OpEQ = exports2.OpEQ = {
                create: createNode
              };
            },
            /* 20 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpNE = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("op-ne", position, left2, right2);
                node.getValue = function(state) {
                  return left2.getValue(state) !== right2.getValue(state);
                };
                return node;
              }
              var OpNE = exports2.OpNE = {
                create: createNode
              };
            },
            /* 21 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpGE = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("op-ge", position, left2, right2);
                node.getValue = function(state) {
                  return left2.getValue(state) >= right2.getValue(state);
                };
                return node;
              }
              var OpGE = exports2.OpGE = {
                create: createNode
              };
            },
            /* 22 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpGT = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("op-gt", position, left2, right2);
                node.getValue = function(state) {
                  return left2.getValue(state) > right2.getValue(state);
                };
                return node;
              }
              var OpGT = exports2.OpGT = {
                create: createNode
              };
            },
            /* 23 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpLE = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("op-le", position, left2, right2);
                node.getValue = function(state) {
                  return left2.getValue(state) <= right2.getValue(state);
                };
                return node;
              }
              var OpLE = exports2.OpLE = {
                create: createNode
              };
            },
            /* 24 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpLT = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("op-lt", position, left2, right2);
                node.getValue = function(state) {
                  return left2.getValue(state) < right2.getValue(state);
                };
                return node;
              }
              var OpLT = exports2.OpLT = {
                create: createNode
              };
            },
            /* 25 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpPlus = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("op-plus", position, left2, right2);
                node.getValue = function(state) {
                  if (!right2) {
                    return +left2.getValue(state);
                  }
                  return left2.getValue(state) + right2.getValue(state);
                };
                return node;
              }
              var OpPlus = exports2.OpPlus = {
                create: createNode
              };
            },
            /* 26 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpMinus = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("op-minus", position, left2, right2);
                node.getValue = function(state) {
                  if (!right2) {
                    return -left2.getValue(state);
                  }
                  return left2.getValue(state) - right2.getValue(state);
                };
                return node;
              }
              var OpMinus = exports2.OpMinus = {
                create: createNode
              };
            },
            /* 27 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpMultiply = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("op-multiply", position, left2, right2);
                node.getValue = function(state) {
                  var leftValue = left2.getValue(state), rightValue = right2.getValue(state);
                  if (typeof leftValue === "number" && typeof rightValue === "number") {
                    return leftValue * rightValue;
                  }
                  if (typeof leftValue === "string" && typeof rightValue === "number") {
                    var s = "", i = 0;
                    for (; i < rightValue; i += 1) {
                      s += leftValue;
                    }
                    return s;
                  }
                  return null;
                };
                return node;
              }
              var OpMultiply = exports2.OpMultiply = {
                create: createNode
              };
            },
            /* 28 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpDivide = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("op-divide", position, left2, right2);
                node.getValue = function(state) {
                  return left2.getValue(state) / right2.getValue(state);
                };
                return node;
              }
              var OpDivide = exports2.OpDivide = {
                create: createNode
              };
            },
            /* 29 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpModulus = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("op-modulus", position, left2, right2);
                node.getValue = function(state) {
                  return left2.getValue(state) % right2.getValue(state);
                };
                return node;
              }
              var OpModulus = exports2.OpModulus = {
                create: createNode
              };
            },
            /* 30 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpPower = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, base3, exp) {
                var node = _SpelNode.SpelNode.create("op-power", position, base3, exp);
                node.getValue = function(state) {
                  return Math.pow(base3.getValue(state), exp.getValue(state));
                };
                return node;
              }
              var OpPower = exports2.OpPower = {
                create: createNode
              };
            },
            /* 31 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpInc = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, postfix, int) {
                var node = _SpelNode.SpelNode.create("op-inc", position, int);
                node.getValue = function(state) {
                  var cur = int.getValue(state);
                  int.setValue(cur + 1, state);
                  if (postfix) {
                    return cur;
                  }
                  return cur + 1;
                };
                return node;
              }
              var OpInc = exports2.OpInc = {
                create: createNode
              };
            },
            /* 32 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpDec = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, postfix, int) {
                var node = _SpelNode.SpelNode.create("op-dec", position, int);
                node.getValue = function(state) {
                  var cur = int.getValue(state);
                  int.setValue(cur - 1, state);
                  if (postfix) {
                    return cur;
                  }
                  return cur - 1;
                };
                return node;
              }
              var OpDec = exports2.OpDec = {
                create: createNode
              };
            },
            /* 33 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpNot = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, expr) {
                var node = _SpelNode.SpelNode.create("op-not", position, expr);
                node.getValue = function(state) {
                  return !expr.getValue(state);
                };
                return node;
              }
              var OpNot = exports2.OpNot = {
                create: createNode
              };
            },
            /* 34 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpAnd = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("op-and", position, left2, right2);
                node.getValue = function(state) {
                  return !!left2.getValue(state) && !!right2.getValue(state);
                };
                return node;
              }
              var OpAnd = exports2.OpAnd = {
                create: createNode
              };
            },
            /* 35 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpOr = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("op-or", position, left2, right2);
                node.getValue = function(state) {
                  return !!left2.getValue(state) || !!right2.getValue(state);
                };
                return node;
              }
              var OpOr = exports2.OpOr = {
                create: createNode
              };
            },
            /* 36 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpMatches = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("matches", position, left2, right2);
                node.getValue = function(state) {
                  var data = left2.getValue(state);
                  var regexpString = right2.getValue(state);
                  try {
                    var regexp = new RegExp(regexpString);
                    return !!regexp.exec(data);
                  } catch (error2) {
                    throw {
                      name: "EvaluationException",
                      message: error2.toString()
                    };
                  }
                };
                return node;
              }
              var OpMatches = exports2.OpMatches = {
                create: createNode
              };
            },
            /* 37 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Ternary = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, expression, ifTrue, ifFalse) {
                var node = _SpelNode.SpelNode.create("ternary", position, expression, ifTrue, ifFalse);
                node.getValue = function(state) {
                  return expression.getValue(state) ? ifTrue.getValue(state) : ifFalse.getValue(state);
                };
                return node;
              }
              var Ternary = exports2.Ternary = {
                create: createNode
              };
            },
            /* 38 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Elvis = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, expression, ifFalse) {
                var node = _SpelNode.SpelNode.create("elvis", position, expression, ifFalse);
                node.getValue = function(state) {
                  return expression.getValue(state) !== null ? expression.getValue(state) : ifFalse.getValue(state);
                };
                return node;
              }
              var Elvis = exports2.Elvis = {
                create: createNode
              };
            },
            /* 39 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.InlineList = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, elements) {
                var node = _SpelNode.SpelNode.create("list", position), list = [].concat(elements || []);
                node.getRaw = function() {
                  return list;
                };
                node.getValue = function(state) {
                  return list.map(function(element) {
                    return element.getValue(state);
                  });
                };
                return node;
              }
              var InlineList = exports2.InlineList = {
                create: createNode
              };
            },
            /* 40 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.InlineMap = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, elements) {
                var node = _SpelNode.SpelNode.create("map", position), mapPieces = [].concat(elements || []);
                node.getValue = function(state) {
                  var key = true, keyValue = null, map = {};
                  mapPieces.forEach(function(piece) {
                    if (key) {
                      if (piece.getType() === "property") {
                        keyValue = piece.getName();
                      } else {
                        keyValue = piece.getValue(state);
                      }
                    } else {
                      map[keyValue] = piece.getValue(state);
                    }
                    key = !key;
                  });
                  return map;
                };
                return node;
              }
              var InlineMap = exports2.InlineMap = {
                create: createNode
              };
            },
            /* 41 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Selection = void 0;
              var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                return typeof obj;
              } : function(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              };
              var _SpelNode = __webpack_require__(0);
              function matches(element, expr, state) {
                var doesMatch = false;
                state.activeContext.push(element);
                doesMatch = expr.getValue(state);
                state.activeContext.pop();
                return doesMatch;
              }
              function selectFromArray(collection, whichElement, expr, state) {
                var newCollection = collection.filter(function(element) {
                  return matches(element, expr, state);
                });
                switch (whichElement) {
                  case "ALL":
                    return newCollection;
                  case "FIRST":
                    return newCollection[0] || null;
                  case "LAST":
                    if (newCollection.length) {
                      return newCollection[newCollection.length - 1];
                    }
                    return null;
                }
              }
              function selectFromMap(collection, whichElement, expr, state) {
                var newCollection = {}, entry, key, entries = [], returnValue = {};
                for (key in collection) {
                  if (collection.hasOwnProperty(key)) {
                    entry = {
                      key,
                      value: collection[key]
                    };
                    if (matches(entry, expr, state)) {
                      entries.push(entry);
                    }
                  }
                }
                switch (whichElement) {
                  case "ALL":
                    entries.forEach(function(entry2) {
                      newCollection[entry2.key] = entry2.value;
                    });
                    return newCollection;
                  case "FIRST":
                    if (entries.length) {
                      returnValue[entries[0].key] = entries[0].value;
                      return returnValue;
                    }
                    return null;
                  case "LAST":
                    if (entries.length) {
                      returnValue[entries[entries.length - 1].key] = entries[entries.length - 1].value;
                      return returnValue;
                    }
                    return null;
                }
                entries.forEach(function(entry2) {
                  newCollection[entry2.key] = entry2.value;
                });
              }
              function createNode(nullSafeNavigation, whichElement, position, expr) {
                var node = _SpelNode.SpelNode.create("selection", position, expr);
                node.getValue = function(state) {
                  var collection = state.activeContext.peek();
                  if (collection) {
                    if (Array.isArray(collection)) {
                      return selectFromArray(collection, whichElement, expr, state);
                    } else if ((typeof collection === "undefined" ? "undefined" : _typeof2(collection)) === "object") {
                      return selectFromMap(collection, whichElement, expr, state);
                    }
                  }
                  return null;
                };
                return node;
              }
              var Selection = exports2.Selection = {
                create: createNode,
                FIRST: "FIRST",
                LAST: "LAST",
                ALL: "ALL"
              };
            },
            /* 42 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Projection = void 0;
              var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                return typeof obj;
              } : function(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              };
              var _SpelNode = __webpack_require__(0);
              function projectCollection(collection, expr, state) {
                return collection.map(function(element) {
                  var matches;
                  state.activeContext.push(element);
                  matches = expr.getValue(state);
                  state.activeContext.pop();
                  return matches;
                });
              }
              function createNode(nullSafeNavigation, position, expr) {
                var node = _SpelNode.SpelNode.create("projection", position, expr);
                node.getValue = function(state) {
                  var collection = state.activeContext.peek(), entries = [], key;
                  if (Array.isArray(collection)) {
                    return projectCollection(collection, expr, state);
                  } else if ((typeof collection === "undefined" ? "undefined" : _typeof2(collection)) === "object") {
                    for (key in collection) {
                      if (collection.hasOwnProperty(key)) {
                        entries.push(collection[key]);
                      }
                    }
                    return projectCollection(entries, expr, state);
                  }
                  return null;
                };
                return node;
              }
              var Projection = exports2.Projection = {
                create: createNode
              };
            },
            /* 43 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpInstanceof = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("instanceof", position, left2, right2);
                node.getValue = function(state) {
                  throw {
                    name: "MethodNotImplementedException",
                    message: "OpInstanceOf: Not implemented"
                  };
                };
                return node;
              }
              var OpInstanceof = exports2.OpInstanceof = {
                create: createNode
              };
            },
            /* 44 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OpBetween = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, left2, right2) {
                var node = _SpelNode.SpelNode.create("between", position, left2, right2);
                node.getValue = function(state) {
                  throw {
                    name: "MethodNotImplementedException",
                    message: "OpBetween: Not implemented"
                  };
                };
                return node;
              }
              var OpBetween = exports2.OpBetween = {
                create: createNode
              };
            },
            /* 45 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TypeReference = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, node, _dims) {
                var node = _SpelNode.SpelNode.create("typeref", position, node);
                node.getValue = function(state) {
                  throw {
                    name: "MethodNotImplementedException",
                    message: "TypeReference: Not implemented"
                  };
                };
                return node;
              }
              var TypeReference = exports2.TypeReference = {
                create: createNode
              };
            },
            /* 46 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.BeanReference = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(position, beanName) {
                var node = _SpelNode.SpelNode.create("beanref", position);
                node.getValue = function(state) {
                  throw {
                    name: "MethodNotImplementedException",
                    message: "BeanReference: Not implemented"
                  };
                };
                return node;
              }
              var BeanReference = exports2.BeanReference = {
                create: createNode
              };
            },
            /* 47 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Identifier = void 0;
              var _SpelNode = __webpack_require__(0);
              function createNode(identifierName, position) {
                var node = _SpelNode.SpelNode.create("identifier", position);
                node.getRaw = function() {
                  return identifierName;
                };
                node.getValue = function(state) {
                  throw {
                    name: "MethodNotImplementedException",
                    message: "Identifier: Not implemented"
                  };
                };
                return node;
              }
              var Identifier = exports2.Identifier = {
                create: createNode
              };
            },
            /* 48 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.QualifiedIdentifier = void 0;
              var _SpelNode = __webpack_require__(0);
              function _toConsumableArray2(arr) {
                if (Array.isArray(arr)) {
                  for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                } else {
                  return Array.from(arr);
                }
              }
              function createNode(position, pieces) {
                var node = _SpelNode.SpelNode.create.apply(_SpelNode.SpelNode, ["qualifiedidentifier", position].concat(_toConsumableArray2(pieces)));
                node.getRaw = function() {
                  return pieces.map(function(p) {
                    return p.getRaw();
                  });
                };
                node.getValue = function(state) {
                  throw {
                    name: "MethodNotImplementedException",
                    message: "QualifiedIdentifier: Not implemented"
                  };
                };
                return node;
              }
              var QualifiedIdentifier = exports2.QualifiedIdentifier = {
                create: createNode
              };
            },
            /* 49 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ConstructorReference = void 0;
              var _SpelNode = __webpack_require__(0);
              var _Stack = __webpack_require__(1);
              function _toConsumableArray2(arr) {
                if (Array.isArray(arr)) {
                  for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                } else {
                  return Array.from(arr);
                }
              }
              function _toArray(arr) {
                return Array.isArray(arr) ? arr : Array.from(arr);
              }
              function createNode(position, dimensions, nodes) {
                var isArray = nodes !== void 0;
                var dimension;
                if (isArray) {
                  dimension = dimensions.length && dimensions[0] && dimensions[0].getType() === "number" ? dimensions[0].getValue() : null;
                } else {
                  nodes = dimensions;
                  dimensions = void 0;
                }
                var _nodes = nodes, _nodes2 = _toArray(_nodes), _qualifiedIdentifier = _nodes2[0], args = _nodes2.slice(1);
                var node = _SpelNode.SpelNode.create.apply(_SpelNode.SpelNode, ["constructorref", position].concat(_toConsumableArray2(nodes)));
                node.getRaw = function() {
                  return dimension;
                };
                node.getValue = function(state) {
                  if (isArray && args.length <= 1) {
                    var compiledArgs = [];
                    args.forEach(function(arg) {
                      var currentActiveContext = state.activeContext;
                      state.activeContext = new _Stack.Stack();
                      state.activeContext.push(state.rootContext);
                      compiledArgs.push(arg.getValue(state));
                      state.activeContext = currentActiveContext;
                    });
                    if (args.length === 1) {
                      return compiledArgs[0];
                    } else {
                      return dimension ? new Array(dimension) : [];
                    }
                  }
                  throw {
                    name: "MethodNotImplementedException",
                    message: "ConstructorReference: Not implemented"
                  };
                };
                return node;
              }
              var ConstructorReference = exports2.ConstructorReference = {
                create: createNode
              };
            },
            /* 50 */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              function create(authentication, principal) {
                var context = {};
                context.authentication = authentication || {};
                context.principal = principal || {};
                context.hasRole = function(role) {
                  var hasRole = false;
                  if (!role) {
                    return false;
                  }
                  if (!context.authentication && !Array.isArray(context.authentication.authorities)) {
                    return false;
                  }
                  context.authentication.authorities.forEach(function(grantedAuthority) {
                    if (grantedAuthority.authority.toLowerCase() === role.toLowerCase()) {
                      hasRole = true;
                    }
                  });
                  return hasRole;
                };
                context.hasPermission = function() {
                  var args = Array.prototype.slice.call(arguments);
                  if (args.length === 1) {
                    return context.hasRole(args[0]);
                  }
                };
                return context;
              }
              var StandardContext = exports2.StandardContext = {
                create
              };
            }
            /******/
          ])
        );
      });
    }
  });

  // node_modules/lodash/_baseForOwn.js
  var require_baseForOwn = __commonJS({
    "node_modules/lodash/_baseForOwn.js"(exports, module) {
      var baseFor = require_baseFor();
      var keys5 = require_keys();
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys5);
      }
      module.exports = baseForOwn;
    }
  });

  // node_modules/lodash/_setCacheAdd.js
  var require_setCacheAdd = __commonJS({
    "node_modules/lodash/_setCacheAdd.js"(exports, module) {
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      module.exports = setCacheAdd;
    }
  });

  // node_modules/lodash/_setCacheHas.js
  var require_setCacheHas = __commonJS({
    "node_modules/lodash/_setCacheHas.js"(exports, module) {
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      module.exports = setCacheHas;
    }
  });

  // node_modules/lodash/_SetCache.js
  var require_SetCache = __commonJS({
    "node_modules/lodash/_SetCache.js"(exports, module) {
      var MapCache = require_MapCache();
      var setCacheAdd = require_setCacheAdd();
      var setCacheHas = require_setCacheHas();
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      module.exports = SetCache;
    }
  });

  // node_modules/lodash/_arraySome.js
  var require_arraySome = __commonJS({
    "node_modules/lodash/_arraySome.js"(exports, module) {
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      module.exports = arraySome;
    }
  });

  // node_modules/lodash/_cacheHas.js
  var require_cacheHas = __commonJS({
    "node_modules/lodash/_cacheHas.js"(exports, module) {
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      module.exports = cacheHas;
    }
  });

  // node_modules/lodash/_equalArrays.js
  var require_equalArrays = __commonJS({
    "node_modules/lodash/_equalArrays.js"(exports, module) {
      var SetCache = require_SetCache();
      var arraySome = require_arraySome();
      var cacheHas = require_cacheHas();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      module.exports = equalArrays;
    }
  });

  // node_modules/lodash/_mapToArray.js
  var require_mapToArray = __commonJS({
    "node_modules/lodash/_mapToArray.js"(exports, module) {
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      module.exports = mapToArray;
    }
  });

  // node_modules/lodash/_setToArray.js
  var require_setToArray = __commonJS({
    "node_modules/lodash/_setToArray.js"(exports, module) {
      function setToArray(set3) {
        var index = -1, result = Array(set3.size);
        set3.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      module.exports = setToArray;
    }
  });

  // node_modules/lodash/_equalByTag.js
  var require_equalByTag = __commonJS({
    "node_modules/lodash/_equalByTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var Uint8Array2 = require_Uint8Array();
      var eq = require_eq();
      var equalArrays = require_equalArrays();
      var mapToArray = require_mapToArray();
      var setToArray = require_setToArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      module.exports = equalByTag;
    }
  });

  // node_modules/lodash/_equalObjects.js
  var require_equalObjects = __commonJS({
    "node_modules/lodash/_equalObjects.js"(exports, module) {
      var getAllKeys = require_getAllKeys();
      var COMPARE_PARTIAL_FLAG = 1;
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      module.exports = equalObjects;
    }
  });

  // node_modules/lodash/_baseIsEqualDeep.js
  var require_baseIsEqualDeep = __commonJS({
    "node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
      var Stack2 = require_Stack();
      var equalArrays = require_equalArrays();
      var equalByTag = require_equalByTag();
      var equalObjects = require_equalObjects();
      var getTag = require_getTag();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isTypedArray = require_isTypedArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack2());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack2());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      module.exports = baseIsEqualDeep;
    }
  });

  // node_modules/lodash/_baseIsEqual.js
  var require_baseIsEqual = __commonJS({
    "node_modules/lodash/_baseIsEqual.js"(exports, module) {
      var baseIsEqualDeep = require_baseIsEqualDeep();
      var isObjectLike = require_isObjectLike();
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      module.exports = baseIsEqual;
    }
  });

  // node_modules/lodash/_baseIsMatch.js
  var require_baseIsMatch = __commonJS({
    "node_modules/lodash/_baseIsMatch.js"(exports, module) {
      var Stack2 = require_Stack();
      var baseIsEqual = require_baseIsEqual();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack2();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      module.exports = baseIsMatch;
    }
  });

  // node_modules/lodash/_isStrictComparable.js
  var require_isStrictComparable = __commonJS({
    "node_modules/lodash/_isStrictComparable.js"(exports, module) {
      var isObject8 = require_isObject();
      function isStrictComparable(value) {
        return value === value && !isObject8(value);
      }
      module.exports = isStrictComparable;
    }
  });

  // node_modules/lodash/_getMatchData.js
  var require_getMatchData = __commonJS({
    "node_modules/lodash/_getMatchData.js"(exports, module) {
      var isStrictComparable = require_isStrictComparable();
      var keys5 = require_keys();
      function getMatchData(object) {
        var result = keys5(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      module.exports = getMatchData;
    }
  });

  // node_modules/lodash/_matchesStrictComparable.js
  var require_matchesStrictComparable = __commonJS({
    "node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      module.exports = matchesStrictComparable;
    }
  });

  // node_modules/lodash/_baseMatches.js
  var require_baseMatches = __commonJS({
    "node_modules/lodash/_baseMatches.js"(exports, module) {
      var baseIsMatch = require_baseIsMatch();
      var getMatchData = require_getMatchData();
      var matchesStrictComparable = require_matchesStrictComparable();
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      module.exports = baseMatches;
    }
  });

  // node_modules/lodash/get.js
  var require_get = __commonJS({
    "node_modules/lodash/get.js"(exports, module) {
      var baseGet = require_baseGet();
      function get2(object, path, defaultValue6) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue6 : result;
      }
      module.exports = get2;
    }
  });

  // node_modules/lodash/_baseMatchesProperty.js
  var require_baseMatchesProperty = __commonJS({
    "node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
      var baseIsEqual = require_baseIsEqual();
      var get2 = require_get();
      var hasIn = require_hasIn();
      var isKey = require_isKey();
      var isStrictComparable = require_isStrictComparable();
      var matchesStrictComparable = require_matchesStrictComparable();
      var toKey = require_toKey();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get2(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      module.exports = baseMatchesProperty;
    }
  });

  // node_modules/lodash/_baseProperty.js
  var require_baseProperty = __commonJS({
    "node_modules/lodash/_baseProperty.js"(exports, module) {
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      module.exports = baseProperty;
    }
  });

  // node_modules/lodash/_basePropertyDeep.js
  var require_basePropertyDeep = __commonJS({
    "node_modules/lodash/_basePropertyDeep.js"(exports, module) {
      var baseGet = require_baseGet();
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      module.exports = basePropertyDeep;
    }
  });

  // node_modules/lodash/property.js
  var require_property = __commonJS({
    "node_modules/lodash/property.js"(exports, module) {
      var baseProperty = require_baseProperty();
      var basePropertyDeep = require_basePropertyDeep();
      var isKey = require_isKey();
      var toKey = require_toKey();
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      module.exports = property;
    }
  });

  // node_modules/lodash/_baseIteratee.js
  var require_baseIteratee = __commonJS({
    "node_modules/lodash/_baseIteratee.js"(exports, module) {
      var baseMatches = require_baseMatches();
      var baseMatchesProperty = require_baseMatchesProperty();
      var identity = require_identity();
      var isArray = require_isArray();
      var property = require_property();
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      module.exports = baseIteratee;
    }
  });

  // node_modules/lodash/mapValues.js
  var require_mapValues = __commonJS({
    "node_modules/lodash/mapValues.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var baseForOwn = require_baseForOwn();
      var baseIteratee = require_baseIteratee();
      function mapValues5(object, iteratee) {
        var result = {};
        iteratee = baseIteratee(iteratee, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result, key, iteratee(value, key, object2));
        });
        return result;
      }
      module.exports = mapValues5;
    }
  });

  // node_modules/react-redux/node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development2 = __commonJS({
    "node_modules/react-redux/node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var REACT_ELEMENT_TYPE = 60103;
          var REACT_PORTAL_TYPE = 60106;
          var REACT_FRAGMENT_TYPE = 60107;
          var REACT_STRICT_MODE_TYPE = 60108;
          var REACT_PROFILER_TYPE = 60114;
          var REACT_PROVIDER_TYPE = 60109;
          var REACT_CONTEXT_TYPE = 60110;
          var REACT_FORWARD_REF_TYPE = 60112;
          var REACT_SUSPENSE_TYPE = 60113;
          var REACT_SUSPENSE_LIST_TYPE = 60120;
          var REACT_MEMO_TYPE = 60115;
          var REACT_LAZY_TYPE = 60116;
          var REACT_BLOCK_TYPE = 60121;
          var REACT_SERVER_BLOCK_TYPE = 60122;
          var REACT_FUNDAMENTAL_TYPE = 60117;
          var REACT_SCOPE_TYPE = 60119;
          var REACT_OPAQUE_ID_TYPE = 60128;
          var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
          var REACT_OFFSCREEN_TYPE = 60130;
          var REACT_LEGACY_HIDDEN_TYPE = 60131;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            REACT_ELEMENT_TYPE = symbolFor("react.element");
            REACT_PORTAL_TYPE = symbolFor("react.portal");
            REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
            REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
            REACT_PROFILER_TYPE = symbolFor("react.profiler");
            REACT_PROVIDER_TYPE = symbolFor("react.provider");
            REACT_CONTEXT_TYPE = symbolFor("react.context");
            REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
            REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
            REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
            REACT_MEMO_TYPE = symbolFor("react.memo");
            REACT_LAZY_TYPE = symbolFor("react.lazy");
            REACT_BLOCK_TYPE = symbolFor("react.block");
            REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
            REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
            REACT_SCOPE_TYPE = symbolFor("react.scope");
            REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
            REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
            REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
            REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
          }
          var enableScopeAPI = false;
          function isValidElementType2(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
                return true;
              }
            }
            return false;
          }
          function typeOf2(object) {
            if (typeof object === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;
                  switch (type) {
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                    case REACT_SUSPENSE_LIST_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element2 = REACT_ELEMENT_TYPE;
          var ForwardRef = REACT_FORWARD_REF_TYPE;
          var Fragment2 = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          var hasWarnedAboutDeprecatedIsConcurrentMode = false;
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
              }
            }
            return false;
          }
          function isConcurrentMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
                hasWarnedAboutDeprecatedIsConcurrentMode = true;
                console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
              }
            }
            return false;
          }
          function isContextConsumer2(object) {
            return typeOf2(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf2(object) === REACT_PROVIDER_TYPE;
          }
          function isElement3(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf2(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf2(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf2(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf2(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf2(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf2(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf2(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf2(object) === REACT_SUSPENSE_TYPE;
          }
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element2;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment2;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer2;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement3;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType2;
          exports.typeOf = typeOf2;
        })();
      }
    }
  });

  // node_modules/react-redux/node_modules/react-is/index.js
  var require_react_is2 = __commonJS({
    "node_modules/react-redux/node_modules/react-is/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_is_development2();
      }
    }
  });

  // node_modules/classnames/index.js
  var require_classnames = __commonJS({
    "node_modules/classnames/index.js"(exports, module) {
      (function() {
        "use strict";
        var hasOwn = {}.hasOwnProperty;
        var nativeCodeString = "[native code]";
        function classNames8() {
          var classes = [];
          for (var i = 0; i < arguments.length; i++) {
            var arg = arguments[i];
            if (!arg)
              continue;
            var argType = typeof arg;
            if (argType === "string" || argType === "number") {
              classes.push(arg);
            } else if (Array.isArray(arg)) {
              if (arg.length) {
                var inner = classNames8.apply(null, arg);
                if (inner) {
                  classes.push(inner);
                }
              }
            } else if (argType === "object") {
              if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                classes.push(arg.toString());
                continue;
              }
              for (var key in arg) {
                if (hasOwn.call(arg, key) && arg[key]) {
                  classes.push(key);
                }
              }
            }
          }
          return classes.join(" ");
        }
        if (typeof module !== "undefined" && module.exports) {
          classNames8.default = classNames8;
          module.exports = classNames8;
        } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
          define("classnames", [], function() {
            return classNames8;
          });
        } else {
          window.classNames = classNames8;
        }
      })();
    }
  });

  // node_modules/lodash/pickBy.js
  var require_pickBy = __commonJS({
    "node_modules/lodash/pickBy.js"(exports, module) {
      var arrayMap = require_arrayMap();
      var baseIteratee = require_baseIteratee();
      var basePickBy = require_basePickBy();
      var getAllKeysIn = require_getAllKeysIn();
      function pickBy2(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = baseIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      module.exports = pickBy2;
    }
  });

  // node_modules/lodash/_baseRange.js
  var require_baseRange = __commonJS({
    "node_modules/lodash/_baseRange.js"(exports, module) {
      var nativeCeil = Math.ceil;
      var nativeMax = Math.max;
      function baseRange(start3, end2, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end2 - start3) / (step || 1)), 0), result = Array(length);
        while (length--) {
          result[fromRight ? length : ++index] = start3;
          start3 += step;
        }
        return result;
      }
      module.exports = baseRange;
    }
  });

  // node_modules/lodash/_trimmedEndIndex.js
  var require_trimmedEndIndex = __commonJS({
    "node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
      var reWhitespace = /\s/;
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      module.exports = trimmedEndIndex;
    }
  });

  // node_modules/lodash/_baseTrim.js
  var require_baseTrim = __commonJS({
    "node_modules/lodash/_baseTrim.js"(exports, module) {
      var trimmedEndIndex = require_trimmedEndIndex();
      var reTrimStart = /^\s+/;
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      module.exports = baseTrim;
    }
  });

  // node_modules/lodash/toNumber.js
  var require_toNumber = __commonJS({
    "node_modules/lodash/toNumber.js"(exports, module) {
      var baseTrim = require_baseTrim();
      var isObject8 = require_isObject();
      var isSymbol = require_isSymbol();
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject8(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject8(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = toNumber;
    }
  });

  // node_modules/lodash/toFinite.js
  var require_toFinite = __commonJS({
    "node_modules/lodash/toFinite.js"(exports, module) {
      var toNumber = require_toNumber();
      var INFINITY = 1 / 0;
      var MAX_INTEGER = 17976931348623157e292;
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      module.exports = toFinite;
    }
  });

  // node_modules/lodash/_createRange.js
  var require_createRange = __commonJS({
    "node_modules/lodash/_createRange.js"(exports, module) {
      var baseRange = require_baseRange();
      var isIterateeCall = require_isIterateeCall();
      var toFinite = require_toFinite();
      function createRange(fromRight) {
        return function(start3, end2, step) {
          if (step && typeof step != "number" && isIterateeCall(start3, end2, step)) {
            end2 = step = void 0;
          }
          start3 = toFinite(start3);
          if (end2 === void 0) {
            end2 = start3;
            start3 = 0;
          } else {
            end2 = toFinite(end2);
          }
          step = step === void 0 ? start3 < end2 ? 1 : -1 : toFinite(step);
          return baseRange(start3, end2, step, fromRight);
        };
      }
      module.exports = createRange;
    }
  });

  // node_modules/lodash/range.js
  var require_range = __commonJS({
    "node_modules/lodash/range.js"(exports, module) {
      var createRange = require_createRange();
      var range3 = createRange();
      module.exports = range3;
    }
  });

  // node_modules/lodash/_baseClamp.js
  var require_baseClamp = __commonJS({
    "node_modules/lodash/_baseClamp.js"(exports, module) {
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== void 0) {
            number = number <= upper ? number : upper;
          }
          if (lower !== void 0) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      module.exports = baseClamp;
    }
  });

  // node_modules/lodash/toInteger.js
  var require_toInteger = __commonJS({
    "node_modules/lodash/toInteger.js"(exports, module) {
      var toFinite = require_toFinite();
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      module.exports = toInteger;
    }
  });

  // node_modules/lodash/startsWith.js
  var require_startsWith = __commonJS({
    "node_modules/lodash/startsWith.js"(exports, module) {
      var baseClamp = require_baseClamp();
      var baseToString = require_baseToString();
      var toInteger = require_toInteger();
      var toString = require_toString();
      function startsWith2(string, target, position) {
        string = toString(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      module.exports = startsWith2;
    }
  });

  // node_modules/@babel/runtime/helpers/typeof.js
  var require_typeof = __commonJS({
    "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(obj);
      }
      module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorRuntime.js
  var require_regeneratorRuntime = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
      var _typeof2 = require_typeof()["default"];
      function _regeneratorRuntime2() {
        "use strict";
        module.exports = _regeneratorRuntime2 = function _regeneratorRuntime3() {
          return exports2;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
        var exports2 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
          obj[key] = desc.value;
        }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
        function define2(obj, key, value) {
          return Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          }), obj[key];
        }
        try {
          define2({}, "");
        } catch (err) {
          define2 = function define3(obj, key, value) {
            return obj[key] = value;
          };
        }
        function wrap(innerFn, outerFn, self2, tryLocsList) {
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context2(tryLocsList || []);
          return defineProperty(generator, "_invoke", {
            value: makeInvokeMethod(innerFn, self2, context)
          }), generator;
        }
        function tryCatch(fn2, obj, arg) {
          try {
            return {
              type: "normal",
              arg: fn2.call(obj, arg)
            };
          } catch (err) {
            return {
              type: "throw",
              arg: err
            };
          }
        }
        exports2.wrap = wrap;
        var ContinueSentinel = {};
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        }
        var IteratorPrototype = {};
        define2(IteratorPrototype, iteratorSymbol, function() {
          return this;
        });
        var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function(method) {
            define2(prototype, method, function(arg) {
              return this._invoke(method, arg);
            });
          });
        }
        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if ("throw" !== record.type) {
              var result = record.arg, value = result.value;
              return value && "object" == _typeof2(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              }) : PromiseImpl.resolve(value).then(function(unwrapped) {
                result.value = unwrapped, resolve(result);
              }, function(error2) {
                return invoke("throw", error2, resolve, reject);
              });
            }
            reject(record.arg);
          }
          var previousPromise;
          defineProperty(this, "_invoke", {
            value: function value(method, arg) {
              function callInvokeWithMethodAndArg() {
                return new PromiseImpl(function(resolve, reject) {
                  invoke(method, arg, resolve, reject);
                });
              }
              return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
            }
          });
        }
        function makeInvokeMethod(innerFn, self2, context) {
          var state = "suspendedStart";
          return function(method, arg) {
            if ("executing" === state)
              throw new Error("Generator is already running");
            if ("completed" === state) {
              if ("throw" === method)
                throw arg;
              return doneResult();
            }
            for (context.method = method, context.arg = arg; ; ) {
              var delegate = context.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel)
                    continue;
                  return delegateResult;
                }
              }
              if ("next" === context.method)
                context.sent = context._sent = context.arg;
              else if ("throw" === context.method) {
                if ("suspendedStart" === state)
                  throw state = "completed", context.arg;
                context.dispatchException(context.arg);
              } else
                "return" === context.method && context.abrupt("return", context.arg);
              state = "executing";
              var record = tryCatch(innerFn, self2, context);
              if ("normal" === record.type) {
                if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                  continue;
                return {
                  value: record.arg,
                  done: context.done
                };
              }
              "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
            }
          };
        }
        function maybeInvokeDelegate(delegate, context) {
          var methodName = context.method, method = delegate.iterator[methodName];
          if (void 0 === method)
            return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
          var record = tryCatch(method, delegate.iterator, context.arg);
          if ("throw" === record.type)
            return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
          var info = record.arg;
          return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
        }
        function pushTryEntry(locs) {
          var entry = {
            tryLoc: locs[0]
          };
          1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
        }
        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal", delete record.arg, entry.completion = record;
        }
        function Context2(tryLocsList) {
          this.tryEntries = [{
            tryLoc: "root"
          }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
        }
        function values(iterable) {
          if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod)
              return iteratorMethod.call(iterable);
            if ("function" == typeof iterable.next)
              return iterable;
            if (!isNaN(iterable.length)) {
              var i = -1, next = function next2() {
                for (; ++i < iterable.length; )
                  if (hasOwn.call(iterable, i))
                    return next2.value = iterable[i], next2.done = false, next2;
                return next2.value = void 0, next2.done = true, next2;
              };
              return next.next = next;
            }
          }
          return {
            next: doneResult
          };
        }
        function doneResult() {
          return {
            value: void 0,
            done: true
          };
        }
        return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
          value: GeneratorFunctionPrototype,
          configurable: true
        }), defineProperty(GeneratorFunctionPrototype, "constructor", {
          value: GeneratorFunction,
          configurable: true
        }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
          var ctor = "function" == typeof genFun && genFun.constructor;
          return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
        }, exports2.mark = function(genFun) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
        }, exports2.awrap = function(arg) {
          return {
            __await: arg
          };
        }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
          return this;
        }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
          void 0 === PromiseImpl && (PromiseImpl = Promise);
          var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
          return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
        }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
          return this;
        }), define2(Gp, "toString", function() {
          return "[object Generator]";
        }), exports2.keys = function(val) {
          var object = Object(val), keys5 = [];
          for (var key in object)
            keys5.push(key);
          return keys5.reverse(), function next() {
            for (; keys5.length; ) {
              var key2 = keys5.pop();
              if (key2 in object)
                return next.value = key2, next.done = false, next;
            }
            return next.done = true, next;
          };
        }, exports2.values = values, Context2.prototype = {
          constructor: Context2,
          reset: function reset(skipTempReset) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
              for (var name in this)
                "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
          },
          stop: function stop() {
            this.done = true;
            var rootRecord = this.tryEntries[0].completion;
            if ("throw" === rootRecord.type)
              throw rootRecord.arg;
            return this.rval;
          },
          dispatchException: function dispatchException(exception) {
            if (this.done)
              throw exception;
            var context = this;
            function handle(loc, caught) {
              return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
            }
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i], record = entry.completion;
              if ("root" === entry.tryLoc)
                return handle("end");
              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc)
                    return handle(entry.catchLoc, true);
                  if (this.prev < entry.finallyLoc)
                    return handle(entry.finallyLoc);
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc)
                    return handle(entry.catchLoc, true);
                } else {
                  if (!hasFinally)
                    throw new Error("try statement without catch or finally");
                  if (this.prev < entry.finallyLoc)
                    return handle(entry.finallyLoc);
                }
              }
            }
          },
          abrupt: function abrupt(type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }
            finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
            var record = finallyEntry ? finallyEntry.completion : {};
            return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
          },
          complete: function complete(record, afterLoc) {
            if ("throw" === record.type)
              throw record.arg;
            return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
          },
          finish: function finish(finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.finallyLoc === finallyLoc)
                return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
            }
          },
          "catch": function _catch(tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;
                if ("throw" === record.type) {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }
                return thrown;
              }
            }
            throw new Error("illegal catch attempt");
          },
          delegateYield: function delegateYield(iterable, resultName, nextLoc) {
            return this.delegate = {
              iterator: values(iterable),
              resultName,
              nextLoc
            }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
          }
        }, exports2;
      }
      module.exports = _regeneratorRuntime2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/regenerator/index.js
  var require_regenerator = __commonJS({
    "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
      var runtime = require_regeneratorRuntime()();
      module.exports = runtime;
      try {
        regeneratorRuntime = runtime;
      } catch (accidentalStrictMode) {
        if (typeof globalThis === "object") {
          globalThis.regeneratorRuntime = runtime;
        } else {
          Function("r", "regeneratorRuntime = r")(runtime);
        }
      }
    }
  });

  // node_modules/lodash/now.js
  var require_now = __commonJS({
    "node_modules/lodash/now.js"(exports, module) {
      var root = require_root();
      var now2 = function() {
        return root.Date.now();
      };
      module.exports = now2;
    }
  });

  // node_modules/lodash/debounce.js
  var require_debounce = __commonJS({
    "node_modules/lodash/debounce.js"(exports, module) {
      var isObject8 = require_isObject();
      var now2 = require_now();
      var toNumber = require_toNumber();
      var FUNC_ERROR_TEXT = "Expected a function";
      var nativeMax = Math.max;
      var nativeMin = Math.min;
      function debounce3(func, wait, options2) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject8(options2)) {
          leading = !!options2.leading;
          maxing = "maxWait" in options2;
          maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options2 ? !!options2.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      module.exports = debounce3;
    }
  });

  // node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  (function() {
    if (window.Reflect === void 0 || window.customElements === void 0 || window.customElements.polyfillWrapFlushCallback) {
      return;
    }
    const BuiltInHTMLElement = HTMLElement;
    const wrapperForTheName = {
      HTMLElement: function HTMLElement2() {
        return Reflect.construct(BuiltInHTMLElement, [], this.constructor);
      }
    };
    window.HTMLElement = wrapperForTheName["HTMLElement"];
    HTMLElement.prototype = BuiltInHTMLElement.prototype;
    HTMLElement.prototype.constructor = HTMLElement;
    Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);
  })();
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function")
      return;
    prototype.requestSubmit = function(submitter) {
      if (submitter) {
        validateSubmitter(submitter, this);
        submitter.click();
      } else {
        submitter = document.createElement("input");
        submitter.type = "submit";
        submitter.hidden = true;
        this.appendChild(submitter);
        submitter.click();
        this.removeChild(submitter);
      }
    };
    function validateSubmitter(submitter, form) {
      submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
    }
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return (candidate === null || candidate === void 0 ? void 0 : candidate.type) == "submit" ? candidate : null;
  }
  function clickCaptured(event) {
    const submitter = findSubmitterFromClickTarget(event.target);
    if (submitter && submitter.form) {
      submittersByForm.set(submitter.form, submitter);
    }
  }
  (function() {
    if ("submitter" in Event.prototype)
      return;
    let prototype = window.Event.prototype;
    if ("SubmitEvent" in window && /Apple Computer/.test(navigator.vendor)) {
      prototype = window.SubmitEvent.prototype;
    } else if ("SubmitEvent" in window) {
      return;
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle;
  (function(FrameLoadingStyle2) {
    FrameLoadingStyle2["eager"] = "eager";
    FrameLoadingStyle2["lazy"] = "lazy";
  })(FrameLoadingStyle || (FrameLoadingStyle = {}));
  var FrameElement = class extends HTMLElement {
    static get observedAttributes() {
      return ["disabled", "complete", "loading", "src"];
    }
    constructor() {
      super();
      this.loaded = Promise.resolve();
      this.delegate = new FrameElement.delegateConstructor(this);
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      return this.delegate.sourceURLReloaded();
    }
    attributeChangedCallback(name) {
      if (name == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name == "complete") {
        this.delegate.completeChanged();
      } else if (name == "src") {
        this.delegate.sourceURLChanged();
      } else {
        this.delegate.disabledChanged();
      }
    }
    get src() {
      return this.getAttribute("src");
    }
    set src(value) {
      if (value) {
        this.setAttribute("src", value);
      } else {
        this.removeAttribute("src");
      }
    }
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    set loading(value) {
      if (value) {
        this.setAttribute("loading", value);
      } else {
        this.removeAttribute("loading");
      }
    }
    get disabled() {
      return this.hasAttribute("disabled");
    }
    set disabled(value) {
      if (value) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    set autoscroll(value) {
      if (value) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    get complete() {
      return !this.delegate.isLoading;
    }
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    get isPreview() {
      var _a, _b;
      return (_b = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement) === null || _b === void 0 ? void 0 : _b.hasAttribute("data-turbo-preview");
    }
  };
  function frameLoadingStyleFromString(style) {
    switch (style.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  function getAction(form, submitter) {
    const action = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formaction")) || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  function isHTML(url) {
    return !!getExtension(url).match(/^(?:|\.(?:htm|html|xhtml|php))$/);
  }
  function isPrefixedBy(baseURL, url) {
    const prefix = getPrefix(url);
    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
  }
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && isHTML(location2);
  }
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  function urlsAreEqual(left2, right2) {
    return expandURL(left2).href == expandURL(right2).href;
  }
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  function addTrailingSlash(value) {
    return value.endsWith("/") ? value : value + "/";
  }
  var FetchResponse = class {
    constructor(response) {
      this.response = response;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name) {
      return this.response.headers.get(name);
    }
  };
  function activateScriptElement(element) {
    if (element.getAttribute("data-turbo-eval") == "false") {
      return element;
    } else {
      const createdScriptElement = document.createElement("script");
      const cspNonce = getMetaContent("csp-nonce");
      if (cspNonce) {
        createdScriptElement.nonce = cspNonce;
      }
      createdScriptElement.textContent = element.textContent;
      createdScriptElement.async = false;
      copyElementAttributes(createdScriptElement, element);
      return createdScriptElement;
    }
  }
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name, value } of sourceElement.attributes) {
      destinationElement.setAttribute(name, value);
    }
  }
  function createDocumentFragment(html) {
    const template = document.createElement("template");
    template.innerHTML = html;
    return template.content;
  }
  function dispatch(eventName, { target, cancelable, detail } = {}) {
    const event = new CustomEvent(eventName, {
      cancelable,
      bubbles: true,
      composed: true,
      detail
    });
    if (target && target.isConnected) {
      target.dispatchEvent(event);
    } else {
      document.documentElement.dispatchEvent(event);
    }
    return event;
  }
  function nextAnimationFrame() {
    return new Promise((resolve) => requestAnimationFrame(() => resolve()));
  }
  function nextEventLoopTick() {
    return new Promise((resolve) => setTimeout(() => resolve(), 0));
  }
  function nextMicrotask() {
    return Promise.resolve();
  }
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  function unindent(strings, ...values) {
    const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
    const match2 = lines[0].match(/^\s+/);
    const indent = match2 ? match2[0].length : 0;
    return lines.map((line) => line.slice(indent)).join("\n");
  }
  function interpolate(strings, values) {
    return strings.reduce((result, string, i) => {
      const value = values[i] == void 0 ? "" : values[i];
      return result + string + value;
    }, "");
  }
  function uuid() {
    return Array.from({ length: 36 }).map((_, i) => {
      if (i == 8 || i == 13 || i == 18 || i == 23) {
        return "-";
      } else if (i == 14) {
        return "4";
      } else if (i == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  function getAttribute(attributeName, ...elements) {
    for (const value of elements.map((element) => element === null || element === void 0 ? void 0 : element.getAttribute(attributeName))) {
      if (typeof value == "string")
        return value;
    }
    return null;
  }
  function hasAttribute(attributeName, ...elements) {
    return elements.some((element) => element && element.hasAttribute(attributeName));
  }
  function markAsBusy(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  function clearBusyState(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  function waitForLoad(element, timeoutInMilliseconds = 2e3) {
    return new Promise((resolve) => {
      const onComplete = () => {
        element.removeEventListener("error", onComplete);
        element.removeEventListener("load", onComplete);
        resolve();
      };
      element.addEventListener("load", onComplete, { once: true });
      element.addEventListener("error", onComplete, { once: true });
      setTimeout(resolve, timeoutInMilliseconds);
    });
  }
  function getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  function getVisitAction(...elements) {
    const action = getAttribute("data-turbo-action", ...elements);
    return isAction(action) ? action : null;
  }
  function getMetaElement(name) {
    return document.querySelector(`meta[name="${name}"]`);
  }
  function getMetaContent(name) {
    const element = getMetaElement(name);
    return element && element.content;
  }
  function setMetaContent(name, content) {
    let element = getMetaElement(name);
    if (!element) {
      element = document.createElement("meta");
      element.setAttribute("name", name);
      document.head.appendChild(element);
    }
    element.setAttribute("content", content);
    return element;
  }
  function findClosestRecursively(element, selector) {
    var _a;
    if (element instanceof Element) {
      return element.closest(selector) || findClosestRecursively(element.assignedSlot || ((_a = element.getRootNode()) === null || _a === void 0 ? void 0 : _a.host), selector);
    }
  }
  var FetchMethod;
  (function(FetchMethod2) {
    FetchMethod2[FetchMethod2["get"] = 0] = "get";
    FetchMethod2[FetchMethod2["post"] = 1] = "post";
    FetchMethod2[FetchMethod2["put"] = 2] = "put";
    FetchMethod2[FetchMethod2["patch"] = 3] = "patch";
    FetchMethod2[FetchMethod2["delete"] = 4] = "delete";
  })(FetchMethod || (FetchMethod = {}));
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  var FetchRequest = class {
    constructor(delegate, method, location2, body = new URLSearchParams(), target = null) {
      this.abortController = new AbortController();
      this.resolveRequestPromise = (_value) => {
      };
      this.delegate = delegate;
      this.method = method;
      this.headers = this.defaultHeaders;
      this.body = body;
      this.url = location2;
      this.target = target;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    async perform() {
      const { fetchOptions } = this;
      this.delegate.prepareRequest(this);
      await this.allowRequestToBeIntercepted(fetchOptions);
      try {
        this.delegate.requestStarted(this);
        const response = await fetch(this.url.href, fetchOptions);
        return await this.receive(response);
      } catch (error2) {
        if (error2.name !== "AbortError") {
          if (this.willDelegateErrorHandling(error2)) {
            this.delegate.requestErrored(this, error2);
          }
          throw error2;
        }
      } finally {
        this.delegate.requestFinished(this);
      }
    }
    async receive(response) {
      const fetchResponse = new FetchResponse(response);
      const event = dispatch("turbo:before-fetch-response", {
        cancelable: true,
        detail: { fetchResponse },
        target: this.target
      });
      if (event.defaultPrevented) {
        this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
      } else if (fetchResponse.succeeded) {
        this.delegate.requestSucceededWithResponse(this, fetchResponse);
      } else {
        this.delegate.requestFailedWithResponse(this, fetchResponse);
      }
      return fetchResponse;
    }
    get fetchOptions() {
      var _a;
      return {
        method: FetchMethod[this.method].toUpperCase(),
        credentials: "same-origin",
        headers: this.headers,
        redirect: "follow",
        body: this.isSafe ? null : this.body,
        signal: this.abortSignal,
        referrer: (_a = this.delegate.referrer) === null || _a === void 0 ? void 0 : _a.href
      };
    }
    get defaultHeaders() {
      return {
        Accept: "text/html, application/xhtml+xml"
      };
    }
    get isSafe() {
      return this.method === FetchMethod.get;
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    acceptResponseType(mimeType) {
      this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
    }
    async allowRequestToBeIntercepted(fetchOptions) {
      const requestInterception = new Promise((resolve) => this.resolveRequestPromise = resolve);
      const event = dispatch("turbo:before-fetch-request", {
        cancelable: true,
        detail: {
          fetchOptions,
          url: this.url,
          resume: this.resolveRequestPromise
        },
        target: this.target
      });
      if (event.defaultPrevented)
        await requestInterception;
    }
    willDelegateErrorHandling(error2) {
      const event = dispatch("turbo:fetch-request-error", {
        target: this.target,
        cancelable: true,
        detail: { request: this, error: error2 }
      });
      return !event.defaultPrevented;
    }
  };
  var AppearanceObserver = class {
    constructor(delegate, element) {
      this.started = false;
      this.intersect = (entries) => {
        const lastEntry = entries.slice(-1)[0];
        if (lastEntry === null || lastEntry === void 0 ? void 0 : lastEntry.isIntersecting) {
          this.delegate.elementAppearedInViewport(this.element);
        }
      };
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
  };
  var StreamMessage = class {
    static wrap(message) {
      if (typeof message == "string") {
        return new this(createDocumentFragment(message));
      } else {
        return message;
      }
    }
    constructor(fragment) {
      this.fragment = importStreamElements(fragment);
    }
  };
  StreamMessage.contentType = "text/vnd.turbo-stream.html";
  function importStreamElements(fragment) {
    for (const element of fragment.querySelectorAll("turbo-stream")) {
      const streamElement = document.importNode(element, true);
      for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
        inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
      }
      element.replaceWith(streamElement);
    }
    return fragment;
  }
  var FormSubmissionState;
  (function(FormSubmissionState2) {
    FormSubmissionState2[FormSubmissionState2["initialized"] = 0] = "initialized";
    FormSubmissionState2[FormSubmissionState2["requesting"] = 1] = "requesting";
    FormSubmissionState2[FormSubmissionState2["waiting"] = 2] = "waiting";
    FormSubmissionState2[FormSubmissionState2["receiving"] = 3] = "receiving";
    FormSubmissionState2[FormSubmissionState2["stopping"] = 4] = "stopping";
    FormSubmissionState2[FormSubmissionState2["stopped"] = 5] = "stopped";
  })(FormSubmissionState || (FormSubmissionState = {}));
  var FormEnctype;
  (function(FormEnctype2) {
    FormEnctype2["urlEncoded"] = "application/x-www-form-urlencoded";
    FormEnctype2["multipart"] = "multipart/form-data";
    FormEnctype2["plain"] = "text/plain";
  })(FormEnctype || (FormEnctype = {}));
  function formEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FormEnctype.multipart:
        return FormEnctype.multipart;
      case FormEnctype.plain:
        return FormEnctype.plain;
      default:
        return FormEnctype.urlEncoded;
    }
  }
  var FormSubmission = class {
    static confirmMethod(message, _element, _submitter) {
      return Promise.resolve(confirm(message));
    }
    constructor(delegate, formElement, submitter, mustRedirect = false) {
      this.state = FormSubmissionState.initialized;
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter;
      this.formData = buildFormData(formElement, submitter);
      this.location = expandURL(this.action);
      if (this.method == FetchMethod.get) {
        mergeFormDataEntries(this.location, [...this.body.entries()]);
      }
      this.fetchRequest = new FetchRequest(this, this.method, this.location, this.body, this.formElement);
      this.mustRedirect = mustRedirect;
    }
    get method() {
      var _a;
      const method = ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formmethod")) || this.formElement.getAttribute("method") || "";
      return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
    }
    get action() {
      var _a;
      const formElementAction = typeof this.formElement.action === "string" ? this.formElement.action : null;
      if ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.hasAttribute("formaction")) {
        return this.submitter.getAttribute("formaction") || "";
      } else {
        return this.formElement.getAttribute("action") || formElementAction || "";
      }
    }
    get body() {
      if (this.enctype == FormEnctype.urlEncoded || this.method == FetchMethod.get) {
        return new URLSearchParams(this.stringFormData);
      } else {
        return this.formData;
      }
    }
    get enctype() {
      var _a;
      return formEnctypeFromString(((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formenctype")) || this.formElement.enctype);
    }
    get isSafe() {
      return this.fetchRequest.isSafe;
    }
    get stringFormData() {
      return [...this.formData].reduce((entries, [name, value]) => {
        return entries.concat(typeof value == "string" ? [[name, value]] : []);
      }, []);
    }
    async start() {
      const { initialized, requesting } = FormSubmissionState;
      const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
      if (typeof confirmationMessage === "string") {
        const answer = await FormSubmission.confirmMethod(confirmationMessage, this.formElement, this.submitter);
        if (!answer) {
          return;
        }
      }
      if (this.state == initialized) {
        this.state = requesting;
        return this.fetchRequest.perform();
      }
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    prepareRequest(request) {
      if (!request.isSafe) {
        const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token) {
          request.headers["X-CSRF-Token"] = token;
        }
      }
      if (this.requestAcceptsTurboStreamResponse(request)) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      var _a;
      this.state = FormSubmissionState.waiting;
      (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.setAttribute("disabled", "");
      this.setSubmitsWith();
      dispatch("turbo:submit-start", {
        target: this.formElement,
        detail: { formSubmission: this }
      });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request, response) {
      this.result = { success: response.succeeded, fetchResponse: response };
    }
    requestSucceededWithResponse(request, response) {
      if (response.clientError || response.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response);
      } else if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
        const error2 = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error2);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response };
        this.delegate.formSubmissionSucceededWithResponse(this, response);
      }
    }
    requestFailedWithResponse(request, response) {
      this.result = { success: false, fetchResponse: response };
      this.delegate.formSubmissionFailedWithResponse(this, response);
    }
    requestErrored(request, error2) {
      this.result = { success: false, error: error2 };
      this.delegate.formSubmissionErrored(this, error2);
    }
    requestFinished(_request) {
      var _a;
      this.state = FormSubmissionState.stopped;
      (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.removeAttribute("disabled");
      this.resetSubmitterText();
      dispatch("turbo:submit-end", {
        target: this.formElement,
        detail: Object.assign({ formSubmission: this }, this.result)
      });
      this.delegate.formSubmissionFinished(this);
    }
    setSubmitsWith() {
      if (!this.submitter || !this.submitsWith)
        return;
      if (this.submitter.matches("button")) {
        this.originalSubmitText = this.submitter.innerHTML;
        this.submitter.innerHTML = this.submitsWith;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        this.originalSubmitText = input.value;
        input.value = this.submitsWith;
      }
    }
    resetSubmitterText() {
      if (!this.submitter || !this.originalSubmitText)
        return;
      if (this.submitter.matches("button")) {
        this.submitter.innerHTML = this.originalSubmitText;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        input.value = this.originalSubmitText;
      }
    }
    requestMustRedirect(request) {
      return !request.isSafe && this.mustRedirect;
    }
    requestAcceptsTurboStreamResponse(request) {
      return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
    }
    get submitsWith() {
      var _a;
      return (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("data-turbo-submits-with");
    }
  };
  function buildFormData(formElement, submitter) {
    const formData = new FormData(formElement);
    const name = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("name");
    const value = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("value");
    if (name) {
      formData.append(name, value || "");
    }
    return formData;
  }
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value = cookie.split("=").slice(1).join("=");
        return value ? decodeURIComponent(value) : void 0;
      }
    }
  }
  function responseSucceededWithoutRedirect(response) {
    return response.statusCode == 200 && !response.redirected;
  }
  function mergeFormDataEntries(url, entries) {
    const searchParams = new URLSearchParams();
    for (const [name, value] of entries) {
      if (value instanceof File)
        continue;
      searchParams.append(name, value);
    }
    url.search = searchParams.toString();
    return url;
  }
  var Snapshot = class {
    constructor(element) {
      this.element = element;
    }
    get activeElement() {
      return this.element.ownerDocument.activeElement;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
      for (const element of this.element.querySelectorAll("[autofocus]")) {
        if (element.closest(inertDisabledOrHidden) == null)
          return element;
        else
          continue;
      }
      return null;
    }
    get permanentElements() {
      return queryPermanentElementsAll(this.element);
    }
    getPermanentElementById(id) {
      return getPermanentElementById(this.element, id);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id);
        if (newPermanentElement) {
          permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  function getPermanentElementById(node, id) {
    return node.querySelector(`#${id}[data-turbo-permanent]`);
  }
  function queryPermanentElementsAll(node) {
    return node.querySelectorAll("[id][data-turbo-permanent]");
  }
  var FormSubmitObserver = class {
    constructor(delegate, eventTarget) {
      this.started = false;
      this.submitCaptured = () => {
        this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
        this.eventTarget.addEventListener("submit", this.submitBubbled, false);
      };
      this.submitBubbled = (event) => {
        if (!event.defaultPrevented) {
          const form = event.target instanceof HTMLFormElement ? event.target : void 0;
          const submitter = event.submitter || void 0;
          if (form && submissionDoesNotDismissDialog(form, submitter) && submissionDoesNotTargetIFrame(form, submitter) && this.delegate.willSubmitForm(form, submitter)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            this.delegate.formSubmitted(form, submitter);
          }
        }
      };
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
  };
  function submissionDoesNotDismissDialog(form, submitter) {
    const method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formmethod")) || form.getAttribute("method");
    return method != "dialog";
  }
  function submissionDoesNotTargetIFrame(form, submitter) {
    if ((submitter === null || submitter === void 0 ? void 0 : submitter.hasAttribute("formtarget")) || form.hasAttribute("target")) {
      const target = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formtarget")) || form.target;
      for (const element of document.getElementsByName(target)) {
        if (element instanceof HTMLIFrameElement)
          return false;
      }
      return true;
    } else {
      return true;
    }
  }
  var View = class {
    constructor(delegate, element) {
      this.resolveRenderPromise = (_value) => {
      };
      this.resolveInterceptionPromise = (_value) => {
      };
      this.delegate = delegate;
      this.element = element;
    }
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x, y }) {
      this.scrollRoot.scrollTo(x, y);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    async render(renderer) {
      const { isPreview, shouldRender, newSnapshot: snapshot } = renderer;
      if (shouldRender) {
        try {
          this.renderPromise = new Promise((resolve) => this.resolveRenderPromise = resolve);
          this.renderer = renderer;
          await this.prepareToRenderSnapshot(renderer);
          const renderInterception = new Promise((resolve) => this.resolveInterceptionPromise = resolve);
          const options2 = { resume: this.resolveInterceptionPromise, render: this.renderer.renderElement };
          const immediateRender = this.delegate.allowsImmediateRender(snapshot, options2);
          if (!immediateRender)
            await renderInterception;
          await this.renderSnapshot(renderer);
          this.delegate.viewRenderedSnapshot(snapshot, isPreview);
          this.delegate.preloadOnLoadLinksForView(this.element);
          this.finishRenderingSnapshot(renderer);
        } finally {
          delete this.renderer;
          this.resolveRenderPromise(void 0);
          delete this.renderPromise;
        }
      } else {
        this.invalidate(renderer.reloadReason);
      }
    }
    invalidate(reason) {
      this.delegate.viewInvalidated(reason);
    }
    async prepareToRenderSnapshot(renderer) {
      this.markAsPreview(renderer.isPreview);
      await renderer.prepareToRender();
    }
    markAsPreview(isPreview) {
      if (isPreview) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    async renderSnapshot(renderer) {
      await renderer.render();
    }
    finishRenderingSnapshot(renderer) {
      renderer.finishRendering();
    }
  };
  var FrameView = class extends View {
    missing() {
      this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    constructor(delegate, element) {
      this.clickBubbled = (event) => {
        if (this.respondsToEventTarget(event.target)) {
          this.clickEvent = event;
        } else {
          delete this.clickEvent;
        }
      };
      this.linkClicked = (event) => {
        if (this.clickEvent && this.respondsToEventTarget(event.target) && event.target instanceof Element) {
          if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
            this.clickEvent.preventDefault();
            event.preventDefault();
            this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
          }
        }
        delete this.clickEvent;
      };
      this.willVisit = (_event) => {
        delete this.clickEvent;
      };
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    respondsToEventTarget(target) {
      const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
      return element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var LinkClickObserver = class {
    constructor(delegate, eventTarget) {
      this.started = false;
      this.clickCaptured = () => {
        this.eventTarget.removeEventListener("click", this.clickBubbled, false);
        this.eventTarget.addEventListener("click", this.clickBubbled, false);
      };
      this.clickBubbled = (event) => {
        if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
          const target = event.composedPath && event.composedPath()[0] || event.target;
          const link = this.findLinkFromClickTarget(target);
          if (link && doesNotTargetIFrame(link)) {
            const location2 = this.getLocationForLink(link);
            if (this.delegate.willFollowLinkToLocation(link, location2, event)) {
              event.preventDefault();
              this.delegate.followedLinkToLocation(link, location2);
            }
          }
        }
      };
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickEventIsSignificant(event) {
      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
    }
    findLinkFromClickTarget(target) {
      return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
    }
    getLocationForLink(link) {
      return expandURL(link.getAttribute("href") || "");
    }
  };
  function doesNotTargetIFrame(anchor) {
    if (anchor.hasAttribute("target")) {
      for (const element of document.getElementsByName(anchor.target)) {
        if (element instanceof HTMLIFrameElement)
          return false;
      }
      return true;
    } else {
      return true;
    }
  }
  var FormLinkClickObserver = class {
    constructor(delegate, element) {
      this.delegate = delegate;
      this.linkInterceptor = new LinkClickObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
    }
    willFollowLinkToLocation(link, location2, originalEvent) {
      return this.delegate.willSubmitFormLinkToLocation(link, location2, originalEvent) && link.hasAttribute("data-turbo-method");
    }
    followedLinkToLocation(link, location2) {
      const form = document.createElement("form");
      const type = "hidden";
      for (const [name, value] of location2.searchParams) {
        form.append(Object.assign(document.createElement("input"), { type, name, value }));
      }
      const action = Object.assign(location2, { search: "" });
      form.setAttribute("data-turbo", "true");
      form.setAttribute("action", action.href);
      form.setAttribute("hidden", "");
      const method = link.getAttribute("data-turbo-method");
      if (method)
        form.setAttribute("method", method);
      const turboFrame = link.getAttribute("data-turbo-frame");
      if (turboFrame)
        form.setAttribute("data-turbo-frame", turboFrame);
      const turboAction = getVisitAction(link);
      if (turboAction)
        form.setAttribute("data-turbo-action", turboAction);
      const turboConfirm = link.getAttribute("data-turbo-confirm");
      if (turboConfirm)
        form.setAttribute("data-turbo-confirm", turboConfirm);
      const turboStream = link.hasAttribute("data-turbo-stream");
      if (turboStream)
        form.setAttribute("data-turbo-stream", "");
      this.delegate.submittedFormLinkToLocation(link, location2, form);
      document.body.appendChild(form);
      form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
      requestAnimationFrame(() => form.requestSubmit());
    }
  };
  var Bardo = class {
    static async preservingPermanentElements(delegate, permanentElementMap, callback) {
      const bardo = new this(delegate, permanentElementMap);
      bardo.enter();
      await callback();
      bardo.leave();
    }
    constructor(delegate, permanentElementMap) {
      this.delegate = delegate;
      this.permanentElementMap = permanentElementMap;
    }
    enter() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];
        this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
        this.delegate.leavingBardo(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone5 = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone5);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder === null || placeholder === void 0 ? void 0 : placeholder.replaceWith(permanentElement);
    }
    getPlaceholderById(id) {
      return this.placeholders.find((element) => element.content == id);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  var Renderer = class {
    constructor(currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      this.activeElement = null;
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview;
      this.willRender = willRender;
      this.renderElement = renderElement;
      this.promise = new Promise((resolve, reject) => this.resolvingFunctions = { resolve, reject });
    }
    get shouldRender() {
      return true;
    }
    get reloadReason() {
      return;
    }
    prepareToRender() {
      return;
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    async preservingPermanentElements(callback) {
      await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
    }
    focusFirstAutofocusableElement() {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (elementIsFocusable(element)) {
        element.focus();
      }
    }
    enteringBardo(currentPermanentElement) {
      if (this.activeElement)
        return;
      if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
        this.activeElement = this.currentSnapshot.activeElement;
      }
    }
    leavingBardo(currentPermanentElement) {
      if (currentPermanentElement.contains(this.activeElement) && this.activeElement instanceof HTMLElement) {
        this.activeElement.focus();
        this.activeElement = null;
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
  };
  function elementIsFocusable(element) {
    return element && typeof element.focus == "function";
  }
  var FrameRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      var _a;
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(currentElement);
      destinationRange.deleteContents();
      const frameElement = newElement;
      const sourceRange = (_a = frameElement.ownerDocument) === null || _a === void 0 ? void 0 : _a.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        currentElement.appendChild(sourceRange.extractContents());
      }
    }
    constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
      this.delegate = delegate;
    }
    get shouldRender() {
      return true;
    }
    async render() {
      await nextAnimationFrame();
      this.preservingPermanentElements(() => {
        this.loadFrameElement();
      });
      this.scrollFrameIntoView();
      await nextAnimationFrame();
      this.focusFirstAutofocusableElement();
      await nextAnimationFrame();
      this.activateScriptElements();
    }
    loadFrameElement() {
      this.delegate.willRenderFrame(this.currentElement, this.newElement);
      this.renderElement(this.currentElement, this.newElement);
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
        if (element) {
          element.scrollIntoView({ block, behavior });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value, defaultValue6) {
    if (value == "end" || value == "start" || value == "center" || value == "nearest") {
      return value;
    } else {
      return defaultValue6;
    }
  }
  function readScrollBehavior(value, defaultValue6) {
    if (value == "auto" || value == "smooth") {
      return value;
    } else {
      return defaultValue6;
    }
  }
  var ProgressBar = class {
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${ProgressBar.animationDuration}ms ease-out,
          opacity ${ProgressBar.animationDuration / 2}ms ${ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    constructor() {
      this.hiding = false;
      this.value = 0;
      this.visible = false;
      this.trickle = () => {
        this.setValue(this.value + Math.random() / 100);
      };
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value) {
      this.value = value;
      this.refresh();
    }
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback, ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = ProgressBar.defaultCSS;
      if (this.cspNonce) {
        element.nonce = this.cspNonce;
      }
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
    get cspNonce() {
      return getMetaContent("csp-nonce");
    }
  };
  ProgressBar.animationDuration = 300;
  var HeadSnapshot = class extends Snapshot {
    constructor() {
      super(...arguments);
      this.detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
        const { outerHTML } = element;
        const details = outerHTML in result ? result[outerHTML] : {
          type: elementType(element),
          tracked: elementIsTracked(element),
          elements: []
        };
        return Object.assign(Object.assign({}, result), { [outerHTML]: Object.assign(Object.assign({}, details), { elements: [...details.elements, element] }) });
      }, {});
    }
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result, ...elements];
        } else if (elements.length > 1) {
          return [...result, ...elements.slice(1)];
        } else {
          return result;
        }
      }, []);
    }
    getMetaValue(name) {
      const element = this.findMetaElementByName(name);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name) {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { elements: [element] } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name) ? element : result;
      }, void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  function elementIsScript(element) {
    const tagName = element.localName;
    return tagName == "script";
  }
  function elementIsNoscript(element) {
    const tagName = element.localName;
    return tagName == "noscript";
  }
  function elementIsStylesheet(element) {
    const tagName = element.localName;
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  function elementIsMetaElementWithName(element, name) {
    const tagName = element.localName;
    return tagName == "meta" && element.getAttribute("name") == name;
  }
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  var PageSnapshot = class extends Snapshot {
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ head, body }) {
      return new this(body, new HeadSnapshot(head));
    }
    constructor(element, headSnapshot) {
      super(element);
      this.headSnapshot = headSnapshot;
    }
    clone() {
      const clonedElement = this.element.cloneNode(true);
      const selectElements = this.element.querySelectorAll("select");
      const clonedSelectElements = clonedElement.querySelectorAll("select");
      for (const [index, source] of selectElements.entries()) {
        const clone5 = clonedSelectElements[index];
        for (const option of clone5.selectedOptions)
          option.selected = false;
        for (const option of source.selectedOptions)
          clone5.options[option.index].selected = true;
      }
      for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
        clonedPasswordInput.value = "";
      }
      return new PageSnapshot(clonedElement, this.headSnapshot);
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      var _a;
      const root = (_a = this.getSetting("root")) !== null && _a !== void 0 ? _a : "/";
      return expandURL(root);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    getSetting(name) {
      return this.headSnapshot.getMetaValue(`turbo-${name}`);
    }
  };
  var TimingMetric;
  (function(TimingMetric2) {
    TimingMetric2["visitStart"] = "visitStart";
    TimingMetric2["requestStart"] = "requestStart";
    TimingMetric2["requestEnd"] = "requestEnd";
    TimingMetric2["visitEnd"] = "visitEnd";
  })(TimingMetric || (TimingMetric = {}));
  var VisitState;
  (function(VisitState2) {
    VisitState2["initialized"] = "initialized";
    VisitState2["started"] = "started";
    VisitState2["canceled"] = "canceled";
    VisitState2["failed"] = "failed";
    VisitState2["completed"] = "completed";
  })(VisitState || (VisitState = {}));
  var defaultOptions = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true,
    updateHistory: true,
    shouldCacheSnapshot: true,
    acceptsStreamResponse: false
  };
  var SystemStatusCode;
  (function(SystemStatusCode2) {
    SystemStatusCode2[SystemStatusCode2["networkFailure"] = 0] = "networkFailure";
    SystemStatusCode2[SystemStatusCode2["timeoutFailure"] = -1] = "timeoutFailure";
    SystemStatusCode2[SystemStatusCode2["contentTypeMismatch"] = -2] = "contentTypeMismatch";
  })(SystemStatusCode || (SystemStatusCode = {}));
  var Visit = class {
    constructor(delegate, location2, restorationIdentifier, options2 = {}) {
      this.identifier = uuid();
      this.timingMetrics = {};
      this.followedRedirect = false;
      this.historyChanged = false;
      this.scrolled = false;
      this.shouldCacheSnapshot = true;
      this.acceptsStreamResponse = false;
      this.snapshotCached = false;
      this.state = VisitState.initialized;
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const { action, historyChanged, referrer, snapshot, snapshotHTML, response, visitCachedSnapshot, willRender, updateHistory, shouldCacheSnapshot, acceptsStreamResponse } = Object.assign(Object.assign({}, defaultOptions), options2);
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshot = snapshot;
      this.snapshotHTML = snapshotHTML;
      this.response = response;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.updateHistory = updateHistory;
      this.scrolled = !willRender;
      this.shouldCacheSnapshot = shouldCacheSnapshot;
      this.acceptsStreamResponse = acceptsStreamResponse;
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.state = VisitState.completed;
        this.followRedirect();
        if (!this.followedRedirect) {
          this.adapter.visitCompleted(this);
          this.delegate.visitCompleted(this);
        }
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
      }
    }
    changeHistory() {
      var _a;
      if (!this.historyChanged && this.updateHistory) {
        const actionForHistory = this.location.href === ((_a = this.referrer) === null || _a === void 0 ? void 0 : _a.href) ? "replace" : this.action;
        const method = getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response = this.response) {
      this.response = response;
      if (response) {
        const { statusCode } = response;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(async () => {
          if (this.shouldCacheSnapshot)
            this.cacheSnapshot();
          if (this.view.renderPromise)
            await this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            await this.view.renderPage(PageSnapshot.fromHTMLString(responseHTML), false, this.willRender, this);
            this.performScroll();
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
            this.adapter.visitRendered(this);
            this.fail();
          }
        });
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview = this.shouldIssueRequest();
        this.render(async () => {
          this.cacheSnapshot();
          if (this.isSamePage) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise)
              await this.view.renderPromise;
            await this.view.renderPage(snapshot, isPreview, this.willRender, this);
            this.performScroll();
            this.adapter.visitRendered(this);
            if (!isPreview) {
              this.complete();
            }
          }
        });
      }
    }
    followRedirect() {
      var _a;
      if (this.redirectedToLocation && !this.followedRedirect && ((_a = this.response) === null || _a === void 0 ? void 0 : _a.redirected)) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response,
          shouldCacheSnapshot: false,
          willRender: false
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(async () => {
          this.cacheSnapshot();
          this.performScroll();
          this.changeHistory();
          this.adapter.visitRendered(this);
        });
      }
    }
    prepareRequest(request) {
      if (this.acceptsStreamResponse) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(_request, _response) {
    }
    async requestSucceededWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.redirectedToLocation = response.redirected ? response.location : void 0;
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    async requestFailedWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    requestErrored(_request, _error) {
      this.recordResponse({
        statusCode: SystemStatusCode.networkFailure,
        redirected: false
      });
    }
    requestFinished() {
      this.finishRequest();
    }
    performScroll() {
      if (!this.scrolled && !this.view.forceReloaded) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = (/* @__PURE__ */ new Date()).getTime();
    }
    getTimingMetrics() {
      return Object.assign({}, this.timingMetrics);
    }
    getHistoryMethodForAction(action) {
      switch (action) {
        case "replace":
          return history.replaceState;
        case "advance":
        case "restore":
          return history.pushState;
      }
    }
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    async render(callback) {
      this.cancelRender();
      await new Promise((resolve) => {
        this.frame = requestAnimationFrame(() => resolve());
      });
      await callback();
      delete this.frame;
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  var BrowserAdapter = class {
    constructor(session2) {
      this.progressBar = new ProgressBar();
      this.showProgressBar = () => {
        this.progressBar.show();
      };
      this.session = session2;
    }
    visitProposedToLocation(location2, options2) {
      this.navigator.startVisit(location2, (options2 === null || options2 === void 0 ? void 0 : options2.restorationIdentifier) || uuid(), options2);
    }
    visitStarted(visit2) {
      this.location = visit2.location;
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload({
            reason: "request_failed",
            context: {
              statusCode
            }
          });
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitCompleted(_visit) {
    }
    pageInvalidated(reason) {
      this.reload(reason);
    }
    visitFailed(_visit) {
    }
    visitRendered(_visit) {
    }
    formSubmissionStarted(_formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(_formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    reload(reason) {
      var _a;
      dispatch("turbo:reload", { detail: reason });
      window.location.href = ((_a = this.location) === null || _a === void 0 ? void 0 : _a.toString()) || window.location.href;
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    constructor() {
      this.selector = "[data-turbo-temporary]";
      this.deprecatedSelector = "[data-turbo-cache=false]";
      this.started = false;
      this.removeTemporaryElements = (_event) => {
        for (const element of this.temporaryElements) {
          element.remove();
        }
      };
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    get temporaryElements() {
      return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
    }
    get temporaryElementsWithDeprecation() {
      const elements = document.querySelectorAll(this.deprecatedSelector);
      if (elements.length) {
        console.warn(`The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`);
      }
      return [...elements];
    }
  };
  var FrameRedirector = class {
    constructor(session2, element) {
      this.session = session2;
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formSubmitObserver = new FormSubmitObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
    shouldInterceptLinkClick(element, _location, _event) {
      return this.shouldRedirect(element);
    }
    linkClickIntercepted(element, url, event) {
      const frame = this.findFrameElement(element);
      if (frame) {
        frame.delegate.linkClickIntercepted(element, url, event);
      }
    }
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == null && this.shouldSubmit(element, submitter) && this.shouldRedirect(element, submitter);
    }
    formSubmitted(element, submitter) {
      const frame = this.findFrameElement(element, submitter);
      if (frame) {
        frame.delegate.formSubmitted(element, submitter);
      }
    }
    shouldSubmit(form, submitter) {
      var _a;
      const action = getAction(form, submitter);
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const rootLocation = expandURL((_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/");
      return this.shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation);
    }
    shouldRedirect(element, submitter) {
      const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter) : this.session.elementIsNavigatable(element);
      if (isNavigatable) {
        const frame = this.findFrameElement(element, submitter);
        return frame ? frame != element.closest("turbo-frame") : false;
      } else {
        return false;
      }
    }
    findFrameElement(element, submitter) {
      const id = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("data-turbo-frame")) || element.getAttribute("data-turbo-frame");
      if (id && id != "_top") {
        const frame = this.element.querySelector(`#${id}:not([disabled])`);
        if (frame instanceof FrameElement) {
          return frame;
        }
      }
    }
  };
  var History = class {
    constructor(delegate) {
      this.restorationIdentifier = uuid();
      this.restorationData = {};
      this.started = false;
      this.pageLoaded = false;
      this.onPopState = (event) => {
        if (this.shouldHandlePopState()) {
          const { turbo } = event.state || {};
          if (turbo) {
            this.location = new URL(window.location.href);
            const { restorationIdentifier } = turbo;
            this.restorationIdentifier = restorationIdentifier;
            this.delegate.historyPoppedToLocationWithRestorationIdentifier(this.location, restorationIdentifier);
          }
        }
      };
      this.onPageLoad = async (_event) => {
        await nextMicrotask();
        this.pageLoaded = true;
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      const state = { turbo: { restorationIdentifier } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = Object.assign(Object.assign({}, restorationData), additionalData);
    }
    assumeControlOfScrollRestoration() {
      var _a;
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = (_a = history.scrollRestoration) !== null && _a !== void 0 ? _a : "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var Navigator = class {
    constructor(delegate) {
      this.delegate = delegate;
    }
    proposeVisit(location2, options2 = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options2.action)) {
        if (locationIsVisitable(location2, this.view.snapshot.rootLocation)) {
          this.delegate.visitProposedToLocation(location2, options2);
        } else {
          window.location.href = location2.toString();
        }
      }
    }
    startVisit(locatable, restorationIdentifier, options2 = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, Object.assign({ referrer: this.location }, options2));
      this.currentVisit.start();
    }
    submitForm(form, submitter) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      if (formSubmission == this.formSubmission) {
        const responseHTML = await fetchResponse.responseHTML;
        if (responseHTML) {
          const shouldCacheSnapshot = formSubmission.isSafe;
          if (!shouldCacheSnapshot) {
            this.view.clearSnapshotCache();
          }
          const { statusCode, redirected } = fetchResponse;
          const action = this.getActionForFormSubmission(formSubmission);
          const visitOptions = {
            action,
            shouldCacheSnapshot,
            response: { statusCode, responseHTML, redirected }
          };
          this.proposeVisit(fetchResponse.location, visitOptions);
        }
      }
    }
    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        if (fetchResponse.serverError) {
          await this.view.renderError(snapshot, this.currentVisit);
        } else {
          await this.view.renderPage(snapshot, false, true, this.currentVisit);
        }
        this.view.scrollToTop();
        this.view.clearSnapshotCache();
      }
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    getActionForFormSubmission({ submitter, formElement }) {
      return getVisitAction(submitter, formElement) || "advance";
    }
  };
  var PageStage;
  (function(PageStage2) {
    PageStage2[PageStage2["initial"] = 0] = "initial";
    PageStage2[PageStage2["loading"] = 1] = "loading";
    PageStage2[PageStage2["interactive"] = 2] = "interactive";
    PageStage2[PageStage2["complete"] = 3] = "complete";
  })(PageStage || (PageStage = {}));
  var PageObserver = class {
    constructor(delegate) {
      this.stage = PageStage.initial;
      this.started = false;
      this.interpretReadyState = () => {
        const { readyState } = this;
        if (readyState == "interactive") {
          this.pageIsInteractive();
        } else if (readyState == "complete") {
          this.pageIsComplete();
        }
      };
      this.pageWillUnload = () => {
        this.delegate.pageWillUnload();
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    constructor(delegate) {
      this.started = false;
      this.onScroll = () => {
        this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamMessageRenderer = class {
    render({ fragment }) {
      Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => document.documentElement.appendChild(fragment));
    }
    enteringBardo(currentPermanentElement, newPermanentElement) {
      newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
    }
    leavingBardo() {
    }
  };
  function getPermanentElementMapForFragment(fragment) {
    const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
    const permanentElementMap = {};
    for (const permanentElementInDocument of permanentElementsInDocument) {
      const { id } = permanentElementInDocument;
      for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
        const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);
        if (elementInStream) {
          permanentElementMap[id] = [permanentElementInDocument, elementInStream];
        }
      }
    }
    return permanentElementMap;
  }
  var StreamObserver = class {
    constructor(delegate) {
      this.sources = /* @__PURE__ */ new Set();
      this.started = false;
      this.inspectFetchResponse = (event) => {
        const response = fetchResponseFromEvent(event);
        if (response && fetchResponseIsStream(response)) {
          event.preventDefault();
          this.receiveMessageResponse(response);
        }
      };
      this.receiveMessageEvent = (event) => {
        if (this.started && typeof event.data == "string") {
          this.receiveMessageHTML(event.data);
        }
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source) {
      if (!this.streamSourceIsConnected(source)) {
        this.sources.add(source);
        source.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source) {
      if (this.streamSourceIsConnected(source)) {
        this.sources.delete(source);
        source.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source) {
      return this.sources.has(source);
    }
    async receiveMessageResponse(response) {
      const html = await response.responseHTML;
      if (html) {
        this.receiveMessageHTML(html);
      }
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
    }
  };
  function fetchResponseFromEvent(event) {
    var _a;
    const fetchResponse = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  function fetchResponseIsStream(response) {
    var _a;
    const contentType = (_a = response.contentType) !== null && _a !== void 0 ? _a : "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  var ErrorRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const { documentElement, body } = document;
      documentElement.replaceChild(newElement, body);
    }
    async render() {
      this.replaceHeadAndBody();
      this.activateScriptElements();
    }
    replaceHeadAndBody() {
      const { documentElement, head } = document;
      documentElement.replaceChild(this.newHead, head);
      this.renderElement(this.currentElement, this.newElement);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode = replaceableElement.parentNode;
        if (parentNode) {
          const element = activateScriptElement(replaceableElement);
          parentNode.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return document.documentElement.querySelectorAll("script");
    }
  };
  var PageRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      if (document.body && newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(newElement);
      } else {
        document.documentElement.appendChild(newElement);
      }
    }
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    get reloadReason() {
      if (!this.newSnapshot.isVisitable) {
        return {
          reason: "turbo_visit_control_is_reload"
        };
      }
      if (!this.trackedElementsAreIdentical) {
        return {
          reason: "tracked_element_mismatch"
        };
      }
    }
    async prepareToRender() {
      await this.mergeHead();
    }
    async render() {
      if (this.willRender) {
        await this.replaceBody();
      }
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    async mergeHead() {
      const mergedHeadElements = this.mergeProvisionalElements();
      const newStylesheetElements = this.copyNewHeadStylesheetElements();
      this.copyNewHeadScriptElements();
      await mergedHeadElements;
      await newStylesheetElements;
    }
    async replaceBody() {
      await this.preservingPermanentElements(async () => {
        this.activateNewBody();
        await this.assignNewBody();
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    async copyNewHeadStylesheetElements() {
      const loadingElements = [];
      for (const element of this.newHeadStylesheetElements) {
        loadingElements.push(waitForLoad(element));
        document.head.appendChild(element);
      }
      await Promise.all(loadingElements);
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(activateScriptElement(element));
      }
    }
    async mergeProvisionalElements() {
      const newHeadElements = [...this.newHeadProvisionalElements];
      for (const element of this.currentHeadProvisionalElements) {
        if (!this.isCurrentElementInElementList(element, newHeadElements)) {
          document.head.removeChild(element);
        }
      }
      for (const element of newHeadElements) {
        document.head.appendChild(element);
      }
    }
    isCurrentElementInElementList(element, elementList) {
      for (const [index, newElement] of elementList.entries()) {
        if (element.tagName == "TITLE") {
          if (newElement.tagName != "TITLE") {
            continue;
          }
          if (element.innerHTML == newElement.innerHTML) {
            elementList.splice(index, 1);
            return true;
          }
        }
        if (newElement.isEqualNode(element)) {
          elementList.splice(index, 1);
          return true;
        }
      }
      return false;
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    async assignNewBody() {
      await this.renderElement(this.currentElement, this.newElement);
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  var SnapshotCache = class {
    constructor(size) {
      this.keys = [];
      this.snapshots = {};
      this.size = size;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key = toCacheKey(location2);
      const index = this.keys.indexOf(key);
      if (index > -1)
        this.keys.splice(index, 1);
      this.keys.unshift(key);
      this.trim();
    }
    trim() {
      for (const key of this.keys.splice(this.size)) {
        delete this.snapshots[key];
      }
    }
  };
  var PageView = class extends View {
    constructor() {
      super(...arguments);
      this.snapshotCache = new SnapshotCache(10);
      this.lastRenderedLocation = new URL(location.href);
      this.forceReloaded = false;
    }
    renderPage(snapshot, isPreview = false, willRender = true, visit2) {
      const renderer = new PageRenderer(this.snapshot, snapshot, PageRenderer.renderElement, isPreview, willRender);
      if (!renderer.shouldRender) {
        this.forceReloaded = true;
      } else {
        visit2 === null || visit2 === void 0 ? void 0 : visit2.changeHistory();
      }
      return this.render(renderer);
    }
    renderError(snapshot, visit2) {
      visit2 === null || visit2 === void 0 ? void 0 : visit2.changeHistory();
      const renderer = new ErrorRenderer(this.snapshot, snapshot, ErrorRenderer.renderElement, false);
      return this.render(renderer);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    async cacheSnapshot(snapshot = this.snapshot) {
      if (snapshot.isCacheable) {
        this.delegate.viewWillCacheSnapshot();
        const { lastRenderedLocation: location2 } = this;
        await nextEventLoopTick();
        const cachedSnapshot = snapshot.clone();
        this.snapshotCache.put(location2, cachedSnapshot);
        return cachedSnapshot;
      }
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
  };
  var Preloader = class {
    constructor(delegate) {
      this.selector = "a[data-turbo-preload]";
      this.delegate = delegate;
    }
    get snapshotCache() {
      return this.delegate.navigator.view.snapshotCache;
    }
    start() {
      if (document.readyState === "loading") {
        return document.addEventListener("DOMContentLoaded", () => {
          this.preloadOnLoadLinksForView(document.body);
        });
      } else {
        this.preloadOnLoadLinksForView(document.body);
      }
    }
    preloadOnLoadLinksForView(element) {
      for (const link of element.querySelectorAll(this.selector)) {
        this.preloadURL(link);
      }
    }
    async preloadURL(link) {
      const location2 = new URL(link.href);
      if (this.snapshotCache.has(location2)) {
        return;
      }
      try {
        const response = await fetch(location2.toString(), { headers: { "VND.PREFETCH": "true", Accept: "text/html" } });
        const responseText = await response.text();
        const snapshot = PageSnapshot.fromHTMLString(responseText);
        this.snapshotCache.put(location2, snapshot);
      } catch (_) {
      }
    }
  };
  var Session = class {
    constructor() {
      this.navigator = new Navigator(this);
      this.history = new History(this);
      this.preloader = new Preloader(this);
      this.view = new PageView(this, document.documentElement);
      this.adapter = new BrowserAdapter(this);
      this.pageObserver = new PageObserver(this);
      this.cacheObserver = new CacheObserver();
      this.linkClickObserver = new LinkClickObserver(this, window);
      this.formSubmitObserver = new FormSubmitObserver(this, document);
      this.scrollObserver = new ScrollObserver(this);
      this.streamObserver = new StreamObserver(this);
      this.formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
      this.frameRedirector = new FrameRedirector(this, document.documentElement);
      this.streamMessageRenderer = new StreamMessageRenderer();
      this.drive = true;
      this.enabled = true;
      this.progressBarDelay = 500;
      this.started = false;
      this.formMode = "on";
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.formLinkClickObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.preloader.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter) {
      this.adapter = adapter;
    }
    visit(location2, options2 = {}) {
      const frameElement = options2.frame ? document.getElementById(options2.frame) : null;
      if (frameElement instanceof FrameElement) {
        frameElement.src = location2.toString();
        frameElement.loaded;
      } else {
        this.navigator.proposeVisit(expandURL(location2), options2);
      }
    }
    connectStreamSource(source) {
      this.streamObserver.connectStreamSource(source);
    }
    disconnectStreamSource(source) {
      this.streamObserver.disconnectStreamSource(source);
    }
    renderStreamMessage(message) {
      this.streamMessageRenderer.render(StreamMessage.wrap(message));
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      this.progressBarDelay = delay;
    }
    setFormMode(mode) {
      this.formMode = mode;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    historyPoppedToLocationWithRestorationIdentifier(location2, restorationIdentifier) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, {
          action: "restore",
          historyChanged: true
        });
      } else {
        this.adapter.pageInvalidated({
          reason: "turbo_disabled"
        });
      }
    }
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    willSubmitFormLinkToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    submittedFormLinkToLocation() {
    }
    willFollowLinkToLocation(link, location2, event) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2, event);
    }
    followedLinkToLocation(link, location2) {
      const action = this.getActionForLink(link);
      const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
      this.visit(location2.href, { action, acceptsStreamResponse });
    }
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options2) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options2);
    }
    visitStarted(visit2) {
      if (!visit2.acceptsStreamResponse) {
        markAsBusy(document.documentElement);
      }
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      clearBusyState(document.documentElement);
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    willSubmitForm(form, submitter) {
      const action = getAction(form, submitter);
      return this.submissionIsNavigatable(form, submitter) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter) {
      this.navigator.submitForm(form, submitter);
    }
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    viewWillCacheSnapshot() {
      var _a;
      if (!((_a = this.navigator.currentVisit) === null || _a === void 0 ? void 0 : _a.silent)) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, options2) {
      const event = this.notifyApplicationBeforeRender(element, options2);
      const { defaultPrevented, detail: { render } } = event;
      if (this.view.renderer && render) {
        this.view.renderer.renderElement = render;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender();
    }
    preloadOnLoadLinksForView(element) {
      this.preloader.preloadOnLoadLinksForView(element);
    }
    viewInvalidated(reason) {
      this.adapter.pageInvalidated(reason);
    }
    frameLoaded(frame) {
      this.notifyApplicationAfterFrameLoad(frame);
    }
    frameRendered(fetchResponse, frame) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame);
    }
    applicationAllowsFollowingLinkToLocation(link, location2, ev) {
      const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2, ev);
      return !event.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link, location2, event) {
      return dispatch("turbo:click", {
        target: link,
        detail: { url: location2.href, originalEvent: event },
        cancelable: true
      });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch("turbo:before-visit", {
        detail: { url: location2.href },
        cancelable: true
      });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      return dispatch("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, options2) {
      return dispatch("turbo:before-render", {
        detail: Object.assign({ newBody }, options2),
        cancelable: true
      });
    }
    notifyApplicationAfterRender() {
      return dispatch("turbo:render");
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      return dispatch("turbo:load", {
        detail: { url: this.location.href, timing }
      });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(new HashChangeEvent("hashchange", {
        oldURL: oldURL.toString(),
        newURL: newURL.toString()
      }));
    }
    notifyApplicationAfterFrameLoad(frame) {
      return dispatch("turbo:frame-load", { target: frame });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame) {
      return dispatch("turbo:frame-render", {
        detail: { fetchResponse },
        target: frame,
        cancelable: true
      });
    }
    submissionIsNavigatable(form, submitter) {
      if (this.formMode == "off") {
        return false;
      } else {
        const submitterIsNavigatable = submitter ? this.elementIsNavigatable(submitter) : true;
        if (this.formMode == "optin") {
          return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
        } else {
          return submitterIsNavigatable && this.elementIsNavigatable(form);
        }
      }
    }
    elementIsNavigatable(element) {
      const container = findClosestRecursively(element, "[data-turbo]");
      const withinFrame = findClosestRecursively(element, "turbo-frame");
      if (this.drive || withinFrame) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    getActionForLink(link) {
      return getVisitAction(link) || "advance";
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var Cache = class {
    constructor(session2) {
      this.session = session2;
    }
    clear() {
      this.session.clearCache();
    }
    resetCacheControl() {
      this.setCacheControl("");
    }
    exemptPageFromCache() {
      this.setCacheControl("no-cache");
    }
    exemptPageFromPreview() {
      this.setCacheControl("no-preview");
    }
    setCacheControl(value) {
      setMetaContent("turbo-cache-control", value);
    }
  };
  var StreamActions = {
    after() {
      this.targetElements.forEach((e) => {
        var _a;
        return (_a = e.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e.nextSibling);
      });
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e) => e.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e) => {
        var _a;
        return (_a = e.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e);
      });
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e) => e.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e) => e.remove());
    },
    replace() {
      this.targetElements.forEach((e) => e.replaceWith(this.templateContent));
    },
    update() {
      this.targetElements.forEach((targetElement) => {
        targetElement.innerHTML = "";
        targetElement.append(this.templateContent);
      });
    }
  };
  var session = new Session();
  var cache = new Cache(session);
  var { navigator: navigator$1 } = session;
  function start() {
    session.start();
  }
  function registerAdapter(adapter) {
    session.registerAdapter(adapter);
  }
  function visit(location2, options2) {
    session.visit(location2, options2);
  }
  function connectStreamSource(source) {
    session.connectStreamSource(source);
  }
  function disconnectStreamSource(source) {
    session.disconnectStreamSource(source);
  }
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  function clearCache() {
    console.warn("Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`");
    session.clearCache();
  }
  function setProgressBarDelay(delay) {
    session.setProgressBarDelay(delay);
  }
  function setConfirmMethod(confirmMethod) {
    FormSubmission.confirmMethod = confirmMethod;
  }
  function setFormMode(mode) {
    session.setFormMode(mode);
  }
  var Turbo = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    cache,
    PageRenderer,
    PageSnapshot,
    FrameRenderer,
    start,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod,
    setFormMode,
    StreamActions
  });
  var TurboFrameMissingError = class extends Error {
  };
  var FrameController = class {
    constructor(element) {
      this.fetchResponseLoaded = (_fetchResponse) => {
      };
      this.currentFetchRequest = null;
      this.resolveVisitPromise = () => {
      };
      this.connected = false;
      this.hasBeenLoaded = false;
      this.ignoredAttributes = /* @__PURE__ */ new Set();
      this.action = null;
      this.visitCachedSnapshot = ({ element: element2 }) => {
        const frame = element2.querySelector("#" + this.element.id);
        if (frame && this.previousFrameElement) {
          frame.replaceChildren(...this.previousFrameElement.children);
        }
        delete this.previousFrameElement;
      };
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver(this, this.element);
      this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.restorationIdentifier = uuid();
      this.formSubmitObserver = new FormSubmitObserver(this, this.element);
    }
    connect() {
      if (!this.connected) {
        this.connected = true;
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        } else {
          this.loadSourceURL();
        }
        this.formLinkClickObserver.start();
        this.linkInterceptor.start();
        this.formSubmitObserver.start();
      }
    }
    disconnect() {
      if (this.connected) {
        this.connected = false;
        this.appearanceObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkInterceptor.stop();
        this.formSubmitObserver.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        this.loadSourceURL();
      }
    }
    sourceURLChanged() {
      if (this.isIgnoringChangesTo("src"))
        return;
      if (this.element.isConnected) {
        this.complete = false;
      }
      if (this.loadingStyle == FrameLoadingStyle.eager || this.hasBeenLoaded) {
        this.loadSourceURL();
      }
    }
    sourceURLReloaded() {
      const { src } = this.element;
      this.ignoringChangesToAttribute("complete", () => {
        this.element.removeAttribute("complete");
      });
      this.element.src = null;
      this.element.src = src;
      return this.element.loaded;
    }
    completeChanged() {
      if (this.isIgnoringChangesTo("complete"))
        return;
      this.loadSourceURL();
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        this.loadSourceURL();
      }
    }
    async loadSourceURL() {
      if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
        this.element.loaded = this.visit(expandURL(this.sourceURL));
        this.appearanceObserver.stop();
        await this.element.loaded;
        this.hasBeenLoaded = true;
      }
    }
    async loadResponse(fetchResponse) {
      if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
        this.sourceURL = fetchResponse.response.url;
      }
      try {
        const html = await fetchResponse.responseHTML;
        if (html) {
          const document2 = parseHTMLDocument(html);
          const pageSnapshot = PageSnapshot.fromDocument(document2);
          if (pageSnapshot.isVisitable) {
            await this.loadFrameResponse(fetchResponse, document2);
          } else {
            await this.handleUnvisitableFrameResponse(fetchResponse);
          }
        }
      } finally {
        this.fetchResponseLoaded = () => {
        };
      }
    }
    elementAppearedInViewport(element) {
      this.proposeVisitIfNavigatedWithAction(element, element);
      this.loadSourceURL();
    }
    willSubmitFormLinkToLocation(link) {
      return this.shouldInterceptNavigation(link);
    }
    submittedFormLinkToLocation(link, _location, form) {
      const frame = this.findFrameElement(link);
      if (frame)
        form.setAttribute("data-turbo-frame", frame.id);
    }
    shouldInterceptLinkClick(element, _location, _event) {
      return this.shouldInterceptNavigation(element);
    }
    linkClickIntercepted(element, location2) {
      this.navigateFrame(element, location2);
    }
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == this.element && this.shouldInterceptNavigation(element, submitter);
    }
    formSubmitted(element, submitter) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.formSubmission = new FormSubmission(this, element, submitter);
      const { fetchRequest } = this.formSubmission;
      this.prepareRequest(fetchRequest);
      this.formSubmission.start();
    }
    prepareRequest(request) {
      var _a;
      request.headers["Turbo-Frame"] = this.id;
      if ((_a = this.currentNavigationElement) === null || _a === void 0 ? void 0 : _a.hasAttribute("data-turbo-stream")) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(_request, _response) {
      this.resolveVisitPromise();
    }
    async requestSucceededWithResponse(request, response) {
      await this.loadResponse(response);
      this.resolveVisitPromise();
    }
    async requestFailedWithResponse(request, response) {
      await this.loadResponse(response);
      this.resolveVisitPromise();
    }
    requestErrored(request, error2) {
      console.error(error2);
      this.resolveVisitPromise();
    }
    requestFinished(_request) {
      clearBusyState(this.element);
    }
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, this.findFrameElement(formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response) {
      const frame = this.findFrameElement(formSubmission.formElement, formSubmission.submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, formSubmission.formElement, formSubmission.submitter);
      frame.delegate.loadResponse(response);
      if (!formSubmission.isSafe) {
        session.clearCache();
      }
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
      session.clearCache();
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, this.findFrameElement(formElement));
    }
    allowsImmediateRender({ element: newFrame }, options2) {
      const event = dispatch("turbo:before-frame-render", {
        target: this.element,
        detail: Object.assign({ newFrame }, options2),
        cancelable: true
      });
      const { defaultPrevented, detail: { render } } = event;
      if (this.view.renderer && render) {
        this.view.renderer.renderElement = render;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview) {
    }
    preloadOnLoadLinksForView(element) {
      session.preloadOnLoadLinksForView(element);
    }
    viewInvalidated() {
    }
    willRenderFrame(currentElement, _newElement) {
      this.previousFrameElement = currentElement.cloneNode(true);
    }
    async loadFrameResponse(fetchResponse, document2) {
      const newFrameElement = await this.extractForeignFrameElement(document2.body);
      if (newFrameElement) {
        const snapshot = new Snapshot(newFrameElement);
        const renderer = new FrameRenderer(this, this.view.snapshot, snapshot, FrameRenderer.renderElement, false, false);
        if (this.view.renderPromise)
          await this.view.renderPromise;
        this.changeHistory();
        await this.view.render(renderer);
        this.complete = true;
        session.frameRendered(fetchResponse, this.element);
        session.frameLoaded(this.element);
        this.fetchResponseLoaded(fetchResponse);
      } else if (this.willHandleFrameMissingFromResponse(fetchResponse)) {
        this.handleFrameMissingFromResponse(fetchResponse);
      }
    }
    async visit(url) {
      var _a;
      const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
      (_a = this.currentFetchRequest) === null || _a === void 0 ? void 0 : _a.cancel();
      this.currentFetchRequest = request;
      return new Promise((resolve) => {
        this.resolveVisitPromise = () => {
          this.resolveVisitPromise = () => {
          };
          this.currentFetchRequest = null;
          resolve();
        };
        request.perform();
      });
    }
    navigateFrame(element, url, submitter) {
      const frame = this.findFrameElement(element, submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, element, submitter);
      this.withCurrentNavigationElement(element, () => {
        frame.src = url;
      });
    }
    proposeVisitIfNavigatedWithAction(frame, element, submitter) {
      this.action = getVisitAction(submitter, element, frame);
      if (this.action) {
        const pageSnapshot = PageSnapshot.fromElement(frame).clone();
        const { visitCachedSnapshot } = frame.delegate;
        frame.delegate.fetchResponseLoaded = (fetchResponse) => {
          if (frame.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = frame.ownerDocument.documentElement.outerHTML;
            const response = { statusCode, redirected, responseHTML };
            const options2 = {
              response,
              visitCachedSnapshot,
              willRender: false,
              updateHistory: false,
              restorationIdentifier: this.restorationIdentifier,
              snapshot: pageSnapshot
            };
            if (this.action)
              options2.action = this.action;
            session.visit(frame.src, options2);
          }
        };
      }
    }
    changeHistory() {
      if (this.action) {
        const method = getHistoryMethodForAction(this.action);
        session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
      }
    }
    async handleUnvisitableFrameResponse(fetchResponse) {
      console.warn(`The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`);
      await this.visitResponse(fetchResponse.response);
    }
    willHandleFrameMissingFromResponse(fetchResponse) {
      this.element.setAttribute("complete", "");
      const response = fetchResponse.response;
      const visit2 = async (url, options2 = {}) => {
        if (url instanceof Response) {
          this.visitResponse(url);
        } else {
          session.visit(url, options2);
        }
      };
      const event = dispatch("turbo:frame-missing", {
        target: this.element,
        detail: { response, visit: visit2 },
        cancelable: true
      });
      return !event.defaultPrevented;
    }
    handleFrameMissingFromResponse(fetchResponse) {
      this.view.missing();
      this.throwFrameMissingError(fetchResponse);
    }
    throwFrameMissingError(fetchResponse) {
      const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
      throw new TurboFrameMissingError(message);
    }
    async visitResponse(response) {
      const wrapped = new FetchResponse(response);
      const responseHTML = await wrapped.responseHTML;
      const { location: location2, redirected, statusCode } = wrapped;
      return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
    }
    findFrameElement(element, submitter) {
      var _a;
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      return (_a = getFrameElementById(id)) !== null && _a !== void 0 ? _a : this.element;
    }
    async extractForeignFrameElement(container) {
      let element;
      const id = CSS.escape(this.id);
      try {
        element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);
        if (element) {
          return element;
        }
        element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);
        if (element) {
          await element.loaded;
          return await this.extractForeignFrameElement(element);
        }
      } catch (error2) {
        console.error(error2);
        return new FrameElement();
      }
      return null;
    }
    formActionIsVisitable(form, submitter) {
      const action = getAction(form, submitter);
      return locationIsVisitable(expandURL(action), this.rootLocation);
    }
    shouldInterceptNavigation(element, submitter) {
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      if (element instanceof HTMLFormElement && !this.formActionIsVisitable(element, submitter)) {
        return false;
      }
      if (!this.enabled || id == "_top") {
        return false;
      }
      if (id) {
        const frameElement = getFrameElementById(id);
        if (frameElement) {
          return !frameElement.disabled;
        }
      }
      if (!session.elementIsNavigatable(element)) {
        return false;
      }
      if (submitter && !session.elementIsNavigatable(submitter)) {
        return false;
      }
      return true;
    }
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    set sourceURL(sourceURL) {
      this.ignoringChangesToAttribute("src", () => {
        this.element.src = sourceURL !== null && sourceURL !== void 0 ? sourceURL : null;
      });
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || this.resolveVisitPromise() !== void 0;
    }
    get complete() {
      return this.element.hasAttribute("complete");
    }
    set complete(value) {
      this.ignoringChangesToAttribute("complete", () => {
        if (value) {
          this.element.setAttribute("complete", "");
        } else {
          this.element.removeAttribute("complete");
        }
      });
    }
    get isActive() {
      return this.element.isActive && this.connected;
    }
    get rootLocation() {
      var _a;
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root = (_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/";
      return expandURL(root);
    }
    isIgnoringChangesTo(attributeName) {
      return this.ignoredAttributes.has(attributeName);
    }
    ignoringChangesToAttribute(attributeName, callback) {
      this.ignoredAttributes.add(attributeName);
      callback();
      this.ignoredAttributes.delete(attributeName);
    }
    withCurrentNavigationElement(element, callback) {
      this.currentNavigationElement = element;
      callback();
      delete this.currentNavigationElement;
    }
  };
  function getFrameElementById(id) {
    if (id != null) {
      const element = document.getElementById(id);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  var StreamElement = class extends HTMLElement {
    static async renderElement(newElement) {
      await newElement.performAction();
    }
    async connectedCallback() {
      try {
        await this.render();
      } catch (error2) {
        console.error(error2);
      } finally {
        this.disconnect();
      }
    }
    async render() {
      var _a;
      return (_a = this.renderPromise) !== null && _a !== void 0 ? _a : this.renderPromise = (async () => {
        const event = this.beforeRenderEvent;
        if (this.dispatchEvent(event)) {
          await nextAnimationFrame();
          await event.detail.render(this);
        }
      })();
    }
    disconnect() {
      try {
        this.remove();
      } catch (_a) {
      }
    }
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c) => c.remove());
    }
    get duplicateChildren() {
      var _a;
      const existingChildren = this.targetElements.flatMap((e) => [...e.children]).filter((c) => !!c.id);
      const newChildrenIds = [...((_a = this.templateContent) === null || _a === void 0 ? void 0 : _a.children) || []].filter((c) => !!c.id).map((c) => c.id);
      return existingChildren.filter((c) => newChildrenIds.includes(c.id));
    }
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        this.raise("unknown action");
      }
      this.raise("action attribute is missing");
    }
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        this.raise("target or targets attribute is missing");
      }
    }
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    get templateElement() {
      if (this.firstElementChild === null) {
        const template = this.ownerDocument.createElement("template");
        this.appendChild(template);
        return template;
      } else if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      this.raise("first child element must be a <template> element");
    }
    get action() {
      return this.getAttribute("action");
    }
    get target() {
      return this.getAttribute("target");
    }
    get targets() {
      return this.getAttribute("targets");
    }
    raise(message) {
      throw new Error(`${this.description}: ${message}`);
    }
    get description() {
      var _a, _b;
      return (_b = ((_a = this.outerHTML.match(/<[^>]+>/)) !== null && _a !== void 0 ? _a : [])[0]) !== null && _b !== void 0 ? _b : "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", {
        bubbles: true,
        cancelable: true,
        detail: { newStream: this, render: StreamElement.renderElement }
      });
    }
    get targetElementsById() {
      var _a;
      const element = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      var _a;
      const elements = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.querySelectorAll(this.targets);
      if (elements.length !== 0) {
        return Array.prototype.slice.call(elements);
      } else {
        return [];
      }
    }
  };
  var StreamSourceElement = class extends HTMLElement {
    constructor() {
      super(...arguments);
      this.streamSource = null;
    }
    connectedCallback() {
      this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
      connectStreamSource(this.streamSource);
    }
    disconnectedCallback() {
      if (this.streamSource) {
        disconnectStreamSource(this.streamSource);
      }
    }
    get src() {
      return this.getAttribute("src") || "";
    }
  };
  FrameElement.delegateConstructor = FrameController;
  if (customElements.get("turbo-frame") === void 0) {
    customElements.define("turbo-frame", FrameElement);
  }
  if (customElements.get("turbo-stream") === void 0) {
    customElements.define("turbo-stream", StreamElement);
  }
  if (customElements.get("turbo-stream-source") === void 0) {
    customElements.define("turbo-stream-source", StreamSourceElement);
  }
  (() => {
    let element = document.currentScript;
    if (!element)
      return;
    if (element.hasAttribute("data-turbo-suppress-warning"))
      return;
    element = element.parentElement;
    while (element) {
      if (element == document.body) {
        return console.warn(unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your application’s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        ——
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `, element.outerHTML);
      }
      element = element.parentElement;
    }
  })();
  window.Turbo = Turbo;
  start();

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
  var consumer;
  async function getConsumer() {
    return consumer || setConsumer(createConsumer2().then(setConsumer));
  }
  function setConsumer(newConsumer) {
    return consumer = newConsumer;
  }
  async function createConsumer2() {
    const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), src_exports));
    return createConsumer3();
  }
  async function subscribeTo(channel, mixin) {
    const { subscriptions } = await getConsumer();
    return subscriptions.create(channel, mixin);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/snakeize.js
  function walk(obj) {
    if (!obj || typeof obj !== "object")
      return obj;
    if (obj instanceof Date || obj instanceof RegExp)
      return obj;
    if (Array.isArray(obj))
      return obj.map(walk);
    return Object.keys(obj).reduce(function(acc, key) {
      var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function(m, x) {
        return "_" + x.toLowerCase();
      });
      acc[camel] = walk(obj[key]);
      return acc;
    }, {});
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
  var TurboCableStreamSourceElement = class extends HTMLElement {
    async connectedCallback() {
      connectStreamSource(this);
      this.subscription = await subscribeTo(this.channel, {
        received: this.dispatchMessageEvent.bind(this),
        connected: this.subscriptionConnected.bind(this),
        disconnected: this.subscriptionDisconnected.bind(this)
      });
    }
    disconnectedCallback() {
      disconnectStreamSource(this);
      if (this.subscription)
        this.subscription.unsubscribe();
    }
    dispatchMessageEvent(data) {
      const event = new MessageEvent("message", { data });
      return this.dispatchEvent(event);
    }
    subscriptionConnected() {
      this.setAttribute("connected", "");
    }
    subscriptionDisconnected() {
      this.removeAttribute("connected");
    }
    get channel() {
      const channel = this.getAttribute("channel");
      const signed_stream_name = this.getAttribute("signed-stream-name");
      return { channel, signed_stream_name, ...walk({ ...this.dataset }) };
    }
  };
  if (customElements.get("turbo-cable-stream-source") === void 0) {
    customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/fetch_requests.js
  function encodeMethodIntoRequestBody(event) {
    if (event.target instanceof HTMLFormElement) {
      const { target: form, detail: { fetchOptions } } = event;
      form.addEventListener("turbo:submit-start", ({ detail: { formSubmission: { submitter } } }) => {
        const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams();
        const method = determineFetchMethod(submitter, body, form);
        if (!/get/i.test(method)) {
          if (/post/i.test(method)) {
            body.delete("_method");
          } else {
            body.set("_method", method);
          }
          fetchOptions.method = "post";
        }
      }, { once: true });
    }
  }
  function determineFetchMethod(submitter, body, form) {
    const formMethod = determineFormMethod(submitter);
    const overrideMethod = body.get("_method");
    const method = form.getAttribute("method") || "get";
    if (typeof formMethod == "string") {
      return formMethod;
    } else if (typeof overrideMethod == "string") {
      return overrideMethod;
    } else {
      return method;
    }
  }
  function determineFormMethod(submitter) {
    if (submitter instanceof HTMLButtonElement || submitter instanceof HTMLInputElement) {
      if (submitter.hasAttribute("formmethod")) {
        return submitter.formMethod;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  function isBodyInit(body) {
    return body instanceof FormData || body instanceof URLSearchParams;
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/index.js
  addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

  // node_modules/@hotwired/stimulus/dist/stimulus.js
  var EventListener = class {
    constructor(eventTarget, eventName, eventOptions) {
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this.eventOptions = eventOptions;
      this.unorderedBindings = /* @__PURE__ */ new Set();
    }
    connect() {
      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
      this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
      this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
      const extendedEvent = extendEvent(event);
      for (const binding of this.bindings) {
        if (extendedEvent.immediatePropagationStopped) {
          break;
        } else {
          binding.handleEvent(extendedEvent);
        }
      }
    }
    hasBindings() {
      return this.unorderedBindings.size > 0;
    }
    get bindings() {
      return Array.from(this.unorderedBindings).sort((left2, right2) => {
        const leftIndex = left2.index, rightIndex = right2.index;
        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
      });
    }
  };
  function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
      return event;
    } else {
      const { stopImmediatePropagation } = event;
      return Object.assign(event, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
          this.immediatePropagationStopped = true;
          stopImmediatePropagation.call(this);
        }
      });
    }
  }
  var Dispatcher = class {
    constructor(application2) {
      this.application = application2;
      this.eventListenerMaps = /* @__PURE__ */ new Map();
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.eventListeners.forEach((eventListener) => eventListener.connect());
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.eventListeners.forEach((eventListener) => eventListener.disconnect());
      }
    }
    get eventListeners() {
      return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
    }
    bindingConnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding, clearEventListeners = false) {
      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
      if (clearEventListeners)
        this.clearEventListenersForBinding(binding);
    }
    handleError(error2, message, detail = {}) {
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    clearEventListenersForBinding(binding) {
      const eventListener = this.fetchEventListenerForBinding(binding);
      if (!eventListener.hasBindings()) {
        eventListener.disconnect();
        this.removeMappedEventListenerFor(binding);
      }
    }
    removeMappedEventListenerFor(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      eventListenerMap.delete(cacheKey);
      if (eventListenerMap.size == 0)
        this.eventListenerMaps.delete(eventTarget);
    }
    fetchEventListenerForBinding(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      let eventListener = eventListenerMap.get(cacheKey);
      if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
      }
      return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
      const eventListener = new EventListener(eventTarget, eventName, eventOptions);
      if (this.started) {
        eventListener.connect();
      }
      return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
      let eventListenerMap = this.eventListenerMaps.get(eventTarget);
      if (!eventListenerMap) {
        eventListenerMap = /* @__PURE__ */ new Map();
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
      }
      return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
      const parts2 = [eventName];
      Object.keys(eventOptions).sort().forEach((key) => {
        parts2.push(`${eventOptions[key] ? "" : "!"}${key}`);
      });
      return parts2.join(":");
    }
  };
  var defaultActionDescriptorFilters = {
    stop({ event, value }) {
      if (value)
        event.stopPropagation();
      return true;
    },
    prevent({ event, value }) {
      if (value)
        event.preventDefault();
      return true;
    },
    self({ event, value, element }) {
      if (value) {
        return element === event.target;
      } else {
        return true;
      }
    }
  };
  var descriptorPattern = /^(?:(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
  function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches = source.match(descriptorPattern) || [];
    let eventName = matches[1];
    let keyFilter = matches[2];
    if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
      eventName += `.${keyFilter}`;
      keyFilter = "";
    }
    return {
      eventTarget: parseEventTarget(matches[3]),
      eventName,
      eventOptions: matches[6] ? parseEventOptions(matches[6]) : {},
      identifier: matches[4],
      methodName: matches[5],
      keyFilter
    };
  }
  function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
      return window;
    } else if (eventTargetName == "document") {
      return document;
    }
  }
  function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options2, token) => Object.assign(options2, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
  }
  function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
      return "window";
    } else if (eventTarget == document) {
      return "document";
    }
  }
  function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
  }
  function namespaceCamelize(value) {
    return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
  }
  function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
  function dasherize(value) {
    return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
  }
  function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
  }
  var Action = class {
    constructor(element, index, descriptor, schema) {
      this.element = element;
      this.index = index;
      this.eventTarget = descriptor.eventTarget || element;
      this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
      this.eventOptions = descriptor.eventOptions || {};
      this.identifier = descriptor.identifier || error("missing identifier");
      this.methodName = descriptor.methodName || error("missing method name");
      this.keyFilter = descriptor.keyFilter || "";
      this.schema = schema;
    }
    static forToken(token, schema) {
      return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
    }
    toString() {
      const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
      const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
      return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
    }
    isFilterTarget(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filteres = this.keyFilter.split("+");
      const modifiers = ["meta", "ctrl", "alt", "shift"];
      const [meta, ctrl, alt, shift] = modifiers.map((modifier) => filteres.includes(modifier));
      if (event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift) {
        return true;
      }
      const standardFilter = filteres.filter((key) => !modifiers.includes(key))[0];
      if (!standardFilter) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(this.keyMappings, standardFilter)) {
        error(`contains unknown key filter: ${this.keyFilter}`);
      }
      return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
    }
    get params() {
      const params = {};
      const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
      for (const { name, value } of Array.from(this.element.attributes)) {
        const match2 = name.match(pattern);
        const key = match2 && match2[1];
        if (key) {
          params[camelize(key)] = typecast(value);
        }
      }
      return params;
    }
    get eventTargetName() {
      return stringifyEventTarget(this.eventTarget);
    }
    get keyMappings() {
      return this.schema.keyMappings;
    }
  };
  var defaultEventNames = {
    a: () => "click",
    button: () => "click",
    form: () => "submit",
    details: () => "toggle",
    input: (e) => e.getAttribute("type") == "submit" ? "click" : "input",
    select: () => "change",
    textarea: () => "input"
  };
  function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
      return defaultEventNames[tagName](element);
    }
  }
  function error(message) {
    throw new Error(message);
  }
  function typecast(value) {
    try {
      return JSON.parse(value);
    } catch (o_O) {
      return value;
    }
  }
  var Binding = class {
    constructor(context, action) {
      this.context = context;
      this.action = action;
    }
    get index() {
      return this.action.index;
    }
    get eventTarget() {
      return this.action.eventTarget;
    }
    get eventOptions() {
      return this.action.eventOptions;
    }
    get identifier() {
      return this.context.identifier;
    }
    handleEvent(event) {
      if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(event)) {
        this.invokeWithEvent(event);
      }
    }
    get eventName() {
      return this.action.eventName;
    }
    get method() {
      const method = this.controller[this.methodName];
      if (typeof method == "function") {
        return method;
      }
      throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    applyEventModifiers(event) {
      const { element } = this.action;
      const { actionDescriptorFilters } = this.context.application;
      let passes = true;
      for (const [name, value] of Object.entries(this.eventOptions)) {
        if (name in actionDescriptorFilters) {
          const filter3 = actionDescriptorFilters[name];
          passes = passes && filter3({ name, value, event, element });
        } else {
          continue;
        }
      }
      return passes;
    }
    invokeWithEvent(event) {
      const { target, currentTarget } = event;
      try {
        const { params } = this.action;
        const actionEvent = Object.assign(event, { params });
        this.method.call(this.controller, actionEvent);
        this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
      } catch (error2) {
        const { identifier, controller, element, index } = this;
        const detail = { identifier, controller, element, index, event };
        this.context.handleError(error2, `invoking action "${this.action}"`, detail);
      }
    }
    willBeInvokedByEvent(event) {
      const eventTarget = event.target;
      if (event instanceof KeyboardEvent && this.action.isFilterTarget(event)) {
        return false;
      }
      if (this.element === eventTarget) {
        return true;
      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
      } else {
        return this.scope.containsElement(this.action.element);
      }
    }
    get controller() {
      return this.context.controller;
    }
    get methodName() {
      return this.action.methodName;
    }
    get element() {
      return this.scope.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var ElementObserver = class {
    constructor(element, delegate) {
      this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
      }
    }
    pause(callback) {
      if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
      }
      callback();
      if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        const matches = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
          if (!matches.has(element)) {
            this.removeElement(element);
          }
        }
        for (const element of Array.from(matches)) {
          this.addElement(element);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    }
    processAttributeChange(node, attributeName) {
      const element = node;
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    }
    processRemovedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    }
    processAddedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    }
    matchElement(element) {
      return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree2 = this.element) {
      return this.delegate.matchElementsInTree(tree2);
    }
    processTree(tree2, processor) {
      for (const element of this.matchElementsInTree(tree2)) {
        processor.call(this, element);
      }
    }
    elementFromNode(node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
      }
    }
    elementIsActive(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    }
    addElement(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    }
    removeElement(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    }
  };
  var AttributeObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
      return this.elementObserver.element;
    }
    get selector() {
      return `[${this.attributeName}]`;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get started() {
      return this.elementObserver.started;
    }
    matchElement(element) {
      return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree2) {
      const match2 = this.matchElement(tree2) ? [tree2] : [];
      const matches = Array.from(tree2.querySelectorAll(this.selector));
      return match2.concat(matches);
    }
    elementMatched(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    }
    elementUnmatched(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    }
    elementAttributeChanged(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    }
  };
  function add(map, key, value) {
    fetch2(map, key).add(value);
  }
  function del(map, key, value) {
    fetch2(map, key).delete(value);
    prune(map, key);
  }
  function fetch2(map, key) {
    let values = map.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      map.set(key, values);
    }
    return values;
  }
  function prune(map, key) {
    const values = map.get(key);
    if (values != null && values.size == 0) {
      map.delete(key);
    }
  }
  var Multimap = class {
    constructor() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    get keys() {
      return Array.from(this.valuesByKey.keys());
    }
    get values() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((values, set3) => values.concat(Array.from(set3)), []);
    }
    get size() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((size, set3) => size + set3.size, 0);
    }
    add(key, value) {
      add(this.valuesByKey, key, value);
    }
    delete(key, value) {
      del(this.valuesByKey, key, value);
    }
    has(key, value) {
      const values = this.valuesByKey.get(key);
      return values != null && values.has(value);
    }
    hasKey(key) {
      return this.valuesByKey.has(key);
    }
    hasValue(value) {
      const sets = Array.from(this.valuesByKey.values());
      return sets.some((set3) => set3.has(value));
    }
    getValuesForKey(key) {
      const values = this.valuesByKey.get(key);
      return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
      return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value)).map(([key, _values]) => key);
    }
  };
  var SelectorObserver = class {
    constructor(element, selector, delegate, details = {}) {
      this.selector = selector;
      this.details = details;
      this.elementObserver = new ElementObserver(element, this);
      this.delegate = delegate;
      this.matchesByElement = new Multimap();
    }
    get started() {
      return this.elementObserver.started;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get element() {
      return this.elementObserver.element;
    }
    matchElement(element) {
      const matches = element.matches(this.selector);
      if (this.delegate.selectorMatchElement) {
        return matches && this.delegate.selectorMatchElement(element, this.details);
      }
      return matches;
    }
    matchElementsInTree(tree2) {
      const match2 = this.matchElement(tree2) ? [tree2] : [];
      const matches = Array.from(tree2.querySelectorAll(this.selector)).filter((match3) => this.matchElement(match3));
      return match2.concat(matches);
    }
    elementMatched(element) {
      this.selectorMatched(element);
    }
    elementUnmatched(element) {
      this.selectorUnmatched(element);
    }
    elementAttributeChanged(element, _attributeName) {
      const matches = this.matchElement(element);
      const matchedBefore = this.matchesByElement.has(this.selector, element);
      if (!matches && matchedBefore) {
        this.selectorUnmatched(element);
      }
    }
    selectorMatched(element) {
      if (this.delegate.selectorMatched) {
        this.delegate.selectorMatched(element, this.selector, this.details);
        this.matchesByElement.add(this.selector, element);
      }
    }
    selectorUnmatched(element) {
      this.delegate.selectorUnmatched(element, this.selector, this.details);
      this.matchesByElement.delete(this.selector, element);
    }
  };
  var StringMapObserver = class {
    constructor(element, delegate) {
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
          this.refreshAttribute(attributeName, null);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      const attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
      }
    }
    refreshAttribute(attributeName, oldValue) {
      const key = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key, attributeName);
        }
        const value = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value) {
          this.stringMapValueChanged(value, key, oldValue);
        }
        if (value == null) {
          const oldValue2 = this.stringMap.get(attributeName);
          this.stringMap.delete(attributeName);
          if (oldValue2)
            this.stringMapKeyRemoved(key, attributeName, oldValue2);
        } else {
          this.stringMap.set(attributeName, value);
        }
      }
    }
    stringMapKeyAdded(key, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
      }
    }
    stringMapValueChanged(value, key, oldValue) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value, key, oldValue);
      }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
      }
    }
    get knownAttributeNames() {
      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
      return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
      return Array.from(this.stringMap.keys());
    }
  };
  var TokenListObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap();
    }
    get started() {
      return this.attributeObserver.started;
    }
    start() {
      this.attributeObserver.start();
    }
    pause(callback) {
      this.attributeObserver.pause(callback);
    }
    stop() {
      this.attributeObserver.stop();
    }
    refresh() {
      this.attributeObserver.refresh();
    }
    get element() {
      return this.attributeObserver.element;
    }
    get attributeName() {
      return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
      this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
      const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
      tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
      tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
      this.delegate.tokenMatched(token);
      this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
      this.delegate.tokenUnmatched(token);
      this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
      const previousTokens = this.tokensByElement.getValuesForKey(element);
      const currentTokens = this.readTokensForElement(element);
      const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    }
    readTokensForElement(element) {
      const attributeName = this.attributeName;
      const tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString(tokenString, element, attributeName);
    }
  };
  function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index) => ({ element, attributeName, content, index }));
  }
  function zip(left2, right2) {
    const length = Math.max(left2.length, right2.length);
    return Array.from({ length }, (_, index) => [left2[index], right2[index]]);
  }
  function tokensAreEqual(left2, right2) {
    return left2 && right2 && left2.index == right2.index && left2.content == right2.content;
  }
  var ValueListObserver = class {
    constructor(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    get started() {
      return this.tokenListObserver.started;
    }
    start() {
      this.tokenListObserver.start();
    }
    stop() {
      this.tokenListObserver.stop();
    }
    refresh() {
      this.tokenListObserver.refresh();
    }
    get element() {
      return this.tokenListObserver.element;
    }
    get attributeName() {
      return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).set(token, value);
        this.delegate.elementMatchedValue(element, value);
      }
    }
    tokenUnmatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).delete(token);
        this.delegate.elementUnmatchedValue(element, value);
      }
    }
    fetchParseResultForToken(token) {
      let parseResult = this.parseResultsByToken.get(token);
      if (!parseResult) {
        parseResult = this.parseToken(token);
        this.parseResultsByToken.set(token, parseResult);
      }
      return parseResult;
    }
    fetchValuesByTokenForElement(element) {
      let valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    }
    parseToken(token) {
      try {
        const value = this.delegate.parseValueForToken(token);
        return { value };
      } catch (error2) {
        return { error: error2 };
      }
    }
  };
  var BindingObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.bindingsByAction = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
      }
    }
    stop() {
      if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
      }
    }
    get element() {
      return this.context.element;
    }
    get identifier() {
      return this.context.identifier;
    }
    get actionAttribute() {
      return this.schema.actionAttribute;
    }
    get schema() {
      return this.context.schema;
    }
    get bindings() {
      return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
      const binding = new Binding(this.context, action);
      this.bindingsByAction.set(action, binding);
      this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
      const binding = this.bindingsByAction.get(action);
      if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
      }
    }
    disconnectAllActions() {
      this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
      this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
      const action = Action.forToken(token, this.schema);
      if (action.identifier == this.identifier) {
        return action;
      }
    }
    elementMatchedValue(element, action) {
      this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
      this.disconnectAction(action);
    }
  };
  var ValueObserver = class {
    constructor(context, receiver) {
      this.context = context;
      this.receiver = receiver;
      this.stringMapObserver = new StringMapObserver(this.element, this);
      this.valueDescriptorMap = this.controller.valueDescriptorMap;
    }
    start() {
      this.stringMapObserver.start();
      this.invokeChangedCallbacksForDefaultValues();
    }
    stop() {
      this.stringMapObserver.stop();
    }
    get element() {
      return this.context.element;
    }
    get controller() {
      return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
      if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
      }
    }
    stringMapKeyAdded(key, attributeName) {
      const descriptor = this.valueDescriptorMap[attributeName];
      if (!this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
      }
    }
    stringMapValueChanged(value, name, oldValue) {
      const descriptor = this.valueDescriptorNameMap[name];
      if (value === null)
        return;
      if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
      }
      this.invokeChangedCallback(name, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      const descriptor = this.valueDescriptorNameMap[key];
      if (this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
      } else {
        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
      }
    }
    invokeChangedCallbacksForDefaultValues() {
      for (const { key, name, defaultValue: defaultValue6, writer } of this.valueDescriptors) {
        if (defaultValue6 != void 0 && !this.controller.data.has(key)) {
          this.invokeChangedCallback(name, writer(defaultValue6), void 0);
        }
      }
    }
    invokeChangedCallback(name, rawValue, rawOldValue) {
      const changedMethodName = `${name}Changed`;
      const changedMethod = this.receiver[changedMethodName];
      if (typeof changedMethod == "function") {
        const descriptor = this.valueDescriptorNameMap[name];
        try {
          const value = descriptor.reader(rawValue);
          let oldValue = rawOldValue;
          if (rawOldValue) {
            oldValue = descriptor.reader(rawOldValue);
          }
          changedMethod.call(this.receiver, value, oldValue);
        } catch (error2) {
          if (error2 instanceof TypeError) {
            error2.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error2.message}`;
          }
          throw error2;
        }
      }
    }
    get valueDescriptors() {
      const { valueDescriptorMap } = this;
      return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
      const descriptors = {};
      Object.keys(this.valueDescriptorMap).forEach((key) => {
        const descriptor = this.valueDescriptorMap[key];
        descriptors[descriptor.name] = descriptor;
      });
      return descriptors;
    }
    hasValue(attributeName) {
      const descriptor = this.valueDescriptorNameMap[attributeName];
      const hasMethodName = `has${capitalize(descriptor.name)}`;
      return this.receiver[hasMethodName];
    }
  };
  var TargetObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.targetsByName = new Multimap();
    }
    start() {
      if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
      }
    }
    stop() {
      if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
      }
    }
    tokenMatched({ element, content: name }) {
      if (this.scope.containsElement(element)) {
        this.connectTarget(element, name);
      }
    }
    tokenUnmatched({ element, content: name }) {
      this.disconnectTarget(element, name);
    }
    connectTarget(element, name) {
      var _a;
      if (!this.targetsByName.has(name, element)) {
        this.targetsByName.add(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
      }
    }
    disconnectTarget(element, name) {
      var _a;
      if (this.targetsByName.has(name, element)) {
        this.targetsByName.delete(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
      }
    }
    disconnectAllTargets() {
      for (const name of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name)) {
          this.disconnectTarget(element, name);
        }
      }
    }
    get attributeName() {
      return `data-${this.context.identifier}-target`;
    }
    get element() {
      return this.context.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor2) => {
      getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values.add(name));
      return values;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
  }
  var OutletObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.outletsByName = new Multimap();
      this.outletElementsByName = new Multimap();
      this.selectorObserverMap = /* @__PURE__ */ new Map();
    }
    start() {
      if (this.selectorObserverMap.size === 0) {
        this.outletDefinitions.forEach((outletName) => {
          const selector = this.selector(outletName);
          const details = { outletName };
          if (selector) {
            this.selectorObserverMap.set(outletName, new SelectorObserver(document.body, selector, this, details));
          }
        });
        this.selectorObserverMap.forEach((observer) => observer.start());
      }
      this.dependentContexts.forEach((context) => context.refresh());
    }
    stop() {
      if (this.selectorObserverMap.size > 0) {
        this.disconnectAllOutlets();
        this.selectorObserverMap.forEach((observer) => observer.stop());
        this.selectorObserverMap.clear();
      }
    }
    refresh() {
      this.selectorObserverMap.forEach((observer) => observer.refresh());
    }
    selectorMatched(element, _selector, { outletName }) {
      const outlet = this.getOutlet(element, outletName);
      if (outlet) {
        this.connectOutlet(outlet, element, outletName);
      }
    }
    selectorUnmatched(element, _selector, { outletName }) {
      const outlet = this.getOutletFromMap(element, outletName);
      if (outlet) {
        this.disconnectOutlet(outlet, element, outletName);
      }
    }
    selectorMatchElement(element, { outletName }) {
      return this.hasOutlet(element, outletName) && element.matches(`[${this.context.application.schema.controllerAttribute}~=${outletName}]`);
    }
    connectOutlet(outlet, element, outletName) {
      var _a;
      if (!this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.add(outletName, outlet);
        this.outletElementsByName.add(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
      }
    }
    disconnectOutlet(outlet, element, outletName) {
      var _a;
      if (this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.delete(outletName, outlet);
        this.outletElementsByName.delete(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
      }
    }
    disconnectAllOutlets() {
      for (const outletName of this.outletElementsByName.keys) {
        for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
          for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
            this.disconnectOutlet(outlet, element, outletName);
          }
        }
      }
    }
    selector(outletName) {
      return this.scope.outlets.getSelectorForOutletName(outletName);
    }
    get outletDependencies() {
      const dependencies = new Multimap();
      this.router.modules.forEach((module) => {
        const constructor = module.definition.controllerConstructor;
        const outlets = readInheritableStaticArrayValues(constructor, "outlets");
        outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
      });
      return dependencies;
    }
    get outletDefinitions() {
      return this.outletDependencies.getKeysForValue(this.identifier);
    }
    get dependentControllerIdentifiers() {
      return this.outletDependencies.getValuesForKey(this.identifier);
    }
    get dependentContexts() {
      const identifiers = this.dependentControllerIdentifiers;
      return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
    }
    hasOutlet(element, outletName) {
      return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
    }
    getOutlet(element, outletName) {
      return this.application.getControllerForElementAndIdentifier(element, outletName);
    }
    getOutletFromMap(element, outletName) {
      return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
    }
    get scope() {
      return this.context.scope;
    }
    get identifier() {
      return this.context.identifier;
    }
    get application() {
      return this.context.application;
    }
    get router() {
      return this.application.router;
    }
  };
  var Context = class {
    constructor(module, scope) {
      this.logDebugActivity = (functionName, detail = {}) => {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
      };
      this.module = module;
      this.scope = scope;
      this.controller = new module.controllerConstructor(this);
      this.bindingObserver = new BindingObserver(this, this.dispatcher);
      this.valueObserver = new ValueObserver(this, this.controller);
      this.targetObserver = new TargetObserver(this, this);
      this.outletObserver = new OutletObserver(this, this);
      try {
        this.controller.initialize();
        this.logDebugActivity("initialize");
      } catch (error2) {
        this.handleError(error2, "initializing controller");
      }
    }
    connect() {
      this.bindingObserver.start();
      this.valueObserver.start();
      this.targetObserver.start();
      this.outletObserver.start();
      try {
        this.controller.connect();
        this.logDebugActivity("connect");
      } catch (error2) {
        this.handleError(error2, "connecting controller");
      }
    }
    refresh() {
      this.outletObserver.refresh();
    }
    disconnect() {
      try {
        this.controller.disconnect();
        this.logDebugActivity("disconnect");
      } catch (error2) {
        this.handleError(error2, "disconnecting controller");
      }
      this.outletObserver.stop();
      this.targetObserver.stop();
      this.valueObserver.stop();
      this.bindingObserver.stop();
    }
    get application() {
      return this.module.application;
    }
    get identifier() {
      return this.module.identifier;
    }
    get schema() {
      return this.application.schema;
    }
    get dispatcher() {
      return this.application.dispatcher;
    }
    get element() {
      return this.scope.element;
    }
    get parentElement() {
      return this.element.parentElement;
    }
    handleError(error2, message, detail = {}) {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    targetConnected(element, name) {
      this.invokeControllerMethod(`${name}TargetConnected`, element);
    }
    targetDisconnected(element, name) {
      this.invokeControllerMethod(`${name}TargetDisconnected`, element);
    }
    outletConnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
    }
    outletDisconnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
    }
    invokeControllerMethod(methodName, ...args) {
      const controller = this.controller;
      if (typeof controller[methodName] == "function") {
        controller[methodName](...args);
      }
    }
  };
  function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
  }
  function shadow(constructor, properties) {
    const shadowConstructor = extend2(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
  }
  function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
      const properties = blessing(constructor);
      for (const key in properties) {
        const descriptor = blessedProperties[key] || {};
        blessedProperties[key] = Object.assign(descriptor, properties[key]);
      }
      return blessedProperties;
    }, {});
  }
  function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
      const descriptor = getShadowedDescriptor(prototype, properties, key);
      if (descriptor) {
        Object.assign(shadowProperties, { [key]: descriptor });
      }
      return shadowProperties;
    }, {});
  }
  function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
      const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
      if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
      }
      return descriptor;
    }
  }
  var getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
      return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
    } else {
      return Object.getOwnPropertyNames;
    }
  })();
  var extend2 = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a = function() {
        this.a.call(this);
      };
      const b = extendWithReflect(a);
      b.prototype.a = function() {
      };
      return new b();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error2) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function blessDefinition(definition) {
    return {
      identifier: definition.identifier,
      controllerConstructor: bless(definition.controllerConstructor)
    };
  }
  var Module = class {
    constructor(application2, definition) {
      this.application = application2;
      this.definition = blessDefinition(definition);
      this.contextsByScope = /* @__PURE__ */ new WeakMap();
      this.connectedContexts = /* @__PURE__ */ new Set();
    }
    get identifier() {
      return this.definition.identifier;
    }
    get controllerConstructor() {
      return this.definition.controllerConstructor;
    }
    get contexts() {
      return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
      const context = this.fetchContextForScope(scope);
      this.connectedContexts.add(context);
      context.connect();
    }
    disconnectContextForScope(scope) {
      const context = this.contextsByScope.get(scope);
      if (context) {
        this.connectedContexts.delete(context);
        context.disconnect();
      }
    }
    fetchContextForScope(scope) {
      let context = this.contextsByScope.get(scope);
      if (!context) {
        context = new Context(this, scope);
        this.contextsByScope.set(scope, context);
      }
      return context;
    }
  };
  var ClassMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    has(name) {
      return this.data.has(this.getDataKey(name));
    }
    get(name) {
      return this.getAll(name)[0];
    }
    getAll(name) {
      const tokenString = this.data.get(this.getDataKey(name)) || "";
      return tokenize(tokenString);
    }
    getAttributeName(name) {
      return this.data.getAttributeNameForKey(this.getDataKey(name));
    }
    getDataKey(name) {
      return `${name}-class`;
    }
    get data() {
      return this.scope.data;
    }
  };
  var DataMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.getAttribute(name);
    }
    set(key, value) {
      const name = this.getAttributeNameForKey(key);
      this.element.setAttribute(name, value);
      return this.get(key);
    }
    has(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.hasAttribute(name);
    }
    delete(key) {
      if (this.has(key)) {
        const name = this.getAttributeNameForKey(key);
        this.element.removeAttribute(name);
        return true;
      } else {
        return false;
      }
    }
    getAttributeNameForKey(key) {
      return `data-${this.identifier}-${dasherize(key)}`;
    }
  };
  var Guide = class {
    constructor(logger3) {
      this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
      this.logger = logger3;
    }
    warn(object, key, message) {
      let warnedKeys = this.warnedKeysByObject.get(object);
      if (!warnedKeys) {
        warnedKeys = /* @__PURE__ */ new Set();
        this.warnedKeysByObject.set(object, warnedKeys);
      }
      if (!warnedKeys.has(key)) {
        warnedKeys.add(key);
        this.logger.warn(message, object);
      }
    }
  };
  function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
  }
  var TargetSet = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(targetName) {
      return this.find(targetName) != null;
    }
    find(...targetNames) {
      return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
    }
    findAll(...targetNames) {
      return targetNames.reduce((targets, targetName) => [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
      ], []);
    }
    findTarget(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
      const attributeName = this.schema.targetAttributeForScope(this.identifier);
      return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
      const targetDescriptor = `${this.identifier}.${targetName}`;
      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
      if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
      }
      return element;
    }
    get guide() {
      return this.scope.guide;
    }
  };
  var OutletSet = class {
    constructor(scope, controllerElement) {
      this.scope = scope;
      this.controllerElement = controllerElement;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(outletName) {
      return this.find(outletName) != null;
    }
    find(...outletNames) {
      return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), void 0);
    }
    findAll(...outletNames) {
      return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
    }
    getSelectorForOutletName(outletName) {
      const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
      return this.controllerElement.getAttribute(attributeName);
    }
    findOutlet(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      if (selector)
        return this.findElement(selector, outletName);
    }
    findAllOutlets(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      return selector ? this.findAllElements(selector, outletName) : [];
    }
    findElement(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
    }
    findAllElements(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName));
    }
    matchesElement(element, selector, outletName) {
      const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
      return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
    }
  };
  var Scope = class {
    constructor(schema, element, identifier, logger3) {
      this.targets = new TargetSet(this);
      this.classes = new ClassMap(this);
      this.data = new DataMap(this);
      this.containsElement = (element2) => {
        return element2.closest(this.controllerSelector) === this.element;
      };
      this.schema = schema;
      this.element = element;
      this.identifier = identifier;
      this.guide = new Guide(logger3);
      this.outlets = new OutletSet(this.documentScope, element);
    }
    findElement(selector) {
      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
      return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
      ];
    }
    queryElements(selector) {
      return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
    get isDocumentScope() {
      return this.element === document.documentElement;
    }
    get documentScope() {
      return this.isDocumentScope ? this : new Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
    }
  };
  var ScopeObserver = class {
    constructor(element, schema, delegate) {
      this.element = element;
      this.schema = schema;
      this.delegate = delegate;
      this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
      this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
      this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
    }
    start() {
      this.valueListObserver.start();
    }
    stop() {
      this.valueListObserver.stop();
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
      const { element, content: identifier } = token;
      const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
      let scope = scopesByIdentifier.get(identifier);
      if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
      }
      return scope;
    }
    elementMatchedValue(element, value) {
      const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
      this.scopeReferenceCounts.set(value, referenceCount);
      if (referenceCount == 1) {
        this.delegate.scopeConnected(value);
      }
    }
    elementUnmatchedValue(element, value) {
      const referenceCount = this.scopeReferenceCounts.get(value);
      if (referenceCount) {
        this.scopeReferenceCounts.set(value, referenceCount - 1);
        if (referenceCount == 1) {
          this.delegate.scopeDisconnected(value);
        }
      }
    }
    fetchScopesByIdentifierForElement(element) {
      let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
      if (!scopesByIdentifier) {
        scopesByIdentifier = /* @__PURE__ */ new Map();
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
      }
      return scopesByIdentifier;
    }
  };
  var Router = class {
    constructor(application2) {
      this.application = application2;
      this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
      this.scopesByIdentifier = new Multimap();
      this.modulesByIdentifier = /* @__PURE__ */ new Map();
    }
    get element() {
      return this.application.element;
    }
    get schema() {
      return this.application.schema;
    }
    get logger() {
      return this.application.logger;
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    get modules() {
      return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
      return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
      this.scopeObserver.start();
    }
    stop() {
      this.scopeObserver.stop();
    }
    loadDefinition(definition) {
      this.unloadIdentifier(definition.identifier);
      const module = new Module(this.application, definition);
      this.connectModule(module);
      const afterLoad = definition.controllerConstructor.afterLoad;
      if (afterLoad) {
        afterLoad(definition.identifier, this.application);
      }
    }
    unloadIdentifier(identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        this.disconnectModule(module);
      }
    }
    getContextForElementAndIdentifier(element, identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        return module.contexts.find((context) => context.element == element);
      }
    }
    handleError(error2, message, detail) {
      this.application.handleError(error2, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
      return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
      this.scopesByIdentifier.add(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.connectContextForScope(scope);
      }
    }
    scopeDisconnected(scope) {
      this.scopesByIdentifier.delete(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.disconnectContextForScope(scope);
      }
    }
    connectModule(module) {
      this.modulesByIdentifier.set(module.identifier, module);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
      this.modulesByIdentifier.delete(module.identifier);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.disconnectContextForScope(scope));
    }
  };
  var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`,
    outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
    keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c) => [c, c]))), objectFromEntries("0123456789".split("").map((n) => [n, n])))
  };
  function objectFromEntries(array) {
    return array.reduce((memo3, [k, v]) => Object.assign(Object.assign({}, memo3), { [k]: v }), {});
  }
  var Application = class {
    constructor(element = document.documentElement, schema = defaultSchema) {
      this.logger = console;
      this.debug = false;
      this.logDebugActivity = (identifier, functionName, detail = {}) => {
        if (this.debug) {
          this.logFormattedMessage(identifier, functionName, detail);
        }
      };
      this.element = element;
      this.schema = schema;
      this.dispatcher = new Dispatcher(this);
      this.router = new Router(this);
      this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
    }
    static start(element, schema) {
      const application2 = new this(element, schema);
      application2.start();
      return application2;
    }
    async start() {
      await domReady();
      this.logDebugActivity("application", "starting");
      this.dispatcher.start();
      this.router.start();
      this.logDebugActivity("application", "start");
    }
    stop() {
      this.logDebugActivity("application", "stopping");
      this.dispatcher.stop();
      this.router.stop();
      this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
      this.load({ identifier, controllerConstructor });
    }
    registerActionOption(name, filter3) {
      this.actionDescriptorFilters[name] = filter3;
    }
    load(head, ...rest) {
      const definitions = Array.isArray(head) ? head : [head, ...rest];
      definitions.forEach((definition) => {
        if (definition.controllerConstructor.shouldLoad) {
          this.router.loadDefinition(definition);
        }
      });
    }
    unload(head, ...rest) {
      const identifiers = Array.isArray(head) ? head : [head, ...rest];
      identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
      return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
      const context = this.router.getContextForElementAndIdentifier(element, identifier);
      return context ? context.controller : null;
    }
    handleError(error2, message, detail) {
      var _a;
      this.logger.error(`%s

%o

%o`, message, error2, detail);
      (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error2);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
      detail = Object.assign({ application: this }, detail);
      this.logger.groupCollapsed(`${identifier} #${functionName}`);
      this.logger.log("details:", Object.assign({}, detail));
      this.logger.groupEnd();
    }
  };
  function domReady() {
    return new Promise((resolve) => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", () => resolve());
      } else {
        resolve();
      }
    });
  }
  function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition(key) {
    return {
      [`${key}Class`]: {
        get() {
          const { classes } = this;
          if (classes.has(key)) {
            return classes.get(key);
          } else {
            const attribute = classes.getAttributeName(key);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key}Classes`]: {
        get() {
          return this.classes.getAll(key);
        }
      },
      [`has${capitalize(key)}Class`]: {
        get() {
          return this.classes.has(key);
        }
      }
    };
  }
  function OutletPropertiesBlessing(constructor) {
    const outlets = readInheritableStaticArrayValues(constructor, "outlets");
    return outlets.reduce((properties, outletDefinition) => {
      return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
    }, {});
  }
  function propertiesForOutletDefinition(name) {
    const camelizedName = namespaceCamelize(name);
    return {
      [`${camelizedName}Outlet`]: {
        get() {
          const outlet = this.outlets.find(name);
          if (outlet) {
            const outletController = this.application.getControllerForElementAndIdentifier(outlet, name);
            if (outletController) {
              return outletController;
            } else {
              throw new Error(`Missing "data-controller=${name}" attribute on outlet element for "${this.identifier}" controller`);
            }
          }
          throw new Error(`Missing outlet element "${name}" for "${this.identifier}" controller`);
        }
      },
      [`${camelizedName}Outlets`]: {
        get() {
          const outlets = this.outlets.findAll(name);
          if (outlets.length > 0) {
            return outlets.map((outlet) => {
              const controller = this.application.getControllerForElementAndIdentifier(outlet, name);
              if (controller) {
                return controller;
              } else {
                console.warn(`The provided outlet element is missing the outlet controller "${name}" for "${this.identifier}"`, outlet);
              }
            }).filter((controller) => controller);
          }
          return [];
        }
      },
      [`${camelizedName}OutletElement`]: {
        get() {
          const outlet = this.outlets.find(name);
          if (outlet) {
            return outlet;
          } else {
            throw new Error(`Missing outlet element "${name}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${camelizedName}OutletElements`]: {
        get() {
          return this.outlets.findAll(name);
        }
      },
      [`has${capitalize(camelizedName)}Outlet`]: {
        get() {
          return this.outlets.has(name);
        }
      }
    };
  }
  function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition(name) {
    return {
      [`${name}Target`]: {
        get() {
          const target = this.targets.find(name);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name}Targets`]: {
        get() {
          return this.targets.findAll(name);
        }
      },
      [`has${capitalize(name)}Target`]: {
        get() {
          return this.targets.has(name);
        }
      }
    };
  }
  function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result, { [attributeName]: valueDescriptor });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
    const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
    const { key, name, reader: read2, writer: write2 } = definition;
    return {
      [name]: {
        get() {
          const value = this.data.get(key);
          if (value !== null) {
            return read2(value);
          } else {
            return definition.defaultValue;
          }
        },
        set(value) {
          if (value === void 0) {
            this.data.delete(key);
          } else {
            this.data.set(key, write2(value));
          }
        }
      },
      [`has${capitalize(name)}`]: {
        get() {
          return this.data.has(key) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair([token, typeDefinition], controller) {
    return valueDescriptorForTokenAndTypeDefinition({
      controller,
      token,
      typeDefinition
    });
  }
  function parseValueTypeConstant(constant) {
    switch (constant) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault(defaultValue6) {
    switch (typeof defaultValue6) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue6))
      return "array";
    if (Object.prototype.toString.call(defaultValue6) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject(payload) {
    const typeFromObject = parseValueTypeConstant(payload.typeObject.type);
    if (!typeFromObject)
      return;
    const defaultValueType = parseValueTypeDefault(payload.typeObject.default);
    if (typeFromObject !== defaultValueType) {
      const propertyPath = payload.controller ? `${payload.controller}.${payload.token}` : payload.token;
      throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${payload.typeObject.default}" is of type "${defaultValueType}".`);
    }
    return typeFromObject;
  }
  function parseValueTypeDefinition(payload) {
    const typeFromObject = parseValueTypeObject({
      controller: payload.controller,
      token: payload.token,
      typeObject: payload.typeDefinition
    });
    const typeFromDefaultValue = parseValueTypeDefault(payload.typeDefinition);
    const typeFromConstant = parseValueTypeConstant(payload.typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    const propertyPath = payload.controller ? `${payload.controller}.${payload.typeDefinition}` : payload.token;
    throw new Error(`Unknown value type "${propertyPath}" for "${payload.token}" value`);
  }
  function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
      return defaultValuesByType[constant];
    const defaultValue6 = typeDefinition.default;
    if (defaultValue6 !== void 0)
      return defaultValue6;
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition(payload) {
    const key = `${dasherize(payload.token)}-value`;
    const type = parseValueTypeDefinition(payload);
    return {
      type,
      key,
      name: camelize(key),
      get defaultValue() {
        return defaultValueForDefinition(payload.typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault(payload.typeDefinition) !== void 0;
      },
      reader: readers[type],
      writer: writers[type] || writers.default
    };
  }
  var defaultValuesByType = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers = {
    array(value) {
      const array = JSON.parse(value);
      if (!Array.isArray(array)) {
        throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
      }
      return array;
    },
    boolean(value) {
      return !(value == "0" || String(value).toLowerCase() == "false");
    },
    number(value) {
      return Number(value);
    },
    object(value) {
      const object = JSON.parse(value);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
      }
      return object;
    },
    string(value) {
      return value;
    }
  };
  var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
  };
  function writeJSON(value) {
    return JSON.stringify(value);
  }
  function writeString(value) {
    return `${value}`;
  }
  var Controller = class {
    constructor(context) {
      this.context = context;
    }
    static get shouldLoad() {
      return true;
    }
    static afterLoad(_identifier, _application) {
      return;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get outlets() {
      return this.scope.outlets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
      const type = prefix ? `${prefix}:${eventName}` : eventName;
      const event = new CustomEvent(type, { detail, bubbles, cancelable });
      target.dispatchEvent(event);
      return event;
    }
  };
  Controller.blessings = [
    ClassPropertiesBlessing,
    TargetPropertiesBlessing,
    ValuePropertiesBlessing,
    OutletPropertiesBlessing
  ];
  Controller.targets = [];
  Controller.outlets = [];
  Controller.values = {};

  // app/javascript/controllers/application.js
  var application = Application.start();
  application.debug = false;
  window.Stimulus = application;

  // app/javascript/controllers/hello_controller.js
  var hello_controller_default = class extends Controller {
    connect() {
      this.element.textContent = "Hello World!";
    }
  };

  // app/javascript/controllers/index.js
  application.register("hello", hello_controller_default);

  // node_modules/@popperjs/core/lib/index.js
  var lib_exports = {};
  __export(lib_exports, {
    afterMain: () => afterMain,
    afterRead: () => afterRead,
    afterWrite: () => afterWrite,
    applyStyles: () => applyStyles_default,
    arrow: () => arrow_default,
    auto: () => auto,
    basePlacements: () => basePlacements,
    beforeMain: () => beforeMain,
    beforeRead: () => beforeRead,
    beforeWrite: () => beforeWrite,
    bottom: () => bottom,
    clippingParents: () => clippingParents,
    computeStyles: () => computeStyles_default,
    createPopper: () => createPopper3,
    createPopperBase: () => createPopper,
    createPopperLite: () => createPopper2,
    detectOverflow: () => detectOverflow,
    end: () => end,
    eventListeners: () => eventListeners_default,
    flip: () => flip_default,
    hide: () => hide_default,
    left: () => left,
    main: () => main,
    modifierPhases: () => modifierPhases,
    offset: () => offset_default,
    placements: () => placements,
    popper: () => popper,
    popperGenerator: () => popperGenerator,
    popperOffsets: () => popperOffsets_default,
    preventOverflow: () => preventOverflow_default,
    read: () => read,
    reference: () => reference,
    right: () => right,
    start: () => start2,
    top: () => top,
    variationPlacements: () => variationPlacements,
    viewport: () => viewport,
    write: () => write
  });

  // node_modules/@popperjs/core/lib/enums.js
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start2 = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start2, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start2, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }

  // node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect,
    requires: ["computeStyles"]
  };

  // node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // node_modules/@popperjs/core/lib/utils/math.js
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  // node_modules/@popperjs/core/lib/utils/userAgent.js
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }

  // node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  // node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width,
      height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x,
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }

  // node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle2(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle2(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css24 = getComputedStyle2(currentNode);
      if (css24.transform !== "none" || css24.perspective !== "none" || css24.contain === "paint" || ["transform", "perspective"].indexOf(css24.willChange) !== -1 || isFirefox && css24.willChange === "filter" || isFirefox && css24.filter && css24.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // node_modules/@popperjs/core/lib/utils/within.js
  function within(min2, value, max2) {
    return max(min2, min(value, max2));
  }
  function withinMaxClamp(min2, value, max2) {
    var v = within(min2, value, max2);
    return v > max2 ? max2 : v;
  }

  // node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys5) {
    return keys5.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  // node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options2 = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options2.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options2 = _ref2.options;
    var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (true) {
      if (!isHTMLElement(arrowElement)) {
        console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      if (true) {
        console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      }
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref) {
    var x = _ref.x, y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options2 = _ref5.options;
    var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    if (true) {
      var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
      if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
        return transitionProperty.indexOf(property) >= 0;
      })) {
        console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
      }
    }
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect3(_ref) {
    var state = _ref.state, instance = _ref.instance, options2 = _ref.options;
    var _options$scroll = options2.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect3,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }

  // node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash2 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x + getWindowScrollBarX(element),
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle2(body || html).direction === "rtl") {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }

  // node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }

  // node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start2:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  // node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements2;
      if (true) {
        console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
      }
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
      return overflows[a] - overflows[b];
    });
  }

  // node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options2 = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start2;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options2 = _ref2.options, name = _ref2.name;
    var _options$offset = options2.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options2 = _ref.options, name = _ref.name;
    var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min2 = offset2 + overflow[mainSide];
      var max2 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start2 ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start2 ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  // node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn2());
          });
        });
      }
      return pending;
    };
  }

  // node_modules/@popperjs/core/lib/utils/format.js
  function format(str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return [].concat(args).reduce(function(p, c) {
      return p.replace(/%s/, c);
    }, str);
  }

  // node_modules/@popperjs/core/lib/utils/validateModifiers.js
  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function validateModifiers(modifiers) {
    modifiers.forEach(function(modifier) {
      [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {
        return self2.indexOf(value) === index;
      }).forEach(function(key) {
        switch (key) {
          case "name":
            if (typeof modifier.name !== "string") {
              console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
            }
            break;
          case "enabled":
            if (typeof modifier.enabled !== "boolean") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
            }
            break;
          case "phase":
            if (modifierPhases.indexOf(modifier.phase) < 0) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
            }
            break;
          case "fn":
            if (typeof modifier.fn !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "effect":
            if (modifier.effect != null && typeof modifier.effect !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "requires":
            if (modifier.requires != null && !Array.isArray(modifier.requires)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
            }
            break;
          case "requiresIfExists":
            if (!Array.isArray(modifier.requiresIfExists)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
            }
            break;
          case "options":
          case "data":
            break;
          default:
            console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
              return '"' + s + '"';
            }).join(", ") + '; but "' + key + '" was provided.');
        }
        modifier.requires && modifier.requires.forEach(function(requirement) {
          if (modifiers.find(function(mod) {
            return mod.name === requirement;
          }) == null) {
            console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  }

  // node_modules/@popperjs/core/lib/utils/uniqueBy.js
  function uniqueBy(arr, fn2) {
    var identifiers = /* @__PURE__ */ new Set();
    return arr.filter(function(item) {
      var identifier = fn2(item);
      if (!identifiers.has(identifier)) {
        identifiers.add(identifier);
        return true;
      }
    });
  }

  // node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }

  // node_modules/@popperjs/core/lib/createPopper.js
  var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
  var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions3 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper4(reference2, popper2, options2) {
      if (options2 === void 0) {
        options2 = defaultOptions3;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions3),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options3 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions3, state.options, options3);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m) {
            return m.enabled;
          });
          if (true) {
            var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
              var name = _ref.name;
              return name;
            });
            validateModifiers(modifiers);
            if (getBasePlacement(state.options.placement) === auto) {
              var flipModifier = state.orderedModifiers.find(function(_ref2) {
                var name = _ref2.name;
                return name === "flip";
              });
              if (!flipModifier) {
                console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
              }
            }
            var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
            if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
              return parseFloat(margin);
            })) {
              console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
            }
          }
          runModifierEffects();
          return instance.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            if (true) {
              console.error(INVALID_ELEMENT_ERROR);
            }
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (true) {
              __debug_loops__ += 1;
              if (__debug_loops__ > 100) {
                console.error(INFINITE_LOOP_ERROR);
                break;
              }
            }
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        if (true) {
          console.error(INVALID_ELEMENT_ERROR);
        }
        return instance;
      }
      instance.setOptions(options2).then(function(state2) {
        if (!isDestroyed && options2.onFirstUpdate) {
          options2.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref3) {
          var name = _ref3.name, _ref3$options = _ref3.options, options3 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
          if (typeof effect4 === "function") {
            var cleanupFn = effect4({
              state,
              name,
              instance,
              options: options3
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }
  var createPopper = /* @__PURE__ */ popperGenerator();

  // node_modules/@popperjs/core/lib/popper-lite.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
  var createPopper2 = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper3 = /* @__PURE__ */ popperGenerator({
    defaultModifiers: defaultModifiers2
  });

  // node_modules/bootstrap/dist/js/bootstrap.esm.js
  var MAX_UID = 1e6;
  var MILLISECONDS_MULTIPLIER = 1e3;
  var TRANSITION_END = "transitionend";
  var toType = (object) => {
    if (object === null || object === void 0) {
      return `${object}`;
    }
    return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
  };
  var getUID = (prefix) => {
    do {
      prefix += Math.floor(Math.random() * MAX_UID);
    } while (document.getElementById(prefix));
    return prefix;
  };
  var getSelector = (element) => {
    let selector = element.getAttribute("data-bs-target");
    if (!selector || selector === "#") {
      let hrefAttribute = element.getAttribute("href");
      if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) {
        return null;
      }
      if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) {
        hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
      }
      selector = hrefAttribute && hrefAttribute !== "#" ? hrefAttribute.trim() : null;
    }
    return selector;
  };
  var getSelectorFromElement = (element) => {
    const selector = getSelector(element);
    if (selector) {
      return document.querySelector(selector) ? selector : null;
    }
    return null;
  };
  var getElementFromSelector = (element) => {
    const selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };
  var getTransitionDurationFromElement = (element) => {
    if (!element) {
      return 0;
    }
    let {
      transitionDuration,
      transitionDelay
    } = window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay);
    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    }
    transitionDuration = transitionDuration.split(",")[0];
    transitionDelay = transitionDelay.split(",")[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };
  var triggerTransitionEnd = (element) => {
    element.dispatchEvent(new Event(TRANSITION_END));
  };
  var isElement2 = (object) => {
    if (!object || typeof object !== "object") {
      return false;
    }
    if (typeof object.jquery !== "undefined") {
      object = object[0];
    }
    return typeof object.nodeType !== "undefined";
  };
  var getElement = (object) => {
    if (isElement2(object)) {
      return object.jquery ? object[0] : object;
    }
    if (typeof object === "string" && object.length > 0) {
      return document.querySelector(object);
    }
    return null;
  };
  var isVisible = (element) => {
    if (!isElement2(element) || element.getClientRects().length === 0) {
      return false;
    }
    const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
    const closedDetails = element.closest("details:not([open])");
    if (!closedDetails) {
      return elementIsVisible;
    }
    if (closedDetails !== element) {
      const summary = element.closest("summary");
      if (summary && summary.parentNode !== closedDetails) {
        return false;
      }
      if (summary === null) {
        return false;
      }
    }
    return elementIsVisible;
  };
  var isDisabled = (element) => {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    if (element.classList.contains("disabled")) {
      return true;
    }
    if (typeof element.disabled !== "undefined") {
      return element.disabled;
    }
    return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
  };
  var findShadowRoot = (element) => {
    if (!document.documentElement.attachShadow) {
      return null;
    }
    if (typeof element.getRootNode === "function") {
      const root = element.getRootNode();
      return root instanceof ShadowRoot ? root : null;
    }
    if (element instanceof ShadowRoot) {
      return element;
    }
    if (!element.parentNode) {
      return null;
    }
    return findShadowRoot(element.parentNode);
  };
  var noop = () => {
  };
  var reflow = (element) => {
    element.offsetHeight;
  };
  var getjQuery = () => {
    if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
      return window.jQuery;
    }
    return null;
  };
  var DOMContentLoadedCallbacks = [];
  var onDOMContentLoaded = (callback) => {
    if (document.readyState === "loading") {
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener("DOMContentLoaded", () => {
          for (const callback2 of DOMContentLoadedCallbacks) {
            callback2();
          }
        });
      }
      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };
  var isRTL = () => document.documentElement.dir === "rtl";
  var defineJQueryPlugin = (plugin) => {
    onDOMContentLoaded(() => {
      const $2 = getjQuery();
      if ($2) {
        const name = plugin.NAME;
        const JQUERY_NO_CONFLICT = $2.fn[name];
        $2.fn[name] = plugin.jQueryInterface;
        $2.fn[name].Constructor = plugin;
        $2.fn[name].noConflict = () => {
          $2.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  var execute = (callback) => {
    if (typeof callback === "function") {
      callback();
    }
  };
  var executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
    if (!waitForTransition) {
      execute(callback);
      return;
    }
    const durationPadding = 5;
    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    let called = false;
    const handler = ({
      target
    }) => {
      if (target !== transitionElement) {
        return;
      }
      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };
    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(() => {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };
  var getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
    const listLength = list.length;
    let index = list.indexOf(activeElement);
    if (index === -1) {
      return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
    }
    index += shouldGetNext ? 1 : -1;
    if (isCycleAllowed) {
      index = (index + listLength) % listLength;
    }
    return list[Math.max(0, Math.min(index, listLength - 1))];
  };
  var namespaceRegex = /[^.]*(?=\..*)\.|.*/;
  var stripNameRegex = /\..*/;
  var stripUidRegex = /::\d+$/;
  var eventRegistry = {};
  var uidEvent = 1;
  var customEvents = {
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  };
  var nativeEvents = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
  function makeEventUid(element, uid) {
    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
  }
  function getElementEvents(element) {
    const uid = makeEventUid(element);
    element.uidEvent = uid;
    eventRegistry[uid] = eventRegistry[uid] || {};
    return eventRegistry[uid];
  }
  function bootstrapHandler(element, fn2) {
    return function handler(event) {
      hydrateObj(event, {
        delegateTarget: element
      });
      if (handler.oneOff) {
        EventHandler.off(element, event.type, fn2);
      }
      return fn2.apply(element, [event]);
    };
  }
  function bootstrapDelegationHandler(element, selector, fn2) {
    return function handler(event) {
      const domElements = element.querySelectorAll(selector);
      for (let {
        target
      } = event; target && target !== this; target = target.parentNode) {
        for (const domElement of domElements) {
          if (domElement !== target) {
            continue;
          }
          hydrateObj(event, {
            delegateTarget: target
          });
          if (handler.oneOff) {
            EventHandler.off(element, event.type, selector, fn2);
          }
          return fn2.apply(target, [event]);
        }
      }
    };
  }
  function findHandler(events, callable, delegationSelector = null) {
    return Object.values(events).find((event) => event.callable === callable && event.delegationSelector === delegationSelector);
  }
  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
    const isDelegated = typeof handler === "string";
    const callable = isDelegated ? delegationFunction : handler || delegationFunction;
    let typeEvent = getTypeEvent(originalTypeEvent);
    if (!nativeEvents.has(typeEvent)) {
      typeEvent = originalTypeEvent;
    }
    return [isDelegated, callable, typeEvent];
  }
  function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
    if (typeof originalTypeEvent !== "string" || !element) {
      return;
    }
    let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
    if (originalTypeEvent in customEvents) {
      const wrapFunction = (fn3) => {
        return function(event) {
          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
            return fn3.call(this, event);
          }
        };
      };
      callable = wrapFunction(callable);
    }
    const events = getElementEvents(element);
    const handlers = events[typeEvent] || (events[typeEvent] = {});
    const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
    if (previousFunction) {
      previousFunction.oneOff = previousFunction.oneOff && oneOff;
      return;
    }
    const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ""));
    const fn2 = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
    fn2.delegationSelector = isDelegated ? handler : null;
    fn2.callable = callable;
    fn2.oneOff = oneOff;
    fn2.uidEvent = uid;
    handlers[uid] = fn2;
    element.addEventListener(typeEvent, fn2, isDelegated);
  }
  function removeHandler(element, events, typeEvent, handler, delegationSelector) {
    const fn2 = findHandler(events[typeEvent], handler, delegationSelector);
    if (!fn2) {
      return;
    }
    element.removeEventListener(typeEvent, fn2, Boolean(delegationSelector));
    delete events[typeEvent][fn2.uidEvent];
  }
  function removeNamespacedHandlers(element, events, typeEvent, namespace) {
    const storeElementEvent = events[typeEvent] || {};
    for (const handlerKey of Object.keys(storeElementEvent)) {
      if (handlerKey.includes(namespace)) {
        const event = storeElementEvent[handlerKey];
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  }
  function getTypeEvent(event) {
    event = event.replace(stripNameRegex, "");
    return customEvents[event] || event;
  }
  var EventHandler = {
    on(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, false);
    },
    one(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, true);
    },
    off(element, originalTypeEvent, handler, delegationFunction) {
      if (typeof originalTypeEvent !== "string" || !element) {
        return;
      }
      const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
      const inNamespace = typeEvent !== originalTypeEvent;
      const events = getElementEvents(element);
      const storeElementEvent = events[typeEvent] || {};
      const isNamespace = originalTypeEvent.startsWith(".");
      if (typeof callable !== "undefined") {
        if (!Object.keys(storeElementEvent).length) {
          return;
        }
        removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
        return;
      }
      if (isNamespace) {
        for (const elementEvent of Object.keys(events)) {
          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
        }
      }
      for (const keyHandlers of Object.keys(storeElementEvent)) {
        const handlerKey = keyHandlers.replace(stripUidRegex, "");
        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
          const event = storeElementEvent[keyHandlers];
          removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
        }
      }
    },
    trigger(element, event, args) {
      if (typeof event !== "string" || !element) {
        return null;
      }
      const $2 = getjQuery();
      const typeEvent = getTypeEvent(event);
      const inNamespace = event !== typeEvent;
      let jQueryEvent = null;
      let bubbles = true;
      let nativeDispatch = true;
      let defaultPrevented = false;
      if (inNamespace && $2) {
        jQueryEvent = $2.Event(event, args);
        $2(element).trigger(jQueryEvent);
        bubbles = !jQueryEvent.isPropagationStopped();
        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
        defaultPrevented = jQueryEvent.isDefaultPrevented();
      }
      let evt = new Event(event, {
        bubbles,
        cancelable: true
      });
      evt = hydrateObj(evt, args);
      if (defaultPrevented) {
        evt.preventDefault();
      }
      if (nativeDispatch) {
        element.dispatchEvent(evt);
      }
      if (evt.defaultPrevented && jQueryEvent) {
        jQueryEvent.preventDefault();
      }
      return evt;
    }
  };
  function hydrateObj(obj, meta) {
    for (const [key, value] of Object.entries(meta || {})) {
      try {
        obj[key] = value;
      } catch (_unused) {
        Object.defineProperty(obj, key, {
          configurable: true,
          get() {
            return value;
          }
        });
      }
    }
    return obj;
  }
  var elementMap = /* @__PURE__ */ new Map();
  var Data = {
    set(element, key, instance) {
      if (!elementMap.has(element)) {
        elementMap.set(element, /* @__PURE__ */ new Map());
      }
      const instanceMap = elementMap.get(element);
      if (!instanceMap.has(key) && instanceMap.size !== 0) {
        console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
        return;
      }
      instanceMap.set(key, instance);
    },
    get(element, key) {
      if (elementMap.has(element)) {
        return elementMap.get(element).get(key) || null;
      }
      return null;
    },
    remove(element, key) {
      if (!elementMap.has(element)) {
        return;
      }
      const instanceMap = elementMap.get(element);
      instanceMap.delete(key);
      if (instanceMap.size === 0) {
        elementMap.delete(element);
      }
    }
  };
  function normalizeData(value) {
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    if (value === Number(value).toString()) {
      return Number(value);
    }
    if (value === "" || value === "null") {
      return null;
    }
    if (typeof value !== "string") {
      return value;
    }
    try {
      return JSON.parse(decodeURIComponent(value));
    } catch (_unused) {
      return value;
    }
  }
  function normalizeDataKey(key) {
    return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
  }
  var Manipulator = {
    setDataAttribute(element, key, value) {
      element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
    },
    removeDataAttribute(element, key) {
      element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
    },
    getDataAttributes(element) {
      if (!element) {
        return {};
      }
      const attributes = {};
      const bsKeys = Object.keys(element.dataset).filter((key) => key.startsWith("bs") && !key.startsWith("bsConfig"));
      for (const key of bsKeys) {
        let pureKey = key.replace(/^bs/, "");
        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
        attributes[pureKey] = normalizeData(element.dataset[key]);
      }
      return attributes;
    },
    getDataAttribute(element, key) {
      return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
    }
  };
  var Config = class {
    // Getters
    static get Default() {
      return {};
    }
    static get DefaultType() {
      return {};
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
    _getConfig(config2) {
      config2 = this._mergeConfigObj(config2);
      config2 = this._configAfterMerge(config2);
      this._typeCheckConfig(config2);
      return config2;
    }
    _configAfterMerge(config2) {
      return config2;
    }
    _mergeConfigObj(config2, element) {
      const jsonConfig = isElement2(element) ? Manipulator.getDataAttribute(element, "config") : {};
      return {
        ...this.constructor.Default,
        ...typeof jsonConfig === "object" ? jsonConfig : {},
        ...isElement2(element) ? Manipulator.getDataAttributes(element) : {},
        ...typeof config2 === "object" ? config2 : {}
      };
    }
    _typeCheckConfig(config2, configTypes = this.constructor.DefaultType) {
      for (const property of Object.keys(configTypes)) {
        const expectedTypes = configTypes[property];
        const value = config2[property];
        const valueType = isElement2(value) ? "element" : toType(value);
        if (!new RegExp(expectedTypes).test(valueType)) {
          throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
        }
      }
    }
  };
  var VERSION = "5.2.3";
  var BaseComponent = class extends Config {
    constructor(element, config2) {
      super();
      element = getElement(element);
      if (!element) {
        return;
      }
      this._element = element;
      this._config = this._getConfig(config2);
      Data.set(this._element, this.constructor.DATA_KEY, this);
    }
    // Public
    dispose() {
      Data.remove(this._element, this.constructor.DATA_KEY);
      EventHandler.off(this._element, this.constructor.EVENT_KEY);
      for (const propertyName of Object.getOwnPropertyNames(this)) {
        this[propertyName] = null;
      }
    }
    _queueCallback(callback, element, isAnimated = true) {
      executeAfterTransition(callback, element, isAnimated);
    }
    _getConfig(config2) {
      config2 = this._mergeConfigObj(config2, this._element);
      config2 = this._configAfterMerge(config2);
      this._typeCheckConfig(config2);
      return config2;
    }
    // Static
    static getInstance(element) {
      return Data.get(getElement(element), this.DATA_KEY);
    }
    static getOrCreateInstance(element, config2 = {}) {
      return this.getInstance(element) || new this(element, typeof config2 === "object" ? config2 : null);
    }
    static get VERSION() {
      return VERSION;
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
    static eventName(name) {
      return `${name}${this.EVENT_KEY}`;
    }
  };
  var enableDismissTrigger = (component, method = "hide") => {
    const clickEvent = `click.dismiss${component.EVENT_KEY}`;
    const name = component.NAME;
    EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function(event) {
      if (["A", "AREA"].includes(this.tagName)) {
        event.preventDefault();
      }
      if (isDisabled(this)) {
        return;
      }
      const target = getElementFromSelector(this) || this.closest(`.${name}`);
      const instance = component.getOrCreateInstance(target);
      instance[method]();
    });
  };
  var NAME$f = "alert";
  var DATA_KEY$a = "bs.alert";
  var EVENT_KEY$b = `.${DATA_KEY$a}`;
  var EVENT_CLOSE = `close${EVENT_KEY$b}`;
  var EVENT_CLOSED = `closed${EVENT_KEY$b}`;
  var CLASS_NAME_FADE$5 = "fade";
  var CLASS_NAME_SHOW$8 = "show";
  var Alert = class extends BaseComponent {
    // Getters
    static get NAME() {
      return NAME$f;
    }
    // Public
    close() {
      const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
      if (closeEvent.defaultPrevented) {
        return;
      }
      this._element.classList.remove(CLASS_NAME_SHOW$8);
      const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
      this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
    }
    // Private
    _destroyElement() {
      this._element.remove();
      EventHandler.trigger(this._element, EVENT_CLOSED);
      this.dispose();
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = Alert.getOrCreateInstance(this);
        if (typeof config2 !== "string") {
          return;
        }
        if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2](this);
      });
    }
  };
  enableDismissTrigger(Alert, "close");
  defineJQueryPlugin(Alert);
  var NAME$e = "button";
  var DATA_KEY$9 = "bs.button";
  var EVENT_KEY$a = `.${DATA_KEY$9}`;
  var DATA_API_KEY$6 = ".data-api";
  var CLASS_NAME_ACTIVE$3 = "active";
  var SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
  var EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
  var Button = class extends BaseComponent {
    // Getters
    static get NAME() {
      return NAME$e;
    }
    // Public
    toggle() {
      this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = Button.getOrCreateInstance(this);
        if (config2 === "toggle") {
          data[config2]();
        }
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event) => {
    event.preventDefault();
    const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
    const data = Button.getOrCreateInstance(button);
    data.toggle();
  });
  defineJQueryPlugin(Button);
  var SelectorEngine = {
    find(selector, element = document.documentElement) {
      return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
    },
    findOne(selector, element = document.documentElement) {
      return Element.prototype.querySelector.call(element, selector);
    },
    children(element, selector) {
      return [].concat(...element.children).filter((child) => child.matches(selector));
    },
    parents(element, selector) {
      const parents = [];
      let ancestor = element.parentNode.closest(selector);
      while (ancestor) {
        parents.push(ancestor);
        ancestor = ancestor.parentNode.closest(selector);
      }
      return parents;
    },
    prev(element, selector) {
      let previous = element.previousElementSibling;
      while (previous) {
        if (previous.matches(selector)) {
          return [previous];
        }
        previous = previous.previousElementSibling;
      }
      return [];
    },
    // TODO: this is now unused; remove later along with prev()
    next(element, selector) {
      let next = element.nextElementSibling;
      while (next) {
        if (next.matches(selector)) {
          return [next];
        }
        next = next.nextElementSibling;
      }
      return [];
    },
    focusableChildren(element) {
      const focusables = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((selector) => `${selector}:not([tabindex^="-"])`).join(",");
      return this.find(focusables, element).filter((el) => !isDisabled(el) && isVisible(el));
    }
  };
  var NAME$d = "swipe";
  var EVENT_KEY$9 = ".bs.swipe";
  var EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
  var EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
  var EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
  var EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
  var EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
  var POINTER_TYPE_TOUCH = "touch";
  var POINTER_TYPE_PEN = "pen";
  var CLASS_NAME_POINTER_EVENT = "pointer-event";
  var SWIPE_THRESHOLD = 40;
  var Default$c = {
    endCallback: null,
    leftCallback: null,
    rightCallback: null
  };
  var DefaultType$c = {
    endCallback: "(function|null)",
    leftCallback: "(function|null)",
    rightCallback: "(function|null)"
  };
  var Swipe = class extends Config {
    constructor(element, config2) {
      super();
      this._element = element;
      if (!element || !Swipe.isSupported()) {
        return;
      }
      this._config = this._getConfig(config2);
      this._deltaX = 0;
      this._supportPointerEvents = Boolean(window.PointerEvent);
      this._initEvents();
    }
    // Getters
    static get Default() {
      return Default$c;
    }
    static get DefaultType() {
      return DefaultType$c;
    }
    static get NAME() {
      return NAME$d;
    }
    // Public
    dispose() {
      EventHandler.off(this._element, EVENT_KEY$9);
    }
    // Private
    _start(event) {
      if (!this._supportPointerEvents) {
        this._deltaX = event.touches[0].clientX;
        return;
      }
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX;
      }
    }
    _end(event) {
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX - this._deltaX;
      }
      this._handleSwipe();
      execute(this._config.endCallback);
    }
    _move(event) {
      this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
    }
    _handleSwipe() {
      const absDeltaX = Math.abs(this._deltaX);
      if (absDeltaX <= SWIPE_THRESHOLD) {
        return;
      }
      const direction = absDeltaX / this._deltaX;
      this._deltaX = 0;
      if (!direction) {
        return;
      }
      execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
    }
    _initEvents() {
      if (this._supportPointerEvents) {
        EventHandler.on(this._element, EVENT_POINTERDOWN, (event) => this._start(event));
        EventHandler.on(this._element, EVENT_POINTERUP, (event) => this._end(event));
        this._element.classList.add(CLASS_NAME_POINTER_EVENT);
      } else {
        EventHandler.on(this._element, EVENT_TOUCHSTART, (event) => this._start(event));
        EventHandler.on(this._element, EVENT_TOUCHMOVE, (event) => this._move(event));
        EventHandler.on(this._element, EVENT_TOUCHEND, (event) => this._end(event));
      }
    }
    _eventIsPointerPenTouch(event) {
      return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
    }
    // Static
    static isSupported() {
      return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
    }
  };
  var NAME$c = "carousel";
  var DATA_KEY$8 = "bs.carousel";
  var EVENT_KEY$8 = `.${DATA_KEY$8}`;
  var DATA_API_KEY$5 = ".data-api";
  var ARROW_LEFT_KEY$1 = "ArrowLeft";
  var ARROW_RIGHT_KEY$1 = "ArrowRight";
  var TOUCHEVENT_COMPAT_WAIT = 500;
  var ORDER_NEXT = "next";
  var ORDER_PREV = "prev";
  var DIRECTION_LEFT = "left";
  var DIRECTION_RIGHT = "right";
  var EVENT_SLIDE = `slide${EVENT_KEY$8}`;
  var EVENT_SLID = `slid${EVENT_KEY$8}`;
  var EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
  var EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
  var EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
  var EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
  var EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
  var EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
  var CLASS_NAME_CAROUSEL = "carousel";
  var CLASS_NAME_ACTIVE$2 = "active";
  var CLASS_NAME_SLIDE = "slide";
  var CLASS_NAME_END = "carousel-item-end";
  var CLASS_NAME_START = "carousel-item-start";
  var CLASS_NAME_NEXT = "carousel-item-next";
  var CLASS_NAME_PREV = "carousel-item-prev";
  var SELECTOR_ACTIVE = ".active";
  var SELECTOR_ITEM = ".carousel-item";
  var SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
  var SELECTOR_ITEM_IMG = ".carousel-item img";
  var SELECTOR_INDICATORS = ".carousel-indicators";
  var SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
  var SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
  var KEY_TO_DIRECTION = {
    [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
    [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
  };
  var Default$b = {
    interval: 5e3,
    keyboard: true,
    pause: "hover",
    ride: false,
    touch: true,
    wrap: true
  };
  var DefaultType$b = {
    interval: "(number|boolean)",
    // TODO:v6 remove boolean support
    keyboard: "boolean",
    pause: "(string|boolean)",
    ride: "(boolean|string)",
    touch: "boolean",
    wrap: "boolean"
  };
  var Carousel = class extends BaseComponent {
    constructor(element, config2) {
      super(element, config2);
      this._interval = null;
      this._activeElement = null;
      this._isSliding = false;
      this.touchTimeout = null;
      this._swipeHelper = null;
      this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
      this._addEventListeners();
      if (this._config.ride === CLASS_NAME_CAROUSEL) {
        this.cycle();
      }
    }
    // Getters
    static get Default() {
      return Default$b;
    }
    static get DefaultType() {
      return DefaultType$b;
    }
    static get NAME() {
      return NAME$c;
    }
    // Public
    next() {
      this._slide(ORDER_NEXT);
    }
    nextWhenVisible() {
      if (!document.hidden && isVisible(this._element)) {
        this.next();
      }
    }
    prev() {
      this._slide(ORDER_PREV);
    }
    pause() {
      if (this._isSliding) {
        triggerTransitionEnd(this._element);
      }
      this._clearInterval();
    }
    cycle() {
      this._clearInterval();
      this._updateInterval();
      this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
    }
    _maybeEnableCycle() {
      if (!this._config.ride) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
        return;
      }
      this.cycle();
    }
    to(index) {
      const items = this._getItems();
      if (index > items.length - 1 || index < 0) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
        return;
      }
      const activeIndex = this._getItemIndex(this._getActive());
      if (activeIndex === index) {
        return;
      }
      const order2 = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
      this._slide(order2, items[index]);
    }
    dispose() {
      if (this._swipeHelper) {
        this._swipeHelper.dispose();
      }
      super.dispose();
    }
    // Private
    _configAfterMerge(config2) {
      config2.defaultInterval = config2.interval;
      return config2;
    }
    _addEventListeners() {
      if (this._config.keyboard) {
        EventHandler.on(this._element, EVENT_KEYDOWN$1, (event) => this._keydown(event));
      }
      if (this._config.pause === "hover") {
        EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
        EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
      }
      if (this._config.touch && Swipe.isSupported()) {
        this._addTouchEventListeners();
      }
    }
    _addTouchEventListeners() {
      for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
        EventHandler.on(img, EVENT_DRAG_START, (event) => event.preventDefault());
      }
      const endCallBack = () => {
        if (this._config.pause !== "hover") {
          return;
        }
        this.pause();
        if (this.touchTimeout) {
          clearTimeout(this.touchTimeout);
        }
        this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
      };
      const swipeConfig = {
        leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
        rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
        endCallback: endCallBack
      };
      this._swipeHelper = new Swipe(this._element, swipeConfig);
    }
    _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }
      const direction = KEY_TO_DIRECTION[event.key];
      if (direction) {
        event.preventDefault();
        this._slide(this._directionToOrder(direction));
      }
    }
    _getItemIndex(element) {
      return this._getItems().indexOf(element);
    }
    _setActiveIndicatorElement(index) {
      if (!this._indicatorsElement) {
        return;
      }
      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
      activeIndicator.removeAttribute("aria-current");
      const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
      if (newActiveIndicator) {
        newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
        newActiveIndicator.setAttribute("aria-current", "true");
      }
    }
    _updateInterval() {
      const element = this._activeElement || this._getActive();
      if (!element) {
        return;
      }
      const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
      this._config.interval = elementInterval || this._config.defaultInterval;
    }
    _slide(order2, element = null) {
      if (this._isSliding) {
        return;
      }
      const activeElement = this._getActive();
      const isNext = order2 === ORDER_NEXT;
      const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
      if (nextElement === activeElement) {
        return;
      }
      const nextElementIndex = this._getItemIndex(nextElement);
      const triggerEvent = (eventName) => {
        return EventHandler.trigger(this._element, eventName, {
          relatedTarget: nextElement,
          direction: this._orderToDirection(order2),
          from: this._getItemIndex(activeElement),
          to: nextElementIndex
        });
      };
      const slideEvent = triggerEvent(EVENT_SLIDE);
      if (slideEvent.defaultPrevented) {
        return;
      }
      if (!activeElement || !nextElement) {
        return;
      }
      const isCycling = Boolean(this._interval);
      this.pause();
      this._isSliding = true;
      this._setActiveIndicatorElement(nextElementIndex);
      this._activeElement = nextElement;
      const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
      const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
      nextElement.classList.add(orderClassName);
      reflow(nextElement);
      activeElement.classList.add(directionalClassName);
      nextElement.classList.add(directionalClassName);
      const completeCallBack = () => {
        nextElement.classList.remove(directionalClassName, orderClassName);
        nextElement.classList.add(CLASS_NAME_ACTIVE$2);
        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
        this._isSliding = false;
        triggerEvent(EVENT_SLID);
      };
      this._queueCallback(completeCallBack, activeElement, this._isAnimated());
      if (isCycling) {
        this.cycle();
      }
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_SLIDE);
    }
    _getActive() {
      return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
    }
    _getItems() {
      return SelectorEngine.find(SELECTOR_ITEM, this._element);
    }
    _clearInterval() {
      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }
    }
    _directionToOrder(direction) {
      if (isRTL()) {
        return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
      }
      return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
    }
    _orderToDirection(order2) {
      if (isRTL()) {
        return order2 === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return order2 === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = Carousel.getOrCreateInstance(this, config2);
        if (typeof config2 === "number") {
          data.to(config2);
          return;
        }
        if (typeof config2 === "string") {
          if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
            throw new TypeError(`No method named "${config2}"`);
          }
          data[config2]();
        }
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {
    const target = getElementFromSelector(this);
    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
      return;
    }
    event.preventDefault();
    const carousel = Carousel.getOrCreateInstance(target);
    const slideIndex = this.getAttribute("data-bs-slide-to");
    if (slideIndex) {
      carousel.to(slideIndex);
      carousel._maybeEnableCycle();
      return;
    }
    if (Manipulator.getDataAttribute(this, "slide") === "next") {
      carousel.next();
      carousel._maybeEnableCycle();
      return;
    }
    carousel.prev();
    carousel._maybeEnableCycle();
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
    for (const carousel of carousels) {
      Carousel.getOrCreateInstance(carousel);
    }
  });
  defineJQueryPlugin(Carousel);
  var NAME$b = "collapse";
  var DATA_KEY$7 = "bs.collapse";
  var EVENT_KEY$7 = `.${DATA_KEY$7}`;
  var DATA_API_KEY$4 = ".data-api";
  var EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
  var EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
  var EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
  var EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
  var EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
  var CLASS_NAME_SHOW$7 = "show";
  var CLASS_NAME_COLLAPSE = "collapse";
  var CLASS_NAME_COLLAPSING = "collapsing";
  var CLASS_NAME_COLLAPSED = "collapsed";
  var CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
  var CLASS_NAME_HORIZONTAL = "collapse-horizontal";
  var WIDTH = "width";
  var HEIGHT = "height";
  var SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
  var SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
  var Default$a = {
    parent: null,
    toggle: true
  };
  var DefaultType$a = {
    parent: "(null|element)",
    toggle: "boolean"
  };
  var Collapse = class extends BaseComponent {
    constructor(element, config2) {
      super(element, config2);
      this._isTransitioning = false;
      this._triggerArray = [];
      const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
      for (const elem of toggleList) {
        const selector = getSelectorFromElement(elem);
        const filterElement = SelectorEngine.find(selector).filter((foundElement) => foundElement === this._element);
        if (selector !== null && filterElement.length) {
          this._triggerArray.push(elem);
        }
      }
      this._initializeChildren();
      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
      }
      if (this._config.toggle) {
        this.toggle();
      }
    }
    // Getters
    static get Default() {
      return Default$a;
    }
    static get DefaultType() {
      return DefaultType$a;
    }
    static get NAME() {
      return NAME$b;
    }
    // Public
    toggle() {
      if (this._isShown()) {
        this.hide();
      } else {
        this.show();
      }
    }
    show() {
      if (this._isTransitioning || this._isShown()) {
        return;
      }
      let activeChildren = [];
      if (this._config.parent) {
        activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element) => element !== this._element).map((element) => Collapse.getOrCreateInstance(element, {
          toggle: false
        }));
      }
      if (activeChildren.length && activeChildren[0]._isTransitioning) {
        return;
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      for (const activeInstance of activeChildren) {
        activeInstance.hide();
      }
      const dimension = this._getDimension();
      this._element.classList.remove(CLASS_NAME_COLLAPSE);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.style[dimension] = 0;
      this._addAriaAndCollapsedClass(this._triggerArray, true);
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
        this._element.style[dimension] = "";
        EventHandler.trigger(this._element, EVENT_SHOWN$6);
      };
      const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      const scrollSize = `scroll${capitalizedDimension}`;
      this._queueCallback(complete, this._element, true);
      this._element.style[dimension] = `${this._element[scrollSize]}px`;
    }
    hide() {
      if (this._isTransitioning || !this._isShown()) {
        return;
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      const dimension = this._getDimension();
      this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      for (const trigger of this._triggerArray) {
        const element = getElementFromSelector(trigger);
        if (element && !this._isShown(element)) {
          this._addAriaAndCollapsedClass([trigger], false);
        }
      }
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE);
        EventHandler.trigger(this._element, EVENT_HIDDEN$6);
      };
      this._element.style[dimension] = "";
      this._queueCallback(complete, this._element, true);
    }
    _isShown(element = this._element) {
      return element.classList.contains(CLASS_NAME_SHOW$7);
    }
    // Private
    _configAfterMerge(config2) {
      config2.toggle = Boolean(config2.toggle);
      config2.parent = getElement(config2.parent);
      return config2;
    }
    _getDimension() {
      return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
    }
    _initializeChildren() {
      if (!this._config.parent) {
        return;
      }
      const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
      for (const element of children) {
        const selected = getElementFromSelector(element);
        if (selected) {
          this._addAriaAndCollapsedClass([element], this._isShown(selected));
        }
      }
    }
    _getFirstLevelChildren(selector) {
      const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
      return SelectorEngine.find(selector, this._config.parent).filter((element) => !children.includes(element));
    }
    _addAriaAndCollapsedClass(triggerArray, isOpen) {
      if (!triggerArray.length) {
        return;
      }
      for (const element of triggerArray) {
        element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
        element.setAttribute("aria-expanded", isOpen);
      }
    }
    // Static
    static jQueryInterface(config2) {
      const _config = {};
      if (typeof config2 === "string" && /show|hide/.test(config2)) {
        _config.toggle = false;
      }
      return this.each(function() {
        const data = Collapse.getOrCreateInstance(this, _config);
        if (typeof config2 === "string") {
          if (typeof data[config2] === "undefined") {
            throw new TypeError(`No method named "${config2}"`);
          }
          data[config2]();
        }
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
    if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
      event.preventDefault();
    }
    const selector = getSelectorFromElement(this);
    const selectorElements = SelectorEngine.find(selector);
    for (const element of selectorElements) {
      Collapse.getOrCreateInstance(element, {
        toggle: false
      }).toggle();
    }
  });
  defineJQueryPlugin(Collapse);
  var NAME$a = "dropdown";
  var DATA_KEY$6 = "bs.dropdown";
  var EVENT_KEY$6 = `.${DATA_KEY$6}`;
  var DATA_API_KEY$3 = ".data-api";
  var ESCAPE_KEY$2 = "Escape";
  var TAB_KEY$1 = "Tab";
  var ARROW_UP_KEY$1 = "ArrowUp";
  var ARROW_DOWN_KEY$1 = "ArrowDown";
  var RIGHT_MOUSE_BUTTON = 2;
  var EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
  var EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
  var EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
  var EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
  var EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
  var EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
  var EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
  var CLASS_NAME_SHOW$6 = "show";
  var CLASS_NAME_DROPUP = "dropup";
  var CLASS_NAME_DROPEND = "dropend";
  var CLASS_NAME_DROPSTART = "dropstart";
  var CLASS_NAME_DROPUP_CENTER = "dropup-center";
  var CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
  var SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
  var SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
  var SELECTOR_MENU = ".dropdown-menu";
  var SELECTOR_NAVBAR = ".navbar";
  var SELECTOR_NAVBAR_NAV = ".navbar-nav";
  var SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
  var PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
  var PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
  var PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
  var PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
  var PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
  var PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
  var PLACEMENT_TOPCENTER = "top";
  var PLACEMENT_BOTTOMCENTER = "bottom";
  var Default$9 = {
    autoClose: true,
    boundary: "clippingParents",
    display: "dynamic",
    offset: [0, 2],
    popperConfig: null,
    reference: "toggle"
  };
  var DefaultType$9 = {
    autoClose: "(boolean|string)",
    boundary: "(string|element)",
    display: "string",
    offset: "(array|string|function)",
    popperConfig: "(null|object|function)",
    reference: "(string|element|object)"
  };
  var Dropdown = class extends BaseComponent {
    constructor(element, config2) {
      super(element, config2);
      this._popper = null;
      this._parent = this._element.parentNode;
      this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
      this._inNavbar = this._detectNavbar();
    }
    // Getters
    static get Default() {
      return Default$9;
    }
    static get DefaultType() {
      return DefaultType$9;
    }
    static get NAME() {
      return NAME$a;
    }
    // Public
    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (isDisabled(this._element) || this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._createPopper();
      if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.on(element, "mouseover", noop);
        }
      }
      this._element.focus();
      this._element.setAttribute("aria-expanded", true);
      this._menu.classList.add(CLASS_NAME_SHOW$6);
      this._element.classList.add(CLASS_NAME_SHOW$6);
      EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
    }
    hide() {
      if (isDisabled(this._element) || !this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      this._completeHide(relatedTarget);
    }
    dispose() {
      if (this._popper) {
        this._popper.destroy();
      }
      super.dispose();
    }
    update() {
      this._inNavbar = this._detectNavbar();
      if (this._popper) {
        this._popper.update();
      }
    }
    // Private
    _completeHide(relatedTarget) {
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
      if (hideEvent.defaultPrevented) {
        return;
      }
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.off(element, "mouseover", noop);
        }
      }
      if (this._popper) {
        this._popper.destroy();
      }
      this._menu.classList.remove(CLASS_NAME_SHOW$6);
      this._element.classList.remove(CLASS_NAME_SHOW$6);
      this._element.setAttribute("aria-expanded", "false");
      Manipulator.removeDataAttribute(this._menu, "popper");
      EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
    }
    _getConfig(config2) {
      config2 = super._getConfig(config2);
      if (typeof config2.reference === "object" && !isElement2(config2.reference) && typeof config2.reference.getBoundingClientRect !== "function") {
        throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
      }
      return config2;
    }
    _createPopper() {
      if (typeof lib_exports === "undefined") {
        throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
      }
      let referenceElement = this._element;
      if (this._config.reference === "parent") {
        referenceElement = this._parent;
      } else if (isElement2(this._config.reference)) {
        referenceElement = getElement(this._config.reference);
      } else if (typeof this._config.reference === "object") {
        referenceElement = this._config.reference;
      }
      const popperConfig = this._getPopperConfig();
      this._popper = createPopper3(referenceElement, this._menu, popperConfig);
    }
    _isShown() {
      return this._menu.classList.contains(CLASS_NAME_SHOW$6);
    }
    _getPlacement() {
      const parentDropdown = this._parent;
      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
        return PLACEMENT_RIGHT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
        return PLACEMENT_LEFT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
        return PLACEMENT_TOPCENTER;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
        return PLACEMENT_BOTTOMCENTER;
      }
      const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
      }
      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
    }
    _detectNavbar() {
      return this._element.closest(SELECTOR_NAVBAR) !== null;
    }
    _getOffset() {
      const {
        offset: offset2
      } = this._config;
      if (typeof offset2 === "string") {
        return offset2.split(",").map((value) => Number.parseInt(value, 10));
      }
      if (typeof offset2 === "function") {
        return (popperData) => offset2(popperData, this._element);
      }
      return offset2;
    }
    _getPopperConfig() {
      const defaultBsPopperConfig = {
        placement: this._getPlacement(),
        modifiers: [{
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }]
      };
      if (this._inNavbar || this._config.display === "static") {
        Manipulator.setDataAttribute(this._menu, "popper", "static");
        defaultBsPopperConfig.modifiers = [{
          name: "applyStyles",
          enabled: false
        }];
      }
      return {
        ...defaultBsPopperConfig,
        ...typeof this._config.popperConfig === "function" ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
      };
    }
    _selectMenuItem({
      key,
      target
    }) {
      const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element) => isVisible(element));
      if (!items.length) {
        return;
      }
      getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = Dropdown.getOrCreateInstance(this, config2);
        if (typeof config2 !== "string") {
          return;
        }
        if (typeof data[config2] === "undefined") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2]();
      });
    }
    static clearMenus(event) {
      if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY$1) {
        return;
      }
      const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
      for (const toggle of openToggles) {
        const context = Dropdown.getInstance(toggle);
        if (!context || context._config.autoClose === false) {
          continue;
        }
        const composedPath = event.composedPath();
        const isMenuTarget = composedPath.includes(context._menu);
        if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
          continue;
        }
        if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
          continue;
        }
        const relatedTarget = {
          relatedTarget: context._element
        };
        if (event.type === "click") {
          relatedTarget.clickEvent = event;
        }
        context._completeHide(relatedTarget);
      }
    }
    static dataApiKeydownHandler(event) {
      const isInput = /input|textarea/i.test(event.target.tagName);
      const isEscapeEvent = event.key === ESCAPE_KEY$2;
      const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
      if (!isUpOrDownEvent && !isEscapeEvent) {
        return;
      }
      if (isInput && !isEscapeEvent) {
        return;
      }
      event.preventDefault();
      const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
      const instance = Dropdown.getOrCreateInstance(getToggleButton);
      if (isUpOrDownEvent) {
        event.stopPropagation();
        instance.show();
        instance._selectMenuItem(event);
        return;
      }
      if (instance._isShown()) {
        event.stopPropagation();
        instance.hide();
        getToggleButton.focus();
      }
    }
  };
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
    event.preventDefault();
    Dropdown.getOrCreateInstance(this).toggle();
  });
  defineJQueryPlugin(Dropdown);
  var SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
  var SELECTOR_STICKY_CONTENT = ".sticky-top";
  var PROPERTY_PADDING = "padding-right";
  var PROPERTY_MARGIN = "margin-right";
  var ScrollBarHelper = class {
    constructor() {
      this._element = document.body;
    }
    // Public
    getWidth() {
      const documentWidth = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
    hide() {
      const width = this.getWidth();
      this._disableOverFlow();
      this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
      this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
      this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue) => calculatedValue - width);
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow");
      this._resetElementAttributes(this._element, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }
    // Private
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow");
      this._element.style.overflow = "hidden";
    }
    _setElementAttributes(selector, styleProperty, callback) {
      const scrollbarWidth = this.getWidth();
      const manipulationCallBack = (element) => {
        if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
          return;
        }
        this._saveInitialAttribute(element, styleProperty);
        const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
        element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _saveInitialAttribute(element, styleProperty) {
      const actualValue = element.style.getPropertyValue(styleProperty);
      if (actualValue) {
        Manipulator.setDataAttribute(element, styleProperty, actualValue);
      }
    }
    _resetElementAttributes(selector, styleProperty) {
      const manipulationCallBack = (element) => {
        const value = Manipulator.getDataAttribute(element, styleProperty);
        if (value === null) {
          element.style.removeProperty(styleProperty);
          return;
        }
        Manipulator.removeDataAttribute(element, styleProperty);
        element.style.setProperty(styleProperty, value);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _applyManipulationCallback(selector, callBack) {
      if (isElement2(selector)) {
        callBack(selector);
        return;
      }
      for (const sel of SelectorEngine.find(selector, this._element)) {
        callBack(sel);
      }
    }
  };
  var NAME$9 = "backdrop";
  var CLASS_NAME_FADE$4 = "fade";
  var CLASS_NAME_SHOW$5 = "show";
  var EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
  var Default$8 = {
    className: "modal-backdrop",
    clickCallback: null,
    isAnimated: false,
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    rootElement: "body"
    // give the choice to place backdrop under different elements
  };
  var DefaultType$8 = {
    className: "string",
    clickCallback: "(function|null)",
    isAnimated: "boolean",
    isVisible: "boolean",
    rootElement: "(element|string)"
  };
  var Backdrop = class extends Config {
    constructor(config2) {
      super();
      this._config = this._getConfig(config2);
      this._isAppended = false;
      this._element = null;
    }
    // Getters
    static get Default() {
      return Default$8;
    }
    static get DefaultType() {
      return DefaultType$8;
    }
    static get NAME() {
      return NAME$9;
    }
    // Public
    show(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._append();
      const element = this._getElement();
      if (this._config.isAnimated) {
        reflow(element);
      }
      element.classList.add(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        execute(callback);
      });
    }
    hide(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._getElement().classList.remove(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        this.dispose();
        execute(callback);
      });
    }
    dispose() {
      if (!this._isAppended) {
        return;
      }
      EventHandler.off(this._element, EVENT_MOUSEDOWN);
      this._element.remove();
      this._isAppended = false;
    }
    // Private
    _getElement() {
      if (!this._element) {
        const backdrop = document.createElement("div");
        backdrop.className = this._config.className;
        if (this._config.isAnimated) {
          backdrop.classList.add(CLASS_NAME_FADE$4);
        }
        this._element = backdrop;
      }
      return this._element;
    }
    _configAfterMerge(config2) {
      config2.rootElement = getElement(config2.rootElement);
      return config2;
    }
    _append() {
      if (this._isAppended) {
        return;
      }
      const element = this._getElement();
      this._config.rootElement.append(element);
      EventHandler.on(element, EVENT_MOUSEDOWN, () => {
        execute(this._config.clickCallback);
      });
      this._isAppended = true;
    }
    _emulateAnimation(callback) {
      executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
    }
  };
  var NAME$8 = "focustrap";
  var DATA_KEY$5 = "bs.focustrap";
  var EVENT_KEY$5 = `.${DATA_KEY$5}`;
  var EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
  var EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
  var TAB_KEY = "Tab";
  var TAB_NAV_FORWARD = "forward";
  var TAB_NAV_BACKWARD = "backward";
  var Default$7 = {
    autofocus: true,
    trapElement: null
    // The element to trap focus inside of
  };
  var DefaultType$7 = {
    autofocus: "boolean",
    trapElement: "element"
  };
  var FocusTrap = class extends Config {
    constructor(config2) {
      super();
      this._config = this._getConfig(config2);
      this._isActive = false;
      this._lastTabNavDirection = null;
    }
    // Getters
    static get Default() {
      return Default$7;
    }
    static get DefaultType() {
      return DefaultType$7;
    }
    static get NAME() {
      return NAME$8;
    }
    // Public
    activate() {
      if (this._isActive) {
        return;
      }
      if (this._config.autofocus) {
        this._config.trapElement.focus();
      }
      EventHandler.off(document, EVENT_KEY$5);
      EventHandler.on(document, EVENT_FOCUSIN$2, (event) => this._handleFocusin(event));
      EventHandler.on(document, EVENT_KEYDOWN_TAB, (event) => this._handleKeydown(event));
      this._isActive = true;
    }
    deactivate() {
      if (!this._isActive) {
        return;
      }
      this._isActive = false;
      EventHandler.off(document, EVENT_KEY$5);
    }
    // Private
    _handleFocusin(event) {
      const {
        trapElement
      } = this._config;
      if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
        return;
      }
      const elements = SelectorEngine.focusableChildren(trapElement);
      if (elements.length === 0) {
        trapElement.focus();
      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
        elements[elements.length - 1].focus();
      } else {
        elements[0].focus();
      }
    }
    _handleKeydown(event) {
      if (event.key !== TAB_KEY) {
        return;
      }
      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
    }
  };
  var NAME$7 = "modal";
  var DATA_KEY$4 = "bs.modal";
  var EVENT_KEY$4 = `.${DATA_KEY$4}`;
  var DATA_API_KEY$2 = ".data-api";
  var ESCAPE_KEY$1 = "Escape";
  var EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
  var EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
  var EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
  var EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
  var EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
  var EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
  var EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
  var EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
  var EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
  var EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
  var CLASS_NAME_OPEN = "modal-open";
  var CLASS_NAME_FADE$3 = "fade";
  var CLASS_NAME_SHOW$4 = "show";
  var CLASS_NAME_STATIC = "modal-static";
  var OPEN_SELECTOR$1 = ".modal.show";
  var SELECTOR_DIALOG = ".modal-dialog";
  var SELECTOR_MODAL_BODY = ".modal-body";
  var SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
  var Default$6 = {
    backdrop: true,
    focus: true,
    keyboard: true
  };
  var DefaultType$6 = {
    backdrop: "(boolean|string)",
    focus: "boolean",
    keyboard: "boolean"
  };
  var Modal = class extends BaseComponent {
    constructor(element, config2) {
      super(element, config2);
      this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._isShown = false;
      this._isTransitioning = false;
      this._scrollBar = new ScrollBarHelper();
      this._addEventListeners();
    }
    // Getters
    static get Default() {
      return Default$6;
    }
    static get DefaultType() {
      return DefaultType$6;
    }
    static get NAME() {
      return NAME$7;
    }
    // Public
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown || this._isTransitioning) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
        relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._isTransitioning = true;
      this._scrollBar.hide();
      document.body.classList.add(CLASS_NAME_OPEN);
      this._adjustDialog();
      this._backdrop.show(() => this._showElement(relatedTarget));
    }
    hide() {
      if (!this._isShown || this._isTransitioning) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._isShown = false;
      this._isTransitioning = true;
      this._focustrap.deactivate();
      this._element.classList.remove(CLASS_NAME_SHOW$4);
      this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
    }
    dispose() {
      for (const htmlElement of [window, this._dialog]) {
        EventHandler.off(htmlElement, EVENT_KEY$4);
      }
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }
    // Private
    _initializeBackDrop() {
      return new Backdrop({
        isVisible: Boolean(this._config.backdrop),
        // 'static' option will be translated to true, and booleans will keep their value,
        isAnimated: this._isAnimated()
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
    _showElement(relatedTarget) {
      if (!document.body.contains(this._element)) {
        document.body.append(this._element);
      }
      this._element.style.display = "block";
      this._element.removeAttribute("aria-hidden");
      this._element.setAttribute("aria-modal", true);
      this._element.setAttribute("role", "dialog");
      this._element.scrollTop = 0;
      const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
      if (modalBody) {
        modalBody.scrollTop = 0;
      }
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW$4);
      const transitionComplete = () => {
        if (this._config.focus) {
          this._focustrap.activate();
        }
        this._isTransitioning = false;
        EventHandler.trigger(this._element, EVENT_SHOWN$4, {
          relatedTarget
        });
      };
      this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
    }
    _addEventListeners() {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event) => {
        if (event.key !== ESCAPE_KEY$1) {
          return;
        }
        if (this._config.keyboard) {
          event.preventDefault();
          this.hide();
          return;
        }
        this._triggerBackdropTransition();
      });
      EventHandler.on(window, EVENT_RESIZE$1, () => {
        if (this._isShown && !this._isTransitioning) {
          this._adjustDialog();
        }
      });
      EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event) => {
        EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2) => {
          if (this._element !== event.target || this._element !== event2.target) {
            return;
          }
          if (this._config.backdrop === "static") {
            this._triggerBackdropTransition();
            return;
          }
          if (this._config.backdrop) {
            this.hide();
          }
        });
      });
    }
    _hideModal() {
      this._element.style.display = "none";
      this._element.setAttribute("aria-hidden", true);
      this._element.removeAttribute("aria-modal");
      this._element.removeAttribute("role");
      this._isTransitioning = false;
      this._backdrop.hide(() => {
        document.body.classList.remove(CLASS_NAME_OPEN);
        this._resetAdjustments();
        this._scrollBar.reset();
        EventHandler.trigger(this._element, EVENT_HIDDEN$4);
      });
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_FADE$3);
    }
    _triggerBackdropTransition() {
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      const initialOverflowY = this._element.style.overflowY;
      if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC)) {
        return;
      }
      if (!isModalOverflowing) {
        this._element.style.overflowY = "hidden";
      }
      this._element.classList.add(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        this._element.classList.remove(CLASS_NAME_STATIC);
        this._queueCallback(() => {
          this._element.style.overflowY = initialOverflowY;
        }, this._dialog);
      }, this._dialog);
      this._element.focus();
    }
    /**
     * The following methods are used to handle overflowing modals
     */
    _adjustDialog() {
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      const scrollbarWidth = this._scrollBar.getWidth();
      const isBodyOverflowing = scrollbarWidth > 0;
      if (isBodyOverflowing && !isModalOverflowing) {
        const property = isRTL() ? "paddingLeft" : "paddingRight";
        this._element.style[property] = `${scrollbarWidth}px`;
      }
      if (!isBodyOverflowing && isModalOverflowing) {
        const property = isRTL() ? "paddingRight" : "paddingLeft";
        this._element.style[property] = `${scrollbarWidth}px`;
      }
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = "";
      this._element.style.paddingRight = "";
    }
    // Static
    static jQueryInterface(config2, relatedTarget) {
      return this.each(function() {
        const data = Modal.getOrCreateInstance(this, config2);
        if (typeof config2 !== "string") {
          return;
        }
        if (typeof data[config2] === "undefined") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2](relatedTarget);
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
    const target = getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    EventHandler.one(target, EVENT_SHOW$4, (showEvent) => {
      if (showEvent.defaultPrevented) {
        return;
      }
      EventHandler.one(target, EVENT_HIDDEN$4, () => {
        if (isVisible(this)) {
          this.focus();
        }
      });
    });
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
    if (alreadyOpen) {
      Modal.getInstance(alreadyOpen).hide();
    }
    const data = Modal.getOrCreateInstance(target);
    data.toggle(this);
  });
  enableDismissTrigger(Modal);
  defineJQueryPlugin(Modal);
  var NAME$6 = "offcanvas";
  var DATA_KEY$3 = "bs.offcanvas";
  var EVENT_KEY$3 = `.${DATA_KEY$3}`;
  var DATA_API_KEY$1 = ".data-api";
  var EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
  var ESCAPE_KEY = "Escape";
  var CLASS_NAME_SHOW$3 = "show";
  var CLASS_NAME_SHOWING$1 = "showing";
  var CLASS_NAME_HIDING = "hiding";
  var CLASS_NAME_BACKDROP = "offcanvas-backdrop";
  var OPEN_SELECTOR = ".offcanvas.show";
  var EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
  var EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
  var EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
  var EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
  var EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
  var EVENT_RESIZE = `resize${EVENT_KEY$3}`;
  var EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
  var EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
  var SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
  var Default$5 = {
    backdrop: true,
    keyboard: true,
    scroll: false
  };
  var DefaultType$5 = {
    backdrop: "(boolean|string)",
    keyboard: "boolean",
    scroll: "boolean"
  };
  var Offcanvas = class extends BaseComponent {
    constructor(element, config2) {
      super(element, config2);
      this._isShown = false;
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._addEventListeners();
    }
    // Getters
    static get Default() {
      return Default$5;
    }
    static get DefaultType() {
      return DefaultType$5;
    }
    static get NAME() {
      return NAME$6;
    }
    // Public
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
        relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._backdrop.show();
      if (!this._config.scroll) {
        new ScrollBarHelper().hide();
      }
      this._element.setAttribute("aria-modal", true);
      this._element.setAttribute("role", "dialog");
      this._element.classList.add(CLASS_NAME_SHOWING$1);
      const completeCallBack = () => {
        if (!this._config.scroll || this._config.backdrop) {
          this._focustrap.activate();
        }
        this._element.classList.add(CLASS_NAME_SHOW$3);
        this._element.classList.remove(CLASS_NAME_SHOWING$1);
        EventHandler.trigger(this._element, EVENT_SHOWN$3, {
          relatedTarget
        });
      };
      this._queueCallback(completeCallBack, this._element, true);
    }
    hide() {
      if (!this._isShown) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._focustrap.deactivate();
      this._element.blur();
      this._isShown = false;
      this._element.classList.add(CLASS_NAME_HIDING);
      this._backdrop.hide();
      const completeCallback = () => {
        this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
        this._element.removeAttribute("aria-modal");
        this._element.removeAttribute("role");
        if (!this._config.scroll) {
          new ScrollBarHelper().reset();
        }
        EventHandler.trigger(this._element, EVENT_HIDDEN$3);
      };
      this._queueCallback(completeCallback, this._element, true);
    }
    dispose() {
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    // Private
    _initializeBackDrop() {
      const clickCallback = () => {
        if (this._config.backdrop === "static") {
          EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
          return;
        }
        this.hide();
      };
      const isVisible2 = Boolean(this._config.backdrop);
      return new Backdrop({
        className: CLASS_NAME_BACKDROP,
        isVisible: isVisible2,
        isAnimated: true,
        rootElement: this._element.parentNode,
        clickCallback: isVisible2 ? clickCallback : null
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
    _addEventListeners() {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {
        if (event.key !== ESCAPE_KEY) {
          return;
        }
        if (!this._config.keyboard) {
          EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
          return;
        }
        this.hide();
      });
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = Offcanvas.getOrCreateInstance(this, config2);
        if (typeof config2 !== "string") {
          return;
        }
        if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2](this);
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
    const target = getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    EventHandler.one(target, EVENT_HIDDEN$3, () => {
      if (isVisible(this)) {
        this.focus();
      }
    });
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
    if (alreadyOpen && alreadyOpen !== target) {
      Offcanvas.getInstance(alreadyOpen).hide();
    }
    const data = Offcanvas.getOrCreateInstance(target);
    data.toggle(this);
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
    for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
      Offcanvas.getOrCreateInstance(selector).show();
    }
  });
  EventHandler.on(window, EVENT_RESIZE, () => {
    for (const element of SelectorEngine.find("[aria-modal][class*=show][class*=offcanvas-]")) {
      if (getComputedStyle(element).position !== "fixed") {
        Offcanvas.getOrCreateInstance(element).hide();
      }
    }
  });
  enableDismissTrigger(Offcanvas);
  defineJQueryPlugin(Offcanvas);
  var uriAttributes = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
  var allowedAttribute = (attribute, allowedAttributeList) => {
    const attributeName = attribute.nodeName.toLowerCase();
    if (allowedAttributeList.includes(attributeName)) {
      if (uriAttributes.has(attributeName)) {
        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));
      }
      return true;
    }
    return allowedAttributeList.filter((attributeRegex) => attributeRegex instanceof RegExp).some((regex) => regex.test(attributeName));
  };
  var DefaultAllowlist = {
    // Global attributes allowed on any supplied element below.
    "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
    a: ["target", "href", "title", "rel"],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ["src", "srcset", "alt", "title", "width", "height"],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  };
  function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
    if (!unsafeHtml.length) {
      return unsafeHtml;
    }
    if (sanitizeFunction && typeof sanitizeFunction === "function") {
      return sanitizeFunction(unsafeHtml);
    }
    const domParser = new window.DOMParser();
    const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
    const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
    for (const element of elements) {
      const elementName = element.nodeName.toLowerCase();
      if (!Object.keys(allowList).includes(elementName)) {
        element.remove();
        continue;
      }
      const attributeList = [].concat(...element.attributes);
      const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
      for (const attribute of attributeList) {
        if (!allowedAttribute(attribute, allowedAttributes)) {
          element.removeAttribute(attribute.nodeName);
        }
      }
    }
    return createdDocument.body.innerHTML;
  }
  var NAME$5 = "TemplateFactory";
  var Default$4 = {
    allowList: DefaultAllowlist,
    content: {},
    // { selector : text ,  selector2 : text2 , }
    extraClass: "",
    html: false,
    sanitize: true,
    sanitizeFn: null,
    template: "<div></div>"
  };
  var DefaultType$4 = {
    allowList: "object",
    content: "object",
    extraClass: "(string|function)",
    html: "boolean",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    template: "string"
  };
  var DefaultContentType = {
    entry: "(string|element|function|null)",
    selector: "(string|element)"
  };
  var TemplateFactory = class extends Config {
    constructor(config2) {
      super();
      this._config = this._getConfig(config2);
    }
    // Getters
    static get Default() {
      return Default$4;
    }
    static get DefaultType() {
      return DefaultType$4;
    }
    static get NAME() {
      return NAME$5;
    }
    // Public
    getContent() {
      return Object.values(this._config.content).map((config2) => this._resolvePossibleFunction(config2)).filter(Boolean);
    }
    hasContent() {
      return this.getContent().length > 0;
    }
    changeContent(content) {
      this._checkContent(content);
      this._config.content = {
        ...this._config.content,
        ...content
      };
      return this;
    }
    toHtml() {
      const templateWrapper = document.createElement("div");
      templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
      for (const [selector, text] of Object.entries(this._config.content)) {
        this._setContent(templateWrapper, text, selector);
      }
      const template = templateWrapper.children[0];
      const extraClass = this._resolvePossibleFunction(this._config.extraClass);
      if (extraClass) {
        template.classList.add(...extraClass.split(" "));
      }
      return template;
    }
    // Private
    _typeCheckConfig(config2) {
      super._typeCheckConfig(config2);
      this._checkContent(config2.content);
    }
    _checkContent(arg) {
      for (const [selector, content] of Object.entries(arg)) {
        super._typeCheckConfig({
          selector,
          entry: content
        }, DefaultContentType);
      }
    }
    _setContent(template, content, selector) {
      const templateElement = SelectorEngine.findOne(selector, template);
      if (!templateElement) {
        return;
      }
      content = this._resolvePossibleFunction(content);
      if (!content) {
        templateElement.remove();
        return;
      }
      if (isElement2(content)) {
        this._putElementInTemplate(getElement(content), templateElement);
        return;
      }
      if (this._config.html) {
        templateElement.innerHTML = this._maybeSanitize(content);
        return;
      }
      templateElement.textContent = content;
    }
    _maybeSanitize(arg) {
      return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
    }
    _resolvePossibleFunction(arg) {
      return typeof arg === "function" ? arg(this) : arg;
    }
    _putElementInTemplate(element, templateElement) {
      if (this._config.html) {
        templateElement.innerHTML = "";
        templateElement.append(element);
        return;
      }
      templateElement.textContent = element.textContent;
    }
  };
  var NAME$4 = "tooltip";
  var DISALLOWED_ATTRIBUTES = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]);
  var CLASS_NAME_FADE$2 = "fade";
  var CLASS_NAME_MODAL = "modal";
  var CLASS_NAME_SHOW$2 = "show";
  var SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
  var SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
  var EVENT_MODAL_HIDE = "hide.bs.modal";
  var TRIGGER_HOVER = "hover";
  var TRIGGER_FOCUS = "focus";
  var TRIGGER_CLICK = "click";
  var TRIGGER_MANUAL = "manual";
  var EVENT_HIDE$2 = "hide";
  var EVENT_HIDDEN$2 = "hidden";
  var EVENT_SHOW$2 = "show";
  var EVENT_SHOWN$2 = "shown";
  var EVENT_INSERTED = "inserted";
  var EVENT_CLICK$1 = "click";
  var EVENT_FOCUSIN$1 = "focusin";
  var EVENT_FOCUSOUT$1 = "focusout";
  var EVENT_MOUSEENTER = "mouseenter";
  var EVENT_MOUSELEAVE = "mouseleave";
  var AttachmentMap = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: isRTL() ? "left" : "right",
    BOTTOM: "bottom",
    LEFT: isRTL() ? "right" : "left"
  };
  var Default$3 = {
    allowList: DefaultAllowlist,
    animation: true,
    boundary: "clippingParents",
    container: false,
    customClass: "",
    delay: 0,
    fallbackPlacements: ["top", "right", "bottom", "left"],
    html: false,
    offset: [0, 0],
    placement: "top",
    popperConfig: null,
    sanitize: true,
    sanitizeFn: null,
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    title: "",
    trigger: "hover focus"
  };
  var DefaultType$3 = {
    allowList: "object",
    animation: "boolean",
    boundary: "(string|element)",
    container: "(string|element|boolean)",
    customClass: "(string|function)",
    delay: "(number|object)",
    fallbackPlacements: "array",
    html: "boolean",
    offset: "(array|string|function)",
    placement: "(string|function)",
    popperConfig: "(null|object|function)",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    selector: "(string|boolean)",
    template: "string",
    title: "(string|element|function)",
    trigger: "string"
  };
  var Tooltip = class extends BaseComponent {
    constructor(element, config2) {
      if (typeof lib_exports === "undefined") {
        throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
      }
      super(element, config2);
      this._isEnabled = true;
      this._timeout = 0;
      this._isHovered = null;
      this._activeTrigger = {};
      this._popper = null;
      this._templateFactory = null;
      this._newContent = null;
      this.tip = null;
      this._setListeners();
      if (!this._config.selector) {
        this._fixTitle();
      }
    }
    // Getters
    static get Default() {
      return Default$3;
    }
    static get DefaultType() {
      return DefaultType$3;
    }
    static get NAME() {
      return NAME$4;
    }
    // Public
    enable() {
      this._isEnabled = true;
    }
    disable() {
      this._isEnabled = false;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle() {
      if (!this._isEnabled) {
        return;
      }
      this._activeTrigger.click = !this._activeTrigger.click;
      if (this._isShown()) {
        this._leave();
        return;
      }
      this._enter();
    }
    dispose() {
      clearTimeout(this._timeout);
      EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
      if (this._element.getAttribute("data-bs-original-title")) {
        this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title"));
      }
      this._disposePopper();
      super.dispose();
    }
    show() {
      if (this._element.style.display === "none") {
        throw new Error("Please use show on visible elements");
      }
      if (!(this._isWithContent() && this._isEnabled)) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
      const shadowRoot = findShadowRoot(this._element);
      const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
      if (showEvent.defaultPrevented || !isInTheDom) {
        return;
      }
      this._disposePopper();
      const tip = this._getTipElement();
      this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
      const {
        container
      } = this._config;
      if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
        container.append(tip);
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
      }
      this._popper = this._createPopper(tip);
      tip.classList.add(CLASS_NAME_SHOW$2);
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.on(element, "mouseover", noop);
        }
      }
      const complete = () => {
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
        if (this._isHovered === false) {
          this._leave();
        }
        this._isHovered = false;
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
    hide() {
      if (!this._isShown()) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
      if (hideEvent.defaultPrevented) {
        return;
      }
      const tip = this._getTipElement();
      tip.classList.remove(CLASS_NAME_SHOW$2);
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.off(element, "mouseover", noop);
        }
      }
      this._activeTrigger[TRIGGER_CLICK] = false;
      this._activeTrigger[TRIGGER_FOCUS] = false;
      this._activeTrigger[TRIGGER_HOVER] = false;
      this._isHovered = null;
      const complete = () => {
        if (this._isWithActiveTrigger()) {
          return;
        }
        if (!this._isHovered) {
          this._disposePopper();
        }
        this._element.removeAttribute("aria-describedby");
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
    update() {
      if (this._popper) {
        this._popper.update();
      }
    }
    // Protected
    _isWithContent() {
      return Boolean(this._getTitle());
    }
    _getTipElement() {
      if (!this.tip) {
        this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
      }
      return this.tip;
    }
    _createTipElement(content) {
      const tip = this._getTemplateFactory(content).toHtml();
      if (!tip) {
        return null;
      }
      tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
      tip.classList.add(`bs-${this.constructor.NAME}-auto`);
      const tipId = getUID(this.constructor.NAME).toString();
      tip.setAttribute("id", tipId);
      if (this._isAnimated()) {
        tip.classList.add(CLASS_NAME_FADE$2);
      }
      return tip;
    }
    setContent(content) {
      this._newContent = content;
      if (this._isShown()) {
        this._disposePopper();
        this.show();
      }
    }
    _getTemplateFactory(content) {
      if (this._templateFactory) {
        this._templateFactory.changeContent(content);
      } else {
        this._templateFactory = new TemplateFactory({
          ...this._config,
          // the `content` var has to be after `this._config`
          // to override config.content in case of popover
          content,
          extraClass: this._resolvePossibleFunction(this._config.customClass)
        });
      }
      return this._templateFactory;
    }
    _getContentForTemplate() {
      return {
        [SELECTOR_TOOLTIP_INNER]: this._getTitle()
      };
    }
    _getTitle() {
      return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
    }
    // Private
    _initializeOnDelegatedTarget(event) {
      return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
    }
    _isAnimated() {
      return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
    }
    _isShown() {
      return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
    }
    _createPopper(tip) {
      const placement = typeof this._config.placement === "function" ? this._config.placement.call(this, tip, this._element) : this._config.placement;
      const attachment = AttachmentMap[placement.toUpperCase()];
      return createPopper3(this._element, tip, this._getPopperConfig(attachment));
    }
    _getOffset() {
      const {
        offset: offset2
      } = this._config;
      if (typeof offset2 === "string") {
        return offset2.split(",").map((value) => Number.parseInt(value, 10));
      }
      if (typeof offset2 === "function") {
        return (popperData) => offset2(popperData, this._element);
      }
      return offset2;
    }
    _resolvePossibleFunction(arg) {
      return typeof arg === "function" ? arg.call(this._element) : arg;
    }
    _getPopperConfig(attachment) {
      const defaultBsPopperConfig = {
        placement: attachment,
        modifiers: [{
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }, {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        }, {
          name: "preSetPlacement",
          enabled: true,
          phase: "beforeMain",
          fn: (data) => {
            this._getTipElement().setAttribute("data-popper-placement", data.state.placement);
          }
        }]
      };
      return {
        ...defaultBsPopperConfig,
        ...typeof this._config.popperConfig === "function" ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig
      };
    }
    _setListeners() {
      const triggers = this._config.trigger.split(" ");
      for (const trigger of triggers) {
        if (trigger === "click") {
          EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event) => {
            const context = this._initializeOnDelegatedTarget(event);
            context.toggle();
          });
        } else if (trigger !== TRIGGER_MANUAL) {
          const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
          const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
          EventHandler.on(this._element, eventIn, this._config.selector, (event) => {
            const context = this._initializeOnDelegatedTarget(event);
            context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
            context._enter();
          });
          EventHandler.on(this._element, eventOut, this._config.selector, (event) => {
            const context = this._initializeOnDelegatedTarget(event);
            context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
            context._leave();
          });
        }
      }
      this._hideModalHandler = () => {
        if (this._element) {
          this.hide();
        }
      };
      EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    }
    _fixTitle() {
      const title = this._element.getAttribute("title");
      if (!title) {
        return;
      }
      if (!this._element.getAttribute("aria-label") && !this._element.textContent.trim()) {
        this._element.setAttribute("aria-label", title);
      }
      this._element.setAttribute("data-bs-original-title", title);
      this._element.removeAttribute("title");
    }
    _enter() {
      if (this._isShown() || this._isHovered) {
        this._isHovered = true;
        return;
      }
      this._isHovered = true;
      this._setTimeout(() => {
        if (this._isHovered) {
          this.show();
        }
      }, this._config.delay.show);
    }
    _leave() {
      if (this._isWithActiveTrigger()) {
        return;
      }
      this._isHovered = false;
      this._setTimeout(() => {
        if (!this._isHovered) {
          this.hide();
        }
      }, this._config.delay.hide);
    }
    _setTimeout(handler, timeout) {
      clearTimeout(this._timeout);
      this._timeout = setTimeout(handler, timeout);
    }
    _isWithActiveTrigger() {
      return Object.values(this._activeTrigger).includes(true);
    }
    _getConfig(config2) {
      const dataAttributes = Manipulator.getDataAttributes(this._element);
      for (const dataAttribute of Object.keys(dataAttributes)) {
        if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
          delete dataAttributes[dataAttribute];
        }
      }
      config2 = {
        ...dataAttributes,
        ...typeof config2 === "object" && config2 ? config2 : {}
      };
      config2 = this._mergeConfigObj(config2);
      config2 = this._configAfterMerge(config2);
      this._typeCheckConfig(config2);
      return config2;
    }
    _configAfterMerge(config2) {
      config2.container = config2.container === false ? document.body : getElement(config2.container);
      if (typeof config2.delay === "number") {
        config2.delay = {
          show: config2.delay,
          hide: config2.delay
        };
      }
      if (typeof config2.title === "number") {
        config2.title = config2.title.toString();
      }
      if (typeof config2.content === "number") {
        config2.content = config2.content.toString();
      }
      return config2;
    }
    _getDelegateConfig() {
      const config2 = {};
      for (const key in this._config) {
        if (this.constructor.Default[key] !== this._config[key]) {
          config2[key] = this._config[key];
        }
      }
      config2.selector = false;
      config2.trigger = "manual";
      return config2;
    }
    _disposePopper() {
      if (this._popper) {
        this._popper.destroy();
        this._popper = null;
      }
      if (this.tip) {
        this.tip.remove();
        this.tip = null;
      }
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = Tooltip.getOrCreateInstance(this, config2);
        if (typeof config2 !== "string") {
          return;
        }
        if (typeof data[config2] === "undefined") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2]();
      });
    }
  };
  defineJQueryPlugin(Tooltip);
  var NAME$3 = "popover";
  var SELECTOR_TITLE = ".popover-header";
  var SELECTOR_CONTENT = ".popover-body";
  var Default$2 = {
    ...Tooltip.Default,
    content: "",
    offset: [0, 8],
    placement: "right",
    template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
    trigger: "click"
  };
  var DefaultType$2 = {
    ...Tooltip.DefaultType,
    content: "(null|string|element|function)"
  };
  var Popover = class extends Tooltip {
    // Getters
    static get Default() {
      return Default$2;
    }
    static get DefaultType() {
      return DefaultType$2;
    }
    static get NAME() {
      return NAME$3;
    }
    // Overrides
    _isWithContent() {
      return this._getTitle() || this._getContent();
    }
    // Private
    _getContentForTemplate() {
      return {
        [SELECTOR_TITLE]: this._getTitle(),
        [SELECTOR_CONTENT]: this._getContent()
      };
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = Popover.getOrCreateInstance(this, config2);
        if (typeof config2 !== "string") {
          return;
        }
        if (typeof data[config2] === "undefined") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2]();
      });
    }
  };
  defineJQueryPlugin(Popover);
  var NAME$2 = "scrollspy";
  var DATA_KEY$2 = "bs.scrollspy";
  var EVENT_KEY$2 = `.${DATA_KEY$2}`;
  var DATA_API_KEY = ".data-api";
  var EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
  var EVENT_CLICK = `click${EVENT_KEY$2}`;
  var EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
  var CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
  var CLASS_NAME_ACTIVE$1 = "active";
  var SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
  var SELECTOR_TARGET_LINKS = "[href]";
  var SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
  var SELECTOR_NAV_LINKS = ".nav-link";
  var SELECTOR_NAV_ITEMS = ".nav-item";
  var SELECTOR_LIST_ITEMS = ".list-group-item";
  var SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
  var SELECTOR_DROPDOWN = ".dropdown";
  var SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
  var Default$1 = {
    offset: null,
    // TODO: v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: "0px 0px -25%",
    smoothScroll: false,
    target: null,
    threshold: [0.1, 0.5, 1]
  };
  var DefaultType$1 = {
    offset: "(number|null)",
    // TODO v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: "string",
    smoothScroll: "boolean",
    target: "element",
    threshold: "array"
  };
  var ScrollSpy = class extends BaseComponent {
    constructor(element, config2) {
      super(element, config2);
      this._targetLinks = /* @__PURE__ */ new Map();
      this._observableSections = /* @__PURE__ */ new Map();
      this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element;
      this._activeTarget = null;
      this._observer = null;
      this._previousScrollData = {
        visibleEntryTop: 0,
        parentScrollTop: 0
      };
      this.refresh();
    }
    // Getters
    static get Default() {
      return Default$1;
    }
    static get DefaultType() {
      return DefaultType$1;
    }
    static get NAME() {
      return NAME$2;
    }
    // Public
    refresh() {
      this._initializeTargetsAndObservables();
      this._maybeEnableSmoothScroll();
      if (this._observer) {
        this._observer.disconnect();
      } else {
        this._observer = this._getNewObserver();
      }
      for (const section of this._observableSections.values()) {
        this._observer.observe(section);
      }
    }
    dispose() {
      this._observer.disconnect();
      super.dispose();
    }
    // Private
    _configAfterMerge(config2) {
      config2.target = getElement(config2.target) || document.body;
      config2.rootMargin = config2.offset ? `${config2.offset}px 0px -30%` : config2.rootMargin;
      if (typeof config2.threshold === "string") {
        config2.threshold = config2.threshold.split(",").map((value) => Number.parseFloat(value));
      }
      return config2;
    }
    _maybeEnableSmoothScroll() {
      if (!this._config.smoothScroll) {
        return;
      }
      EventHandler.off(this._config.target, EVENT_CLICK);
      EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event) => {
        const observableSection = this._observableSections.get(event.target.hash);
        if (observableSection) {
          event.preventDefault();
          const root = this._rootElement || window;
          const height = observableSection.offsetTop - this._element.offsetTop;
          if (root.scrollTo) {
            root.scrollTo({
              top: height,
              behavior: "smooth"
            });
            return;
          }
          root.scrollTop = height;
        }
      });
    }
    _getNewObserver() {
      const options2 = {
        root: this._rootElement,
        threshold: this._config.threshold,
        rootMargin: this._config.rootMargin
      };
      return new IntersectionObserver((entries) => this._observerCallback(entries), options2);
    }
    // The logic of selection
    _observerCallback(entries) {
      const targetElement = (entry) => this._targetLinks.get(`#${entry.target.id}`);
      const activate = (entry) => {
        this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
        this._process(targetElement(entry));
      };
      const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
      const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
      this._previousScrollData.parentScrollTop = parentScrollTop;
      for (const entry of entries) {
        if (!entry.isIntersecting) {
          this._activeTarget = null;
          this._clearActiveClass(targetElement(entry));
          continue;
        }
        const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
        if (userScrollsDown && entryIsLowerThanPrevious) {
          activate(entry);
          if (!parentScrollTop) {
            return;
          }
          continue;
        }
        if (!userScrollsDown && !entryIsLowerThanPrevious) {
          activate(entry);
        }
      }
    }
    _initializeTargetsAndObservables() {
      this._targetLinks = /* @__PURE__ */ new Map();
      this._observableSections = /* @__PURE__ */ new Map();
      const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
      for (const anchor of targetLinks) {
        if (!anchor.hash || isDisabled(anchor)) {
          continue;
        }
        const observableSection = SelectorEngine.findOne(anchor.hash, this._element);
        if (isVisible(observableSection)) {
          this._targetLinks.set(anchor.hash, anchor);
          this._observableSections.set(anchor.hash, observableSection);
        }
      }
    }
    _process(target) {
      if (this._activeTarget === target) {
        return;
      }
      this._clearActiveClass(this._config.target);
      this._activeTarget = target;
      target.classList.add(CLASS_NAME_ACTIVE$1);
      this._activateParents(target);
      EventHandler.trigger(this._element, EVENT_ACTIVATE, {
        relatedTarget: target
      });
    }
    _activateParents(target) {
      if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
        SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
        return;
      }
      for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
        for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
          item.classList.add(CLASS_NAME_ACTIVE$1);
        }
      }
    }
    _clearActiveClass(parent) {
      parent.classList.remove(CLASS_NAME_ACTIVE$1);
      const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
      for (const node of activeNodes) {
        node.classList.remove(CLASS_NAME_ACTIVE$1);
      }
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = ScrollSpy.getOrCreateInstance(this, config2);
        if (typeof config2 !== "string") {
          return;
        }
        if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2]();
      });
    }
  };
  EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
    for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
      ScrollSpy.getOrCreateInstance(spy);
    }
  });
  defineJQueryPlugin(ScrollSpy);
  var NAME$1 = "tab";
  var DATA_KEY$1 = "bs.tab";
  var EVENT_KEY$1 = `.${DATA_KEY$1}`;
  var EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
  var EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
  var EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
  var EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
  var EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
  var EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
  var EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
  var ARROW_LEFT_KEY = "ArrowLeft";
  var ARROW_RIGHT_KEY = "ArrowRight";
  var ARROW_UP_KEY = "ArrowUp";
  var ARROW_DOWN_KEY = "ArrowDown";
  var CLASS_NAME_ACTIVE = "active";
  var CLASS_NAME_FADE$1 = "fade";
  var CLASS_NAME_SHOW$1 = "show";
  var CLASS_DROPDOWN = "dropdown";
  var SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
  var SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
  var NOT_SELECTOR_DROPDOWN_TOGGLE = ":not(.dropdown-toggle)";
  var SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
  var SELECTOR_OUTER = ".nav-item, .list-group-item";
  var SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
  var SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
  var SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
  var Tab = class extends BaseComponent {
    constructor(element) {
      super(element);
      this._parent = this._element.closest(SELECTOR_TAB_PANEL);
      if (!this._parent) {
        return;
      }
      this._setInitialAttributes(this._parent, this._getChildren());
      EventHandler.on(this._element, EVENT_KEYDOWN, (event) => this._keydown(event));
    }
    // Getters
    static get NAME() {
      return NAME$1;
    }
    // Public
    show() {
      const innerElem = this._element;
      if (this._elemIsActive(innerElem)) {
        return;
      }
      const active = this._getActiveElem();
      const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
        relatedTarget: innerElem
      }) : null;
      const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
        relatedTarget: active
      });
      if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
        return;
      }
      this._deactivate(active, innerElem);
      this._activate(innerElem, active);
    }
    // Private
    _activate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.add(CLASS_NAME_ACTIVE);
      this._activate(getElementFromSelector(element));
      const complete = () => {
        if (element.getAttribute("role") !== "tab") {
          element.classList.add(CLASS_NAME_SHOW$1);
          return;
        }
        element.removeAttribute("tabindex");
        element.setAttribute("aria-selected", true);
        this._toggleDropDown(element, true);
        EventHandler.trigger(element, EVENT_SHOWN$1, {
          relatedTarget: relatedElem
        });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _deactivate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.remove(CLASS_NAME_ACTIVE);
      element.blur();
      this._deactivate(getElementFromSelector(element));
      const complete = () => {
        if (element.getAttribute("role") !== "tab") {
          element.classList.remove(CLASS_NAME_SHOW$1);
          return;
        }
        element.setAttribute("aria-selected", false);
        element.setAttribute("tabindex", "-1");
        this._toggleDropDown(element, false);
        EventHandler.trigger(element, EVENT_HIDDEN$1, {
          relatedTarget: relatedElem
        });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _keydown(event) {
      if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY].includes(event.key)) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
      const nextActiveElement = getNextActiveElement(this._getChildren().filter((element) => !isDisabled(element)), event.target, isNext, true);
      if (nextActiveElement) {
        nextActiveElement.focus({
          preventScroll: true
        });
        Tab.getOrCreateInstance(nextActiveElement).show();
      }
    }
    _getChildren() {
      return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
    }
    _getActiveElem() {
      return this._getChildren().find((child) => this._elemIsActive(child)) || null;
    }
    _setInitialAttributes(parent, children) {
      this._setAttributeIfNotExists(parent, "role", "tablist");
      for (const child of children) {
        this._setInitialAttributesOnChild(child);
      }
    }
    _setInitialAttributesOnChild(child) {
      child = this._getInnerElement(child);
      const isActive = this._elemIsActive(child);
      const outerElem = this._getOuterElement(child);
      child.setAttribute("aria-selected", isActive);
      if (outerElem !== child) {
        this._setAttributeIfNotExists(outerElem, "role", "presentation");
      }
      if (!isActive) {
        child.setAttribute("tabindex", "-1");
      }
      this._setAttributeIfNotExists(child, "role", "tab");
      this._setInitialAttributesOnTargetPanel(child);
    }
    _setInitialAttributesOnTargetPanel(child) {
      const target = getElementFromSelector(child);
      if (!target) {
        return;
      }
      this._setAttributeIfNotExists(target, "role", "tabpanel");
      if (child.id) {
        this._setAttributeIfNotExists(target, "aria-labelledby", `#${child.id}`);
      }
    }
    _toggleDropDown(element, open) {
      const outerElem = this._getOuterElement(element);
      if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
        return;
      }
      const toggle = (selector, className) => {
        const element2 = SelectorEngine.findOne(selector, outerElem);
        if (element2) {
          element2.classList.toggle(className, open);
        }
      };
      toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
      toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
      outerElem.setAttribute("aria-expanded", open);
    }
    _setAttributeIfNotExists(element, attribute, value) {
      if (!element.hasAttribute(attribute)) {
        element.setAttribute(attribute, value);
      }
    }
    _elemIsActive(elem) {
      return elem.classList.contains(CLASS_NAME_ACTIVE);
    }
    // Try to get the inner element (usually the .nav-link)
    _getInnerElement(elem) {
      return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
    }
    // Try to get the outer element (usually the .nav-item)
    _getOuterElement(elem) {
      return elem.closest(SELECTOR_OUTER) || elem;
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = Tab.getOrCreateInstance(this);
        if (typeof config2 !== "string") {
          return;
        }
        if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2]();
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    Tab.getOrCreateInstance(this).show();
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
    for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
      Tab.getOrCreateInstance(element);
    }
  });
  defineJQueryPlugin(Tab);
  var NAME = "toast";
  var DATA_KEY = "bs.toast";
  var EVENT_KEY = `.${DATA_KEY}`;
  var EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
  var EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
  var EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
  var EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
  var EVENT_HIDE = `hide${EVENT_KEY}`;
  var EVENT_HIDDEN = `hidden${EVENT_KEY}`;
  var EVENT_SHOW = `show${EVENT_KEY}`;
  var EVENT_SHOWN = `shown${EVENT_KEY}`;
  var CLASS_NAME_FADE = "fade";
  var CLASS_NAME_HIDE = "hide";
  var CLASS_NAME_SHOW = "show";
  var CLASS_NAME_SHOWING = "showing";
  var DefaultType = {
    animation: "boolean",
    autohide: "boolean",
    delay: "number"
  };
  var Default = {
    animation: true,
    autohide: true,
    delay: 5e3
  };
  var Toast = class extends BaseComponent {
    constructor(element, config2) {
      super(element, config2);
      this._timeout = null;
      this._hasMouseInteraction = false;
      this._hasKeyboardInteraction = false;
      this._setListeners();
    }
    // Getters
    static get Default() {
      return Default;
    }
    static get DefaultType() {
      return DefaultType;
    }
    static get NAME() {
      return NAME;
    }
    // Public
    show() {
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._clearTimeout();
      if (this._config.animation) {
        this._element.classList.add(CLASS_NAME_FADE);
      }
      const complete = () => {
        this._element.classList.remove(CLASS_NAME_SHOWING);
        EventHandler.trigger(this._element, EVENT_SHOWN);
        this._maybeScheduleHide();
      };
      this._element.classList.remove(CLASS_NAME_HIDE);
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    hide() {
      if (!this.isShown()) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const complete = () => {
        this._element.classList.add(CLASS_NAME_HIDE);
        this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
        EventHandler.trigger(this._element, EVENT_HIDDEN);
      };
      this._element.classList.add(CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    dispose() {
      this._clearTimeout();
      if (this.isShown()) {
        this._element.classList.remove(CLASS_NAME_SHOW);
      }
      super.dispose();
    }
    isShown() {
      return this._element.classList.contains(CLASS_NAME_SHOW);
    }
    // Private
    _maybeScheduleHide() {
      if (!this._config.autohide) {
        return;
      }
      if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
        return;
      }
      this._timeout = setTimeout(() => {
        this.hide();
      }, this._config.delay);
    }
    _onInteraction(event, isInteracting) {
      switch (event.type) {
        case "mouseover":
        case "mouseout": {
          this._hasMouseInteraction = isInteracting;
          break;
        }
        case "focusin":
        case "focusout": {
          this._hasKeyboardInteraction = isInteracting;
          break;
        }
      }
      if (isInteracting) {
        this._clearTimeout();
        return;
      }
      const nextElement = event.relatedTarget;
      if (this._element === nextElement || this._element.contains(nextElement)) {
        return;
      }
      this._maybeScheduleHide();
    }
    _setListeners() {
      EventHandler.on(this._element, EVENT_MOUSEOVER, (event) => this._onInteraction(event, true));
      EventHandler.on(this._element, EVENT_MOUSEOUT, (event) => this._onInteraction(event, false));
      EventHandler.on(this._element, EVENT_FOCUSIN, (event) => this._onInteraction(event, true));
      EventHandler.on(this._element, EVENT_FOCUSOUT, (event) => this._onInteraction(event, false));
    }
    _clearTimeout() {
      clearTimeout(this._timeout);
      this._timeout = null;
    }
    // Static
    static jQueryInterface(config2) {
      return this.each(function() {
        const data = Toast.getOrCreateInstance(this, config2);
        if (typeof config2 === "string") {
          if (typeof data[config2] === "undefined") {
            throw new TypeError(`No method named "${config2}"`);
          }
          data[config2](this);
        }
      });
    }
  };
  enableDismissTrigger(Toast);
  defineJQueryPlugin(Toast);

  // app/javascript/components/index.jsx
  var import_react170 = __toESM(require_react());
  var import_react171 = __toESM(require_react());
  var import_client = __toESM(require_client());

  // app/javascript/components/App.jsx
  var import_react169 = __toESM(require_react());

  // node_modules/grommet/es6/utils/general-prop-types.js
  var import_prop_types = __toESM(require_prop_types());
  var a11yTitlePropType = import_prop_types.default.string;
  var alignPropType = import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["baseline", "center", "end", "start", "stretch"]), import_prop_types.default.string]);
  var ANIMATION_TYPE = import_prop_types.default.oneOf(["fadeIn", "fadeOut", "jiggle", "pulse", "rotateLeft", "rotateRight", "slideUp", "slideDown", "slideLeft", "slideRight", "zoomIn", "zoomOut"]);
  var ANIMATION_SHAPE = import_prop_types.default.shape({
    type: ANIMATION_TYPE,
    delay: import_prop_types.default.number,
    duration: import_prop_types.default.number,
    size: import_prop_types.default.oneOf(["xsmall", "small", "medium", "large", "xlarge"])
  });
  var animationPropType = import_prop_types.default.oneOfType([ANIMATION_TYPE, ANIMATION_SHAPE, import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([ANIMATION_TYPE, ANIMATION_SHAPE]))]);
  var colorPropType = import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.shape({
    dark: import_prop_types.default.string,
    light: import_prop_types.default.string
  })]);
  var backgroundPropType = import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.shape({
    clip: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["text"]), import_prop_types.default.string]),
    color: colorPropType,
    dark: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.string]),
    image: import_prop_types.default.string,
    position: import_prop_types.default.string,
    opacity: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.bool, import_prop_types.default.number, import_prop_types.default.oneOf(["weak", "medium", "strong"])]),
    repeat: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["no-repeat", "repeat"]), import_prop_types.default.string]),
    rotate: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]),
    size: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["cover", "contain"]), import_prop_types.default.string]),
    light: import_prop_types.default.string
  })]);
  var backgroundDoc = backgroundPropType;
  var MARGIN_SIZES = ["xxsmall", "xsmall", "small", "medium", "large", "xlarge"];
  var marginProp = import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["none"].concat(MARGIN_SIZES)), import_prop_types.default.shape({
    bottom: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(MARGIN_SIZES), import_prop_types.default.string]),
    end: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(MARGIN_SIZES), import_prop_types.default.string]),
    horizontal: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(MARGIN_SIZES), import_prop_types.default.string]),
    left: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(MARGIN_SIZES), import_prop_types.default.string]),
    right: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(MARGIN_SIZES), import_prop_types.default.string]),
    start: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(MARGIN_SIZES), import_prop_types.default.string]),
    top: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(MARGIN_SIZES), import_prop_types.default.string]),
    vertical: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(MARGIN_SIZES), import_prop_types.default.string])
  }), import_prop_types.default.string]);
  var PAD_SIZES = ["xxsmall", "xsmall", "small", "medium", "large", "xlarge"];
  var padPropType = import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["none"].concat(PAD_SIZES)), import_prop_types.default.shape({
    bottom: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(PAD_SIZES), import_prop_types.default.string]),
    end: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(PAD_SIZES), import_prop_types.default.string]),
    horizontal: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(PAD_SIZES), import_prop_types.default.string]),
    left: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(PAD_SIZES), import_prop_types.default.string]),
    right: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(PAD_SIZES), import_prop_types.default.string]),
    start: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(PAD_SIZES), import_prop_types.default.string]),
    top: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(PAD_SIZES), import_prop_types.default.string]),
    vertical: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(PAD_SIZES), import_prop_types.default.string])
  }), import_prop_types.default.string]);
  var genericProps = {
    a11yTitle: a11yTitlePropType,
    alignSelf: import_prop_types.default.oneOf(["start", "center", "end", "stretch", "baseline"]),
    gridArea: import_prop_types.default.string,
    margin: marginProp
  };
  var elevationPropType = import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["none", "xsmall", "small", "medium", "large", "xlarge"]), import_prop_types.default.string]);
  var hoverIndicatorPropType = import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.string, import_prop_types.default.oneOf(["background"]), backgroundPropType, import_prop_types.default.shape({
    background: backgroundPropType,
    elevation: elevationPropType
  })]);
  var pointPropType = import_prop_types.default.oneOf(["circle", "diamond", "square", "star", "triangle", "triangleDown"]);
  var patternPropType = import_prop_types.default.oneOf(["squares", "circles", "stripesHorizontal", "stripesVertical", "stripesDiagonalDown", "stripesDiagonalUp"]);
  var roundPropType = import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.oneOf(["xsmall", "small", "medium", "large", "xlarge", "full"]), import_prop_types.default.string, import_prop_types.default.shape({
    corner: import_prop_types.default.oneOf(["top", "left", "bottom", "right", "top-left", "top-right", "bottom-left", "bottom-right"]),
    size: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["xsmall", "small", "medium", "large", "xlarge"]), import_prop_types.default.string])
  })]);
  var skeletonColorsPropType = import_prop_types.default.shape({
    dark: import_prop_types.default.arrayOf(import_prop_types.default.string),
    light: import_prop_types.default.arrayOf(import_prop_types.default.string)
  });
  var skeletonPropType = import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.shape({
    animation: animationPropType,
    colors: skeletonColorsPropType,
    depth: import_prop_types.default.number,
    message: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.shape({
      start: import_prop_types.default.string,
      end: import_prop_types.default.string
    })])
  })]);
  var dimSizeType = import_prop_types.default.oneOf(["xxsmall", "xsmall", "small", "medium", "large", "xlarge", "xxlarge"]);
  var heightPropType = import_prop_types.default.oneOfType([dimSizeType, import_prop_types.default.string, import_prop_types.default.shape({
    height: import_prop_types.default.oneOfType([dimSizeType, import_prop_types.default.string]),
    min: import_prop_types.default.oneOfType([dimSizeType, import_prop_types.default.string]),
    max: import_prop_types.default.oneOfType([dimSizeType, import_prop_types.default.string])
  })]);
  var widthPropType = import_prop_types.default.oneOfType([dimSizeType, import_prop_types.default.string, import_prop_types.default.shape({
    width: import_prop_types.default.oneOfType([dimSizeType, import_prop_types.default.string]),
    min: import_prop_types.default.oneOfType([dimSizeType, import_prop_types.default.string]),
    max: import_prop_types.default.oneOfType([dimSizeType, import_prop_types.default.string])
  })]);
  var OVERFLOW_VALUES = ["auto", "hidden", "scroll", "visible"];

  // node_modules/grommet/es6/components/Box/Box.js
  var import_react10 = __toESM(require_react());
  var import_styled_components9 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/utils/animation.js
  var import_styled_components = __toESM(require_styled_components_browser_cjs());
  var PULSE_SIZES = {
    xsmall: 1.001,
    small: 1.01,
    medium: 1.1,
    large: 1.5,
    xlarge: 2
  };
  var SLIDE_SIZES = {
    xsmall: 1,
    small: 5,
    medium: 10,
    large: 50,
    xlarge: 200
  };
  var JIGGLE_SIZES = {
    xsmall: 0.1,
    small: 1,
    medium: 5,
    large: 400,
    xlarge: 1e3
  };
  var ZOOM_SIZES = {
    xsmall: 1e-3,
    small: 0.01,
    medium: 0.05,
    large: 0.1,
    xlarge: 0.5
  };
  var animationBounds = function animationBounds2(type, size) {
    if (size === void 0) {
      size = "medium";
    }
    if (type === "draw") {
      return ["", "stroke-dashoffset: 0"];
    }
    if (type === "fadeIn") {
      return ["opacity: 0;", "opacity: 1;"];
    }
    if (type === "fadeOut") {
      return ["opacity: 1;", "opacity: 0;"];
    }
    if (type === "jiggle") {
      var deg = JIGGLE_SIZES[size];
      return ["transform: rotate(-" + deg + "deg);", "transform: rotate(" + deg + "deg);"];
    }
    if (type === "pulse") {
      return ["transform: scale(1);", "transform: scale(" + PULSE_SIZES[size] + ")"];
    }
    if (type === "rotateRight") {
      return ["transform: rotate(0deg);", "transform: rotate(359deg);"];
    }
    if (type === "rotateLeft") {
      return ["transform: rotate(0deg);", "transform: rotate(-359deg);"];
    }
    if (type === "flipIn") {
      return ["transform: rotateY(90deg);", "transform: rotateY(0);"];
    }
    if (type === "flipOut") {
      return ["transform: rotateY(0);", "transform: rotateY(90deg);"];
    }
    if (type === "slideDown") {
      return ["transform: translateY(-" + SLIDE_SIZES[size] + "%);", "transform: none;"];
    }
    if (type === "slideLeft") {
      return ["transform: translateX(" + SLIDE_SIZES[size] + "%);", "transform: none;"];
    }
    if (type === "slideRight") {
      return ["transform: translateX(-" + SLIDE_SIZES[size] + "%);", "transform: none;"];
    }
    if (type === "slideUp") {
      return ["transform: translateY(" + SLIDE_SIZES[size] + "%);", "transform: none;"];
    }
    if (type === "zoomIn") {
      return ["transform: scale(" + (1 - ZOOM_SIZES[size]) + ");", "transform: none;"];
    }
    if (type === "zoomOut") {
      return ["transform: scale(" + (1 + ZOOM_SIZES[size]) + ");", "transform: none;"];
    }
    return [];
  };
  var normalizeTiming = function normalizeTiming2(time, defaultTiming) {
    return typeof time === "number" ? time / 1e3 + "s" : time || defaultTiming;
  };
  var animationEnding = function animationEnding2(type) {
    if (type === "draw") {
      return "linear forwards";
    }
    if (type === "jiggle") {
      return "alternate infinite";
    }
    if (type === "pulse") {
      return "alternate infinite";
    }
    if (type === "rotateRight" || type === "rotateLeft") {
      return "infinite linear";
    }
    return "forwards";
  };
  var animationObjectStyle = function animationObjectStyle2(animation, theme, themeObj) {
    var bounds2 = animationBounds(animation.type, animation.size);
    var animationTheme = themeObj && themeObj.animation || theme.global.animation;
    if (bounds2) {
      var animationTransition = (0, import_styled_components.css)(["from{", ";}to{", ";}"], bounds2[0], bounds2[1]);
      var defaultDuration = function defaultDuration2() {
        return normalizeTiming(animationTheme[animation.type] ? animationTheme[animation.type].duration : animation.duration, animationTheme.duration);
      };
      return (0, import_styled_components.css)(["", " ", " ", " ", ""], (0, import_styled_components.keyframes)(["", ""], animationTransition), normalizeTiming(animation.duration, defaultDuration()), normalizeTiming(animation.delay, "0s"), animationEnding(animation.type));
    }
    return "";
  };

  // node_modules/grommet/es6/utils/mixins.js
  var import_styled_components2 = __toESM(require_styled_components_browser_cjs());
  var parseMetricToNum = function parseMetricToNum2(metric) {
    if (typeof metric === "number")
      return metric;
    if (metric.match(/\s/) && true) {
      console.warn('Invalid single measurement value: "' + metric + '"');
    }
    return parseFloat(metric.match(/\d+(\.\d+)?/), 10);
  };
  var breakpointStyle = function breakpointStyle2(breakpoint, content) {
    return (0, import_styled_components2.css)(["@media only screen ", "{", ";}"], breakpoint.value && "and (max-width: " + breakpoint.value + "px)", content);
  };

  // node_modules/grommet/es6/utils/background.js
  var import_styled_components3 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/utils/colors.js
  var normalizeColor = function normalizeColor2(color, theme, dark) {
    var colorSpec = theme.global && theme.global.colors[color] !== void 0 ? theme.global.colors[color] : color;
    var result = colorSpec;
    if (colorSpec) {
      if ((dark === true || dark === void 0 && theme.dark) && colorSpec.dark !== void 0) {
        result = colorSpec.dark;
      } else if ((dark === false || !theme.dark) && colorSpec.light !== void 0) {
        result = colorSpec.light;
      }
    }
    if (result && theme.global && theme.global.colors[result] !== void 0) {
      result = normalizeColor2(result, theme, dark);
    }
    return result;
  };
  var parseHexToRGB = function parseHexToRGB2(color) {
    return color.length < 7 ? color.match(/[A-Za-z0-9]{1}/g).map(function(v) {
      return parseInt("" + v + v, 16);
    }) : (
      // https://stackoverflow.com/a/42429333
      color.match(/[A-Za-z0-9]{2}/g).map(function(v) {
        return parseInt(v, 16);
      })
    );
  };
  var hslToRGB = function hslToRGB2(h, s, l) {
    var r;
    var g;
    var b;
    if (s === 0 || s === "0") {
      r = l;
      g = l;
      b = l;
    } else {
      var hue2rgb = function hue2rgb2(p2, q2, inT) {
        var t = inT;
        if (t < 0)
          t += 1;
        if (t > 1)
          t -= 1;
        if (t < 0.16666667)
          return p2 + (q2 - p2) * 6 * t;
        if (t < 1 / 2)
          return q2;
        if (t < 0.66666667)
          return p2 + (q2 - p2) * (0.66666667 - t) * 6;
        return p2;
      };
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 0.33333333);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 0.33333333);
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
  };
  var hexExp = /^#[A-Za-z0-9]{3,4}$|^#[A-Za-z0-9]{6,8}$/;
  var rgbExp = /^rgba?\(\s?([0-9]*)\s?,\s?([0-9]*)\s?,\s?([0-9]*)\s?\)/;
  var rgbaExp = /^rgba?\(\s?([0-9]*)\s?,\s?([0-9]*)\s?,\s?([0-9]*)\s?,\s?([.0-9]*)\s?\)/;
  var hslExp = /^hsla?\(\s?([0-9]*)\s?,\s?([0-9]*)%?\s?,\s?([0-9]*)%?\s?.*?\)/;
  var canExtractRGBArray = function canExtractRGBArray2(color) {
    return hexExp.test(color) || rgbExp.test(color) || rgbaExp.test(color) || hslExp.test(color);
  };
  var getRGBArray = function getRGBArray2(color) {
    if (hexExp.test(color)) {
      var _parseHexToRGB = parseHexToRGB(color), red = _parseHexToRGB[0], green = _parseHexToRGB[1], blue = _parseHexToRGB[2], alpha = _parseHexToRGB[3];
      return [red, green, blue, alpha !== void 0 ? alpha / 255 : void 0];
    }
    var match2 = color.match(rgbExp);
    if (match2) {
      return match2.splice(1).map(function(v) {
        return parseInt(v, 10);
      });
    }
    match2 = color.match(rgbaExp);
    if (match2) {
      return match2.splice(1).map(function(v) {
        return parseFloat(v, 10);
      });
    }
    match2 = color.match(hslExp);
    if (match2) {
      var _match$splice$map = match2.splice(1).map(function(v) {
        return parseInt(v, 10);
      }), h = _match$splice$map[0], s = _match$splice$map[1], l = _match$splice$map[2];
      return hslToRGB(h / 360, s / 100, l / 100);
    }
    return color;
  };
  var colorIsDark = function colorIsDark2(color) {
    if (color && canExtractRGBArray(color)) {
      var _getRGBArray = getRGBArray(color), red = _getRGBArray[0], green = _getRGBArray[1], blue = _getRGBArray[2], alpha = _getRGBArray[3];
      if (alpha < 0.5)
        return void 0;
      var brightness = (299 * red + 587 * green + 114 * blue) / 1e3;
      return brightness < 125;
    }
    return void 0;
  };
  var getRGBA = function getRGBA2(color, opacity) {
    if (color && canExtractRGBArray(color)) {
      var _getRGBArray2 = getRGBArray(color), red = _getRGBArray2[0], green = _getRGBArray2[1], blue = _getRGBArray2[2], alpha = _getRGBArray2[3];
      var normalizedAlpha;
      if (opacity !== void 0) {
        normalizedAlpha = opacity;
      } else if (alpha !== void 0) {
        normalizedAlpha = alpha;
      } else {
        normalizedAlpha = 1;
      }
      return "rgba(" + red + ", " + green + ", " + blue + ", " + normalizedAlpha + ")";
    }
    return void 0;
  };

  // node_modules/grommet/es6/utils/background.js
  var evalStyle = function evalStyle2(arg, theme) {
    if (arg && Array.isArray(arg) && typeof arg[0] === "function") {
      return arg[0]({
        theme
      });
    }
    return arg;
  };
  var normalizeBackground = function normalizeBackground2(backgroundArg, theme) {
    var _theme$global$backgro;
    var background = ((_theme$global$backgro = theme.global.backgrounds) == null ? void 0 : _theme$global$backgro[backgroundArg]) || backgroundArg;
    var result = background;
    if (background) {
      if (theme.dark && background.dark && typeof background.dark !== "boolean") {
        result = background.dark;
      } else if (!theme.dark && background.light && typeof background.light !== "boolean") {
        result = background.light;
      }
      result = evalStyle(result, theme);
    }
    return result;
  };
  var normalizeBackgroundColor = function normalizeBackgroundColor2(backgroundArg, theme) {
    var _theme$global$backgro2;
    var background = backgroundArg.color || backgroundArg;
    var result = normalizeColor(
      // Background color may be defined by theme.global.backgrounds or
      // theme.global.colors.
      ((_theme$global$backgro2 = theme.global.backgrounds) == null ? void 0 : _theme$global$backgro2[background]) || background,
      theme,
      backgroundArg.dark
    );
    return result;
  };
  var normalizeBackgroundImage = function normalizeBackgroundImage2(background, theme) {
    var result;
    if (background.image) {
      var _theme$global$backgro3, _theme$global$backgro4, _theme$global$backgro5;
      result = normalizeBackground(background.dark ? (_theme$global$backgro3 = theme.global.backgrounds) == null ? void 0 : (_theme$global$backgro4 = _theme$global$backgro3[background.image]) == null ? void 0 : _theme$global$backgro4.dark : (_theme$global$backgro5 = theme.global.backgrounds) == null ? void 0 : _theme$global$backgro5[background.image], theme) || background.image;
    } else {
      var _theme$global$backgro6;
      var normalized = normalizeBackground((_theme$global$backgro6 = theme.global.backgrounds) == null ? void 0 : _theme$global$backgro6[background], theme);
      result = typeof normalized === "object" ? normalizeBackgroundImage2(normalized, theme) : normalized;
    }
    return result;
  };
  var rotateBackground = function rotateBackground2(background, theme) {
    var backgroundImage = normalizeBackgroundImage(background, theme);
    var result = backgroundImage;
    if (backgroundImage.lastIndexOf("linear-gradient", 0) === 0) {
      var regex = /\d{1,}deg\b,/gm;
      result = backgroundImage.lastIndexOf("deg,") >= 0 ? backgroundImage.replace(regex, background.rotate + "deg,") : backgroundImage.replace("linear-gradient(", "linear-gradient(" + background.rotate + "deg, ");
    } else {
      console.warn(
        // eslint-disable-next-line max-len
        "'background.rotate' property only supports 'background.image' containing a linear-gradient string."
      );
    }
    return result;
  };
  var backgroundIsDark = function backgroundIsDark2(backgroundArg, theme) {
    var background = normalizeBackground(backgroundArg, theme);
    var result;
    if (background) {
      if (typeof background === "object") {
        var color = background.color, dark = background.dark, opacity = background.opacity;
        if (typeof dark === "boolean") {
          result = dark;
        } else if (color && // weak opacity means we keep the existing darkness
        (!opacity || opacity !== "weak")) {
          var backgroundColor = normalizeColor(background.color, theme);
          if (backgroundColor) {
            result = colorIsDark(backgroundColor);
          }
        }
      } else {
        var _color = normalizeColor(background, theme);
        if (_color) {
          result = colorIsDark(_color);
        }
      }
    }
    return result;
  };
  var darkContext = function darkContext2(backgroundColor) {
    var isDark = colorIsDark(backgroundColor);
    if (isDark === void 0)
      return void 0;
    return isDark ? "dark" : "light";
  };
  var backgroundAndTextColors = function backgroundAndTextColors2(backgroundArg, textArg, theme) {
    if (!backgroundArg)
      return [void 0, textArg];
    var global2 = theme.global;
    var background = normalizeBackground(backgroundArg, theme);
    var text = textArg || global2.colors.text;
    var backgroundColor;
    var textColor;
    if (typeof background === "object") {
      if (background.dark === false) {
        textColor = text.light || text;
      } else if (background.dark) {
        textColor = text.dark || text;
      }
      if (background.color) {
        var color = normalizeBackgroundColor(background, theme);
        var opacity = background.opacity === true ? global2.opacity.medium : global2.opacity[background.opacity] || background.opacity;
        backgroundColor = getRGBA(color, opacity) || color;
        if (!textColor && (opacity === void 0 || opacity > 0.3)) {
          var shade = darkContext(backgroundColor, theme);
          textColor = normalizeColor(shade && text[shade] || text, theme);
        }
      }
    } else {
      backgroundColor = normalizeBackgroundColor(background, theme);
      var _shade = darkContext(backgroundColor, theme);
      var transparent;
      if (backgroundColor && canExtractRGBArray(backgroundColor)) {
        var colorArray3 = getRGBArray(backgroundColor);
        if (colorArray3[3] < 0.5)
          transparent = true;
      }
      if (_shade) {
        textColor = normalizeColor(text[_shade] || text, theme, _shade === "dark");
      } else if (transparent && text) {
        textColor = normalizeColor(text, theme);
      } else {
        if (backgroundColor !== "transparent")
          backgroundColor = void 0;
        if (text)
          textColor = normalizeColor(text, theme);
      }
    }
    if (textArg === false)
      textColor = void 0;
    return [backgroundColor, textColor];
  };
  var backgroundStyle = function backgroundStyle2(backgroundArg, theme, textColorArg) {
    if (backgroundArg === void 0)
      return void 0;
    var background = normalizeBackground(backgroundArg, theme);
    var _backgroundAndTextCol = backgroundAndTextColors(background, textColorArg, theme), backgroundColor = _backgroundAndTextCol[0], textColor = _backgroundAndTextCol[1];
    var backgroundImage = background.rotate ? rotateBackground(background, theme) : normalizeBackgroundImage(background, theme);
    var backgroundClipStyle = "";
    if (background.clip) {
      backgroundClipStyle = background.clip === "text" ? "-webkit-text-fill-color: transparent; \n           -webkit-background-clip: text; \n           background-clip: text;" : "background-clip: " + background.clip + ";";
    }
    if (typeof background === "string" && background.lastIndexOf("url", 0) === 0) {
      return (0, import_styled_components3.css)(["background:", " no-repeat center center;background-size:cover;"], background);
    }
    if (backgroundImage) {
      var backgroundStyles = "\n      " + (backgroundColor ? "background-color: " + backgroundColor + ";" : "") + "\n      background-image: " + backgroundImage + ";\n      background-repeat: " + (typeof background === "object" && background.repeat || "no-repeat") + ";\n      background-position: " + (background.position || "center center") + ";\n      background-size: " + (background.size || "cover") + ";\n      " + backgroundClipStyle + "\n    ";
      return (0, import_styled_components3.css)(["", " ", ""], textColor ? "color: " + textColor + ";" : "", !background.opacity ? backgroundStyles : "position: relative;\n        z-index: 0;\n        &:before {\n          content: '';\n          position: absolute;\n          top: 0;\n          right: 0;\n          left: 0;\n          bottom: 0;\n          z-index: -1;\n          border-radius: inherit;\n          " + backgroundStyles + "\n          opacity: " + (background.opacity === true ? theme.global.opacity.medium : theme.global.opacity[background.opacity] || background.opacity) + ";\n        }");
    }
    if (backgroundColor) {
      return (0, import_styled_components3.css)(["background-color:", ";", ""], backgroundColor, textColor ? "color: " + textColor + ";" : "");
    }
    if (typeof background === "string")
      return (0, import_styled_components3.css)(["background:", ";"], normalizeColor(background, theme));
    return void 0;
  };
  var activeStyle = (0, import_styled_components3.css)(["", ""], function(props) {
    return backgroundStyle(normalizeColor(props.theme.global.active.background, props.theme), props.theme, props.theme.global.active.color);
  });
  var selectedStyle = (0, import_styled_components3.css)(["", ""], function(props) {
    return backgroundStyle(normalizeColor(props.theme.global.selected.background, props.theme), props.theme, props.theme.global.selected.color);
  });
  var getHoverIndicatorStyle = function getHoverIndicatorStyle2(hoverIndicator, theme) {
    var background;
    var elevation;
    if (hoverIndicator === true || hoverIndicator === "background") {
      background = theme.global.hover.background;
    } else if (typeof hoverIndicator === "object") {
      if (hoverIndicator.elevation || hoverIndicator.background) {
        elevation = hoverIndicator.elevation;
        background = hoverIndicator.background;
      } else
        background = hoverIndicator;
    } else {
      background = hoverIndicator;
    }
    return (0, import_styled_components3.css)(["", " ", ""], backgroundStyle(background, theme, theme.global.hover.color), elevation && "box-shadow: " + theme.global.elevation[theme.dark ? "dark" : "light"][elevation] + ";");
  };

  // node_modules/grommet/es6/utils/border.js
  var import_styled_components4 = __toESM(require_styled_components_browser_cjs());
  var responsiveBorderStyle = function responsiveBorderStyle2(data, theme) {
    var color = normalizeColor(data.color || "border", theme);
    var borderSize = data.size || "xsmall";
    var style = data.style || "solid";
    var side = typeof data === "string" ? data : data.side || "all";
    var breakpoint = theme.box.responsiveBreakpoint && theme.global.breakpoints[theme.box.responsiveBreakpoint];
    if (!breakpoint.borderSize)
      breakpoint.borderSize = theme.global.borderSize;
    var value = breakpoint && (breakpoint.borderSize[borderSize] || borderSize) && style + " " + (breakpoint.borderSize[borderSize] || borderSize) + " " + color;
    if (!value)
      return void 0;
    if (side === "top" || side === "bottom" || side === "left" || side === "right")
      return "border-" + side + ": " + value + ";";
    if (side === "end" || side === "start")
      return "border-inline-" + side + ": " + value + ";";
    if (side === "vertical")
      return "\n      border-left: " + value + ";\n      border-right: " + value + ";\n    ";
    if (side === "horizontal")
      return "\n      border-top: " + value + ";\n      border-bottom: " + value + ";\n    ";
    if (side === "between")
      return void 0;
    return "border: " + value + ";";
  };
  var borderStyle = function borderStyle2(borderData, responsive, theme) {
    var borderStyles = [];
    (Array.isArray(borderData) ? borderData : [borderData]).forEach(function(data) {
      var styles = [];
      var color = normalizeColor(data.color || "border", theme);
      var borderSize = data.size || "xsmall";
      var style = data.style || "solid";
      var side = typeof data === "string" ? data : data.side || "all";
      var value = style + " " + (theme.global.borderSize[borderSize] || borderSize) + " " + color;
      var responsiveStyle = responsive && responsiveBorderStyle(data, theme);
      var breakpoint = responsiveStyle && theme.box.responsiveBreakpoint && theme.global.breakpoints[theme.box.responsiveBreakpoint];
      if (side === "top" || side === "bottom" || side === "left" || side === "right") {
        styles.push("border-" + side + ": " + value + ";");
        if (responsiveStyle) {
          styles.push(breakpointStyle(breakpoint, responsiveStyle));
        }
      } else if (side === "end" || side === "start") {
        styles.push((0, import_styled_components4.css)(["border-inline-", ":", ";"], side, value));
        if (responsiveStyle) {
          styles.push(breakpointStyle(breakpoint, responsiveStyle));
        }
      } else if (side === "vertical") {
        styles.push((0, import_styled_components4.css)(["border-left:", ";border-right:", ";"], value, value));
        if (responsiveStyle) {
          styles.push(breakpointStyle(breakpoint, responsiveStyle));
        }
      } else if (side === "horizontal") {
        styles.push((0, import_styled_components4.css)(["border-top:", ";border-bottom:", ";"], value, value));
        if (responsiveStyle) {
          styles.push(breakpointStyle(breakpoint, responsiveStyle));
        }
      } else if (side === "between") {
      } else {
        styles.push((0, import_styled_components4.css)(["border:", ";"], value));
        if (responsiveStyle) {
          styles.push(breakpointStyle(breakpoint, responsiveStyle));
        }
      }
      borderStyles.push(styles);
    });
    return borderStyles;
  };

  // node_modules/grommet/es6/utils/DOM.js
  var findScrollParent = function findScrollParent2(element, horizontal12) {
    var result;
    if (element) {
      var parent = element.parentNode;
      while (!result && parent && parent.getBoundingClientRect) {
        var rect = parent.getBoundingClientRect();
        if (horizontal12) {
          if (rect.width && parent.scrollWidth > rect.width + 10) {
            result = parent;
          }
        } else if (rect.height && parent.scrollHeight > rect.height + 10) {
          result = parent;
        }
        parent = parent.parentNode;
      }
      if (!result) {
        result = document;
      } else if (result.tagName.toLowerCase() === "body") {
        result = document;
      }
    }
    return result;
  };
  var documentTags = ["html", "body"];
  var findScrollParents = function findScrollParents2(element, horizontal12) {
    var result = [];
    if (element) {
      var parent = element.parentNode;
      while (parent && parent.getBoundingClientRect) {
        var rect = parent.getBoundingClientRect();
        if (horizontal12) {
          if (rect.width && parent.scrollWidth > rect.width + 10) {
            result.push(parent);
          }
        } else if (rect.height && parent.scrollHeight > rect.height + 10) {
          result.push(parent);
        }
        parent = parent.parentNode;
      }
      if (result.length && documentTags.includes(result[0].tagName.toLowerCase())) {
        result.length = 0;
      }
      result.push(document);
    }
    return result;
  };
  var containsFocus = function containsFocus2(node) {
    var root = node.getRootNode();
    var element = root.activeElement;
    while (element) {
      if (element === node)
        break;
      element = element.parentElement;
    }
    return !!element;
  };
  var withinDropPortal = function withinDropPortal2(node, portalContext) {
    var root = node == null ? void 0 : node.getRootNode();
    var element = node;
    var portalId;
    while (element && element !== root) {
      if (element.hasAttribute("data-g-portal-id")) {
        portalId = element.getAttribute("data-g-portal-id");
        element = root;
      } else {
        element = element.parentElement;
      }
    }
    if (portalId === void 0 || portalContext.indexOf(parseInt(portalId, 10)) !== -1)
      return false;
    return true;
  };
  var isFocusable = function isFocusable2(element) {
    var tagName = element.tagName.toLowerCase();
    return tagName === "input" || tagName === "select" || tagName === "textarea";
  };
  var getFirstFocusableDescendant = function getFirstFocusableDescendant2(element) {
    var children = element.getElementsByTagName("*");
    for (var i = 0; i < children.length; i += 1) {
      var child = children[i];
      if (isFocusable(child)) {
        return child;
      }
    }
    return void 0;
  };
  var shouldKeepFocus = function shouldKeepFocus2(root) {
    var element = root.activeElement;
    if (isFocusable(element))
      return true;
    return !!getFirstFocusableDescendant(element);
  };
  var getNewContainer = function getNewContainer2(target, targetChildPosition) {
    if (target === void 0) {
      target = document.body;
    }
    var container = document.createElement("div");
    if (targetChildPosition === "first") {
      target.prepend(container);
    } else {
      target.appendChild(container);
    }
    return container;
  };
  var setFocusWithoutScroll = function setFocusWithoutScroll2(element) {
    var x = window.scrollX;
    var y = window.scrollY;
    element.focus();
    window.scrollTo(x, y);
  };
  var TABINDEX = "tabindex";
  var TABINDEX_STATE = "data-g-tabindex";
  var makeNodeFocusable = function makeNodeFocusable2(node) {
    if (!node.hasAttribute("aria-live")) {
      node.removeAttribute("aria-hidden");
      var elements = node.getElementsByTagName("*");
      Array.prototype.filter.call(elements || [], function(element) {
        return element.hasAttribute(TABINDEX_STATE);
      }).forEach(function(element) {
        var prior = element.getAttribute(TABINDEX_STATE);
        if (prior >= 0) {
          element.setAttribute(TABINDEX, element.getAttribute(TABINDEX_STATE));
        } else if (prior === "none") {
          element.removeAttribute(TABINDEX);
        }
        element.removeAttribute(TABINDEX_STATE);
      });
    }
  };
  var autoFocusingTags = /(a|area|input|select|textarea|button|iframe)$/;
  var makeNodeUnfocusable = function makeNodeUnfocusable2(node) {
    if (!node.hasAttribute("aria-live")) {
      node.setAttribute("aria-hidden", true);
      var elements = node.getElementsByTagName("*");
      Array.prototype.filter.call(elements || [], function(element) {
        return element.getAttribute(TABINDEX) !== null;
      }).forEach(function(element) {
        element.setAttribute(TABINDEX_STATE, element.getAttribute(TABINDEX));
        element.setAttribute(TABINDEX, -1);
      });
      Array.prototype.filter.call(elements || [], function(element) {
        var currentTag = element.tagName.toLowerCase();
        return currentTag.match(autoFocusingTags) && element.focus && element.getAttribute(TABINDEX_STATE) === null;
      }).forEach(function(element) {
        element.setAttribute(TABINDEX_STATE, "none");
        element.setAttribute(TABINDEX, -1);
      });
    }
  };
  var findVisibleParent = function findVisibleParent2(element) {
    if (element) {
      return element.offsetParent ? element : findVisibleParent2(element.parentElement) || element;
    }
    return void 0;
  };
  var isNodeAfterScroll = function isNodeAfterScroll2(node, target) {
    var _node$getBoundingClie = node.getBoundingClientRect(), bottom2 = _node$getBoundingClie.bottom;
    var _ref = target.getBoundingClientRect ? target.getBoundingClientRect() : {
      height: 0,
      top: 0
    }, height = _ref.height, top2 = _ref.top;
    return bottom2 >= top2 + height;
  };
  var isNodeBeforeScroll = function isNodeBeforeScroll2(node, target) {
    var _node$getBoundingClie2 = node.getBoundingClientRect(), top2 = _node$getBoundingClie2.top;
    var _ref2 = target.getBoundingClientRect ? target.getBoundingClientRect() : {
      top: 0
    }, targetTop = _ref2.top;
    return top2 <= targetTop;
  };
  var findButtonParent = function findButtonParent2(element) {
    if (element && element.nodeName !== "BUTTON" && element.nodeName !== "A")
      return findButtonParent2(element.parentElement);
    return element;
  };

  // node_modules/grommet/es6/utils/styles.js
  var import_styled_components5 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/utils/responsive.js
  var getBreakpoint = function getBreakpoint2(viewportWidth, theme) {
    var sortedBreakpoints = Object.keys(theme.global.breakpoints).sort(function(a, b) {
      var first = theme.global.breakpoints[a];
      var second = theme.global.breakpoints[b];
      if (!first)
        return 1;
      if (!second)
        return -1;
      if (!first.value)
        return 1;
      if (!second.value)
        return -1;
      return first.value - second.value;
    });
    var lastBreakpoint = sortedBreakpoints[sortedBreakpoints.length - 1];
    var result = sortedBreakpoints.find(function(name) {
      var breakpoint = theme.global.breakpoints[name];
      return !breakpoint.value || breakpoint.value >= viewportWidth ? name : false;
    });
    return result || lastBreakpoint;
  };
  var getDeviceBreakpoint = function getDeviceBreakpoint2(type, theme) {
    return theme.global.deviceBreakpoints[type];
  };
  var getBreakpointStyle = function getBreakpointStyle2(theme, breakpointSize) {
    var breakpoint = breakpointSize && theme.global.breakpoints[breakpointSize] || {};
    if (!breakpoint.edgeSize)
      breakpoint.edgeSize = theme.global.edgeSize;
    if (!breakpoint.borderSize)
      breakpoint.borderSize = theme.global.borderSize;
    if (!breakpoint.size)
      breakpoint.size = theme.global.size;
    return breakpoint;
  };

  // node_modules/grommet/es6/utils/styles.js
  var baseStyle = (0, import_styled_components5.css)(["font-family:", ";font-size:", ";line-height:", ";font-weight:", ";", " ", " box-sizing:border-box;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;"], function(props) {
    return props.theme.global.font.family;
  }, function(props) {
    return props.theme.global.font.size;
  }, function(props) {
    return props.theme.global.font.height;
  }, function(props) {
    return props.theme.global.font.weight;
  }, function(props) {
    return props.theme.global.font.variant && "\n    font-variant:" + props.theme.global.font.variant + ";\n  ";
  }, function(props) {
    return !props.plain && backgroundStyle(props.theme.baseBackground, props.theme);
  });
  var controlBorderStyle = (0, import_styled_components5.css)(["border:", " solid ", ";border-radius:", ";"], function(props) {
    return props.theme.global.control.border.width;
  }, function(props) {
    return normalizeColor(props.theme.global.control.border.color || "border", props.theme);
  }, function(props) {
    return props.theme.global.control.border.radius;
  });
  var edgeStyle = function edgeStyle2(kind, data, responsive, responsiveBreakpoint, theme) {
    var breakpoint = responsiveBreakpoint && theme.global.breakpoints[responsiveBreakpoint];
    if (typeof data === "string") {
      return (0, import_styled_components5.css)(["", ":", ";", ";"], kind, theme.global.edgeSize[data] || data, responsive && breakpoint ? breakpointStyle(breakpoint, "\n        " + kind + ": " + (breakpoint.edgeSize[data] || data) + ";\n      ") : "");
    }
    var result = [];
    var horizontal12 = data.horizontal, vertical12 = data.vertical, top2 = data.top, bottom2 = data.bottom, left2 = data.left, right2 = data.right;
    var horizontalVerticalEqual = horizontal12 && vertical12 && horizontal12 === vertical12;
    var allSidesEqual = top2 && bottom2 && left2 && right2 && top2 === bottom2 === left2 === right2;
    if (horizontalVerticalEqual || allSidesEqual) {
      var value = horizontalVerticalEqual ? horizontal12 : top2;
      return (0, import_styled_components5.css)(["", ":", ";", ";"], kind, theme.global.edgeSize[value] || value, responsive && breakpoint ? breakpointStyle(breakpoint, "\n        " + kind + ": " + (breakpoint.edgeSize[value] || value) + ";\n      ") : "");
    }
    if (horizontal12) {
      result.push((0, import_styled_components5.css)(["", "-left:", ";", "-right:", ";", ";"], kind, theme.global.edgeSize[horizontal12] || horizontal12, kind, theme.global.edgeSize[horizontal12] || horizontal12, responsive && breakpoint ? breakpointStyle(breakpoint, "\n          " + kind + "-left: " + (breakpoint.edgeSize[horizontal12] || horizontal12) + ";\n          " + kind + "-right: " + (breakpoint.edgeSize[horizontal12] || horizontal12) + ";\n        ") : ""));
    }
    if (vertical12) {
      result.push((0, import_styled_components5.css)(["", "-top:", ";", "-bottom:", ";", ";"], kind, theme.global.edgeSize[vertical12] || vertical12, kind, theme.global.edgeSize[vertical12] || vertical12, responsive && breakpoint ? breakpointStyle(breakpoint, "\n          " + kind + "-top: " + (breakpoint.edgeSize[vertical12] || vertical12) + ";\n          " + kind + "-bottom: " + (breakpoint.edgeSize[vertical12] || vertical12) + ";\n        ") : ""));
    }
    if (top2) {
      result.push((0, import_styled_components5.css)(["", "-top:", ";", ";"], kind, theme.global.edgeSize[top2] || top2, responsive && breakpoint ? breakpointStyle(breakpoint, "\n          " + kind + "-top: " + (breakpoint.edgeSize[top2] || top2) + ";\n        ") : ""));
    }
    if (bottom2) {
      result.push((0, import_styled_components5.css)(["", "-bottom:", ";", ";"], kind, theme.global.edgeSize[bottom2] || bottom2, responsive && breakpoint ? breakpointStyle(breakpoint, "\n          " + kind + "-bottom: " + (breakpoint.edgeSize[bottom2] || bottom2) + ";\n        ") : ""));
    }
    if (left2) {
      result.push((0, import_styled_components5.css)(["", "-left:", ";", ";"], kind, theme.global.edgeSize[left2] || left2, responsive && breakpoint ? breakpointStyle(breakpoint, "\n          " + kind + "-left: " + (breakpoint.edgeSize[left2] || left2) + ";\n        ") : ""));
    }
    if (right2) {
      result.push((0, import_styled_components5.css)(["", "-right:", ";", ";"], kind, theme.global.edgeSize[right2] || right2, responsive && breakpoint ? breakpointStyle(breakpoint, "\n          " + kind + "-right: " + (breakpoint.edgeSize[right2] || right2) + ";\n        ") : ""));
    }
    if (data.start) {
      result.push((0, import_styled_components5.css)(["", "-inline-start:", ";", ";"], kind, theme.global.edgeSize[data.start] || data.start, responsive && breakpoint ? breakpointStyle(breakpoint, "\n          " + kind + "-inline-start: " + (breakpoint.edgeSize[data.start] || data.start) + ";\n        ") : ""));
    }
    if (data.end) {
      result.push((0, import_styled_components5.css)(["", "-inline-end:", ";", ";"], kind, theme.global.edgeSize[data.end] || data.end, responsive && breakpoint ? breakpointStyle(breakpoint, "\n          " + kind + "-inline-end: " + (breakpoint.edgeSize[data.end] || data.end) + ";\n        ") : ""));
    }
    return result;
  };
  var fillStyle = function fillStyle2(fillProp) {
    if (fillProp === "horizontal") {
      return "width: 100%;";
    }
    if (fillProp === "vertical") {
      return "height: 100%;";
    }
    if (fillProp) {
      return "\n      width: 100%;\n      height: 100%;\n    ";
    }
    return void 0;
  };
  var focusStyles = function focusStyles2(props, _temp) {
    var _ref = _temp === void 0 ? {} : _temp, forceOutline = _ref.forceOutline, justBorder = _ref.justBorder;
    var focus = props.theme.global.focus;
    if (!focus || forceOutline && !focus.outline) {
      var color = normalizeColor("focus", props.theme);
      if (color)
        return "outline: 2px solid " + color + ";";
      return "";
    }
    if (focus.outline && (!focus.border || !justBorder)) {
      if (typeof focus.outline === "object") {
        var _color = normalizeColor(focus.outline.color || "focus", props.theme);
        var size = focus.outline.size || "2px";
        return "\n        outline-offset: 0px;\n        outline: " + size + " solid " + _color + ";\n      ";
      }
      return "outline: " + focus.outline + ";";
    }
    if (focus.shadow && (!focus.border || !justBorder)) {
      if (typeof focus.shadow === "object") {
        var _color2 = normalizeColor(
          // If there is a focus.border.color, use that for shadow too.
          // This is for backwards compatibility in v2.
          focus.border && focus.border.color || focus.shadow.color || "focus",
          props.theme
        );
        var _size = focus.shadow.size || "2px";
        return "\n        outline: none;\n        box-shadow: 0 0 " + _size + " " + _size + " " + _color2 + ";\n      ";
      }
      return "\n      outline: none;\n      box-shadow: " + focus.shadow + ";\n    ";
    }
    if (focus.border) {
      var _color3 = normalizeColor(focus.border.color || "focus", props.theme);
      return "\n      outline: none;\n      border-color: " + _color3 + ";\n    ";
    }
    return "";
  };
  var unfocusStyles = function unfocusStyles2(props, _temp2) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2, forceOutline = _ref2.forceOutline, justBorder = _ref2.justBorder;
    var focus = props.theme.global.focus;
    if (!focus || forceOutline && !focus.outline) {
      var color = normalizeColor("focus", props.theme);
      if (color)
        return "outline: none;";
      return "";
    }
    if (focus.outline && (!focus.border || !justBorder)) {
      if (typeof focus.outline === "object") {
        return "\n        outline-offset: 0px;\n        outline: none;\n      ";
      }
      return "outline: none;";
    }
    if (focus.shadow && (!focus.border || !justBorder)) {
      if (typeof focus.shadow === "object") {
        return "\n        outline: none;\n        box-shadow: none;\n      ";
      }
      return "\n      outline: none;\n      box-shadow: none;\n    ";
    }
    if (focus.border) {
      return "\n      outline: none;\n      border-color: none;\n    ";
    }
    return "";
  };
  var focusStyle = function focusStyle2(_temp3) {
    var _ref3 = _temp3 === void 0 ? {} : _temp3, forceOutline = _ref3.forceOutline, justBorder = _ref3.justBorder, skipSvgChildren = _ref3.skipSvgChildren;
    return (0, import_styled_components5.css)(["", " ", " ", ""], function(props) {
      return !skipSvgChildren && "\n  > circle,\n  > ellipse,\n  > line,\n  > path,\n  > polygon,\n  > polyline,\n  > rect {\n    " + focusStyles(props) + "\n  }";
    }, function(props) {
      return focusStyles(props, {
        forceOutline,
        justBorder
      });
    }, !forceOutline && "\n  ::-moz-focus-inner {\n    border: 0;\n  }\n  ");
  };
  var unfocusStyle = function unfocusStyle2(_temp4) {
    var _ref4 = _temp4 === void 0 ? {} : _temp4, forceOutline = _ref4.forceOutline, justBorder = _ref4.justBorder, skipSvgChildren = _ref4.skipSvgChildren;
    return (0, import_styled_components5.css)(["", " ", " ", ""], function(props) {
      return !skipSvgChildren && "\n  > circle,\n  > ellipse,\n  > line,\n  > path,\n  > polygon,\n  > polyline,\n  > rect {\n    " + unfocusStyles(props) + "\n  }";
    }, function(props) {
      return unfocusStyles(props, {
        forceOutline,
        justBorder
      });
    }, !forceOutline && "\n  ::-moz-focus-inner {\n    border: 0;\n  }\n  ");
  };
  var adjustPad = function adjustPad2(props, value) {
    return parseMetricToNum((props.theme.global.edgeSize[value] || value) + "px") + parseMetricToNum(props.theme.global.control.border.width + "px") + "px";
  };
  var getInputPadBySide = function getInputPadBySide2(props, side) {
    if (typeof props.theme.global.input.padding !== "object") {
      var _adjustedPad = adjustPad(props, props.theme.global.input.padding);
      return _adjustedPad;
    }
    var orientation;
    if (side === "left" || side === "right")
      orientation = "horizontal";
    else if (side === "top" || side === "bottom")
      orientation = "vertical";
    else
      orientation = void 0;
    var pad = props.theme.global.input.padding[side] || props.theme.global.input.padding[orientation];
    var adjustedPad = adjustPad(props, pad);
    return adjustedPad;
  };
  var placeholderColor = (0, import_styled_components5.css)(["color:", ";"], function(props) {
    return normalizeColor(props.theme.global.colors.placeholder, props.theme);
  });
  var placeholderStyle = (0, import_styled_components5.css)(["&::-webkit-input-placeholder{", ";}&::-moz-placeholder{", ";}&:-ms-input-placeholder{", ";}"], placeholderColor, placeholderColor, placeholderColor);
  var inputSizeStyle = function inputSizeStyle2(props) {
    var data = props.theme.text[props.size];
    if (!data) {
      return (0, import_styled_components5.css)(["font-size:", ";"], props.size);
    }
    return (0, import_styled_components5.css)(["font-size:", ";line-height:", ";"], data.size, data.height);
  };
  var inputStyle = (0, import_styled_components5.css)(["box-sizing:border-box;", " font-family:inherit;border:none;-webkit-appearance:none;background:transparent;color:inherit;width:100%;", " ", " ", " margin:0;", " &:focus{", ";}", " ", "::-webkit-search-decoration{-webkit-appearance:none;}&::-moz-focus-inner{border:none;outline:none;}&:-moz-placeholder,&::-moz-placeholder{opacity:1;}", ""], function(props) {
    var _props$theme$text$pro;
    return "font-size: " + (props.theme.global.input.font.size ? ((_props$theme$text$pro = props.theme.text[props.theme.global.input.font.size]) == null ? void 0 : _props$theme$text$pro.size) || props.theme.global.input.font.size : "inherit") + ";";
  }, function(props) {
    return props.theme.global.input.font.height && "line-height: " + props.theme.global.input.font.height + ";";
  }, function(props) {
    return props.theme.global.input.padding && typeof props.theme.global.input.padding !== "object" ? (
      // On a breaking change release, this condition could be removed and
      // just the edgeStyle could remain. Currently, this is needed for
      // backwards compatibility since we are placing the calculation in
      // base.js
      "padding: " + (parseMetricToNum(props.theme.global.edgeSize[props.theme.global.input.padding] || props.theme.global.input.padding) - parseMetricToNum(props.theme.global.control.border.width)) + "px;"
    ) : edgeStyle("padding", props.theme.global.input.padding, props.responsive, props.theme.box.responsiveBreakpoint, props.theme);
  }, function(props) {
    return (
      // for backwards compatibility, check if props.theme.global.input.weight
      (props.theme.global.input.weight || props.theme.global.input.font.weight) && (0, import_styled_components5.css)(["font-weight:", ";"], props.theme.global.input.weight || props.theme.global.input.font.weight)
    );
  }, function(props) {
    return props.size && inputSizeStyle(props);
  }, function(props) {
    return (!props.plain || props.focusIndicator) && focusStyle();
  }, controlBorderStyle, placeholderStyle, function(props) {
    return props.theme.global.input.extend;
  });
  var overflowStyle = function overflowStyle2(overflowProp) {
    if (typeof overflowProp === "string") {
      return (0, import_styled_components5.css)(["overflow:", ";"], overflowProp);
    }
    return (0, import_styled_components5.css)(["", " ", ";"], overflowProp.horizontal && "overflow-x: " + overflowProp.horizontal + ";", overflowProp.vertical && "overflow-y: " + overflowProp.vertical + ";");
  };
  var ALIGN_SELF_MAP = {
    center: "center",
    end: "flex-end",
    start: "flex-start",
    stretch: "stretch",
    baseline: "baseline"
  };
  var genericStyles = (0, import_styled_components5.css)(["", " ", " ", ""], function(props) {
    return props.alignSelf && "align-self: " + ALIGN_SELF_MAP[props.alignSelf] + ";";
  }, function(props) {
    return props.gridArea && "grid-area: " + props.gridArea + ";";
  }, function(props) {
    return props.margin && props.theme.global && edgeStyle("margin", props.margin, props.responsive, props.theme.global.edgeSize.responsiveBreakpoint, props.theme);
  });
  var disabledStyle = function disabledStyle2(componentStyle) {
    return (0, import_styled_components5.css)(["opacity:", ";cursor:default;"], function(props) {
      return componentStyle || props.theme.global.control.disabled.opacity;
    });
  };
  var sizeStyle = function sizeStyle2(name, value, theme) {
    return (0, import_styled_components5.css)(["", ":", ";"], name, theme.global.size[value] || value);
  };
  var plainInputStyle = (0, import_styled_components5.css)(["outline:none;border:none;"]);
  var kindPartStyles = function kindPartStyles2(obj, theme, colorValue) {
    var styles = [];
    if (obj.padding || obj.pad) {
      var pad = obj.padding || obj.pad;
      if (pad.vertical || pad.horizontal)
        styles.push("padding: " + (theme.global.edgeSize[pad.vertical] || pad.vertical || 0) + " " + (theme.global.edgeSize[pad.horizontal] || pad.horizontal || 0) + ";");
      else
        styles.push("padding: " + (theme.global.edgeSize[pad] || pad || 0) + ";");
    }
    if (obj.background)
      styles.push(backgroundStyle(colorValue || obj.background, theme, obj.color || (Object.prototype.hasOwnProperty.call(obj, "color") && obj.color === void 0 ? false : void 0)));
    else if (obj.color)
      styles.push("color: " + normalizeColor(obj.color, theme) + ";");
    if (obj.border) {
      if (obj.border.width)
        styles.push((0, import_styled_components5.css)(["border-style:solid;border-width:", ";"], obj.border.width));
      if (obj.border.color)
        styles.push((0, import_styled_components5.css)(["border-color:", ";"], normalizeColor(!obj.background && colorValue || obj.border.color || "border", theme)));
      if (obj.border.radius)
        styles.push((0, import_styled_components5.css)(["border-radius:", ";"], obj.border.radius));
    } else if (obj.border === false)
      styles.push("border: none;");
    if (colorValue && !obj.border && !obj.background)
      styles.push("color: " + normalizeColor(colorValue, theme) + ";");
    if (obj.font) {
      if (obj.font.size) {
        styles.push("font-size: " + (theme.text[obj.font.size].size || obj.font.size) + ";");
      }
      if (obj.font.height) {
        styles.push("line-height: " + obj.font.height + ";");
      }
      if (obj.font.weight) {
        styles.push("font-weight: " + obj.font.weight + ";");
      }
    }
    if (obj.opacity) {
      var opacity = obj.opacity === true ? theme.global.opacity.medium : theme.global.opacity[obj.opacity] || obj.opacity;
      styles.push("opacity: " + opacity + ";");
    }
    if (obj.extend)
      styles.push(obj.extend);
    return styles;
  };
  var ROUND_MAP = {
    full: "100%"
  };
  var roundStyle = function roundStyle2(data, responsive, theme) {
    var breakpoint = getBreakpointStyle(theme, theme.box.responsiveBreakpoint);
    var styles = [];
    if (typeof data === "object") {
      var size = ROUND_MAP[data.size] || theme.global.edgeSize[data.size || "medium"] || data.size;
      var responsiveSize = responsive && breakpoint && breakpoint.edgeSize[data.size] && (breakpoint.edgeSize[data.size] || data.size);
      if (data.corner === "top") {
        styles.push((0, import_styled_components5.css)(["border-top-left-radius:", ";border-top-right-radius:", ";"], size, size));
        if (responsiveSize) {
          styles.push(breakpointStyle(breakpoint, "\n          border-top-left-radius: " + responsiveSize + ";\n          border-top-right-radius: " + responsiveSize + ";\n        "));
        }
      } else if (data.corner === "bottom") {
        styles.push((0, import_styled_components5.css)(["border-bottom-left-radius:", ";border-bottom-right-radius:", ";"], size, size));
        if (responsiveSize) {
          styles.push(breakpointStyle(breakpoint, "\n          border-bottom-left-radius: " + responsiveSize + ";\n          border-bottom-right-radius: " + responsiveSize + ";\n        "));
        }
      } else if (data.corner === "left") {
        styles.push((0, import_styled_components5.css)(["border-top-left-radius:", ";border-bottom-left-radius:", ";"], size, size));
        if (responsiveSize) {
          styles.push(breakpointStyle(breakpoint, "\n          border-top-left-radius: " + responsiveSize + ";\n          border-bottom-left-radius: " + responsiveSize + ";\n        "));
        }
      } else if (data.corner === "right") {
        styles.push((0, import_styled_components5.css)(["border-top-right-radius:", ";border-bottom-right-radius:", ";"], size, size));
        if (responsiveSize) {
          styles.push(breakpointStyle(breakpoint, "\n          border-top-right-radius: " + responsiveSize + ";\n          border-bottom-right-radius: " + responsiveSize + ";\n        "));
        }
      } else if (data.corner) {
        styles.push((0, import_styled_components5.css)(["border-", "-radius:", ";"], data.corner, size));
        if (responsiveSize) {
          styles.push(breakpointStyle(breakpoint, "\n          border-" + data.corner + "-radius: " + responsiveSize + ";\n        "));
        }
      } else {
        styles.push((0, import_styled_components5.css)(["border-radius:", ";"], size));
        if (responsiveSize) {
          styles.push(breakpointStyle(breakpoint, "\n          border-radius: " + responsiveSize + ";\n        "));
        }
      }
    } else {
      var _size2 = data === true ? "medium" : data;
      styles.push((0, import_styled_components5.css)(["border-radius:", ";"], ROUND_MAP[_size2] || theme.global.edgeSize[_size2] || _size2));
      var _responsiveSize = breakpoint && breakpoint.edgeSize[_size2];
      if (_responsiveSize) {
        styles.push(breakpointStyle(breakpoint, "\n        border-radius: " + _responsiveSize + ";\n      "));
      }
    }
    return styles;
  };
  var TEXT_ALIGN_MAP = {
    center: "center",
    end: "right",
    justify: "justify",
    start: "left"
  };
  var textAlignStyle = (0, import_styled_components5.css)(["text-align:", ";"], function(props) {
    return TEXT_ALIGN_MAP[props.textAlign];
  });
  var ALIGN_ITEMS_MAP = {
    baseline: "baseline",
    center: "center",
    end: "flex-end",
    start: "flex-start",
    stretch: "stretch"
  };
  var alignStyle = (0, import_styled_components5.css)(["align-items:", ";"], function(props) {
    var _ALIGN_ITEMS_MAP$prop;
    return (_ALIGN_ITEMS_MAP$prop = ALIGN_ITEMS_MAP[props.align]) != null ? _ALIGN_ITEMS_MAP$prop : props.align;
  });
  var ALIGN_CONTENT_MAP = {
    around: "space-around",
    baseline: "baseline",
    between: "space-between",
    center: "center",
    evenly: "space-evenly",
    end: "flex-end",
    start: "flex-start",
    stretch: "stretch"
  };
  var alignContentStyle = (0, import_styled_components5.css)(["align-content:", ";"], function(props) {
    var _ALIGN_CONTENT_MAP$pr;
    return (_ALIGN_CONTENT_MAP$pr = ALIGN_CONTENT_MAP[props.alignContent]) != null ? _ALIGN_CONTENT_MAP$pr : props.alignContent;
  });
  var getSize = function getSize2(theme, size) {
    return theme.global.size[size] || size;
  };
  var widthObjectStyle = function widthObjectStyle2(width, theme) {
    var result = [];
    if (width.max)
      result.push((0, import_styled_components5.css)(["max-width:", ";"], getSize(theme, width.max)));
    if (width.min)
      result.push((0, import_styled_components5.css)(["min-width:", ";"], getSize(theme, width.min)));
    if (width.width)
      result.push((0, import_styled_components5.css)(["width:", ";"], getSize(theme, width.width)));
    return result;
  };
  var widthStringStyle = function widthStringStyle2(width, theme) {
    return (0, import_styled_components5.css)(["width:", ";"], getSize(theme, width));
  };
  var widthStyle = function widthStyle2(width, theme) {
    return typeof width === "object" ? widthObjectStyle(width, theme) : widthStringStyle(width, theme);
  };
  var heightObjectStyle = function heightObjectStyle2(height, theme) {
    var result = [];
    if (height.max)
      result.push((0, import_styled_components5.css)(["max-height:", ";"], getSize(theme, height.max)));
    if (height.min)
      result.push((0, import_styled_components5.css)(["min-height:", ";"], getSize(theme, height.min)));
    if (height.width)
      result.push((0, import_styled_components5.css)(["height:", ";"], getSize(theme, height.height)));
    if (height.height)
      result.push((0, import_styled_components5.css)(["height:", ";"], getSize(theme, height.height)));
    return result;
  };
  var heightStringStyle = function heightStringStyle2(height, theme) {
    return (0, import_styled_components5.css)(["height:", ";"], getSize(theme, height));
  };
  var heightStyle = function heightStyle2(height, theme) {
    return typeof height === "object" ? heightObjectStyle(height, theme) : heightStringStyle(height, theme);
  };

  // node_modules/grommet/es6/utils/object.js
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  var isObject = function isObject2(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  };
  var deepFreeze = function deepFreeze2(obj) {
    Object.keys(obj).forEach(function(key) {
      return key && isObject(obj[key]) && Object.freeze(obj[key]);
    });
    return Object.freeze(obj);
  };
  var deepMerge = function deepMerge2(target) {
    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }
    if (!sources.length) {
      return target;
    }
    var output = _extends({}, target);
    sources.forEach(function(source) {
      if (isObject(source)) {
        Object.keys(source).forEach(function(key) {
          if (isObject(source[key])) {
            if (!output[key]) {
              output[key] = _extends({}, source[key]);
            } else {
              output[key] = deepMerge2(output[key], source[key]);
            }
          } else {
            output[key] = source[key];
          }
        });
      }
    });
    return output;
  };
  var removeUndefined = function removeUndefined2(obj) {
    var result = {};
    Object.keys(obj).forEach(function(key) {
      if (obj[key] !== void 0) {
        result[key] = obj[key];
      }
    });
    return result;
  };

  // node_modules/grommet/es6/utils/pagination.js
  var import_react = __toESM(require_react());
  var _excluded = ["data", "page", "step"];
  function _extends2() {
    _extends2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var normalizeShow = function normalizeShow2(showProp, step) {
    var page;
    if (typeof showProp === "number")
      page = Math.ceil((showProp + 1) / step);
    else if (typeof showProp === "object" && "page" in showProp)
      page = showProp.page;
    return page;
  };
  var usePagination = function usePagination2(_ref) {
    var data = _ref.data, page = _ref.page, step = _ref.step, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
    var totalPages = data ? Math.ceil(data.length / step) : 0;
    var _useState = (0, import_react.useState)(Math.min(page, totalPages) || 1), activePage = _useState[0], setActivePage = _useState[1];
    if (activePage > totalPages && (data == null ? void 0 : data.length) > 0)
      setActivePage(Math.max(totalPages, 1));
    var itemsBeginIndex = step * (activePage - 1);
    var itemsEndIndex = itemsBeginIndex + step;
    var currentItems = (0, import_react.useMemo)(function() {
      if (Array.isArray(data))
        return data.slice(itemsBeginIndex, itemsEndIndex);
      return [];
    }, [data, itemsBeginIndex, itemsEndIndex]);
    var paginationProps = _extends2({
      numberItems: data && data.length,
      onChange: function onChange2(event) {
        return setActivePage(event.page);
      },
      page: activePage,
      step
    }, rest);
    return [currentItems, paginationProps];
  };

  // node_modules/grommet/es6/utils/PortalContext.js
  var import_react2 = __toESM(require_react());
  var PortalContext = /* @__PURE__ */ import_react2.default.createContext([]);

  // node_modules/grommet/es6/utils/refs.js
  var import_react3 = __toESM(require_react());
  var useForwardedRef = function useForwardedRef2(ref) {
    var innerRef = (0, import_react3.useRef)(null);
    (0, import_react3.useImperativeHandle)(ref, function() {
      return innerRef.current;
    });
    return innerRef;
  };

  // node_modules/grommet/es6/utils/use-keyboard.js
  var import_react4 = __toESM(require_react());
  var useKeyboard = function useKeyboard2() {
    var _useState = (0, import_react4.useState)(), usingKeyboard = _useState[0], setUsingKeyboard = _useState[1];
    (0, import_react4.useEffect)(function() {
      var onMouseDown = function onMouseDown2() {
        return setUsingKeyboard(false);
      };
      var onKeyDown = function onKeyDown2() {
        return setUsingKeyboard(true);
      };
      document.addEventListener("mousedown", onMouseDown);
      document.addEventListener("keydown", onKeyDown);
      return function() {
        document.removeEventListener("mousedown", onMouseDown);
        document.removeEventListener("keydown", onKeyDown);
      };
    }, []);
    return usingKeyboard;
  };

  // node_modules/grommet/es6/themes/base.js
  var import_Actions = __toESM(require_Actions());
  var import_AssistListening = __toESM(require_AssistListening());
  var import_CircleInformation = __toESM(require_CircleInformation());
  var import_ClosedCaption = __toESM(require_ClosedCaption());
  var import_Expand = __toESM(require_Expand());
  var import_FormClose = __toESM(require_FormClose());
  var import_FormDown = __toESM(require_FormDown());
  var import_FormNext = __toESM(require_FormNext());
  var import_FormPrevious = __toESM(require_FormPrevious());
  var import_FormUp = __toESM(require_FormUp());
  var import_Next = __toESM(require_Next());
  var import_Pause = __toESM(require_Pause());
  var import_Play = __toESM(require_Play());
  var import_FormPin = __toESM(require_FormPin());
  var import_Previous = __toESM(require_Previous());
  var import_StatusCriticalSmall = __toESM(require_StatusCriticalSmall());
  var import_StatusGoodSmall = __toESM(require_StatusGoodSmall());
  var import_StatusWarningSmall = __toESM(require_StatusWarningSmall());
  var import_StatusUnknownSmall = __toESM(require_StatusUnknownSmall());
  var import_Subtract = __toESM(require_Subtract());
  var import_Volume = __toESM(require_Volume());
  var import_VolumeLow = __toESM(require_VolumeLow());
  var import_base = __toESM(require_base());
  function _extends3() {
    _extends3 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends3.apply(this, arguments);
  }
  var brandColor = "#7D4CDB";
  var accentColors = ["#6FFFB0", "#FD6FFF", "#81FCED", "#FFCA58"];
  var neutralColors = ["#00873D", "#3D138D", "#00739D", "#A2423D"];
  var statusColors = {
    critical: "#FF4040",
    error: "#FF4040",
    warning: "#FFAA15",
    ok: "#00C781",
    unknown: "#CCCCCC",
    disabled: "#CCCCCC"
  };
  var darkColors = ["#333333", "#555555", "#777777", "#999999", "#999999", "#999999"];
  var lightColors = ["#F8F8F8", "#F2F2F2", "#EDEDED", "#DADADA", "#DADADA", "#DADADA"];
  var focusColor = accentColors[0];
  var colors = {
    active: "rgba(221, 221, 221, 0.5)",
    "background-back": {
      dark: "#33333308",
      light: "#EDEDED"
    },
    "background-front": {
      dark: "#444444",
      light: "#FFFFFF"
    },
    "background-contrast": {
      light: "#33333310",
      dark: "#FFFFFF18"
    },
    "active-background": "background-contrast",
    "active-text": "text-strong",
    black: "#000000",
    border: {
      dark: "rgba(255, 255, 255, 0.33)",
      light: "rgba(0, 0, 0, 0.33)"
    },
    brand: brandColor,
    control: {
      dark: "accent-1",
      light: "brand"
    },
    focus: focusColor,
    "graph-0": "accent-1",
    "graph-1": "neutral-1",
    "graph-2": "neutral-2",
    "graph-3": "neutral-3",
    "graph-4": "neutral-4",
    placeholder: "#AAAAAA",
    selected: "brand",
    text: {
      dark: "#f8f8f8",
      light: "#444444"
    },
    "text-strong": {
      dark: "#FFFFFF",
      light: "#000000"
    },
    "text-weak": {
      dark: "#CCCCCC",
      light: "#555555"
    },
    "text-xweak": {
      dark: "#BBBBBB",
      light: "#666666"
    },
    icon: {
      dark: "#f8f8f8",
      light: "#666666"
    },
    "selected-background": "brand",
    "selected-text": "text-strong",
    white: "#FFFFFF"
  };
  var colorArray = function colorArray2(array, prefix) {
    return array.forEach(function(color, index) {
      colors[prefix + "-" + (index + 1)] = color;
    });
  };
  colorArray(accentColors, "accent");
  colorArray(darkColors, "dark");
  colorArray(lightColors, "light");
  colorArray(neutralColors, "neutral");
  Object.keys(statusColors).forEach(function(color) {
    colors["status-" + color] = statusColors[color];
  });
  var generate = function generate2(baseSpacing2, scale) {
    if (baseSpacing2 === void 0) {
      baseSpacing2 = 24;
    }
    if (scale === void 0) {
      scale = 6;
    }
    var baseFontSize = baseSpacing2 * 0.75;
    var fontScale = baseSpacing2 / scale;
    var fontSizing = function fontSizing2(factor) {
      return {
        size: baseFontSize + factor * fontScale + "px",
        height: baseSpacing2 + factor * fontScale + "px",
        // maxWidth chosen to be ~50 characters wide
        // see: https://ux.stackexchange.com/a/34125
        maxWidth: baseSpacing2 * (baseFontSize + factor * fontScale) + "px"
      };
    };
    var borderWidth = 2;
    var controlBorderWidth = 1;
    var result = deepMerge(import_base.base, {
      global: {
        active: {
          background: {
            color: "active",
            opacity: "medium"
          },
          color: {
            dark: "white",
            light: "black"
          }
        },
        animation: {
          duration: "1s",
          jiggle: {
            duration: "0.1s"
          }
        },
        // backgrounds: undefined,
        borderSize: {
          xsmall: "1px",
          small: "2px",
          medium: baseSpacing2 / 6 + "px",
          // 4
          large: baseSpacing2 / 2 + "px",
          // 12
          xlarge: baseSpacing2 + "px"
          // 24
        },
        breakpoints: {
          small: {
            value: baseSpacing2 * 32,
            // 768
            borderSize: {
              xsmall: "1px",
              small: "2px",
              medium: baseSpacing2 / 6 + "px",
              // 4
              large: baseSpacing2 / 4 + "px",
              // 6
              xlarge: baseSpacing2 / 2 + "px"
              // 12
            },
            edgeSize: {
              none: "0px",
              hair: "1px",
              // for Chart
              xxsmall: "2px",
              xsmall: baseSpacing2 / 8 + "px",
              // 3
              small: baseSpacing2 / 4 + "px",
              // 6
              medium: baseSpacing2 / 2 + "px",
              // 12
              large: baseSpacing2 + "px",
              // 24
              xlarge: baseSpacing2 * 2 + "px"
              // 48
            },
            size: {
              xxsmall: baseSpacing2 + "px",
              // 24
              xsmall: baseSpacing2 * 2 + "px",
              // 48
              small: baseSpacing2 * 4 + "px",
              // 96
              medium: baseSpacing2 * 8 + "px",
              // 192
              large: baseSpacing2 * 16 + "px",
              // 384
              xlarge: baseSpacing2 * 32 + "px",
              // 768
              full: "100%"
            }
          },
          medium: {
            value: baseSpacing2 * 64
            // 1536
          },
          large: {}
          // anything above 'medium'
        },
        // Breakpoints used at Server Side Rendering for the initial rendering
        // These values correspond to the theme breakpoints
        deviceBreakpoints: {
          phone: "small",
          tablet: "medium",
          computer: "large"
        },
        colors,
        control: {
          border: {
            width: controlBorderWidth + "px",
            radius: "4px",
            color: "border"
          },
          disabled: {
            opacity: 0.3
          }
        },
        // The time to wait after the user stopped typing, measured in ms.
        // A half second (500ms) debounce can be a helpful starting point.
        // You want to give the user time to fill out a field, but capture
        // their attention before they move on past it. 2 second (2000ms)
        // might be too long depending on how fast people type, and 200ms
        // would be an eye blink
        debounceDelay: 500,
        drop: {
          // intelligentMargin: undefined,
          background: {
            dark: "black",
            light: "white"
          },
          border: {
            radius: "0px"
          },
          // margin: undefined
          shadowSize: "small",
          // shadowSize is deprecated, use 'elevation'
          zIndex: "20"
        },
        edgeSize: {
          none: "0px",
          hair: "1px",
          // for Chart
          xxsmall: baseSpacing2 / 8 + "px",
          // 3
          xsmall: baseSpacing2 / 4 + "px",
          // 6
          small: baseSpacing2 / 2 + "px",
          // 12
          medium: baseSpacing2 + "px",
          // 24
          large: baseSpacing2 * 2 + "px",
          // 48
          xlarge: baseSpacing2 * 4 + "px",
          // 96
          responsiveBreakpoint: "small"
        },
        elevation: {
          light: {
            none: "none",
            xsmall: "0px 1px 2px rgba(0, 0, 0, 0.20)",
            small: "0px 2px 4px rgba(0, 0, 0, 0.20)",
            medium: "0px 4px 8px rgba(0, 0, 0, 0.20)",
            large: "0px 8px 16px rgba(0, 0, 0, 0.20)",
            xlarge: "0px 12px 24px rgba(0, 0, 0, 0.20)"
          },
          dark: {
            none: "none",
            xsmall: "0px 2px 2px rgba(255, 255, 255, 0.40)",
            small: "0px 4px 4px rgba(255, 255, 255, 0.40)",
            medium: "0px 6px 8px rgba(255, 255, 255, 0.40)",
            large: "0px 8px 16px rgba(255, 255, 255, 0.40)",
            xlarge: "0px 12px 24px rgba(255, 255, 255, 0.40)"
          }
        },
        focus: {
          // shadow or outline are required for accessibility
          border: {
            // remove to only have shadow
            color: "focus"
          },
          // outline: { color: undefined, size: undefined },
          shadow: {
            color: "focus",
            size: "2px"
          }
        },
        font: _extends3({}, fontSizing(0)),
        hover: {
          background: {
            color: "active",
            opacity: "medium"
          },
          color: {
            dark: "white",
            light: "black"
          }
        },
        input: {
          padding: {
            horizontal: parseMetricToNum(baseSpacing2 / 2 + "px") - parseMetricToNum(controlBorderWidth + "px") + "px",
            vertical: parseMetricToNum(baseSpacing2 / 2 + "px") - parseMetricToNum(controlBorderWidth + "px") + "px"
          },
          font: {
            // size: undefined,
            // height: undefined,
            weight: 600
          }
          // deprecate in v3
          // weight: undefined,
        },
        opacity: {
          strong: 0.8,
          medium: 0.4,
          weak: 0.1
        },
        selected: {
          background: "selected",
          color: "white"
        },
        spacing: baseSpacing2 + "px",
        size: {
          xxsmall: baseSpacing2 * 2 + "px",
          // 48
          xsmall: baseSpacing2 * 4 + "px",
          // 96
          small: baseSpacing2 * 8 + "px",
          // 192
          medium: baseSpacing2 * 16 + "px",
          // 384
          large: baseSpacing2 * 32 + "px",
          // 768
          xlarge: baseSpacing2 * 48 + "px",
          // 1152
          xxlarge: baseSpacing2 * 64 + "px",
          // 1536
          full: "100%"
        }
      },
      accordion: {
        panel: {
          // border: {
          //   side: 'bottom',
          //   color: 'border',
          // },
        },
        border: {
          side: "bottom",
          color: "border"
        },
        heading: {
          level: "4"
          // level ranges from 1-6
          // margin: undefined
        },
        hover: {
          // background: undefined,
          color: {
            dark: "light-4",
            light: "dark-3"
          },
          // deprecated
          heading: {
            color: {
              dark: "light-4",
              light: "dark-3"
            }
          }
        },
        icons: {
          collapse: import_FormUp.FormUp,
          expand: import_FormDown.FormDown
          // color: { dark: undefined, light: undefined },
        }
      },
      anchor: {
        textDecoration: "none",
        fontWeight: 600,
        color: {
          dark: "accent-1",
          light: "brand"
        },
        gap: "small",
        hover: {
          textDecoration: "underline"
          // fontWeight: undefined,
          // extend: undefined,
        }
        // size: {
        //   medium: {
        //     color: undefined,
        //     fontWeight: undefined,
        //     textDecoration: undefined,
        //   },
        // },
        // extend: undefined,
      },
      avatar: {
        // extend: undefined,
        size: {
          xsmall: baseSpacing2 * 0.75 + "px",
          // 18px
          small: baseSpacing2 + "px",
          // 24px
          medium: baseSpacing2 * 2 + "px",
          // default 48px
          large: baseSpacing2 * 3 + "px",
          // 72px
          xlarge: baseSpacing2 * 4 + "px",
          // 96px
          "2xl": baseSpacing2 * 5 + "px",
          // 120px
          "3xl": baseSpacing2 * 6 + "px",
          // 144px
          "4xl": baseSpacing2 * 7 + "px",
          // 168px
          "5xl": baseSpacing2 * 8 + "px"
          // 192px
        },
        text: {
          size: {
            xsmall: "small",
            // 14px
            small: "medium",
            // 18px
            medium: "large",
            // 22px
            large: "xlarge",
            // 26px
            xlarge: "xxlarge",
            // 34px
            "2xl": "3xl",
            // 42px
            "3xl": "4xl",
            // 54px
            "4xl": "5xl",
            // 70px
            "5xl": "6xl"
            // 90px
          }
          // fontWeight: undefined,
          // extend: undefined
        }
      },
      box: {
        responsiveBreakpoint: "small"
        // when we switch rows to columns
        // extend: undefined,
      },
      button: {
        badge: {
          container: {
            background: "brand"
            // pad: undefined,
            // extend: undefined,
          },
          size: {
            medium: baseSpacing2 + "px"
            // 24px
          },
          text: {
            size: {
              medium: "small"
              // 14px
            }
          }
        },
        gap: "small",
        size: {
          small: {
            border: {
              radius: baseSpacing2 * 0.75 + "px"
            },
            pad: {
              vertical: baseSpacing2 / 4 - borderWidth + "px",
              // 4px
              horizontal: baseSpacing2 - borderWidth * 2 + "px"
              // 20px,
            }
            // iconOnly: {
            //   pad: undefined,
            // },
          },
          medium: {
            border: {
              radius: baseSpacing2 * 0.75 + "px"
              // 18px
            },
            pad: {
              vertical: baseSpacing2 / 4 - borderWidth + "px",
              // 4px
              horizontal: baseSpacing2 - borderWidth + "px"
              // 22px
            }
            // iconOnly: {
            //   pad: undefined,
            // },
          },
          large: {
            border: {
              radius: baseSpacing2 + "px"
              // 24px
            },
            pad: {
              vertical: baseSpacing2 / 4 + borderWidth + "px",
              // 8px
              horizontal: baseSpacing2 + borderWidth * 4 + "px"
              // 32px,
            }
            // iconOnly: {
            //   pad: undefined,
            // },
          }
        },
        border: {
          // color: { dark: undefined, light: undefined }
          width: borderWidth + "px",
          radius: baseSpacing2 * 0.75 + "px"
        },
        // color: { dark: undefined, light: undefined }
        // default: {
        //   background: undefined,
        //   border: undefined,
        //   color: undefined,
        //   direction: undefined,
        //   font: {
        //     size: undefined,
        //     weight: undefined,
        //   },
        //   icon: undefined,
        //   padding: {
        //     vertical: undefined,
        //     horizontal: undefined,
        //   },
        //   reverse: undefined,
        //   extend: undefined,
        // },
        // primary: {
        //   font: {
        //     size: undefined,
        //     weight: undefined,
        //   },
        //   background: undefined,
        //   border: undefined,
        //   color: undefined,
        //   direction: undefined,
        //   icon: undefined,
        //   padding: {
        //     vertical: undefined,
        //     horizontal: undefined,
        //   },
        //   reverse: undefined,
        //   extend: undefined,
        // },
        // secondary: {
        //   font: {
        //     size: undefined,
        //     weight: undefined,
        //   },
        //   background: undefined,
        //   border: undefined,
        //   color: undefined,
        //   direction: undefined,
        //   icon: undefined,
        //   padding: {
        //     vertical: undefined,
        //     horizontal: undefined,
        //   },
        //   reverse: undefined,
        //   extend: undefined,
        // },
        // option: {
        //   background: undefined,
        //   border: undefined,
        //   color: undefined,
        //   direction: undefined,
        //   icon: undefined,
        //   padding: {
        //     vertical: undefined,
        //     horizontal: undefined,
        //   },
        //   reverse: undefined,
        //   extend: undefined,
        // },
        active: {
          background: "active-background",
          //   border: undefined,
          color: "active-text"
          //   extend: undefined,
          //   default: {},
          //   primary: {},
          //   secondary: {},
        },
        disabled: {
          //   background: undefined,
          //   border: undefined,
          //   color: undefined,
          opacity: 0.3
          //   extend: undefined,
          //   default: {},
          //   primary: {},
          //   secondary: {},
        },
        // hover: {
        //   background: undefined,
        //   border: undefined,
        //   color: undefined,
        //   extend: undefined,
        //   default: {},
        //   primary: {},
        //   secondary: {},
        // },
        padding: {
          vertical: baseSpacing2 / 4 - borderWidth + "px",
          horizontal: baseSpacing2 - borderWidth + "px"
        },
        transition: {
          timing: "ease-in-out",
          duration: 0.1,
          properties: ["color", "background-color", "border-color", "box-shadow"]
        },
        skeleton: {
          width: {
            min: "100px"
          }
        }
      },
      calendar: {
        // daySize must align with global.size
        small: {
          // title: {},
          fontSize: baseFontSize - fontScale + "px",
          lineHeight: 1.375,
          daySize: baseSpacing2 * 8 / 7 + "px",
          slideDuration: "0.2s"
        },
        medium: {
          // title: {},
          fontSize: baseFontSize + "px",
          lineHeight: 1.45,
          daySize: baseSpacing2 * 16 / 7 + "px",
          slideDuration: "0.5s"
        },
        large: {
          // title: {},
          fontSize: baseFontSize + 3 * fontScale + "px",
          lineHeight: 1.11,
          daySize: baseSpacing2 * 32 / 7 + "px",
          slideDuration: "0.8s"
        },
        icons: {
          previous: import_Previous.Previous,
          next: import_Next.Next,
          small: {
            previous: import_FormPrevious.FormPrevious,
            next: import_FormNext.FormNext
          }
        },
        heading: {
          level: "4"
        }
        // level ranges from 1-6
      },
      card: {
        container: {
          round: "small",
          elevation: "small"
          // extend: undefined,
        },
        // hover: {
        //   container: {
        //     elevation: undefined,
        //   },
        // },
        header: {},
        body: {},
        footer: {}
      },
      cards: {
        container: {
          // any box props
          gap: "xsmall"
          // extend: undefined,
        }
      },
      carousel: {
        icons: {
          current: import_Subtract.Subtract,
          next: import_Next.Next,
          previous: import_Previous.Previous
          // color: { dark: undefined, light: undefined },
        },
        animation: {
          duration: 1e3
        },
        disabled: {
          icons: {
            // color: { dark: undefined, light: undefined },
          }
        }
      },
      chart: {
        color: "graph-0"
        // extend: undefined,
      },
      checkBox: {
        border: {
          color: {
            dark: "rgba(255, 255, 255, 0.5)",
            light: "rgba(0, 0, 0, 0.15)"
          },
          width: "2px"
        },
        check: {
          // extend: undefined,
          radius: "4px",
          thickness: "4px"
        },
        label: {
          align: "center"
        },
        // color: { dark: undefined, light: undefined },
        // extend: undefined,
        // gap: undefined
        hover: {
          border: {
            color: {
              dark: "white",
              light: "black"
            }
          }
          // background: undefined,
          // extend: undefined,
        },
        icon: {
          // size: undefined,
          // extend: undefined,
        },
        icons: {
          // checked: undefined,
          // indeterminate: undefined,
        },
        // pad: undefined,
        size: baseSpacing2 + "px",
        toggle: {
          // background: undefined
          color: {
            dark: "#d9d9d9",
            light: "#d9d9d9"
          },
          knob: {
            // extend: undefined,
          },
          radius: baseSpacing2 + "px",
          size: baseSpacing2 * 2 + "px"
          // extend: undefined,
        }
      },
      checkBoxGroup: {
        // container: {
        //   // any box props
        //   extend: undefined,
        // },
      },
      clock: {
        analog: {
          // extend: undefined,
          hour: {
            color: {
              dark: "light-2",
              light: "dark-3"
            },
            width: baseSpacing2 / 3 + "px",
            size: baseSpacing2 + "px",
            shape: "round"
          },
          minute: {
            color: {
              dark: "light-4",
              light: "dark-3"
            },
            width: baseSpacing2 / 6 + "px",
            size: Math.round(baseSpacing2 / 2) + "px",
            shape: "round"
          },
          second: {
            color: {
              dark: "accent-1",
              light: "accent-1"
            },
            width: baseSpacing2 / 8 + "px",
            size: Math.round(baseSpacing2 / 2.666) + "px",
            shape: "round"
          },
          size: {
            xsmall: baseSpacing2 * 2 + "px",
            small: baseSpacing2 * 3 + "px",
            medium: baseSpacing2 * 4 + "px",
            large: baseSpacing2 * 6 + "px",
            xlarge: baseSpacing2 * 9 + "px",
            xxlarge: baseSpacing2 * 12 + "px",
            huge: baseSpacing2 * 12 + "px"
            // kept for backwards compatibility
          }
        },
        digital: {
          text: {
            xsmall: {
              size: baseFontSize - 2 * fontScale + "px",
              height: 1.5
            },
            small: {
              size: baseFontSize - fontScale + "px",
              height: 1.43
            },
            medium: {
              size: baseFontSize + "px",
              height: 1.375
            },
            large: {
              size: baseFontSize + fontScale + "px",
              height: 1.167
            },
            xlarge: {
              size: baseFontSize + 2 * fontScale + "px",
              height: 1.1875
            },
            xxlarge: {
              size: baseFontSize + 4 * fontScale + "px",
              height: 1.125
            }
          }
        }
      },
      collapsible: {
        minSpeed: 200,
        baseline: 500
      },
      dateInput: {
        container: {
          round: "xxsmall"
        }
        // icon: {
        //   size: undefined,
        // },
      },
      dataTable: {
        // body: {
        //   extend: undefined,
        // },
        pinned: {
          // body: {
          //    background: undefined,
          //    extend: undefined,
          // },
          header: {
            background: {
              opacity: "strong"
            }
            //  extend: undefined,
          },
          footer: {
            background: {
              opacity: "strong"
            }
            //  extend: undefined,
          }
        },
        container: {
          // any box props
          gap: "xsmall"
          // extend: undefined,
        },
        groupHeader: {
          background: {
            dark: "dark-2",
            light: "light-2"
          },
          border: {
            side: "bottom",
            size: "xsmall"
          },
          pad: {
            horizontal: "small",
            vertical: "xsmall"
          }
        },
        groupEnd: {
          border: {
            side: "bottom",
            size: "xsmall"
          }
        },
        header: {
          // background: undefined,
          // border: undefined,
          // color: undefined,
          // extend: undefined,
          // font: {
          //   weight: undefined,
          //   size: undefined,
          // },
          gap: "small",
          // hover: {
          //   background: undefined,
          // },
          // pad: undefined,
          units: {
            color: "text-xweak",
            margin: {
              left: "xsmall"
            },
            alignSelf: "end"
          }
        },
        icons: {
          ascending: import_FormDown.FormDown,
          contract: import_FormUp.FormUp,
          descending: import_FormUp.FormUp,
          expand: import_FormDown.FormDown
          // sortable: undefined,
        },
        primary: {
          weight: "bold"
        },
        resize: {
          border: {
            color: "border",
            side: "end"
          }
          // hover: {
          //   border: {
          //     color: undefined,
          //     side: undefined,
          //     size: undefined,
          //   },
          // },
        }
      },
      diagram: {
        // extend: undefined,
        line: {
          color: "graph-0"
        }
      },
      // drop: {
      //   extend: undefined,
      //   maxHeight: undefined,
      // },
      fileInput: {
        // background: {},
        border: {
          // color: undefined,
          side: "all",
          size: "small",
          style: "dashed"
        },
        dragOver: {
          border: {
            color: "control"
          }
          // extend: undefined,
        },
        hover: {
          border: {
            color: "brand"
          }
          // extend: undefined,
        },
        icons: {
          remove: import_FormClose.FormClose
        },
        // pad: {},
        label: {
          margin: "small"
          // extend: undefined,
        },
        message: {
          margin: "small"
          // extend: undefined,
        }
        // extend: undefined,
      },
      formField: {
        border: {
          color: "border",
          error: {
            color: {
              dark: "white",
              light: "status-critical"
            }
          },
          position: "inner",
          side: "bottom"
        },
        // checkBox: {
        //   pad: undefined,
        // },
        content: {
          // margin: undefined,
          pad: "small"
        },
        disabled: {
          background: {
            color: "status-disabled",
            opacity: "medium"
          }
          // border: {
          //   color: undefined,
          // },
          // label: {
          //   color: undefined,
          // },
        },
        // focus: {
        //   background: {
        //     color: undefined,
        //   },
        //   border: {
        //     color: undefined,
        //   },
        // },
        error: {
          color: "status-critical",
          margin: {
            vertical: "xsmall",
            horizontal: "small"
          }
          // background: undefined,
          // container: {}, // any Box props
          // icon: undefined,
        },
        // extend: undefined,
        help: {
          color: "dark-3",
          margin: {
            start: "small"
          }
        },
        info: {
          color: "text-xweak",
          margin: {
            vertical: "xsmall",
            horizontal: "small"
          }
          // container: {}, // any Box props
          // icon: undefined,
        },
        label: {
          margin: {
            vertical: "xsmall",
            horizontal: "small"
          }
          // requiredIndicator: undefined,
        },
        margin: {
          bottom: "small"
        },
        // round: undefined,
        survey: {
          label: {
            margin: {
              bottom: "xsmall"
            },
            size: "medium",
            weight: 400
          }
        }
      },
      grommet: {
        // extend: undefined
      },
      header: {
        sticky: {
          zIndex: "20"
        }
      },
      heading: {
        // color: undefined,
        font: {
          // family: undefined
        },
        level: {
          1: {
            font: {
              // family: undefined,
              // weight: undefined,
            },
            small: _extends3({}, fontSizing(4)),
            medium: _extends3({}, fontSizing(8)),
            large: _extends3({}, fontSizing(16)),
            xlarge: _extends3({}, fontSizing(24))
          },
          2: {
            font: {
              // family: undefined,
              // weight: undefined,
            },
            small: _extends3({}, fontSizing(2)),
            medium: _extends3({}, fontSizing(4)),
            large: _extends3({}, fontSizing(8)),
            xlarge: _extends3({}, fontSizing(12))
          },
          3: {
            font: {
              // family: undefined,
              // weight: undefined,
            },
            small: _extends3({}, fontSizing(1)),
            medium: _extends3({}, fontSizing(2)),
            large: _extends3({}, fontSizing(4)),
            xlarge: _extends3({}, fontSizing(6))
          },
          4: {
            font: {
              // family: undefined,
              // weight: undefined,
            },
            small: _extends3({}, fontSizing(0)),
            medium: _extends3({}, fontSizing(0)),
            large: _extends3({}, fontSizing(0)),
            xlarge: _extends3({}, fontSizing(0))
          },
          5: {
            font: {
              // family: undefined,
              // weight: undefined,
            },
            small: _extends3({}, fontSizing(-0.5)),
            medium: _extends3({}, fontSizing(-0.5)),
            large: _extends3({}, fontSizing(-0.5)),
            xlarge: _extends3({}, fontSizing(-0.5))
          },
          6: {
            font: {
              // family: undefined,
              // weight: undefined,
            },
            small: _extends3({}, fontSizing(-1)),
            medium: _extends3({}, fontSizing(-1)),
            large: _extends3({}, fontSizing(-1)),
            xlarge: _extends3({}, fontSizing(-1))
          }
        },
        responsiveBreakpoint: "small",
        // when we scale the font size down
        weight: 600,
        skeleton: {
          width: {
            min: "150px",
            max: "200px"
          }
        }
      },
      layer: {
        background: {
          dark: "black",
          light: "white"
        },
        border: {
          radius: "4px"
          // intelligentRounding: undefined,
        },
        container: {
          // elevation: undefined,
          zIndex: "20"
        },
        // extend: undefined,
        overlay: {
          background: "rgba(0, 0, 0, 0.5)"
          // backdropFilter: undefined,
        },
        responsiveBreakpoint: "small",
        // when Layer takes over the full screen
        zIndex: "20"
      },
      list: {
        container: {
          // any box props
          gap: "xsmall"
          // extend: undefined,
        },
        item: {
          // background: undefined,
          border: "horizontal",
          disabled: {
            color: "status-disabled",
            cursor: "default"
          },
          pinned: {
            background: "background-contrast",
            icon: {
              size: "medium",
              pad: "small"
            }
          },
          pad: {
            horizontal: "medium",
            vertical: "small"
          }
          // extend: undefined,
        },
        icons: {
          down: import_FormDown.FormDown,
          up: import_FormUp.FormUp,
          pin: import_FormPin.FormPin
        }
        // extend: undefined,
      },
      maskedInput: {
        // container: {
        //   extend: undefined,
        // },
        // extend: undefined,
        // disabled: { opacity: undefined },
      },
      menu: {
        // background: undefined,
        // item: undefined,
        // extend: undefined,
        drop: {
          align: {
            top: "top",
            left: "left"
          }
          // any drop props
        },
        group: {
          container: {
            pad: {
              vertical: "xsmall"
            }
          },
          separator: {
            color: "border",
            size: "xsmall",
            pad: {
              horizontal: "small"
            }
          }
        },
        icons: {
          down: import_FormDown.FormDown
          // up: undefined,
          // color: { dark: undefined, light: undefined },
        }
      },
      meter: {
        color: "graph-0"
        // colors: [] || colors: ['graph-0', 'graph-1', 'graph-2', 'graph-3'],
        // extend: undefined,
      },
      nameValueList: {
        gap: {
          column: "large",
          row: "small"
        },
        pair: {
          column: {
            gap: {
              column: "large",
              row: "medium"
            }
          }
        },
        name: {
          width: "small"
        },
        value: {
          width: "medium"
        }
      },
      nameValuePair: {
        column: {
          gap: "xxsmall"
        },
        name: {
          // any text props
          color: "text",
          weight: "bold"
        },
        value: {
          // any text props
          color: "text"
        }
      },
      notification: {
        actions: {
          // any anchor props
        },
        direction: "column",
        container: {
          // any box props
          round: "xsmall",
          pad: {
            horizontal: "small",
            vertical: "xsmall"
          },
          background: {
            color: "background-front"
          }
        },
        global: {
          direction: "row",
          container: {
            // any box props
            round: "none",
            pad: {
              horizontal: "large",
              vertical: "xsmall"
            }
          }
        },
        toast: {
          // direction: undefined,
          container: {
            // any box props
            elevation: "medium",
            width: "medium"
          },
          layer: {
            position: "top",
            margin: "medium"
          },
          time: 8e3
        },
        iconContainer: {
          // any box props
          pad: {
            right: "small"
          },
          flex: false
        },
        textContainer: {
          // any box props
          gap: "medium"
        },
        title: {
          // any text props
          weight: "bold"
        },
        message: {
          // any text props
          margin: "none"
        },
        close: {
          icon: import_FormClose.FormClose
        },
        critical: {
          icon: import_StatusCriticalSmall.StatusCriticalSmall,
          background: {
            color: "status-critical",
            opacity: "weak"
          },
          color: "status-critical",
          // global: {},
          toast: {
            background: "background-front"
          }
        },
        warning: {
          icon: import_StatusWarningSmall.StatusWarningSmall,
          background: {
            color: "status-warning",
            opacity: "weak"
          },
          color: "status-warning",
          // global: {},
          toast: {
            background: "background-front"
          }
        },
        normal: {
          icon: import_StatusGoodSmall.StatusGoodSmall,
          background: {
            color: "status-ok",
            opacity: "weak"
          },
          color: "status-ok",
          // global: {},
          toast: {
            background: "background-front"
          }
        },
        info: {
          icon: import_CircleInformation.CircleInformation,
          background: "background-contrast",
          color: "text-strong",
          // global: {},
          toast: {
            background: "background-front"
          }
        },
        unknown: {
          icon: import_StatusUnknownSmall.StatusUnknownSmall,
          background: {
            color: "status-unknown",
            opacity: "weak"
          },
          color: "status-unknown",
          // global: {},
          toast: {
            background: "background-front"
          }
        },
        // deprecate "undefined" in v3
        // and if undefined, no icon
        undefined: {
          icon: import_StatusUnknownSmall.StatusUnknownSmall,
          // background: undefined,
          color: "status-unknown"
          // global: {},
          // toast: {},
        }
      },
      page: {
        wide: {
          alignSelf: "center",
          width: {
            min: "medium",
            max: "xxlarge"
          },
          small: {
            pad: {
              horizontal: "large"
            }
          },
          medium: {
            pad: {
              horizontal: "medium"
            }
          },
          large: {
            pad: {
              horizontal: "large"
            }
          }
        },
        narrow: {
          alignSelf: "center",
          width: {
            min: "medium",
            max: "large"
          },
          small: {
            pad: {
              horizontal: "large"
            }
          },
          medium: {
            pad: {
              horizontal: "medium"
            }
          },
          large: {
            pad: {
              horizontal: "large"
            }
          }
        },
        full: {
          alignSelf: "start",
          width: {
            min: "medium",
            max: "100%"
          },
          small: {
            pad: {
              horizontal: "large"
            }
          },
          medium: {
            pad: {
              horizontal: "medium"
            }
          },
          large: {
            pad: {
              horizontal: "large"
            }
          }
        }
      },
      pageHeader: {
        actions: {
          // any box props
          align: "end"
        },
        pad: {
          top: "large",
          bottom: "medium"
        },
        parent: {
          // any box props
          align: "start"
        },
        responsive: {
          actions: {
            // any box props
            align: "start",
            pad: {
              top: "small"
            }
          },
          areas: [["parent"], ["title"], ["subtitle"], ["actions"]],
          breakpoints: ["small"],
          columns: ["auto"],
          rows: ["auto"]
          // gap: undefined,
        },
        subtitle: {
          // any paragraph props
          margin: "none"
        },
        title: {
          // any heading props
          margin: "none",
          fill: true
        },
        size: {
          small: {
            pad: {
              top: "medium",
              bottom: "small"
            },
            subtitle: {
              size: "small"
            },
            title: {
              size: "small"
            }
          },
          // medium: {
          //   // pad: undefined,
          //   // subtitle: {},
          //   // title: {},
          // },
          large: {
            pad: {
              top: "xlarge",
              bottom: "large"
            },
            subtitle: {
              size: "large"
            },
            title: {
              size: "large"
            }
          }
        },
        small: {
          areas: [["parent", "parent"], ["title", "actions"], ["subtitle", "actions"]],
          columns: [["small", "flex"], "auto"],
          rows: ["auto", "auto", "auto"],
          gap: {
            row: "xsmall",
            column: "large"
          }
        },
        medium: {
          areas: [["parent", "parent"], ["title", "actions"], ["subtitle", "actions"]],
          columns: [["medium", "flex"], "auto"],
          rows: ["auto", "auto", "auto"],
          gap: {
            row: "xsmall",
            column: "medium"
          }
        },
        large: {
          areas: [["parent", "parent"], ["title", "actions"], ["subtitle", "actions"]],
          columns: [["medium", "flex"], "auto"],
          rows: ["auto", "auto", "auto"],
          gap: {
            row: "xsmall",
            column: "large"
          }
        }
      },
      pagination: {
        button: {
          active: {
            background: {
              color: "active-background"
            }
          },
          color: "text-strong",
          hover: {
            background: {
              color: "background-contrast"
            },
            color: void 0
          },
          size: {
            small: {
              border: {
                radius: baseSpacing2 / 8 + "px",
                // 3
                width: "2px"
              },
              pad: {
                vertical: "4px",
                horizontal: "4px"
              },
              font: _extends3({}, fontSizing(-1)),
              height: baseSpacing2 * 1.25 + "px",
              width: baseSpacing2 * 1.25 + "px"
            },
            medium: {
              border: {
                radius: baseSpacing2 / 6 + "px",
                // 4
                width: "2px"
              },
              pad: {
                vertical: "4px",
                horizontal: "4px"
              },
              font: _extends3({}, fontSizing(0)),
              height: baseSpacing2 * 1.5 + "px",
              width: baseSpacing2 * 1.5 + "px"
            },
            large: {
              border: {
                radius: baseSpacing2 / 4 + "px",
                // 6
                width: "2px"
              },
              pad: {
                vertical: "4px",
                horizontal: "4px"
              },
              font: _extends3({}, fontSizing(1)),
              height: baseSpacing2 * 2 + "px",
              width: baseSpacing2 * 2 + "px"
            }
          }
        },
        // container: {
        //   // any box props,
        //   extend: undefined,
        // },
        controls: {
          align: "center",
          direction: "row",
          gap: "xxsmall",
          margin: "none",
          pad: "none"
        },
        icons: {
          // color: undefined,
          next: import_Next.Next,
          previous: import_Previous.Previous
        }
      },
      paragraph: {
        font: {
          // family: undefined
        },
        small: _extends3({}, fontSizing(-1)),
        medium: _extends3({}, fontSizing(0)),
        large: _extends3({}, fontSizing(1)),
        xlarge: _extends3({}, fontSizing(2)),
        xxlarge: _extends3({}, fontSizing(4))
      },
      thumbsRating: {
        // dislike: {
        //   color: undefined,
        // },
        // like: {
        //   color: undefined,
        // },
      },
      spinner: {
        container: {
          animation: "rotateRight",
          color: "brand",
          pad: "small",
          round: "full",
          size: "small"
        },
        // icon: undefined
        size: {
          xsmall: baseSpacing2 * 0.75 + "px",
          small: baseSpacing2 + "px",
          // default 24
          medium: baseSpacing2 * 2 + "px",
          large: baseSpacing2 * 3 + "px",
          xlarge: baseSpacing2 * 4 + "px"
        }
      },
      radioButton: {
        border: {
          color: {
            dark: "rgba(255, 255, 255, 0.5)",
            light: "rgba(0, 0, 0, 0.15)"
          },
          width: "2px"
        },
        check: {
          radius: "100%"
          // background: {
          //  color: undefined,
          // },
          // color: { dark: undefined, light: undefined },
          // extend: undefined,
        },
        // color: undefined,
        hover: {
          // background: {
          //   color: undefined,
          // },
          border: {
            color: {
              dark: "white",
              light: "black"
            }
          }
        },
        icon: {
          // size: undefined,
          // extend: undefined,
        },
        icons: {
          // circle: undefined,
        },
        gap: "small",
        size: baseSpacing2 + "px",
        font: {
          // weight: undefined,
        },
        container: {
          // extend: undefined
        }
      },
      radioButtonGroup: {
        // container: {}, // any box props
      },
      rangeInput: {
        disabled: {
          opacity: 0.3
          //   thumb: {
          //     color: undefined,
          //   },
          //   track: {
          //     color: undefined,
          //   },
        },
        // extend: undefined
        track: {
          height: "4px",
          color: "border"
          // opacity: undefined,
          // lower: {
          //   color: 'undefined',
          //   opacity: undefined,
          // },
          // upper: {
          //   color: undefined,
          //   opacity: undefined,
          // },
          // extend: undefined
        },
        thumb: {
          // color: { dark: undefined, light: undefined },
          // extend: undefined
        }
      },
      rangeSelector: {
        background: {
          invert: {
            color: "light-4"
          }
        }
        // edge: {
        //   type: undefined,
        // },
      },
      select: {
        // background: undefined,
        clear: {
          container: {
            pad: "small",
            background: "background-contrast"
          },
          // any box props
          text: {
            color: "text-weak"
          }
          // any text props
        },
        container: {
          // extend: undefined,
        },
        control: {
          // extend: undefined,
          // open: undefined,
        },
        icons: {
          // color: { dark: undefined, light: undefined },
          margin: {
            horizontal: "small"
          },
          down: import_FormDown.FormDown
          // up: undefined
        },
        options: {
          container: {
            align: "start",
            pad: "small"
          },
          text: {
            margin: "none"
          }
        },
        // searchInput: undefined,
        step: 20
      },
      selectMultiple: {
        maxInline: 5
      },
      skeleton: {
        border: false,
        colors: {
          dark: ["background", "background-front"],
          light: ["background", "background-back"]
        }
      },
      skipLinks: {
        position: "top",
        container: {
          elevation: "large",
          round: "small",
          pad: "medium"
        },
        label: {
          margin: {
            bottom: "medium"
          },
          size: "medium"
        }
      },
      starRating: {
        // color: undefined,
      },
      tab: {
        active: {
          color: "text"
          // background: undefined,
        },
        // background: undefined,
        border: {
          side: "bottom",
          size: "small",
          color: {
            dark: "accent-1",
            light: "brand"
          },
          active: {
            color: {
              dark: "white",
              light: "black"
            }
          },
          disabled: {
            // color: undefined,
          },
          hover: {
            color: {
              dark: "white",
              light: "black"
            }
            // extend: undefined,
          }
        },
        color: "control",
        // disabled: {
        //   color: undefined,
        // },
        // extend: undefined,
        hover: {
          // background: undefined,
          // extend: undefined,
          color: {
            dark: "white",
            light: "black"
          }
        },
        margin: {
          vertical: "xxsmall",
          horizontal: "small"
        },
        pad: {
          bottom: "xsmall"
        }
      },
      tabs: {
        // background: undefined,
        // extend: undefined,
        // gap: undefined,
        header: {
          // alignSelf: undefined,
          // background: undefined,
          // border: {
          //   side: undefined,
          //   size: undefined,
          //   style: undefined,
          //   color: undefined,
          // },
          // extend: undefined,
        },
        panel: {
          // extend: undefined,
        },
        step: {
          small: 1,
          medium: 3,
          large: 3
        }
      },
      table: {
        header: {
          align: "start",
          pad: {
            horizontal: "small",
            vertical: "xsmall"
          },
          border: "bottom"
          // verticalAlign: undefined,
          // background: undefined,
          // extend: undefined,
        },
        body: {
          align: "start",
          pad: {
            horizontal: "small",
            vertical: "xsmall"
          }
          // background: undefined,
          // border: undefined,
          // extend: undefined,
        },
        // row: {
        //   hover: {
        //     background: undefined,
        //     color: undefined,
        //   },
        // },
        footer: {
          align: "start",
          pad: {
            horizontal: "small",
            vertical: "xsmall"
          },
          border: "top"
          // verticalAlign: undefined,
          // background: undefined,
          // extend: undefined,
        }
      },
      tag: {
        // background: undefined,
        border: true,
        round: "large",
        // name: undefined,
        pad: {
          horizontal: "small",
          vertical: "xsmall"
        },
        remove: {
          margin: {
            right: "xsmall"
          }
        },
        separator: " : ",
        size: {
          xsmall: {
            pad: {
              horizontal: baseSpacing2 / 3 + "px",
              vertical: "xxsmall"
            },
            icon: {
              size: baseSpacing2 * 0.75 + "px"
            }
          },
          small: {
            pad: {
              horizontal: baseSpacing2 * 0.4 + "px",
              vertical: "xxsmall"
            },
            icon: {
              size: baseSpacing2 * 0.75 + "px"
            }
          },
          large: {
            pad: {
              horizontal: baseSpacing2 / 3 * 2 + "px",
              vertical: "xsmall"
            },
            icon: {
              size: baseSpacing2 * 1.25 + "px"
            }
          },
          xlarge: {
            pad: {
              horizontal: baseSpacing2 * 0.75 + "px",
              vertical: "xsmall"
            },
            icon: {
              size: baseSpacing2 * 1.5 + "px"
            }
          }
        },
        value: {
          weight: 600
        }
      },
      text: {
        font: {
          // family: undefined
        },
        xsmall: _extends3({}, fontSizing(-1.5)),
        small: _extends3({}, fontSizing(-1)),
        medium: _extends3({}, fontSizing(0)),
        // 18px
        large: _extends3({}, fontSizing(1)),
        // 22px
        xlarge: _extends3({}, fontSizing(2)),
        xxlarge: _extends3({}, fontSizing(4)),
        "2xl": _extends3({}, fontSizing(4)),
        "3xl": _extends3({}, fontSizing(6)),
        "4xl": _extends3({}, fontSizing(9)),
        "5xl": _extends3({}, fontSizing(13)),
        "6xl": _extends3({}, fontSizing(18)),
        skeleton: {
          width: {
            width: "100px",
            min: "100px"
          },
          margin: {
            vertical: "xsmall"
          },
          colors: {
            dark: ["border", "border"],
            light: ["background-front", "background-back"]
          }
        }
      },
      textArea: {
        // extend: undefined,
        // disabled: { opacity: undefined },
      },
      textInput: {
        // extend: undefined,
        // disabled: { opacity: undefined },
      },
      tip: {
        content: {
          // any Box props
          background: "background-contrast",
          elevation: "small",
          margin: "xsmall",
          pad: {
            vertical: "xsmall",
            horizontal: "small"
          },
          round: "small"
        },
        drop: {
          // any props for the drop
          align: {
            top: "bottom"
          },
          // most common use case is Header with Buttons
          background: "none",
          elevation: "none",
          margin: "none"
        }
      },
      video: {
        captions: {
          background: "rgba(0, 0, 0, 0.7)"
        },
        // controls: { background: undefined },
        icons: {
          closedCaption: import_ClosedCaption.ClosedCaption,
          configure: import_Actions.Actions,
          fullScreen: import_Expand.Expand,
          pause: import_Pause.Pause,
          play: import_Play.Play,
          reduceVolume: import_VolumeLow.VolumeLow,
          volume: import_Volume.Volume,
          description: import_AssistListening.AssistListening
          // color: { dark: undefined, light: undefined },
        },
        scrubber: {
          color: "light-4",
          interval: 10
          // track: { color: undefined }
        }
      },
      worldMap: {
        color: "light-3",
        continent: {
          active: "8px",
          base: "6px"
        },
        hover: {
          color: "light-4"
        },
        place: {
          active: "20px",
          base: "8px"
        }
      }
    });
    return deepFreeze(result);
  };
  var base = generate(24);

  // node_modules/grommet/es6/default-props.js
  var defaultProps2 = {
    theme: base
  };

  // node_modules/grommet/es6/components/Keyboard/Keyboard.js
  var import_react5 = __toESM(require_react());

  // node_modules/grommet/es6/components/Keyboard/propTypes.js
  var import_prop_types2 = __toESM(require_prop_types());
  var PropType = {};
  if (true) {
    PropType = {
      target: import_prop_types2.default.oneOf(["component", "document"]),
      onBackspace: import_prop_types2.default.func,
      onComma: import_prop_types2.default.func,
      onDown: import_prop_types2.default.func,
      onEnter: import_prop_types2.default.func,
      onEsc: import_prop_types2.default.func,
      onKeyDown: import_prop_types2.default.func,
      onLeft: import_prop_types2.default.func,
      onRight: import_prop_types2.default.func,
      onShift: import_prop_types2.default.func,
      onSpace: import_prop_types2.default.func,
      onTab: import_prop_types2.default.func,
      onUp: import_prop_types2.default.func
    };
  }
  var KeyboardPropTypes = PropType;

  // node_modules/grommet/es6/components/Keyboard/Keyboard.js
  var _excluded2 = ["capture", "target", "children", "onKeyDown"];
  function _objectWithoutPropertiesLoose2(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var KEYS = {
    8: "onBackspace",
    9: "onTab",
    13: "onEnter",
    27: "onEsc",
    32: "onSpace",
    37: "onLeft",
    38: "onUp",
    39: "onRight",
    40: "onDown",
    188: "onComma",
    16: "onShift"
  };
  var Keyboard = function Keyboard2(_ref) {
    var capture = _ref.capture, target = _ref.target, children = _ref.children, onKeyDown = _ref.onKeyDown, restProps = _objectWithoutPropertiesLoose2(_ref, _excluded2);
    var onKeyDownHandler = (0, import_react5.useCallback)(function(event) {
      var key = event.keyCode ? event.keyCode : event.which;
      var callbackName = KEYS[key];
      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }
      if (callbackName && restProps[callbackName]) {
        restProps[callbackName].apply(restProps, [event].concat(rest));
      }
      if (onKeyDown) {
        onKeyDown.apply(void 0, [event].concat(rest));
      }
    }, [onKeyDown, restProps]);
    (0, import_react5.useEffect)(function() {
      if (target === "document") {
        document.addEventListener("keydown", onKeyDownHandler, capture);
      }
      return function() {
        if (target === "document") {
          document.removeEventListener("keydown", onKeyDownHandler, capture);
        }
      };
    }, [capture, onKeyDownHandler, target]);
    return target === "document" ? children : /* @__PURE__ */ (0, import_react5.cloneElement)(import_react5.Children.only(children), {
      onKeyDown: onKeyDownHandler
    });
  };
  Keyboard.propTypes = KeyboardPropTypes;

  // node_modules/grommet/es6/components/Box/StyledBox.js
  var import_styled_components6 = __toESM(require_styled_components_browser_cjs());
  var _FLEX_MAP;
  function _extends4() {
    _extends4 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends4.apply(this, arguments);
  }
  var BASIS_MAP = {
    auto: "auto",
    full: "100%",
    "1/2": "50%",
    "1/4": "25%",
    "2/4": "50%",
    "3/4": "75%",
    "1/3": "33.33%",
    "2/3": "66.66%"
  };
  var basisStyle = (0, import_styled_components6.css)(["flex-basis:", ";"], function(props) {
    return BASIS_MAP[props.basis] || props.theme.global.size[props.basis] || props.basis;
  });
  var directionStyle = function directionStyle2(direction, theme) {
    var styles = [(0, import_styled_components6.css)(["min-width:0;min-height:0;flex-direction:", ";"], direction === "row-responsive" ? "row" : direction)];
    if (direction === "row-responsive" && theme.box.responsiveBreakpoint) {
      var breakpoint = getBreakpointStyle(theme, theme.box.responsiveBreakpoint);
      if (breakpoint) {
        styles.push(breakpointStyle(breakpoint, "\n        flex-direction: column;\n        flex-basis: auto;\n        justify-content: flex-start;\n        align-items: stretch;\n      "));
      }
    }
    return styles;
  };
  var elevationStyle = function elevationStyle2(elevation) {
    return (0, import_styled_components6.css)(["box-shadow:", ";"], function(props) {
      return props.theme.global.elevation[props.theme.dark ? "dark" : "light"][elevation];
    });
  };
  var FLEX_MAP = (_FLEX_MAP = {}, _FLEX_MAP[true] = "1 1", _FLEX_MAP[false] = "0 0", _FLEX_MAP.grow = "1 0", _FLEX_MAP.shrink = "0 1", _FLEX_MAP);
  var flexGrowShrinkProp = function flexGrowShrinkProp2(flex) {
    if (typeof flex === "boolean" || typeof flex === "string") {
      return FLEX_MAP[flex];
    }
    return (flex.grow ? flex.grow : 0) + " " + (flex.shrink ? flex.shrink : 0);
  };
  var flexStyle = (0, import_styled_components6.css)(["flex:", ";"], function(props) {
    return "" + flexGrowShrinkProp(props.flex) + (props.flex !== true && !props.basis ? " auto" : "");
  });
  var JUSTIFY_MAP = {
    around: "space-around",
    between: "space-between",
    center: "center",
    end: "flex-end",
    evenly: "space-evenly",
    start: "flex-start"
  };
  var justifyStyle = (0, import_styled_components6.css)(["justify-content:", ";"], function(props) {
    return JUSTIFY_MAP[props.justify];
  });
  var WRAP_MAP = {
    "true": "wrap",
    reverse: "wrap-reverse"
  };
  var wrapStyle = (0, import_styled_components6.css)(["flex-wrap:", ";"], function(props) {
    return WRAP_MAP[props.wrapProp];
  });
  var animationItemStyle = function animationItemStyle2(item, theme) {
    if (typeof item === "string") {
      return animationObjectStyle({
        type: item
      }, theme);
    }
    if (Array.isArray(item)) {
      return item.reduce(function(style, a, index) {
        return (0, import_styled_components6.css)(["", "", " ", ""], style, index > 0 ? "," : "", animationItemStyle2(a, theme));
      }, "");
    }
    if (typeof item === "object") {
      return animationObjectStyle(item, theme);
    }
    return "";
  };
  var animationAncilaries = function animationAncilaries2(animation) {
    if (animation.type === "flipIn" || animation.type === "flipOut") {
      return "perspective: 1000px; transform-style: preserve-3d;";
    }
    return "";
  };
  var animationObjectInitialStyle = function animationObjectInitialStyle2(animation) {
    var bounds2 = animationBounds(animation.type, animation.size);
    if (bounds2) {
      return bounds2[0] + " " + animationAncilaries(animation);
    }
    return "";
  };
  var animationInitialStyle = function animationInitialStyle2(item) {
    if (typeof item === "string") {
      return animationObjectInitialStyle({
        type: item
      });
    }
    if (Array.isArray(item)) {
      return item.map(function(a) {
        return typeof a === "string" ? animationObjectInitialStyle({
          type: a
        }) : animationObjectInitialStyle(a);
      }).join("");
    }
    if (typeof item === "object") {
      return animationObjectInitialStyle(item);
    }
    return "";
  };
  var animationStyle = (0, import_styled_components6.css)(["", ";"], function(props) {
    return (0, import_styled_components6.css)(["", " animation:", ";"], animationInitialStyle(props.animation), animationItemStyle(props.animation, props.theme));
  });
  var interactiveStyle = (0, import_styled_components6.css)(["cursor:pointer;&:hover{", " ", "}"], function(props) {
    var _props$kindProp;
    return ((_props$kindProp = props.kindProp) == null ? void 0 : _props$kindProp.hover) && getHoverIndicatorStyle(props.kindProp.hover, props.theme);
  }, function(props) {
    return props.hoverIndicator && getHoverIndicatorStyle(props.hoverIndicator, props.theme);
  });
  var gapStyle = function gapStyle2(directionProp, gap, responsive, wrap, theme) {
    var metric = theme.global.edgeSize[gap] || gap;
    var breakpoint = getBreakpointStyle(theme, theme.box.responsiveBreakpoint);
    var responsiveMetric = responsive && breakpoint && breakpoint.edgeSize[gap];
    var styles = [];
    if (directionProp === "column" || directionProp === "column-reverse") {
      styles.push("row-gap: " + metric + ";");
      if (responsiveMetric) {
        styles.push(breakpointStyle(breakpoint, "row-gap: " + responsiveMetric + ";"));
      }
    } else {
      styles.push("column-gap: " + metric + ";");
      if (wrap)
        styles.push("row-gap: " + metric + ";");
      if (responsiveMetric) {
        if (directionProp === "row" || directionProp === "row-reverse") {
          styles.push(breakpointStyle(breakpoint, "column-gap: " + responsiveMetric + ";"));
        } else if (directionProp === "row-responsive") {
          styles.push(breakpointStyle(breakpoint, "\n          row-gap: " + responsiveMetric + ";\n        "));
        }
      }
    }
    return styles;
  };
  var StyledBox = import_styled_components6.default.div.withConfig({
    displayName: "StyledBox",
    componentId: "sc-13pk1d4-0"
  })(["display:flex;box-sizing:border-box;", ";", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", ""], function(props) {
    return !props.basis && "max-width: 100%;";
  }, genericStyles, function(props) {
    return props.align && alignStyle;
  }, function(props) {
    return props.alignContent && alignContentStyle;
  }, function(props) {
    return props.background && backgroundStyle(props.background, props.theme);
  }, function(props) {
    return props.border && borderStyle(props.border, props.responsive, props.theme);
  }, function(props) {
    return props.directionProp && directionStyle(props.directionProp, props.theme);
  }, function(props) {
    return props.heightProp && heightStyle(props.heightProp, props.theme);
  }, function(props) {
    return props.widthProp && widthStyle(props.widthProp, props.theme);
  }, function(props) {
    return props.flex !== void 0 && flexStyle;
  }, function(props) {
    return props.basis && basisStyle;
  }, function(props) {
    return props.fillProp && fillStyle(props.fillProp);
  }, function(props) {
    return props.justify && justifyStyle;
  }, function(props) {
    return props.pad && edgeStyle("padding", props.pad, props.responsive, props.theme.box.responsiveBreakpoint, props.theme);
  }, function(props) {
    return props.round && roundStyle(props.round, props.responsive, props.theme);
  }, function(props) {
    return props.wrapProp && wrapStyle;
  }, function(props) {
    return props.overflowProp && overflowStyle(props.overflowProp);
  }, function(props) {
    return props.elevationProp && elevationStyle(props.elevationProp);
  }, function(props) {
    return props.gap && gapStyle(props.directionProp, props.gap, props.responsive, props.wrapProp, props.theme);
  }, function(props) {
    return props.animation && animationStyle;
  }, function(props) {
    return props.onClick && interactiveStyle;
  }, function(props) {
    return props.onClick && props.focus && props.focusIndicator !== false && focusStyle();
  }, function(props) {
    return props.theme.box && props.theme.box.extend;
  }, function(props) {
    return props.kindProp && props.kindProp.extend;
  });
  StyledBox.defaultProps = {};
  Object.setPrototypeOf(StyledBox.defaultProps, defaultProps2);
  var gapGapStyle = function gapGapStyle2(directionProp, gap, responsive, border, theme) {
    var metric = theme.global.edgeSize[gap] || gap;
    var breakpoint = getBreakpointStyle(theme, theme.box.responsiveBreakpoint);
    var responsiveMetric = responsive && breakpoint && breakpoint.edgeSize[gap];
    var styles = [];
    if (directionProp === "column" || directionProp === "column-reverse") {
      styles.push("height: " + metric + ";");
      if (responsiveMetric) {
        styles.push(breakpointStyle(breakpoint, "height: " + responsiveMetric + ";"));
      }
    } else {
      styles.push("width: " + metric + ";");
      if (responsiveMetric) {
        if (directionProp === "row" || directionProp === "row-reverse") {
          styles.push(breakpointStyle(breakpoint, "width: " + responsiveMetric + ";"));
        } else if (directionProp === "row-responsive") {
          styles.push(breakpointStyle(breakpoint, "\n          width: auto;\n          height: " + responsiveMetric + ";\n        "));
        }
      }
    }
    if (border === "between" || border && border.side === "between") {
      var borderSize = border.size || "xsmall";
      var borderMetric = theme.global.borderSize[borderSize] || borderSize;
      var borderOffset = parseMetricToNum(metric) / 2 - parseMetricToNum(borderMetric) / 2 + "px";
      var responsiveBorderMetric = responsive && breakpoint && (breakpoint.borderSize[borderSize] || borderSize);
      var responsiveBorderOffset = responsiveBorderMetric && parseMetricToNum(responsiveMetric || metric) / 2 - parseMetricToNum(responsiveBorderMetric) / 2 + "px";
      if (directionProp === "column" || directionProp === "column-reverse") {
        var adjustedBorder = typeof border === "string" ? "top" : _extends4({}, border, {
          side: "top"
        });
        styles.push((0, import_styled_components6.css)(["position:relative;&:after{content:'';position:absolute;width:100%;top:", ";", "}"], borderOffset, borderStyle(adjustedBorder, responsive, theme)));
        if (responsiveBorderOffset) {
          styles.push(breakpointStyle(breakpoint, "\n            &:after {\n              content: '';\n              top: " + responsiveBorderOffset + ";\n            }"));
        }
      } else {
        var _adjustedBorder = typeof border === "string" ? "left" : _extends4({}, border, {
          side: "left"
        });
        styles.push((0, import_styled_components6.css)(["position:relative;&:after{content:'';position:absolute;height:100%;left:", ";", "}"], borderOffset, borderStyle(_adjustedBorder, directionProp !== "row-responsive" && responsive, theme)));
        if (responsiveBorderOffset) {
          if (directionProp === "row" || directionProp === "row-reverse") {
            styles.push(breakpointStyle(breakpoint, "\n              &:after {\n                content: '';\n                left: " + responsiveBorderOffset + ";\n              }"));
          } else if (directionProp === "row-responsive") {
            var adjustedBorder2 = typeof border === "string" ? "top" : _extends4({}, border, {
              side: "top"
            });
            styles.push(breakpointStyle(breakpoint, "\n              &:after {\n                content: '';\n                height: auto;\n                left: unset;\n                width: 100%;\n                top: " + responsiveBorderOffset + ";\n                border-left: none;\n                " + responsiveBorderStyle(adjustedBorder2, theme) + "\n              }"));
          }
        }
      }
    }
    return styles;
  };
  var StyledBoxGap = import_styled_components6.default.div.withConfig({
    displayName: "StyledBox__StyledBoxGap",
    componentId: "sc-13pk1d4-1"
  })(["flex:0 0 auto;align-self:stretch;", ";"], function(props) {
    return props.gap && gapGapStyle(props.directionProp, props.gap, props.responsive, props.border, props.theme);
  });
  StyledBoxGap.defaultProps = {};
  Object.setPrototypeOf(StyledBoxGap.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/Box/propTypes.js
  var import_prop_types3 = __toESM(require_prop_types());
  function _extends5() {
    _extends5 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends5.apply(this, arguments);
  }
  var OVERFLOW_VALUES2 = ["auto", "hidden", "scroll", "visible"];
  var BORDER_SHAPE = import_prop_types3.default.shape({
    color: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.shape({
      dark: import_prop_types3.default.string,
      light: import_prop_types3.default.string
    })]),
    side: import_prop_types3.default.oneOf(["top", "left", "bottom", "right", "start", "end", "horizontal", "vertical", "all", "between"]),
    size: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["xsmall", "small", "medium", "large", "xlarge"]), import_prop_types3.default.string]),
    style: import_prop_types3.default.oneOf(["solid", "dashed", "dotted", "double", "groove", "ridge", "inset", "outset", "hidden"])
  });
  var overflowPropType = import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(OVERFLOW_VALUES2), import_prop_types3.default.shape({
    horizontal: import_prop_types3.default.oneOf(OVERFLOW_VALUES2),
    vertical: import_prop_types3.default.oneOf(OVERFLOW_VALUES2)
  }), import_prop_types3.default.string]);
  var PropType2 = {};
  if (true) {
    PropType2 = _extends5({}, genericProps, {
      align: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["baseline", "center", "end", "start", "stretch"]), import_prop_types3.default.string]),
      alignContent: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["around", "baseline", "between", "center", "evenly", "end", "start", "stretch"]), import_prop_types3.default.string]),
      animation: animationPropType,
      background: backgroundDoc,
      basis: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["xxsmall", "xsmall", "small", "medium", "large", "xlarge", "xxlarge", "full", "1/2", "1/3", "2/3", "1/4", "2/4", "3/4", "auto"]), import_prop_types3.default.string]),
      border: import_prop_types3.default.oneOfType([import_prop_types3.default.bool, import_prop_types3.default.oneOf(["top", "left", "bottom", "right", "start", "end", "horizontal", "vertical", "all", "between"]), BORDER_SHAPE, import_prop_types3.default.arrayOf(BORDER_SHAPE)]),
      direction: import_prop_types3.default.oneOf(["row", "column", "row-responsive", "row-reverse", "column-reverse"]),
      elevation: elevationPropType,
      flex: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["grow", "shrink"]), import_prop_types3.default.bool, import_prop_types3.default.shape({
        grow: import_prop_types3.default.number,
        shrink: import_prop_types3.default.number
      })]),
      fill: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["horizontal", "vertical"]), import_prop_types3.default.bool]),
      focusIndicator: import_prop_types3.default.bool,
      gap: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["none", "xxsmall", "xsmall", "small", "medium", "large", "xlarge"]), import_prop_types3.default.string]),
      height: heightPropType,
      hoverIndicator: hoverIndicatorPropType,
      justify: import_prop_types3.default.oneOf(["around", "between", "center", "end", "evenly", "start", "stretch"]),
      onClick: import_prop_types3.default.func,
      overflow: overflowPropType,
      pad: padPropType,
      responsive: import_prop_types3.default.bool,
      round: roundPropType,
      skeleton: skeletonPropType,
      tag: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.func]),
      as: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.func, import_prop_types3.default.elementType]),
      width: widthPropType,
      wrap: import_prop_types3.default.oneOfType([import_prop_types3.default.bool, import_prop_types3.default.oneOf(["reverse"])])
    });
  }
  var BoxPropTypes = PropType2;

  // node_modules/grommet/es6/components/Skeleton/Skeleton.js
  var import_react7 = __toESM(require_react());
  var import_styled_components8 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/Skeleton/propTypes.js
  var import_prop_types4 = __toESM(require_prop_types());
  function _extends6() {
    _extends6 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends6.apply(this, arguments);
  }
  var PropType3 = {};
  if (true) {
    PropType3 = _extends6({}, genericProps, {
      as: import_prop_types4.default.oneOfType([import_prop_types4.default.string, import_prop_types4.default.func, import_prop_types4.default.element]),
      colors: skeletonColorsPropType,
      height: heightPropType,
      pad: padPropType,
      round: roundPropType,
      width: widthPropType
    });
  }
  var SkeletonPropTypes = PropType3;

  // node_modules/grommet/es6/components/Skeleton/SkeletonContext.js
  var import_react6 = __toESM(require_react());
  var SkeletonContext = /* @__PURE__ */ import_react6.default.createContext();
  var useSkeleton = function useSkeleton2() {
    return (0, import_react6.useContext)(SkeletonContext);
  };

  // node_modules/grommet/es6/components/Skeleton/StyledSkeleton.js
  var import_styled_components7 = __toESM(require_styled_components_browser_cjs());
  var StyledSkeleton = import_styled_components7.default.div.withConfig({
    displayName: "StyledSkeleton",
    componentId: "sc-1omqm6u-0"
  })(["display:flex;box-sizing:border-box;", " ", " ", " ", " ", " ", ""], genericStyles, function(props) {
    return props.background && backgroundStyle(props.background, props.theme);
  }, function(props) {
    var _props$theme$text, _props$theme$text$med;
    return heightStyle(props.heightProp || ((_props$theme$text = props.theme.text) == null ? void 0 : (_props$theme$text$med = _props$theme$text.medium) == null ? void 0 : _props$theme$text$med.height), props.theme);
  }, function(props) {
    return widthStyle(props.widthProp || "100%", props.theme);
  }, function(props) {
    return props.pad && edgeStyle("padding", props.pad, props.responsive, props.theme.box.responsiveBreakpoint, props.theme);
  }, function(props) {
    return props.round && roundStyle(props.round, props.responsive, props.theme);
  });

  // node_modules/grommet/es6/components/Skeleton/Skeleton.js
  var _excluded3 = ["as", "colors", "width", "height"];
  function _extends7() {
    _extends7 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends7.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose3(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Skeleton = /* @__PURE__ */ (0, import_react7.forwardRef)(function(_ref, ref) {
    var _theme$skeleton;
    var as = _ref.as, colorsProp = _ref.colors, widthProp = _ref.width, heightProp = _ref.height, rest = _objectWithoutPropertiesLoose3(_ref, _excluded3);
    var theme = (0, import_react7.useContext)(import_styled_components8.ThemeContext) || defaultProps2.theme;
    var skeleton = useSkeleton();
    var depth = (skeleton == null ? void 0 : skeleton.depth) || 0;
    var colors4 = colorsProp || (theme == null ? void 0 : (_theme$skeleton = theme.skeleton) == null ? void 0 : _theme$skeleton.colors);
    var themeColors = colors4[theme.dark ? "dark" : "light"];
    var background = themeColors[(depth + 1) % themeColors.length];
    return /* @__PURE__ */ import_react7.default.createElement(StyledSkeleton, _extends7({
      ref,
      as,
      background,
      widthProp,
      heightProp
    }, rest));
  });
  Skeleton.displayName = "Skeleton";
  Skeleton.propTypes = SkeletonPropTypes;

  // node_modules/grommet/es6/contexts/AnnounceContext/AnnounceContext.js
  var import_react8 = __toESM(require_react());

  // node_modules/grommet/es6/contexts/AnnounceContext/propTypes.js
  var import_prop_types5 = __toESM(require_prop_types());
  var PropType4 = {};
  if (true) {
    PropType4 = {
      children: import_prop_types5.default.func
    };
  }
  var AnnounceContextPropTypes = PropType4;

  // node_modules/grommet/es6/contexts/AnnounceContext/AnnounceContext.js
  var createAnnouncer = function createAnnouncer2() {
    var announcer = document.createElement("div");
    announcer.id = "grommet-announcer";
    announcer.style.left = "-100%";
    announcer.style.right = "100%";
    announcer.style.position = "fixed";
    announcer.style["z-index"] = "-1";
    document.body.insertBefore(announcer, document.body.firstChild);
    return announcer;
  };
  var AnnounceContext = /* @__PURE__ */ import_react8.default.createContext(function(message, mode, timeout) {
    if (mode === void 0) {
      mode = "polite";
    }
    if (timeout === void 0) {
      timeout = 500;
    }
    var announcer = document.body.querySelector("#grommet-announcer[aria-live]") || createAnnouncer();
    announcer.setAttribute("aria-live", "off");
    announcer.innerHTML = message;
    announcer.setAttribute("aria-live", mode);
    setTimeout(function() {
      announcer.innerHTML = "";
    }, timeout);
  });
  AnnounceContext.propTypes = AnnounceContextPropTypes;

  // node_modules/grommet/es6/contexts/OptionsContext.js
  var import_react9 = __toESM(require_react());
  var OptionsContext = /* @__PURE__ */ import_react9.default.createContext({});

  // node_modules/grommet/es6/components/Box/Box.js
  var _excluded4 = ["a11yTitle", "background", "border", "children", "cssGap", "direction", "elevation", "fill", "gap", "kind", "onBlur", "onClick", "onFocus", "overflow", "responsive", "tag", "as", "wrap", "width", "height", "tabIndex", "skeleton"];
  var _excluded22 = ["colors", "size"];
  function _extends8() {
    _extends8 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends8.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose4(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Box = /* @__PURE__ */ (0, import_react10.forwardRef)(function(_ref, ref) {
    var a11yTitle = _ref.a11yTitle, backgroundProp = _ref.background, border = _ref.border, children = _ref.children, cssGap = _ref.cssGap, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? "column" : _ref$direction, elevation = _ref.elevation, fill = _ref.fill, gap = _ref.gap, kind = _ref.kind, _onBlur = _ref.onBlur, onClick = _ref.onClick, _onFocus = _ref.onFocus, overflow = _ref.overflow, _ref$responsive = _ref.responsive, responsive = _ref$responsive === void 0 ? true : _ref$responsive, tag = _ref.tag, as = _ref.as, wrap = _ref.wrap, width = _ref.width, height = _ref.height, tabIndex = _ref.tabIndex, skeletonProp = _ref.skeleton, rest = _objectWithoutPropertiesLoose4(_ref, _excluded4);
    var theme = (0, import_react10.useContext)(import_styled_components9.ThemeContext) || defaultProps2.theme;
    var _useContext = (0, import_react10.useContext)(OptionsContext), boxOptions = _useContext.box;
    var skeleton = useSkeleton();
    var background = backgroundProp;
    var announce = (0, import_react10.useContext)(AnnounceContext);
    (0, import_react10.useEffect)(function() {
      var _skeletonProp$message;
      if (skeletonProp != null && (_skeletonProp$message = skeletonProp.message) != null && _skeletonProp$message.start)
        announce(skeletonProp.message.start);
      else if (typeof (skeletonProp == null ? void 0 : skeletonProp.message) === "string")
        announce(skeletonProp.message);
      return function() {
        var _skeletonProp$message2;
        return (skeletonProp == null ? void 0 : (_skeletonProp$message2 = skeletonProp.message) == null ? void 0 : _skeletonProp$message2.end) && announce(skeletonProp.message.end);
      };
    }, [announce, skeletonProp]);
    var focusable = (0, import_react10.useMemo)(function() {
      return onClick && !(tabIndex < 0);
    }, [onClick, tabIndex]);
    var _useState = (0, import_react10.useState)(), focus = _useState[0], setFocus = _useState[1];
    var clickProps = (0, import_react10.useMemo)(function() {
      if (focusable) {
        return {
          onClick,
          onFocus: function onFocus(event) {
            setFocus(true);
            if (_onFocus)
              _onFocus(event);
          },
          onBlur: function onBlur(event) {
            setFocus(false);
            if (_onBlur)
              _onBlur(event);
          }
        };
      }
      var result = {};
      if (_onBlur)
        result.onBlur = _onBlur;
      if (onClick)
        result.onClick = onClick;
      if (_onFocus)
        result.onFocus = _onFocus;
      return result;
    }, [focusable, onClick, _onFocus, _onBlur]);
    var adjustedTabIndex = (0, import_react10.useMemo)(function() {
      if (tabIndex !== void 0)
        return tabIndex;
      if (focusable)
        return 0;
      return void 0;
    }, [focusable, tabIndex]);
    if ((border === "between" || border && border.side === "between") && !gap) {
      console.warn("Box must have a gap to use border between");
    }
    var contents = children;
    if (gap && gap !== "none" && (!(boxOptions != null && boxOptions.cssGap || cssGap) || // need this approach to show border between
    border === "between" || (border == null ? void 0 : border.side) === "between")) {
      var boxAs = !as && tag ? tag : as;
      contents = [];
      var firstIndex;
      import_react10.Children.forEach(children, function(child, index) {
        if (child) {
          if (firstIndex === void 0) {
            firstIndex = index;
          } else {
            contents.push(/* @__PURE__ */ import_react10.default.createElement(
              StyledBoxGap,
              {
                key: "gap-" + index,
                as: boxAs === "span" ? boxAs : "div",
                gap,
                directionProp: direction,
                responsive,
                border
              }
            ));
          }
        }
        contents.push(child);
      });
    }
    var nextSkeleton = (0, import_react10.useMemo)(function() {
      if (skeletonProp || (background || border) && skeleton) {
        var depth = skeleton ? skeleton.depth + 1 : 0;
        return _extends8({}, skeleton, {
          depth
        }, typeof skeletonProp === "object" ? skeletonProp : {});
      }
      return void 0;
    }, [background, border, skeleton, skeletonProp]);
    var skeletonProps = {};
    if (nextSkeleton) {
      var _theme$skeleton = theme.skeleton, skeletonThemeColors = _theme$skeleton.colors, skeletonThemeSize = _theme$skeleton.size, skeletonThemeProps = _objectWithoutPropertiesLoose4(_theme$skeleton, _excluded22);
      var skeletonColors = nextSkeleton.colors ? nextSkeleton.colors[theme.dark ? "dark" : "light"] : skeletonThemeColors == null ? void 0 : skeletonThemeColors[theme.dark ? "dark" : "light"];
      skeletonProps = _extends8({}, skeletonThemeProps);
      background = skeletonColors[nextSkeleton.depth % skeletonColors.length];
      if (skeletonProp != null && skeletonProp.animation) {
        skeletonProps.animation = skeletonProp.animation;
      }
      contents = /* @__PURE__ */ import_react10.default.createElement(SkeletonContext.Provider, {
        value: nextSkeleton
      }, contents);
    }
    var nextTheme = (0, import_react10.useMemo)(function() {
      var result;
      if (background || theme.darkChanged) {
        var dark = backgroundIsDark(background, theme);
        var darkChanged = dark !== void 0 && dark !== theme.dark;
        if (darkChanged || theme.darkChanged) {
          result = _extends8({}, theme);
          result.dark = dark === void 0 ? theme.dark : dark;
          result.background = background;
        } else if (background) {
          result = _extends8({}, theme);
          result.background = background;
        }
      }
      return result || theme;
    }, [background, theme]);
    var content = /* @__PURE__ */ import_react10.default.createElement(StyledBox, _extends8({
      as: !as && tag ? tag : as,
      "aria-label": a11yTitle,
      background,
      border,
      ref,
      directionProp: direction,
      elevationProp: elevation,
      fillProp: fill,
      focus,
      gap: ((boxOptions == null ? void 0 : boxOptions.cssGap) || cssGap) && gap && gap !== "none" && border !== "between" && (border == null ? void 0 : border.side) !== "between" && gap,
      kindProp: kind,
      overflowProp: overflow,
      wrapProp: wrap,
      widthProp: width,
      heightProp: height,
      responsive,
      tabIndex: adjustedTabIndex
    }, clickProps, rest, skeletonProps), /* @__PURE__ */ import_react10.default.createElement(import_styled_components9.ThemeContext.Provider, {
      value: nextTheme
    }, contents));
    if (onClick) {
      content = /* @__PURE__ */ import_react10.default.createElement(Keyboard, {
        onEnter: onClick
      }, content);
    }
    return content;
  });
  Box.displayName = "Box";
  Box.propTypes = BoxPropTypes;

  // node_modules/grommet/es6/components/Button/Button.js
  var import_react24 = __toESM(require_react());
  var import_styled_components20 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/Button/propTypes.js
  var import_prop_types6 = __toESM(require_prop_types());
  function _extends9() {
    _extends9 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends9.apply(this, arguments);
  }
  var PropType5 = {};
  if (true) {
    PropType5 = _extends9({}, genericProps, {
      children: import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.object, import_prop_types6.default.node]),
      active: import_prop_types6.default.bool,
      as: import_prop_types6.default.oneOfType([import_prop_types6.default.string, import_prop_types6.default.func, import_prop_types6.default.elementType]),
      badge: import_prop_types6.default.oneOfType([import_prop_types6.default.bool, import_prop_types6.default.element, import_prop_types6.default.number, import_prop_types6.default.shape({
        background: backgroundPropType,
        max: import_prop_types6.default.number,
        value: import_prop_types6.default.oneOfType([import_prop_types6.default.bool, import_prop_types6.default.number])
      })]),
      color: colorPropType,
      disabled: import_prop_types6.default.bool,
      fill: import_prop_types6.default.oneOfType([import_prop_types6.default.oneOf(["horizontal", "vertical"]), import_prop_types6.default.bool]),
      focusIndicator: import_prop_types6.default.bool,
      gap: import_prop_types6.default.oneOfType([import_prop_types6.default.oneOf(["none", "xxsmall", "xsmall", "small", "medium", "large", "xlarge"]), import_prop_types6.default.string]),
      hoverIndicator: hoverIndicatorPropType,
      href: import_prop_types6.default.string,
      icon: import_prop_types6.default.element,
      justify: import_prop_types6.default.oneOf(["around", "between", "center", "end", "evenly", "start", "stretch"]),
      label: import_prop_types6.default.node,
      onClick: import_prop_types6.default.func,
      plain: import_prop_types6.default.bool,
      primary: import_prop_types6.default.bool,
      reverse: import_prop_types6.default.bool,
      secondary: import_prop_types6.default.bool,
      size: import_prop_types6.default.oneOfType([import_prop_types6.default.oneOf(["small", "medium", "large"]), import_prop_types6.default.string]),
      target: import_prop_types6.default.oneOfType([import_prop_types6.default.oneOf(["_self", "_blank", "_parent", "_top"]), import_prop_types6.default.string]),
      tip: import_prop_types6.default.oneOfType([import_prop_types6.default.shape({
        content: import_prop_types6.default.oneOfType([import_prop_types6.default.node, import_prop_types6.default.string]),
        dropProps: import_prop_types6.default.shape({}),
        plain: import_prop_types6.default.bool
      }), import_prop_types6.default.string]),
      type: import_prop_types6.default.oneOf(["button", "reset", "submit"])
    });
  }
  var ButtonPropTypes = PropType5;

  // node_modules/grommet/es6/components/Tip/Tip.js
  var import_react16 = __toESM(require_react());
  var import_styled_components13 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/Drop/Drop.js
  var import_react15 = __toESM(require_react());
  var import_react_dom = __toESM(require_react_dom());
  var import_styled_components12 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/Drop/DropContainer.js
  var import_react14 = __toESM(require_react());
  var import_styled_components11 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/contexts/ContainerTargetContext/ContainerTargetContext.js
  var import_react11 = __toESM(require_react());
  var ContainerTargetContext = /* @__PURE__ */ import_react11.default.createContext(typeof document === "object" ? document.body : void 0);

  // node_modules/grommet/es6/components/FocusedContainer.js
  var import_react13 = __toESM(require_react());

  // node_modules/grommet/es6/contexts/RootsContext.js
  var import_react12 = __toESM(require_react());
  var RootsContext = /* @__PURE__ */ import_react12.default.createContext([]);

  // node_modules/grommet/es6/components/FocusedContainer.js
  var _excluded5 = ["hidden", "restrictScroll", "children", "trapFocus"];
  function _extends10() {
    _extends10 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends10.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose5(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var FocusedContainer = function FocusedContainer2(_ref) {
    var _ref$hidden = _ref.hidden, hidden = _ref$hidden === void 0 ? false : _ref$hidden, _ref$restrictScroll = _ref.restrictScroll, restrictScroll = _ref$restrictScroll === void 0 ? false : _ref$restrictScroll, children = _ref.children, trapFocus = _ref.trapFocus, rest = _objectWithoutPropertiesLoose5(_ref, _excluded5);
    var _useState = (0, import_react13.useState)(""), bodyOverflowStyle = _useState[0], setBodyOverflowStyle = _useState[1];
    var ref = (0, import_react13.useRef)(null);
    var roots = (0, import_react13.useContext)(RootsContext);
    var _useState2 = (0, import_react13.useState)(roots), nextRoots = _useState2[0], setNextRoots = _useState2[1];
    (0, import_react13.useEffect)(function() {
      if (ref.current)
        setNextRoots([].concat(roots, [ref.current]));
    }, [roots]);
    (0, import_react13.useEffect)(function() {
      if (bodyOverflowStyle !== "hidden" && !hidden && restrictScroll && trapFocus) {
        setBodyOverflowStyle(document.body.style.overflow);
        document.body.style.overflow = "hidden";
      }
      return function() {
        if (bodyOverflowStyle !== "hidden" && !hidden && restrictScroll && trapFocus) {
          document.body.style.overflow = bodyOverflowStyle;
        }
      };
    }, [bodyOverflowStyle, hidden, trapFocus, restrictScroll]);
    (0, import_react13.useEffect)(function() {
      var timer = setTimeout(function() {
        if (!hidden && trapFocus && roots && roots[0]) {
          roots.forEach(makeNodeUnfocusable);
        }
      }, 0);
      return function() {
        if (roots && roots[0])
          makeNodeFocusable(roots[roots.length - 1]);
        clearTimeout(timer);
      };
    }, [hidden, roots, trapFocus]);
    return /* @__PURE__ */ import_react13.default.createElement(RootsContext.Provider, {
      value: nextRoots
    }, /* @__PURE__ */ import_react13.default.createElement("div", _extends10({
      ref,
      "aria-hidden": hidden
    }, rest), children));
  };

  // node_modules/grommet/es6/components/Drop/StyledDrop.js
  var import_styled_components10 = __toESM(require_styled_components_browser_cjs());
  function getTransformOriginStyle(align) {
    var vertical12 = "top";
    if (align.bottom) {
      vertical12 = "bottom";
    }
    var horizontal12 = "left";
    if (align.right) {
      horizontal12 = "right";
    }
    return vertical12 + " " + horizontal12;
  }
  var dropKeyFrames = (0, import_styled_components10.keyframes)(["0%{opacity:0.5;transform:scale(0.8);}100%{opacity:1;transform:scale(1);}"]);
  var marginStyle = function marginStyle2(theme, align, data, responsive, marginProp2) {
    var margin = theme.global.edgeSize[data] || data;
    var adjustedMargin = {};
    var customCSS = typeof margin === "string" && margin.split(" ").length > 1;
    if (theme.global.drop.intelligentMargin === true && !customCSS && typeof margin === "string") {
      if (align.top === "bottom")
        adjustedMargin.top = margin;
      else if (align.bottom === "top")
        adjustedMargin.bottom = margin;
      if (align.right === "left")
        adjustedMargin.left = "-" + margin;
      else if (align.left === "right")
        adjustedMargin.left = margin;
      if (!Object.keys(adjustedMargin))
        adjustedMargin = "none";
    } else {
      return edgeStyle("margin", marginProp2 || theme.global.drop.margin, responsive, theme.global.edgeSize.responsiveBreakpoint, theme);
    }
    return edgeStyle("margin", adjustedMargin, responsive, theme.global.edgeSize.responsiveBreakpoint, theme);
  };
  var StyledDrop = import_styled_components10.default.div.withConfig({
    displayName: "StyledDrop",
    componentId: "sc-16s5rx8-0"
  })(["", " ", " position:fixed;z-index:", ";outline:none;", " ", " opacity:0;transform-origin:", ";animation:", " 0.1s forwards;animation-delay:0.01s;@media screen and (-ms-high-contrast:active),(-ms-high-contrast:none){display:flex;align-items:stretch;}", ""], baseStyle, function(props) {
    return !props.plain && (props.round && roundStyle(props.round, true, props.theme) || "border-radius: " + props.theme.global.drop.border.radius + ";");
  }, function(props) {
    return props.theme.global.drop.zIndex;
  }, function(props) {
    return !props.plain && backgroundStyle(props.background || props.theme.global.drop.background, props.theme);
  }, function(props) {
    return !props.plain && (props.margin || props.theme.global.drop.margin) && props.theme.global && marginStyle(props.theme, props.alignProp, props.theme.global.drop.margin, props.responsive, props.margin);
  }, function(props) {
    return getTransformOriginStyle(props.alignProp);
  }, dropKeyFrames, function(props) {
    return props.theme.global.drop && props.theme.global.drop.extend;
  });
  StyledDrop.defaultProps = {};
  Object.setPrototypeOf(StyledDrop.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/Drop/DropContainer.js
  var _excluded6 = ["a11yTitle", "aria-label", "align", "background", "onAlign", "children", "dropTarget", "elevation", "onClickOutside", "onEsc", "onKeyDown", "overflow", "plain", "responsive", "restrictFocus", "stretch", "trapFocus"];
  function _extends11() {
    _extends11 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends11.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose6(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var preventLayerClose = function preventLayerClose2(event) {
    var key = event.keyCode ? event.keyCode : event.which;
    if (key === 27) {
      event.stopPropagation();
    }
  };
  var defaultAlign = {
    top: "top",
    left: "left"
  };
  var DropContainer = /* @__PURE__ */ (0, import_react14.forwardRef)(function(_ref, ref) {
    var a11yTitle = _ref.a11yTitle, ariaLabel = _ref["aria-label"], _ref$align = _ref.align, align = _ref$align === void 0 ? defaultAlign : _ref$align, background = _ref.background, onAlign = _ref.onAlign, children = _ref.children, dropTarget = _ref.dropTarget, elevation = _ref.elevation, onClickOutside = _ref.onClickOutside, onEsc = _ref.onEsc, onKeyDown = _ref.onKeyDown, _ref$overflow = _ref.overflow, overflow = _ref$overflow === void 0 ? "auto" : _ref$overflow, plain = _ref.plain, _ref$responsive = _ref.responsive, responsive = _ref$responsive === void 0 ? true : _ref$responsive, restrictFocus = _ref.restrictFocus, _ref$stretch = _ref.stretch, stretch = _ref$stretch === void 0 ? "width" : _ref$stretch, trapFocus = _ref.trapFocus, rest = _objectWithoutPropertiesLoose6(_ref, _excluded6);
    var containerTarget = (0, import_react14.useContext)(ContainerTargetContext);
    var theme = (0, import_react14.useContext)(import_styled_components11.ThemeContext) || defaultProps2.theme;
    var portalContext = (0, import_react14.useContext)(PortalContext);
    var portalId = (0, import_react14.useMemo)(function() {
      return portalContext.length;
    }, [portalContext]);
    var nextPortalContext = (0, import_react14.useMemo)(function() {
      return [].concat(portalContext, [portalId]);
    }, [portalContext, portalId]);
    var dropRef = useForwardedRef(ref);
    (0, import_react14.useEffect)(function() {
      var onClickDocument = function onClickDocument2(event) {
        var clickedPortalId = null;
        var node = containerTarget === document.body ? event.target : event == null ? void 0 : event.composedPath()[0];
        while (clickedPortalId === null && node !== document) {
          var attr = node.getAttribute("data-g-portal-id");
          if (attr !== null)
            clickedPortalId = parseInt(attr, 10);
          node = node.parentNode;
        }
        if (clickedPortalId === null || portalContext.indexOf(clickedPortalId) !== -1) {
          onClickOutside(event);
        }
      };
      if (onClickOutside) {
        document.addEventListener("mousedown", onClickDocument);
      }
      return function() {
        if (onClickOutside) {
          document.removeEventListener("mousedown", onClickDocument);
        }
      };
    }, [onClickOutside, containerTarget, portalContext]);
    (0, import_react14.useEffect)(function() {
      var notifyAlign = function notifyAlign2() {
        var styleCurrent = dropRef.current.style;
        var alignControl = styleCurrent.top !== "" ? "top" : "bottom";
        onAlign(alignControl);
      };
      var place = function place2(preserveHeight) {
        var windowWidth = window.innerWidth;
        var windowHeight = window.innerHeight;
        var target = (dropTarget == null ? void 0 : dropTarget.current) || dropTarget;
        var container = dropRef.current;
        if (container && target) {
          container.style.left = "";
          container.style.top = "";
          container.style.bottom = "";
          container.style.width = "";
          if (!preserveHeight) {
            container.style.maxHeight = "";
          }
          var targetRect = target.getBoundingClientRect();
          var containerRect = container.getBoundingClientRect();
          var width;
          if (stretch) {
            width = Math.min(stretch === "align" ? Math.min(targetRect.width, containerRect.width) : Math.max(targetRect.width, containerRect.width), windowWidth);
          } else {
            width = Math.min(containerRect.width, windowWidth);
          }
          var left2;
          if (align.left) {
            if (align.left === "left") {
              left2 = targetRect.left;
            } else if (align.left === "right") {
              left2 = targetRect.left + targetRect.width;
            }
          } else if (align.right) {
            if (align.right === "left") {
              left2 = targetRect.left - width;
            } else if (align.right === "right") {
              left2 = targetRect.left + targetRect.width - width;
            }
          } else {
            left2 = targetRect.left + targetRect.width / 2 - width / 2;
          }
          if (left2 + width > windowWidth) {
            left2 -= left2 + width - windowWidth;
          } else if (left2 < 0) {
            left2 = 0;
          }
          var top2;
          var bottom2;
          var maxHeight = containerRect.height;
          if (responsive && (align.top === "top" && targetRect.top < 0 || align.bottom === "top" && targetRect.top - containerRect.height <= 0 && targetRect.bottom + containerRect.height < windowHeight)) {
            top2 = targetRect.bottom;
            maxHeight = top2;
          } else if (responsive && (align.bottom === "bottom" && targetRect.bottom > windowHeight || align.top === "bottom" && targetRect.bottom + containerRect.height >= windowHeight && targetRect.top - containerRect.height > 0)) {
            bottom2 = targetRect.top;
            maxHeight = bottom2;
          } else if (align.top === "top") {
            top2 = targetRect.top;
            maxHeight = windowHeight - top2;
          } else if (align.top === "bottom") {
            top2 = targetRect.bottom;
            maxHeight = windowHeight - top2;
          } else if (align.bottom === "top") {
            bottom2 = targetRect.top;
            maxHeight = bottom2;
          } else if (align.bottom === "bottom") {
            bottom2 = targetRect.bottom;
            maxHeight = bottom2;
          } else {
            top2 = targetRect.top + targetRect.height / 2 - containerRect.height / 2;
          }
          container.style.left = left2 + "px";
          if (stretch) {
            container.style.width = width + 0.1 + "px";
          }
          if (top2 !== "") {
            container.style.top = top2 + "px";
          }
          if (bottom2 !== "") {
            container.style.bottom = windowHeight - bottom2 + "px";
          }
          if (!preserveHeight) {
            if (theme.drop && theme.drop.maxHeight) {
              maxHeight = Math.min(maxHeight, parseMetricToNum(theme.drop.maxHeight));
            }
            container.style.maxHeight = maxHeight + "px";
          }
        }
        if (onAlign)
          notifyAlign();
      };
      var scrollParents;
      var addScrollListeners = function addScrollListeners2() {
        scrollParents = findScrollParents(dropTarget);
        scrollParents.forEach(function(scrollParent) {
          return scrollParent.addEventListener("scroll", place);
        });
      };
      var removeScrollListeners = function removeScrollListeners2() {
        scrollParents.forEach(function(scrollParent) {
          return scrollParent.removeEventListener("scroll", place);
        });
        scrollParents = [];
      };
      var onResize = function onResize2() {
        removeScrollListeners();
        addScrollListeners();
        place(false);
      };
      addScrollListeners();
      window.addEventListener("resize", onResize);
      place(false);
      return function() {
        removeScrollListeners();
        window.removeEventListener("resize", onResize);
      };
    }, [align, containerTarget, onAlign, dropTarget, portalContext, portalId, responsive, restrictFocus, stretch, theme.drop, dropRef]);
    (0, import_react14.useEffect)(function() {
      if (restrictFocus) {
        dropRef.current.focus();
      }
    }, [dropRef, restrictFocus]);
    var content = /* @__PURE__ */ import_react14.default.createElement(StyledDrop, _extends11({
      "aria-label": a11yTitle || ariaLabel,
      ref: dropRef,
      as: Box,
      background,
      plain,
      elevation: !plain ? elevation || theme.global.drop.elevation || theme.global.drop.shadowSize || // backward compatibility
      "small" : void 0,
      tabIndex: "-1",
      alignProp: align,
      overflow,
      "data-g-portal-id": portalId
    }, rest), children);
    var themeContextValue = (0, import_react14.useMemo)(function() {
      var dark2;
      if (background || theme.global.drop.background) {
        dark2 = backgroundIsDark(background || theme.global.drop.background, theme);
      }
      return _extends11({}, theme, {
        dark: dark2
      });
    }, [background, theme]);
    var dark = themeContextValue.dark;
    if (dark !== void 0 && dark !== theme.dark) {
      content = /* @__PURE__ */ import_react14.default.createElement(import_styled_components11.ThemeContext.Provider, {
        value: themeContextValue
      }, content);
    }
    return /* @__PURE__ */ import_react14.default.createElement(PortalContext.Provider, {
      value: nextPortalContext
    }, /* @__PURE__ */ import_react14.default.createElement(FocusedContainer, {
      onKeyDown: onEsc && preventLayerClose,
      trapFocus
    }, /* @__PURE__ */ import_react14.default.createElement(
      Keyboard,
      {
        capture: true,
        onEsc: onEsc ? function(event) {
          event.stopPropagation();
          onEsc(event);
        } : void 0,
        onKeyDown,
        target: "document"
      },
      content
    )));
  });

  // node_modules/grommet/es6/components/Drop/propTypes.js
  var import_prop_types7 = __toESM(require_prop_types());
  var dropOverflowPropTypes = import_prop_types7.default.oneOfType([import_prop_types7.default.oneOf(OVERFLOW_VALUES), import_prop_types7.default.shape({
    horizontal: import_prop_types7.default.oneOf(OVERFLOW_VALUES),
    vertical: import_prop_types7.default.oneOf(OVERFLOW_VALUES)
  }), import_prop_types7.default.string]);
  var PropType6 = {};
  if (true) {
    PropType6 = {
      align: import_prop_types7.default.shape({
        top: import_prop_types7.default.oneOf(["top", "bottom"]),
        bottom: import_prop_types7.default.oneOf(["top", "bottom"]),
        right: import_prop_types7.default.oneOf(["left", "right"]),
        left: import_prop_types7.default.oneOf(["left", "right"])
      }),
      background: backgroundDoc,
      elevation: import_prop_types7.default.oneOfType([import_prop_types7.default.oneOf(["none", "xsmall", "small", "medium", "large", "xlarge"]), import_prop_types7.default.string]),
      inline: import_prop_types7.default.bool,
      margin: marginProp,
      onClickOutside: import_prop_types7.default.func,
      onEsc: import_prop_types7.default.func,
      overflow: dropOverflowPropTypes,
      plain: import_prop_types7.default.bool,
      responsive: import_prop_types7.default.bool,
      restrictFocus: import_prop_types7.default.bool,
      round: roundPropType,
      stretch: import_prop_types7.default.oneOfType([import_prop_types7.default.bool, import_prop_types7.default.oneOf(["align"])]),
      target: import_prop_types7.default.object.isRequired,
      trapFocus: import_prop_types7.default.bool
    };
  }
  var DropPropTypes = PropType6;

  // node_modules/grommet/es6/components/Drop/Drop.js
  var _excluded7 = ["inline", "restrictFocus", "target", "trapFocus"];
  function _extends12() {
    _extends12 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends12.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose7(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Drop = /* @__PURE__ */ (0, import_react15.forwardRef)(function(_ref, ref) {
    var inline = _ref.inline, restrictFocus = _ref.restrictFocus, dropTarget = _ref.target, _ref$trapFocus = _ref.trapFocus, trapFocus = _ref$trapFocus === void 0 ? true : _ref$trapFocus, rest = _objectWithoutPropertiesLoose7(_ref, _excluded7);
    var theme = (0, import_react15.useContext)(import_styled_components12.ThemeContext) || defaultProps2.theme;
    var _useState = (0, import_react15.useState)(), originalFocusedElement = _useState[0], setOriginalFocusedElement = _useState[1];
    (0, import_react15.useEffect)(function() {
      return setOriginalFocusedElement(document.activeElement);
    }, []);
    var _useState2 = (0, import_react15.useState)(), dropContainer = _useState2[0], setDropContainer = _useState2[1];
    var containerTarget = (0, import_react15.useContext)(ContainerTargetContext);
    var containerChildNodesLength = (0, import_react15.useRef)(null);
    (0, import_react15.useEffect)(function() {
      if (!(containerChildNodesLength != null && containerChildNodesLength.current)) {
        containerChildNodesLength.current = containerTarget.childNodes.length;
        setDropContainer(!inline ? getNewContainer(containerTarget) : void 0);
      }
    }, [containerTarget, inline]);
    (0, import_react15.useEffect)(function() {
      return function() {
        if (restrictFocus && originalFocusedElement) {
          if (originalFocusedElement.focus) {
            setFocusWithoutScroll(originalFocusedElement);
          } else if (originalFocusedElement.parentNode && originalFocusedElement.parentNode.focus) {
            setFocusWithoutScroll(originalFocusedElement.parentNode);
          }
        }
        if (dropContainer) {
          containerTarget.removeChild(dropContainer);
        }
      };
    }, [containerTarget, dropContainer, originalFocusedElement, restrictFocus]);
    var content = /* @__PURE__ */ import_react15.default.createElement(DropContainer, _extends12({
      ref,
      dir: theme && theme.dir,
      dropTarget,
      restrictFocus,
      trapFocus
    }, rest));
    if (inline)
      return content;
    if (dropContainer)
      return /* @__PURE__ */ (0, import_react_dom.createPortal)(content, dropContainer);
    return null;
  });
  Drop.displayName = "Drop";
  Drop.propTypes = DropPropTypes;

  // node_modules/grommet/es6/components/Tip/propTypes.js
  var import_prop_types8 = __toESM(require_prop_types());
  var PropType7 = {};
  if (true) {
    PropType7 = {
      content: import_prop_types8.default.node,
      dropProps: import_prop_types8.default.object,
      plain: import_prop_types8.default.bool
    };
  }
  var TipPropTypes = PropType7;

  // node_modules/grommet/es6/components/Tip/Tip.js
  function _extends13() {
    _extends13 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends13.apply(this, arguments);
  }
  var Tip = /* @__PURE__ */ (0, import_react16.forwardRef)(function(_ref, tipRef) {
    var children = _ref.children, content = _ref.content, dropProps4 = _ref.dropProps, plain = _ref.plain;
    var theme = (0, import_react16.useContext)(import_styled_components13.ThemeContext);
    var _useState = (0, import_react16.useState)(false), over = _useState[0], setOver = _useState[1];
    var usingKeyboard = useKeyboard();
    var componentRef = useForwardedRef(tipRef);
    var child = import_react16.Children.count(children) <= 1 && !/* @__PURE__ */ import_react16.default.isValidElement(children) && /* @__PURE__ */ import_react16.default.createElement("span", null, children) || import_react16.Children.only(children);
    var clonedChild = /* @__PURE__ */ (0, import_react16.cloneElement)(child, {
      onMouseEnter: function onMouseEnter(event) {
        var _child$props;
        setOver(true);
        if ((_child$props = child.props) != null && _child$props.onMouseEnter)
          child.props.onMouseEnter(event);
      },
      onMouseLeave: function onMouseLeave(event) {
        var _child$props2;
        setOver(false);
        if ((_child$props2 = child.props) != null && _child$props2.onMouseLeave)
          child.props.onMouseLeave(event);
      },
      onFocus: function onFocus(event) {
        var _child$props3;
        if (usingKeyboard)
          setOver(true);
        if ((_child$props3 = child.props) != null && _child$props3.onFocus)
          child.props.onFocus(event);
      },
      onBlur: function onBlur(event) {
        var _child$props4;
        if (usingKeyboard)
          setOver(false);
        if ((_child$props4 = child.props) != null && _child$props4.onBlur)
          child.props.onBlur(event);
      },
      key: "tip-child",
      ref: function ref(node) {
        if (typeof componentRef === "function") {
          componentRef(node);
        } else if (componentRef) {
          componentRef.current = node;
        }
        var callerRef = child.ref;
        if (typeof callerRef === "function") {
          callerRef(node);
        } else if (callerRef) {
          callerRef.current = node;
        }
      }
    });
    return [clonedChild, over && /* @__PURE__ */ import_react16.default.createElement(Drop, _extends13({
      target: componentRef.current,
      trapFocus: false,
      key: "tip-drop"
    }, theme.tip.drop, dropProps4), plain ? content : /* @__PURE__ */ import_react16.default.createElement(Box, theme.tip.content, content))];
  });
  Tip.displayName = "Tip";
  Tip.propTypes = TipPropTypes;

  // node_modules/grommet/es6/components/Button/Badge.js
  var import_react22 = __toESM(require_react());
  var import_styled_components17 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/utils/use-isomorphic-layout-effect.js
  var import_react17 = __toESM(require_react());
  var useLayoutEffect = typeof window !== "undefined" ? import_react17.useLayoutEffect : import_react17.useEffect;

  // node_modules/grommet/es6/components/Stack/Stack.js
  var import_react18 = __toESM(require_react());

  // node_modules/grommet/es6/components/Stack/StyledStack.js
  var import_styled_components14 = __toESM(require_styled_components_browser_cjs());
  var fillStyle3 = (0, import_styled_components14.css)(["", " ", " flex-grow:1;display:flex;"], function(props) {
    return props.fillContainer === true || props.fillContainer === "horizontal" ? "\n        width: 100%;\n        max-width: none;\n      " : "";
  }, function(props) {
    return props.fillContainer === true || props.fillContainer === "vertical" ? "height: 100%;" : "";
  });
  var StyledStack = import_styled_components14.default.div.withConfig({
    displayName: "StyledStack",
    componentId: "sc-ajspsk-0"
  })(["position:relative;", " ", " ", ""], genericStyles, function(props) {
    return props.fillContainer && fillStyle3;
  }, function(props) {
    return props.theme.stack && props.theme.stack.extend;
  });
  StyledStack.defaultProps = {};
  Object.setPrototypeOf(StyledStack.defaultProps, defaultProps2);
  var styleMap = {
    fill: "\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n  ",
    center: "\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n  ",
    left: "\n    top: 50%;\n    left: 0;\n    transform: translateY(-50%);\n  ",
    right: "\n    top: 50%;\n    right: 0;\n    transform: translateY(-50%);\n  ",
    top: "\n    top: 0;\n    left: 50%;\n    transform: translateX(-50%);\n  ",
    bottom: "\n    bottom: 0;\n    left: 50%;\n    transform: translateX(-50%);\n  ",
    "top-left": "\n    top: 0;\n    left: 0;\n  ",
    "bottom-left": "\n    bottom: 0;\n    left: 0;\n  ",
    "top-right": "\n    top: 0;\n    right: 0;\n  ",
    "bottom-right": "\n    bottom: 0;\n    right: 0;\n  "
  };
  var StyledStackLayer = import_styled_components14.default.div.withConfig({
    displayName: "StyledStack__StyledStackLayer",
    componentId: "sc-ajspsk-1"
  })(["position:", ";", " ", " ", " ", ""], function(props) {
    return props.guiding ? "relative" : "absolute";
  }, function(props) {
    return props.guiding && "display: block;";
  }, function(props) {
    return !props.guiding && styleMap[props.anchor || "fill"] + ";";
  }, function(props) {
    return props.fillContainer && "\n    width: 100%;\n    height: 100%;\n  ";
  }, function(props) {
    return !props.interactive && "pointer-events: none;";
  });
  StyledStackLayer.defaultProps = {};
  Object.setPrototypeOf(StyledStackLayer.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/Stack/propTypes.js
  var import_prop_types9 = __toESM(require_prop_types());
  function _extends14() {
    _extends14 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends14.apply(this, arguments);
  }
  var PropType8 = {};
  if (true) {
    PropType8 = _extends14({}, genericProps, {
      anchor: import_prop_types9.default.oneOf(["center", "left", "right", "top", "bottom", "top-left", "bottom-left", "top-right", "bottom-right"]),
      fill: import_prop_types9.default.oneOfType([import_prop_types9.default.oneOf(["horizontal", "vertical"]), import_prop_types9.default.bool]),
      guidingChild: import_prop_types9.default.oneOfType([import_prop_types9.default.number, import_prop_types9.default.oneOf(["first", "last"])]),
      interactiveChild: import_prop_types9.default.oneOfType([import_prop_types9.default.number, import_prop_types9.default.oneOf(["first", "last"])])
    });
  }
  var StackPropTypes = PropType8;

  // node_modules/grommet/es6/components/Stack/Stack.js
  var _excluded8 = ["anchor", "children", "fill", "guidingChild", "interactiveChild"];
  function _objectWithoutPropertiesLoose8(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _extends15() {
    _extends15 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends15.apply(this, arguments);
  }
  var buildStyledChildren = function buildStyledChildren2(_ref) {
    var anchor = _ref.anchor, fill = _ref.fill, guidingIndex = _ref.guidingIndex, interactiveChild = _ref.interactiveChild, interactiveIndex = _ref.interactiveIndex;
    return function(child, index) {
      var interactive = interactiveChild === void 0 || interactiveIndex === index;
      var isGuidingIndex = index === guidingIndex;
      var props = isGuidingIndex ? {
        guiding: true,
        fillContainer: fill
      } : {
        anchor
      };
      return /* @__PURE__ */ import_react18.default.createElement(StyledStackLayer, _extends15({
        key: index,
        interactive
      }, props), child);
    };
  };
  var Stack = /* @__PURE__ */ (0, import_react18.forwardRef)(function(_ref2, ref) {
    var anchor = _ref2.anchor, children = _ref2.children, fill = _ref2.fill, guidingChild = _ref2.guidingChild, interactiveChild = _ref2.interactiveChild, rest = _objectWithoutPropertiesLoose8(_ref2, _excluded8);
    var prunedChildren = import_react18.Children.toArray(children).filter(function(c) {
      return c;
    });
    var toChildIndex = function toChildIndex2(child) {
      var index = child;
      if (index === "first" || !index)
        index = 0;
      else if (index === "last")
        index = prunedChildren.length - 1;
      return index;
    };
    var guidingIndex = toChildIndex(guidingChild);
    var interactiveIndex = interactiveChild && toChildIndex(interactiveChild);
    var styledChildren = prunedChildren.map(buildStyledChildren({
      anchor,
      fill,
      guidingIndex,
      interactiveChild,
      interactiveIndex
    }));
    return /* @__PURE__ */ import_react18.default.createElement(StyledStack, _extends15({
      ref,
      fillContainer: fill
    }, rest), styledChildren);
  });
  Stack.displayName = "Stack";
  Stack.propTypes = StackPropTypes;

  // node_modules/grommet/es6/components/Text/Text.js
  var import_react21 = __toESM(require_react());

  // node_modules/grommet/es6/components/Text/StyledText.js
  var import_styled_components15 = __toESM(require_styled_components_browser_cjs());
  var sizeStyle3 = function sizeStyle4(props) {
    var size = props.size || "medium";
    var data = props.theme.text[size];
    if (data) {
      return (0, import_styled_components15.css)(["font-size:", ";line-height:", ";"], data.size, data.height);
    }
    return (0, import_styled_components15.css)(["font-size:", ";line-height:normal;"], size);
  };
  var truncateStyle = "\n  white-space: nowrap;\n  max-width: 100%;\n  overflow: hidden;\n  text-overflow: ellipsis;\n";
  var colorStyle = (0, import_styled_components15.css)(["color:", ";"], function(props) {
    return normalizeColor(props.colorProp, props.theme);
  });
  var weightStyle = (0, import_styled_components15.css)(["font-weight:", ";"], function(props) {
    return props.weight;
  });
  var wordBreakStyle = (0, import_styled_components15.css)(["word-break:", ";"], function(props) {
    return props.wordBreak;
  });
  var fontFamily = (0, import_styled_components15.css)(["font-family:", ";"], function(props) {
    return props.theme.text.font.family;
  });
  var StyledText = (0, import_styled_components15.default)("span").withConfig({
    shouldForwardProp: function shouldForwardProp(prop, defaultValidatorFn) {
      return defaultValidatorFn(prop) && prop !== "size";
    }
  }).withConfig({
    displayName: "StyledText",
    componentId: "sc-1sadyjn-0"
  })(["", " ", " ", " ", " ", " ", " ", " ", " ", ""], genericStyles, function(props) {
    return sizeStyle3(props);
  }, function(props) {
    return props.textAlign && textAlignStyle;
  }, function(props) {
    return props.truncate && truncateStyle;
  }, function(props) {
    return props.colorProp && colorStyle;
  }, function(props) {
    return props.weight && weightStyle;
  }, function(props) {
    return props.wordBreak && wordBreakStyle;
  }, function(props) {
    return props.theme.text.font && props.theme.text.font.family && fontFamily;
  }, function(props) {
    return props.theme.text && props.theme.text.extend;
  });
  StyledText.defaultProps = {};
  Object.setPrototypeOf(StyledText.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/Text/propTypes.js
  var import_prop_types10 = __toESM(require_prop_types());
  function _extends16() {
    _extends16 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends16.apply(this, arguments);
  }
  var PropType9 = {};
  if (true) {
    PropType9 = _extends16({}, genericProps, {
      color: colorPropType,
      margin: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(["none"].concat(MARGIN_SIZES)), import_prop_types10.default.shape({
        bottom: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(MARGIN_SIZES), import_prop_types10.default.string]),
        end: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(MARGIN_SIZES), import_prop_types10.default.string]),
        horizontal: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(MARGIN_SIZES), import_prop_types10.default.string]),
        left: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(MARGIN_SIZES), import_prop_types10.default.string]),
        right: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(MARGIN_SIZES), import_prop_types10.default.string]),
        start: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(MARGIN_SIZES), import_prop_types10.default.string]),
        top: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(MARGIN_SIZES), import_prop_types10.default.string]),
        vertical: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(MARGIN_SIZES), import_prop_types10.default.string])
      }), import_prop_types10.default.string]),
      size: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(["xsmall", "small", "medium", "large", "xlarge", "xxlarge", "2xl", "3xl", "4xl", "5xl", "6xl"]), import_prop_types10.default.string]),
      skeleton: skeletonPropType,
      tag: import_prop_types10.default.oneOfType([import_prop_types10.default.string, import_prop_types10.default.func]),
      as: import_prop_types10.default.oneOfType([import_prop_types10.default.string, import_prop_types10.default.func, import_prop_types10.default.element]),
      textAlign: import_prop_types10.default.oneOf(["start", "center", "end", "justify"]),
      tip: import_prop_types10.default.oneOfType([import_prop_types10.default.shape({
        content: import_prop_types10.default.oneOfType([import_prop_types10.default.node, import_prop_types10.default.string]),
        dropProps: import_prop_types10.default.shape({}),
        plain: import_prop_types10.default.bool
      }), import_prop_types10.default.string]),
      truncate: import_prop_types10.default.oneOfType([import_prop_types10.default.bool, import_prop_types10.default.oneOf(["tip"])]),
      weight: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(["normal", "bold", "bolder", "lighter"]), import_prop_types10.default.number]),
      wordBreak: import_prop_types10.default.oneOf(["normal", "break-all", "keep-all", "break-word"])
    });
  }
  var TextPropTypes = PropType9;

  // node_modules/grommet/es6/components/Text/TextSkeleton.js
  var import_react19 = __toESM(require_react());
  var import_styled_components16 = __toESM(require_styled_components_browser_cjs());
  var _excluded9 = ["as", "size"];
  function _extends17() {
    _extends17 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends17.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose9(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var TextSkeleton = /* @__PURE__ */ (0, import_react19.forwardRef)(function(_ref, ref) {
    var as = _ref.as, sizeProp = _ref.size, rest = _objectWithoutPropertiesLoose9(_ref, _excluded9);
    var theme = (0, import_react19.useContext)(import_styled_components16.ThemeContext) || defaultProps2.theme;
    var size = sizeProp || "medium";
    var data = theme.text[size];
    var height = data ? data.size : sizeProp;
    return /* @__PURE__ */ import_react19.default.createElement(Skeleton, _extends17({
      ref,
      as,
      height
    }, theme.text.skeleton, rest));
  });
  TextSkeleton.displayName = "TextSkeleton";

  // node_modules/grommet/es6/components/Text/TextContext.js
  var import_react20 = __toESM(require_react());
  var TextContext = /* @__PURE__ */ import_react20.default.createContext({});

  // node_modules/grommet/es6/components/Text/Text.js
  var _excluded10 = ["children", "color", "tag", "as", "tip", "a11yTitle", "truncate", "size", "skeleton"];
  function _extends18() {
    _extends18 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends18.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose10(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Text = /* @__PURE__ */ (0, import_react21.forwardRef)(function(_ref, ref) {
    var children = _ref.children, color = _ref.color, tag = _ref.tag, as = _ref.as, tipProp = _ref.tip, _ref$a11yTitle = _ref.a11yTitle, a11yTitle = _ref$a11yTitle === void 0 ? typeof tipProp === "string" && tipProp || (tipProp == null ? void 0 : tipProp.content) || void 0 : _ref$a11yTitle, truncate = _ref.truncate, size = _ref.size, skeletonProp = _ref.skeleton, rest = _objectWithoutPropertiesLoose10(_ref, _excluded10);
    var textRef = useForwardedRef(ref);
    var _useState = (0, import_react21.useState)(false), textTruncated = _useState[0], setTextTruncated = _useState[1];
    var textContextValue = (0, import_react21.useMemo)(function() {
      return {
        size
      };
    }, [size]);
    var skeleton = useSkeleton();
    useLayoutEffect(function() {
      var updateTip = function updateTip2() {
        setTextTruncated(false);
        if (truncate === "tip" && textRef.current && textRef.current.scrollWidth > textRef.current.offsetWidth) {
          setTextTruncated(true);
        }
      };
      window.addEventListener("resize", updateTip);
      updateTip();
      return function() {
        return window.removeEventListener("resize", updateTip);
      };
    }, [textRef, truncate]);
    if (skeleton) {
      return /* @__PURE__ */ import_react21.default.createElement(TextSkeleton, _extends18({
        ref,
        as,
        size
      }, skeletonProp, rest));
    }
    var styledTextResult = /* @__PURE__ */ import_react21.default.createElement(StyledText, _extends18({
      as: !as && tag ? tag : as,
      colorProp: color,
      "aria-label": a11yTitle,
      truncate,
      size
    }, rest, {
      ref: textRef
    }), /* @__PURE__ */ import_react21.default.createElement(TextContext.Provider, {
      value: textContextValue
    }, children));
    if (tipProp || textTruncated) {
      if (textTruncated) {
        return /* @__PURE__ */ import_react21.default.createElement(Tip, _extends18({
          content: children
        }, tipProp), styledTextResult);
      }
      if (truncate !== "tip") {
        return /* @__PURE__ */ import_react21.default.createElement(Tip, tipProp, styledTextResult);
      }
    }
    return styledTextResult;
  });
  Text.displayName = "Text";
  Text.defaultProps = {
    level: 1
  };
  Text.propTypes = TextPropTypes;

  // node_modules/grommet/es6/components/Button/Badge.js
  var StyledBadgeContainer = (0, import_styled_components17.default)(Box).withConfig({
    displayName: "Badge__StyledBadgeContainer",
    componentId: "sc-1es4ws1-0"
  })(["", ""], function(props) {
    return props.theme.button.badge.container.extend;
  });
  var Badge = function Badge2(_ref) {
    var children = _ref.children, content = _ref.content;
    var theme = (0, import_react22.useContext)(import_styled_components17.ThemeContext);
    var contentRef = (0, import_react22.useRef)();
    var stackRef = (0, import_react22.useRef)();
    var defaultBadgeDimension = typeof content === "boolean" || content && content.value && typeof content.value === "boolean" ? (
      // empty badge should be smaller. this value was chosen as a default
      // after experimenting with various values
      parseMetricToNum(theme.button.badge.size.medium) / 2 + "px"
    ) : theme.button.badge.size.medium;
    var _useState = (0, import_react22.useState)(defaultBadgeDimension), height = _useState[0], setHeight = _useState[1];
    var _useState2 = (0, import_react22.useState)(height), width = _useState2[0], setWidth = _useState2[1];
    useLayoutEffect(function() {
      var onResize = function onResize2() {
        if (contentRef && contentRef.current) {
          if (typeof content === "number" || typeof content === "object" && content.value) {
            var _contentRef$current$g = contentRef.current.getBoundingClientRect(), contentHeight = _contentRef$current$g.height, contentWidth = _contentRef$current$g.width;
            if (contentHeight) {
              var verticalSpace = (parseMetricToNum(height) - contentHeight) * 2.5;
              setWidth(Math.max(parseMetricToNum(width), Math.ceil(contentWidth + verticalSpace)) + "px");
            }
          } else {
            setWidth(contentRef.current.getBoundingClientRect().width + "px");
            setHeight(contentRef.current.getBoundingClientRect().height + "px");
          }
        }
      };
      window.addEventListener("resize", onResize);
      onResize();
      return function() {
        window.removeEventListener("resize", onResize);
      };
    }, [content, height, width]);
    useLayoutEffect(function() {
      if (stackRef && stackRef.current) {
        var divisor = typeof content === "boolean" || content && content.value === true ? 3.5 : 2;
        var offset2 = {
          right: "-" + Math.round(parseMetricToNum(width) / divisor) + "px",
          top: "-" + Math.round(parseMetricToNum(height) / divisor) + "px"
        };
        stackRef.current.children[1].style.top = offset2.top;
        stackRef.current.children[1].style.right = offset2.right;
      }
    }, [content, height, width]);
    var value;
    if (typeof content === "number")
      value = content;
    else if (typeof content === "object")
      value = content.value;
    var badge;
    if (typeof value === "number" || typeof value === "boolean" || typeof content === "boolean") {
      if (typeof value === "number") {
        var max2 = content.max || 9;
        badge = /* @__PURE__ */ import_react22.default.createElement(Text, {
          color: "text-strong",
          size: theme.button.badge.text.size.medium,
          weight: "normal",
          ref: contentRef
        }, value > max2 ? max2 + "+" : value);
      }
      badge = /* @__PURE__ */ import_react22.default.createElement(StyledBadgeContainer, {
        align: "center",
        background: content.background || theme.button.badge.container.background,
        flex: false,
        height: {
          min: height
        },
        justify: "center",
        round: true,
        pad: !(typeof value === "boolean" || typeof content === "boolean") ? theme.button.badge.container.pad : void 0,
        width: {
          min: width
        }
      }, badge);
    } else
      badge = /* @__PURE__ */ import_react22.default.createElement(Box, {
        ref: contentRef
      }, content);
    return /* @__PURE__ */ import_react22.default.createElement(Stack, {
      ref: stackRef,
      anchor: "top-right"
    }, children, badge);
  };

  // node_modules/grommet/es6/components/Button/StyledButton.js
  var import_styled_components18 = __toESM(require_styled_components_browser_cjs());
  var radiusStyle = function radiusStyle2(props) {
    var isIconOnly = props.hasIcon && !props.hasLabel;
    var size = props.sizeProp;
    if (!isIconOnly && size && props.theme.button.size && props.theme.button.size[size]) {
      return props.theme.button.size[size].border.radius;
    }
    return props.theme.button.border.radius;
  };
  var fontStyle = function fontStyle2(props) {
    var size = props.sizeProp || "medium";
    var data = props.theme.text[size];
    return (0, import_styled_components18.css)(["font-size:", ";line-height:", ";"], data.size, data.height);
  };
  var padStyle = function padStyle2(props) {
    var size = props.sizeProp;
    if (size && props.theme.button.size && props.theme.button.size[size]) {
      return (0, import_styled_components18.css)(["", " ", ""], props.theme.button.size[size].pad.vertical, props.theme.button.size[size].pad.horizontal);
    }
    return (0, import_styled_components18.css)(["", " ", ""], props.theme.button.padding.vertical, props.theme.button.padding.horizontal);
  };
  var basicStyle = function basicStyle2(props) {
    return (0, import_styled_components18.css)(["border:", " solid ", ";border-radius:", ";color:", ";padding:", ";", ""], props.theme.button.border.width, normalizeColor(props.colorValue || props.theme.button.border.color || "control", props.theme), radiusStyle(props), normalizeColor(props.theme.button.color || "text", props.theme), padStyle(props), fontStyle(props));
  };
  var primaryStyle = function primaryStyle2(props) {
    return (0, import_styled_components18.css)(["", " border-radius:", ";", ""], backgroundStyle(normalizeColor(props.colorValue || props.theme.button.primary && props.theme.button.primary.color || "control", props.theme), props.theme, props.theme.button.color), radiusStyle(props), props.theme.button.primary && props.theme.button.primary.extend);
  };
  function getHoverColor(props) {
    if (props.colorValue) {
      return normalizeColor(props.colorValue, props.theme);
    }
    if (props.active && props.primary && props.theme.button.primary && props.theme.button.primary.active && props.theme.button.primary.active.border && props.theme.button.primary.active.border.color) {
      return normalizeColor(props.theme.button.primary.active.border.color, props.theme);
    }
    return normalizeColor(props.theme.button.border.color || "control", props.theme);
  }
  var hoverStyle = (0, import_styled_components18.css)(["&:hover{", " ", ";}"], function(props) {
    return props.hoverIndicator && getHoverIndicatorStyle(props.hoverIndicator, props.theme);
  }, function(props) {
    return !props.plain && (0, import_styled_components18.css)(["box-shadow:0px 0px 0px 2px ", ";"], getHoverColor(props));
  });
  var fillStyle4 = function fillStyle5(fillContainer) {
    if (fillContainer === "horizontal") {
      return "width: 100%;";
    }
    if (fillContainer === "vertical") {
      return "height: 100%;";
    }
    if (fillContainer) {
      return "\n      width: 100%;\n      height: 100%;\n      max-width: none;\n      flex: 1 0 auto;\n    ";
    }
    return void 0;
  };
  var plainStyle = function plainStyle2(props) {
    return (0, import_styled_components18.css)(["color:", ";outline:none;border:none;padding:0;text-align:inherit;"], normalizeColor(props.colorValue || "inherit", props.theme));
  };
  var activeButtonStyle = function activeButtonStyle2(props) {
    return (0, import_styled_components18.css)(["", " ", " ", ""], activeStyle, props.primary && props.theme.button.primary && props.theme.button.primary.active && props.theme.button.primary.active.border && props.theme.button.primary.active.border.color && "border: " + props.theme.button.border.width + " solid\n    " + normalizeColor(props.theme.button.primary.active.border.color, props.theme) + ";\n    ", props.primary && props.theme.button.primary && props.theme.button.primary.active && props.theme.button.primary.active.extend);
  };
  var disabledButtonStyle = function disabledButtonStyle2(props) {
    return (0, import_styled_components18.css)(["", " ", " ", " ", ""], disabledStyle(props.theme.button.disabled.opacity), !props.plain && props.theme.button.disabled.border && props.theme.button.disabled.border.color && "border: " + props.theme.button.border.width + " solid\n    " + normalizeColor(props.theme.button.disabled.border.color, props.theme) + ";", props.theme.button.disabled.color && // if primary button, apply disabled color to background. otherwise,
    // apply disabled color to the label
    (props.primary ? backgroundStyle(normalizeColor(props.theme.button.disabled.color, props.theme), props.theme, props.theme.button.color) : "color: " + normalizeColor(props.theme.button.disabled.color, props.theme) + ";"), props.theme.button.disabled && props.theme.button.disabled.extend);
  };
  var StyledButton = import_styled_components18.default.button.withConfig({
    displayName: "StyledButton",
    componentId: "sc-323bzc-0"
  })(["display:inline-block;box-sizing:border-box;cursor:pointer;font:inherit;text-decoration:none;margin:0;background:transparent;overflow:visible;text-transform:none;", " ", " ", " ", " ", " ", " ", " &:focus{", "}&:focus:not(:focus-visible){", "}", " ", " ", " ", " ", ""], genericStyles, function(props) {
    return props.plain && plainStyle(props);
  }, function(props) {
    return !props.plain && basicStyle(props);
  }, function(props) {
    return props.primary && primaryStyle(props);
  }, function(props) {
    return !props.disabled && !props.selected && !props.focus && hoverStyle;
  }, function(props) {
    return !props.disabled && props.active && activeButtonStyle(props);
  }, function(props) {
    return props.disabled && props.theme.button && props.theme.button.disabled && disabledButtonStyle(props);
  }, function(props) {
    return (!props.plain || props.focusIndicator) && focusStyle();
  }, unfocusStyle(), function(props) {
    return !props.plain && props.theme.button.transition && "\n    transition-property: " + props.theme.button.transition.properties.join(",") + ";\n    transition-duration: " + props.theme.button.transition.duration + "s;\n    transition-timing-function: " + props.theme.button.transition.timing + ";\n  ";
  }, function(props) {
    return props.fillContainer && fillStyle4(props.fillContainer);
  }, function(props) {
    return props.hasIcon && !props.hasLabel && "\n    line-height: 0;\n  ";
  }, function(props) {
    return props.pad && props.hasIcon && !props.hasLabel && "\n    padding: " + props.theme.global.edgeSize.small + ";\n  ";
  }, function(props) {
    return props.theme.button && props.theme.button.extend;
  });
  StyledButton.defaultProps = {};
  Object.setPrototypeOf(StyledButton.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/Button/StyledButtonKind.js
  var import_styled_components19 = __toESM(require_styled_components_browser_cjs());
  var radiusStyle3 = function radiusStyle4(props) {
    var size = props.sizeProp;
    var themeObj = typeof props.kind === "object" ? props.kind : props.theme.button;
    if (size && themeObj.size && themeObj.size[size])
      return (0, import_styled_components19.css)(["border-radius:", ";"], themeObj.size[size].border.radius);
    if (themeObj.border && themeObj.border.radius)
      return (0, import_styled_components19.css)(["border-radius:", ";"], themeObj.border.radius);
    return "";
  };
  var fontStyle3 = function fontStyle4(props) {
    var size = props.sizeProp || "medium";
    var data = props.theme.text[size];
    return (0, import_styled_components19.css)(["font-size:", ";line-height:", ";"], data.size, data.height);
  };
  var padFromTheme = function padFromTheme2(size, theme, themeObj, kind, iconOnly) {
    var _themeObj$size, _themeObj$size$size, _themeObj$size$size$i, _themeObj$size3, _themeObj$size3$size, _themeObj$size3$size$;
    if (size === void 0) {
      size = "medium";
    }
    if (size && iconOnly && themeObj != null && (_themeObj$size = themeObj.size) != null && (_themeObj$size$size = _themeObj$size[size]) != null && (_themeObj$size$size$i = _themeObj$size$size.iconOnly) != null && _themeObj$size$size$i.pad) {
      var _themeObj$size2, _themeObj$size2$size, _themeObj$size2$size$;
      var pad = themeObj == null ? void 0 : (_themeObj$size2 = themeObj.size) == null ? void 0 : (_themeObj$size2$size = _themeObj$size2[size]) == null ? void 0 : (_themeObj$size2$size$ = _themeObj$size2$size.iconOnly) == null ? void 0 : _themeObj$size2$size$.pad;
      return {
        vertical: typeof pad === "string" ? pad : pad.vertical,
        horizontal: typeof pad === "string" ? pad : pad.horizontal
      };
    }
    if (size && themeObj != null && (_themeObj$size3 = themeObj.size) != null && (_themeObj$size3$size = _themeObj$size3[size]) != null && (_themeObj$size3$size$ = _themeObj$size3$size[kind]) != null && _themeObj$size3$size$.pad) {
      return themeObj.size[size][kind].pad;
    }
    if (size && themeObj.size && themeObj.size[size] && themeObj.size[size].pad) {
      return {
        vertical: themeObj.size[size].pad.vertical,
        horizontal: themeObj.size[size].pad.horizontal
      };
    }
    if (theme.button.padding) {
      return {
        vertical: theme.global.edgeSize[theme.button.padding.vertical] || theme.button.padding.vertical,
        horizontal: theme.global.edgeSize[theme.button.padding.horizontal] || theme.button.padding.horizontal
      };
    }
    return void 0;
  };
  var padStyle3 = function padStyle4(_ref) {
    var hasIcon = _ref.hasIcon, hasLabel = _ref.hasLabel, size = _ref.sizeProp, theme = _ref.theme, kind = _ref.kind;
    var themeObj = typeof kind === "object" ? kind : theme.button;
    var iconOnly = hasIcon && !hasLabel;
    var pad = padFromTheme(size, theme, themeObj, kind, iconOnly);
    return pad ? (0, import_styled_components19.css)(["padding:", " ", ";"], pad.vertical, pad.horizontal) : "";
  };
  var basicStyle3 = function basicStyle4(props) {
    return (0, import_styled_components19.css)(["border:none;", ";", " ", " ", ""], radiusStyle3(props), padStyle3(props), fontStyle3(props), props.icon && "\n    > svg {\n      display: flex;\n      align-self: center;\n      vertical-align: middle;\n    }\n  ");
  };
  var getPath = function getPath2(theme, path) {
    var obj;
    if (path) {
      obj = theme;
      var parts2 = path.split(".");
      while (obj && parts2.length)
        obj = obj[parts2.shift()];
    }
    return obj;
  };
  var adjustPadStyle = function adjustPadStyle2(pad, width) {
    var offset2 = parseMetricToNum(width);
    return (0, import_styled_components19.css)(["padding:", "px ", "px;"], Math.max(parseMetricToNum(pad.vertical) - offset2, 0), Math.max(parseMetricToNum(pad.horizontal) - offset2, 0));
  };
  var kindStyle = function kindStyle2(_ref2) {
    var colorValue = _ref2.colorValue, hasIcon = _ref2.hasIcon, hasLabel = _ref2.hasLabel, kind = _ref2.kind, size = _ref2.sizeProp, themePaths = _ref2.themePaths, theme = _ref2.theme;
    var styles = [];
    var themeObj = typeof kind === "object" ? kind : theme.button;
    var iconOnly = hasIcon && !hasLabel;
    var pad = padFromTheme(size, theme, themeObj, kind, iconOnly);
    themePaths.base.forEach(function(themePath) {
      var obj2 = getPath(themeObj, themePath);
      if (obj2) {
        styles.push(kindPartStyles(obj2, theme, colorValue));
        if (obj2.border && obj2.border.width && pad && !obj2.padding) {
          styles.push(adjustPadStyle(pad, obj2.border.width));
        }
      }
    });
    if (!themePaths.base.length && typeof kind === "object") {
      var obj = kind;
      if (obj) {
        styles.push(kindPartStyles(obj, theme, colorValue));
        if (obj.border && obj.border.width && pad && !obj.padding) {
          styles.push(adjustPadStyle(pad, obj.border.width));
        }
      }
    }
    themePaths.hover.forEach(function(themePath) {
      var obj2 = getPath(themeObj, themePath);
      if (obj2) {
        var partStyles = kindPartStyles(obj2, theme);
        var adjPadStyles = "";
        if (obj2.border && obj2.border.width && pad && !obj2.padding) {
          adjPadStyles = adjustPadStyle(pad, obj2.border.width);
        }
        if (partStyles.length > 0) {
          styles.push((0, import_styled_components19.css)(["&:hover{", " ", "}"], partStyles, adjPadStyles));
        }
      }
    });
    return styles;
  };
  var hoverIndicatorStyle = function hoverIndicatorStyle2(_ref3) {
    var hoverIndicator = _ref3.hoverIndicator, theme = _ref3.theme;
    var themishObj = {};
    if (hoverIndicator === true || hoverIndicator === "background")
      themishObj.background = theme.global.hover.background;
    else if (hoverIndicator.color || hoverIndicator.background) {
      if (hoverIndicator.background)
        themishObj.background = hoverIndicator.background;
      if (hoverIndicator.color)
        themishObj.color = hoverIndicator.color;
    } else
      themishObj.background = hoverIndicator;
    var styles = kindPartStyles(themishObj, theme);
    if (styles.length > 0)
      return (0, import_styled_components19.css)(["&:hover{", "}"], styles);
    return "";
  };
  var fillStyle6 = function fillStyle7(fillContainer) {
    if (fillContainer === "horizontal") {
      return "width: 100%;";
    }
    if (fillContainer === "vertical") {
      return "height: 100%;";
    }
    if (fillContainer) {
      return "\n      width: 100%;\n      height: 100%;\n      max-width: none;\n      flex: 1 0 auto;\n    ";
    }
    return void 0;
  };
  var plainStyle3 = function plainStyle4(props) {
    return (0, import_styled_components19.css)(["outline:none;border:none;padding:0;text-align:inherit;color:inherit;", ""], props.icon && "\n    > svg {\n      display: flex;\n      align-self: center;\n      vertical-align: middle;\n    }\n  ");
  };
  var StyledButtonKind = import_styled_components19.default.button.withConfig({
    // don't let kind attribute leak to DOM
    // https://styled-components.com/docs/api#shouldforwardprop
    shouldForwardProp: function shouldForwardProp2(prop, defaultValidatorFn) {
      return !["kind"].includes(prop) && defaultValidatorFn(prop);
    }
  }).withConfig({
    displayName: "StyledButtonKind",
    componentId: "sc-1vhfpnt-0"
  })(["display:inline-block;box-sizing:border-box;cursor:pointer;font:inherit;text-decoration:none;margin:0;background:transparent;overflow:visible;text-transform:none;", " ", " ", " ", " ", " ", " ", " ", " &:focus{", "}&:focus:not(:focus-visible){", "}", " ", " ", ""], genericStyles, function(props) {
    return props.plain && plainStyle3(props);
  }, function(props) {
    return !props.disabled && props.active && activeStyle;
  }, function(props) {
    return !props.plain && basicStyle3(props);
  }, function(props) {
    return !props.plain && kindStyle(props);
  }, function(props) {
    return !props.plain && props.align && "\n    text-align: " + props.align + ";\n    ";
  }, function(props) {
    return !props.disabled && props.hoverIndicator && hoverIndicatorStyle(props);
  }, function(props) {
    return props.disabled && disabledStyle(props.theme.button.disabled.opacity);
  }, function(props) {
    return (!props.plain || props.focusIndicator) && focusStyle();
  }, unfocusStyle(), function(props) {
    return !props.plain && props.theme.button.transition && "\n    transition-property: " + props.theme.button.transition.properties.join(",") + ";\n    transition-duration: " + props.theme.button.transition.duration + "s;\n    transition-timing-function: " + props.theme.button.transition.timing + ";\n  ";
  }, function(props) {
    return props.fillContainer && fillStyle6(props.fillContainer);
  }, function(props) {
    return props.theme.button && props.theme.button.extend;
  });
  StyledButtonKind.defaultProps = {};
  Object.setPrototypeOf(StyledButtonKind.defaultProps, defaultProps2);

  // node_modules/grommet/es6/contexts/AnalyticsContext/AnalyticsContext.js
  var import_react23 = __toESM(require_react());
  var AnalyticsContext = /* @__PURE__ */ import_react23.default.createContext(function() {
  });
  var useAnalytics = function useAnalytics2() {
    return (0, import_react23.useContext)(AnalyticsContext);
  };
  var AnalyticsProvider = function AnalyticsProvider2(_ref) {
    var onAnalytics = _ref.onAnalytics, children = _ref.children;
    var lastUrlRef = (0, import_react23.useRef)();
    var sendAnalytics = (0, import_react23.useCallback)(function(data) {
      return onAnalytics && onAnalytics(data);
    }, [onAnalytics]);
    (0, import_react23.useEffect)(function() {
      var observer;
      if (onAnalytics) {
        observer = new window.MutationObserver(function() {
          var _window, _window$location;
          var url = (_window = window) == null ? void 0 : (_window$location = _window.location) == null ? void 0 : _window$location.href;
          var previousUrl = lastUrlRef.current;
          if (url !== previousUrl) {
            lastUrlRef.current = url;
            sendAnalytics({
              type: "pageView",
              url,
              previousUrl
            });
          }
        });
        observer.observe(document, {
          subtree: true,
          childList: true
        });
      }
      return function() {
        var _observer;
        return (_observer = observer) == null ? void 0 : _observer.disconnect();
      };
    }, [sendAnalytics, onAnalytics]);
    return /* @__PURE__ */ import_react23.default.createElement(AnalyticsContext.Provider, {
      value: sendAnalytics
    }, children);
  };

  // node_modules/grommet/es6/components/Button/Button.js
  var _excluded11 = ["active", "align", "aria-label", "badge", "color", "children", "disabled", "icon", "focusIndicator", "gap", "fill", "href", "justify", "kind", "label", "onBlur", "onClick", "onFocus", "onMouseOut", "onMouseOver", "plain", "primary", "reverse", "secondary", "selected", "size", "tip", "type", "a11yTitle", "as"];
  function _extends19() {
    _extends19 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends19.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose11(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var getIconColor = function getIconColor2(paths, theme, colorProp, kind) {
    if (paths === void 0) {
      paths = [];
    }
    var result = [];
    var index = paths.length - 1;
    if (typeof kind === "object")
      index = 0;
    while (index >= 0 && !result[1]) {
      var baseObj = typeof kind === "object" && kind || theme.button;
      var obj = baseObj;
      if (paths[index]) {
        var parts2 = paths[index].split(".");
        while (obj && parts2.length)
          obj = obj[parts2.shift()];
      }
      if (obj) {
        var _obj, _obj$icon, _obj$icon$props;
        var background = colorProp && obj.background && obj.background.color ? colorProp : obj.background;
        var objColor = obj.color || (Object.prototype.hasOwnProperty.call(obj, "color") && obj.color === void 0 ? false : void 0);
        var color = void 0;
        if ((_obj = obj) != null && (_obj$icon = _obj.icon) != null && (_obj$icon$props = _obj$icon.props) != null && _obj$icon$props.color)
          color = obj.icon.props.color;
        else if (paths[index + 1]) {
          var _obj2, _obj2$icon, _obj2$icon$props;
          var _parts = paths[index + 1].split(".");
          while (baseObj && _parts.length)
            obj = baseObj[_parts.shift()];
          if ((_obj2 = obj) != null && (_obj2$icon = _obj2.icon) != null && (_obj2$icon$props = _obj2$icon.props) != null && _obj2$icon$props.color)
            color = obj.icon.props.color;
        }
        if (!color)
          color = colorProp && (!obj.background || !obj.background.color) && (!obj.border || !obj.border.color) ? colorProp : objColor;
        result = backgroundAndTextColors(background, color, theme);
      }
      index -= 1;
    }
    return result[1] || void 0;
  };
  var getKindIcon = function getKindIcon2(paths, theme, kind) {
    if (paths === void 0) {
      paths = [];
    }
    var result;
    var index = paths.length - 1;
    if (typeof kind === "object")
      index = 0;
    while (index >= 0 && !result) {
      var _obj3;
      var obj = typeof kind === "object" && kind || theme.button;
      if (paths[index]) {
        var parts2 = paths[index].split(".");
        while (obj && parts2.length)
          obj = obj[parts2.shift()];
      }
      if ((_obj3 = obj) != null && _obj3.icon)
        result = obj.icon;
      index -= 1;
    }
    return result || void 0;
  };
  var getPropertyColor = function getPropertyColor2(property, paths, theme, kind, primary) {
    if (paths === void 0) {
      paths = [];
    }
    var result;
    if (kind) {
      var obj = typeof kind === "object" && kind || theme.button;
      if (paths[0]) {
        var parts2 = paths[0].split(".");
        while (obj && parts2.length)
          obj = obj[parts2.shift()];
      }
      if (obj) {
        result = obj[property] || obj[property] && obj[property].color;
      }
    } else if (primary && theme && theme.button && theme.button.primary) {
      result = theme.button.primary[property] || theme.button.primary[property] && theme.button.primary[property].color;
    } else {
      result = theme && theme.button && theme.button[property] || theme && theme.button && theme.button[property] && theme.button[property].color;
    }
    return result;
  };
  var Button2 = /* @__PURE__ */ (0, import_react24.forwardRef)(function(_ref, ref) {
    var _theme$button$kind;
    var active = _ref.active, _ref$align = _ref.align, align = _ref$align === void 0 ? "center" : _ref$align, ariaLabel = _ref["aria-label"], badgeProp = _ref.badge, color = _ref.color, children = _ref.children, disabled = _ref.disabled, icon = _ref.icon, _ref$focusIndicator = _ref.focusIndicator, focusIndicator = _ref$focusIndicator === void 0 ? true : _ref$focusIndicator, gap = _ref.gap, fill = _ref.fill, href = _ref.href, justify = _ref.justify, kindArg = _ref.kind, label = _ref.label, _onBlur = _ref.onBlur, onClickProp = _ref.onClick, _onFocus = _ref.onFocus, onMouseOut = _ref.onMouseOut, onMouseOver = _ref.onMouseOver, plain = _ref.plain, primary = _ref.primary, reverseProp = _ref.reverse, secondary = _ref.secondary, selected = _ref.selected, sizeProp = _ref.size, tip = _ref.tip, _ref$type = _ref.type, type = _ref$type === void 0 ? "button" : _ref$type, _ref$a11yTitle = _ref.a11yTitle, a11yTitle = _ref$a11yTitle === void 0 ? typeof tip === "string" ? tip : void 0 : _ref$a11yTitle, as = _ref.as, rest = _objectWithoutPropertiesLoose11(_ref, _excluded11);
    var theme = (0, import_react24.useContext)(import_styled_components20.ThemeContext) || defaultProps2.theme;
    var _useState = (0, import_react24.useState)(), focus = _useState[0], setFocus = _useState[1];
    var _useState2 = (0, import_react24.useState)(false), hover = _useState2[0], setHover = _useState2[1];
    if ((icon || label) && children) {
      console.warn("Button should not have children if icon or label is provided");
    }
    var skeleton = useSkeleton();
    var sendAnalytics = useAnalytics();
    var onClick = (0, import_react24.useCallback)(function(event) {
      sendAnalytics({
        type: "buttonClick",
        element: findButtonParent(event.target),
        event,
        href,
        label: typeof label === "string" ? label : void 0
      });
      if (onClickProp)
        onClickProp(event);
    }, [onClickProp, sendAnalytics, href, label]);
    var kindObj = (0, import_react24.useMemo)(function() {
      return typeof kindArg === "object";
    }, [kindArg]);
    var kind = (0, import_react24.useMemo)(function() {
      if (theme.button["default"] || kindObj) {
        if (kindArg)
          return kindArg;
        if (primary)
          return "primary";
        if (secondary)
          return "secondary";
        return "default";
      }
      return void 0;
    }, [kindArg, kindObj, primary, secondary, theme]);
    var size = sizeProp || kind && "medium" || void 0;
    var themePaths = (0, import_react24.useMemo)(function() {
      if (!kind || plain)
        return void 0;
      var result = {
        base: [],
        hover: []
      };
      if (!kindObj)
        result.base.push(kind);
      if (selected) {
        result.base.push("selected");
        if (!kindObj)
          result.base.push("selected." + kind);
      }
      if (disabled) {
        result.base.push("disabled");
        if (!kindObj)
          result.base.push("disabled." + kind);
      } else {
        if (active) {
          result.base.push("active");
          if (!kindObj)
            result.base.push("active." + kind);
        }
        result.hover.push("hover");
        if (!kindObj)
          result.hover.push("hover." + kind);
        if (active) {
          result.hover.push("hover.active");
          if (!kindObj) {
            result.hover.push("hover.active." + kind);
          }
        }
      }
      return result;
    }, [active, disabled, kind, kindObj, plain, selected]);
    if (skeleton) {
      var _theme$text, _theme$button$size;
      return /* @__PURE__ */ import_react24.default.createElement(Skeleton, _extends19({
        ref,
        height: ((_theme$text = theme.text[size || "medium"]) == null ? void 0 : _theme$text.height) || size,
        a11yTitle
      }, rest, (_theme$button$size = theme.button.size) == null ? void 0 : _theme$button$size[size || "medium"], theme.button.skeleton));
    }
    var isDarkBackground = function isDarkBackground2() {
      var backgroundColor = normalizeBackground(normalizeColor(color || theme.button.primary && theme.button.primary.color || theme.global.colors.control || "brand", theme), theme);
      return colorIsDark(backgroundColor, theme);
    };
    var onMouseOverButton = function onMouseOverButton2(event) {
      setHover(true);
      if (onMouseOver) {
        onMouseOver(event);
      }
    };
    var onMouseOutButton = function onMouseOutButton2(event) {
      setHover(false);
      if (onMouseOut) {
        onMouseOut(event);
      }
    };
    var kindIcon = hover && getKindIcon(themePaths == null ? void 0 : themePaths.hover, theme, kind) || getKindIcon(themePaths == null ? void 0 : themePaths.base, theme, kind);
    var buttonIcon = icon || kindIcon;
    if (icon && !icon.props.color) {
      if (kind) {
        if (!plain) {
          var iconColor = hover && getIconColor(themePaths.hover, theme) || getIconColor(themePaths.base, theme, color, kind);
          if (iconColor)
            buttonIcon = /* @__PURE__ */ (0, import_react24.cloneElement)(icon, {
              color: iconColor
            });
        }
      } else if (primary) {
        buttonIcon = /* @__PURE__ */ (0, import_react24.cloneElement)(icon, {
          color: theme.global.colors.text[isDarkBackground() ? "dark" : "light"]
        });
      }
    } else if (kindIcon && !plain) {
      var _iconColor = hover && getIconColor(themePaths.hover, theme) || getIconColor(themePaths.base, theme, color, kind);
      if (_iconColor)
        buttonIcon = /* @__PURE__ */ (0, import_react24.cloneElement)(kindIcon, {
          color: _iconColor
        });
    }
    var reverse = reverseProp != null ? reverseProp : (_theme$button$kind = theme.button[kind]) == null ? void 0 : _theme$button$kind.reverse;
    var domTag = !as && href ? "a" : as;
    var first = reverse ? label : buttonIcon;
    var second = reverse ? buttonIcon : label;
    var contents;
    if (first && second) {
      var _theme$button, _theme$button$kind2;
      contents = /* @__PURE__ */ import_react24.default.createElement(Box, {
        direction: ((_theme$button = theme.button) == null ? void 0 : (_theme$button$kind2 = _theme$button[kind]) == null ? void 0 : _theme$button$kind2.direction) || "row",
        align: "center",
        justify: justify || (align === "center" ? "center" : "between"),
        gap: gap || theme.button.gap,
        responsive: false
      }, first, second);
    } else if (typeof children === "function") {
      contents = children({
        disabled,
        hover,
        focus
      });
    } else {
      contents = first || second || children;
    }
    var background = getPropertyColor("background", themePaths && themePaths.base, theme, kind, primary);
    var border = getPropertyColor("border", themePaths && themePaths.base, theme, kind, primary);
    var innerBadge = !background && !border || !kind && icon && !label;
    if (badgeProp && innerBadge) {
      contents = /* @__PURE__ */ import_react24.default.createElement(Badge, {
        content: badgeProp
      }, contents);
    }
    var styledButtonResult;
    if (kind) {
      styledButtonResult = /* @__PURE__ */ import_react24.default.createElement(StyledButtonKind, _extends19({}, rest, {
        as: domTag,
        ref,
        active,
        align,
        "aria-label": ariaLabel || a11yTitle,
        badge: badgeProp,
        colorValue: color,
        disabled,
        hasIcon: !!icon,
        gap,
        hasLabel: !!label,
        icon,
        fillContainer: fill,
        focus,
        focusIndicator,
        href,
        kind,
        themePaths,
        onClick,
        onFocus: function onFocus(event) {
          setFocus(true);
          if (_onFocus)
            _onFocus(event);
        },
        onBlur: function onBlur(event) {
          setFocus(false);
          if (_onBlur)
            _onBlur(event);
        },
        onMouseOver: onMouseOverButton,
        onMouseOut: onMouseOutButton,
        plain: plain || import_react24.Children.count(children) > 0,
        primary,
        sizeProp: size,
        type: !href ? type : void 0
      }), contents);
    } else {
      styledButtonResult = /* @__PURE__ */ import_react24.default.createElement(StyledButton, _extends19({}, rest, {
        as: domTag,
        ref,
        "aria-label": ariaLabel || a11yTitle,
        colorValue: color,
        active,
        selected,
        disabled,
        hasIcon: !!icon,
        gap,
        hasLabel: !!label,
        fillContainer: fill,
        focus,
        focusIndicator,
        href,
        kind,
        themePaths,
        onClick,
        onFocus: function onFocus(event) {
          setFocus(true);
          if (_onFocus)
            _onFocus(event);
        },
        onBlur: function onBlur(event) {
          setFocus(false);
          if (_onBlur)
            _onBlur(event);
        },
        onMouseOver: onMouseOverButton,
        onMouseOut: onMouseOutButton,
        pad: !plain,
        plain: typeof plain !== "undefined" ? plain : import_react24.Children.count(children) > 0 || icon && !label,
        primary,
        sizeProp: size,
        type: !href ? type : void 0
      }), contents);
    }
    if (tip) {
      if (typeof tip === "string") {
        styledButtonResult = /* @__PURE__ */ import_react24.default.createElement(Tip, {
          content: tip
        }, styledButtonResult);
      } else {
        styledButtonResult = /* @__PURE__ */ import_react24.default.createElement(Tip, tip, styledButtonResult);
      }
    }
    if (badgeProp && !innerBadge) {
      styledButtonResult = /* @__PURE__ */ import_react24.default.createElement(Badge, {
        content: badgeProp
      }, styledButtonResult);
    }
    return styledButtonResult;
  });
  Button2.displayName = "Button";
  Button2.propTypes = ButtonPropTypes;

  // node_modules/grommet/es6/components/Heading/Heading.js
  var import_react26 = __toESM(require_react());

  // node_modules/grommet/es6/components/Heading/StyledHeading.js
  var import_styled_components21 = __toESM(require_styled_components_browser_cjs());
  var sizeStyle5 = function sizeStyle6(props) {
    var size = props.size || "medium";
    var headingTheme = props.theme.heading;
    var levelStyle = headingTheme.level[props.level];
    if (levelStyle) {
      var data = levelStyle[size];
      var styles = [(0, import_styled_components21.css)(["font-size:", ";line-height:", ";max-width:", ";font-weight:", ";overflow-wrap:", ";"], data ? data.size : size, data ? data.height : "normal", props.fillProp && "none" || data && data.maxWidth || levelStyle.medium.maxWidth, props.weight || levelStyle.font.weight || headingTheme.weight, props.overflowWrap)];
      if (props.responsive && headingTheme.responsiveBreakpoint) {
        var breakpoint = props.theme.global.breakpoints[headingTheme.responsiveBreakpoint];
        if (breakpoint) {
          var responsiveData = headingTheme.level[props.level + 1] ? headingTheme.level[props.level + 1][size] : headingTheme.level[props.level][size];
          if (responsiveData) {
            styles.push(breakpointStyle(breakpoint, "\n            font-size: " + responsiveData.size + ";\n            line-height: " + responsiveData.height + ";\n            max-width: " + (props.fillProp && "none" || responsiveData.maxWidth) + ";\n          "));
          }
        }
      }
      return styles;
    }
    console.warn("Heading level " + props.level + " is not defined in your theme.");
    return "";
  };
  var fontFamily2 = function fontFamily3(props) {
    var _ref = props.theme.heading.level[props.level] || {}, font = _ref.font;
    if (font && font.family) {
      return (0, import_styled_components21.css)(["font-family:", ";"], font.family);
    }
    return props.theme.heading.font ? (0, import_styled_components21.css)(["font-family:", ";"], props.theme.heading.font.family) : "";
  };
  var truncateStyle2 = "\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n";
  var colorStyle2 = (0, import_styled_components21.css)(["color:", ";"], function(props) {
    return normalizeColor(props.colorProp || props.theme.heading.color, props.theme);
  });
  var StyledHeading = import_styled_components21.default.h1.withConfig({
    displayName: "StyledHeading",
    componentId: "sc-1rdh4aw-0"
  })(["", " ", " ", " ", " ", " ", " ", ""], genericStyles, function(props) {
    return fontFamily2(props);
  }, function(props) {
    return sizeStyle5(props);
  }, function(props) {
    return props.textAlign && textAlignStyle;
  }, function(props) {
    return props.truncate && truncateStyle2;
  }, function(props) {
    return (props.colorProp || props.theme.heading.color) && colorStyle2;
  }, function(props) {
    return props.theme.heading && props.theme.heading.extend;
  });
  StyledHeading.defaultProps = {};
  Object.setPrototypeOf(StyledHeading.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/Heading/propTypes.js
  var import_prop_types11 = __toESM(require_prop_types());
  function _extends20() {
    _extends20 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends20.apply(this, arguments);
  }
  var PropType10 = {};
  if (true) {
    PropType10 = _extends20({}, genericProps, {
      color: colorPropType,
      fill: import_prop_types11.default.bool,
      level: import_prop_types11.default.oneOf([1, 2, 3, 4, 5, 6, "1", "2", "3", "4", "5", "6"]),
      overflowWrap: import_prop_types11.default.oneOfType([import_prop_types11.default.oneOf(["normal", "break-word", "anywhere"]), import_prop_types11.default.string]),
      responsive: import_prop_types11.default.bool,
      size: import_prop_types11.default.oneOfType([import_prop_types11.default.oneOf(["small", "medium", "large", "xlarge"]), import_prop_types11.default.string]),
      textAlign: import_prop_types11.default.oneOf(["start", "center", "end", "justify"]),
      truncate: import_prop_types11.default.bool,
      weight: import_prop_types11.default.oneOfType([import_prop_types11.default.oneOf(["normal", "bold", "lighter", "bolder"]), import_prop_types11.default.number, import_prop_types11.default.string])
    });
  }
  var HeadingPropTypes = PropType10;

  // node_modules/grommet/es6/components/Heading/HeadingSkeleton.js
  var import_react25 = __toESM(require_react());
  var import_styled_components22 = __toESM(require_styled_components_browser_cjs());
  function _extends21() {
    _extends21 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends21.apply(this, arguments);
  }
  var HeadingSkeleton = /* @__PURE__ */ (0, import_react25.forwardRef)(function(_ref, ref) {
    var as = _ref.as, level = _ref.level, size = _ref.size;
    var theme = (0, import_react25.useContext)(import_styled_components22.ThemeContext) || defaultProps.theme;
    var levelStyle = theme.heading.level[level];
    var data = levelStyle == null ? void 0 : levelStyle[size || "medium"];
    var height = data ? data.height : size;
    return /* @__PURE__ */ import_react25.default.createElement(Skeleton, _extends21({
      as,
      ref,
      height
    }, theme.heading.skeleton));
  });
  HeadingSkeleton.displayName = "HeadingSkeleton";
  HeadingSkeleton.defaultProps = {
    level: 1
  };

  // node_modules/grommet/es6/components/Heading/Heading.js
  var _excluded12 = ["children", "color", "fill", "level", "overflowWrap", "weight"];
  function _extends22() {
    _extends22 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends22.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose12(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Heading = /* @__PURE__ */ (0, import_react26.forwardRef)(function(_ref, ref) {
    var children = _ref.children, color = _ref.color, fill = _ref.fill, level = _ref.level, overflowWrapProp = _ref.overflowWrap, weight = _ref.weight, rest = _objectWithoutPropertiesLoose12(_ref, _excluded12);
    var headingRef = useForwardedRef(ref);
    var _useState = (0, import_react26.useState)(overflowWrapProp || "break-word"), overflowWrap = _useState[0], setOverflowWrap = _useState[1];
    var skeleton = useSkeleton();
    useLayoutEffect(function() {
      var updateOverflowWrap = function updateOverflowWrap2() {
        var wrap;
        if (!overflowWrapProp && headingRef.current) {
          wrap = headingRef.current.scrollWidth > headingRef.current.offsetWidth ? "anywhere" : "break-word";
          setOverflowWrap(wrap);
        }
      };
      window.addEventListener("resize", updateOverflowWrap);
      updateOverflowWrap();
      return function() {
        return window.removeEventListener("resize", updateOverflowWrap);
      };
    }, [headingRef, overflowWrapProp]);
    var content = children;
    if (skeleton) {
      content = /* @__PURE__ */ import_react26.default.createElement(HeadingSkeleton, _extends22({
        level,
        fill
      }, rest));
    }
    return (
      // enforce level to be a number
      /* @__PURE__ */ import_react26.default.createElement(StyledHeading, _extends22({
        as: "h" + level,
        colorProp: color,
        fillProp: fill,
        level: +level,
        overflowWrap,
        weight
      }, rest, {
        ref: headingRef
      }), content)
    );
  });
  Heading.displayName = "Heading";
  Heading.defaultProps = {
    level: 1,
    responsive: true
  };
  Heading.propTypes = HeadingPropTypes;

  // node_modules/grommet/es6/contexts/MessageContext/MessageContext.js
  var import_react27 = __toESM(require_react());

  // node_modules/grommet/es6/languages/default.json
  var default_default = {
    calendar: {
      previousMove: "Moved to {date}",
      previous: "Go to {date}",
      nextMove: "Moved to {date}",
      next: "Go to {date}"
    },
    carousel: {
      previous: "Go to slide {slide}",
      next: "Go to slide {slide}",
      jump: "Jump to slide {slide}"
    },
    dateInput: {
      openCalendar: "Press space to open calendar",
      enterCalendar: "Calendar is open, use arrow keys and enter to select a date.",
      exitCalendar: "Exited calendar dialog"
    },
    dataFilters: {
      clear: "Clear filters",
      heading: "Filters",
      open: "Open filters"
    },
    dataForm: {
      reset: "Undo changes",
      submit: "Apply filters"
    },
    dataSearch: {
      label: "Search",
      open: "Open search"
    },
    dataSort: {
      ascending: "Ascending",
      by: "Sort by",
      descending: "Descending",
      direction: "Sort direction",
      open: "Open sort"
    },
    dataSummary: {
      filtered: "{filteredTotal} results of {total} items",
      filteredSingle: "{filteredTotal} result of {total} items",
      total: "{total} items"
    },
    dataTableColumns: {
      open: "Open column selector",
      order: "Order columns",
      select: "Select columns"
    },
    dataView: {
      label: "View"
    },
    fileInput: {
      browse: "browse",
      dropPrompt: "Drop file here or",
      dropPromptMultiple: "Drop files here or",
      files: "files",
      maxSizeSingle: "The file is too large. Select a file no larger than {maxSize}.",
      maxSizeMultiple: {
        singular: "One file is too large. Select files which are no larger than {maxSize}.",
        plural: "{numOfFiles} files are too large. Select files which are no larger than {maxSize}."
      },
      remove: "remove",
      removeAll: "remove all",
      maxFile: "Attach a maximum of {max} files only."
    },
    form: {
      invalid: "invalid",
      required: "required"
    },
    menu: {
      openMenu: "Open Menu",
      closeMenu: "Close Menu"
    },
    rangeSelector: {
      lower: "Lower Bounds",
      upper: "Upper Bounds"
    },
    select: {
      multiple: "multiple",
      selected: "; Selected: {currentSelectedValue}"
    },
    skipLinks: {
      skipTo: "Skip To:"
    },
    tabs: {
      tabContents: "Tab Contents"
    },
    textInput: {
      enterSelect: "(Press Enter to Select)",
      suggestionsCount: "suggestions available",
      suggestionsExist: "This input has suggestions use arrow keys to navigate",
      suggestionIsOpen: "Suggestions drop is open, continue to use arrow keys to navigate"
    },
    video: {
      captions: "closed captions",
      closeMenu: "close menu",
      audioDescriptions: "video audio description",
      fullScreen: "full screen",
      progressMeter: "video progress",
      scrubber: "scrubber",
      openMenu: "open menu",
      pauseButton: "pause",
      playButton: "play",
      volumeDown: "volume down",
      volumeUp: "volume up",
      description: "video audio description"
    }
  };

  // node_modules/grommet/es6/contexts/MessageContext/MessageContext.js
  var _format = function format2(options2, messages) {
    var _options$id;
    var idParts = ((_options$id = options2.id) == null ? void 0 : _options$id.split(".")) || [];
    var baseId = idParts[(idParts == null ? void 0 : idParts.length) - 1];
    var messageObj = messages;
    idParts.forEach(function(idPart) {
      if (typeof messageObj === "object") {
        messageObj = messageObj[idPart];
      }
    });
    var message = (options2.messages ? options2.messages[baseId] : void 0) || messageObj || options2.defaultMessage;
    var values = options2.values;
    var newMessage = message;
    var tokens = message == null ? void 0 : message.match(/\{(.+?)\}/g);
    tokens == null ? void 0 : tokens.forEach(function(token) {
      var names = token.substr(1, token.length - 2);
      var value = values[names];
      newMessage = newMessage.replace(token, value);
    });
    return values ? newMessage : message;
  };
  var defaultValue = {
    messages: default_default,
    format: function format3(options2) {
      return _format(options2, default_default);
    }
  };
  var MessageContext = /* @__PURE__ */ import_react27.default.createContext(defaultValue);

  // node_modules/grommet/es6/components/Header/Header.js
  var import_react28 = __toESM(require_react());
  var import_styled_components23 = __toESM(require_styled_components_browser_cjs());
  var _excluded13 = ["sticky"];
  function _extends23() {
    _extends23 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends23.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose13(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Header = /* @__PURE__ */ import_react28.default.forwardRef(function(_ref, ref) {
    var _theme$header2, _theme$header2$sticky;
    var sticky = _ref.sticky, rest = _objectWithoutPropertiesLoose13(_ref, _excluded13);
    var theme = (0, import_react28.useContext)(import_styled_components23.ThemeContext);
    var headerRef = useForwardedRef(ref);
    (0, import_react28.useEffect)(function() {
      var scrollTop = 0;
      var updateScrollDir = function updateScrollDir2() {
        var target = findScrollParent(headerRef.current);
        var header = headerRef.current;
        if (target && sticky === "scrollup") {
          var nextScrollTop = target === document ? window.pageYOffset : target.scrollTop;
          if (scrollTop - nextScrollTop <= 0) {
            header.style.top = "-" + header.getBoundingClientRect().height + "px";
            header.style.zIndex = "";
          } else if (scrollTop - nextScrollTop > 0) {
            var _theme$header, _theme$header$sticky;
            header.style.position = "sticky";
            header.style.top = "0px";
            header.style.zIndex = "" + ((_theme$header = theme.header) == null ? void 0 : (_theme$header$sticky = _theme$header.sticky) == null ? void 0 : _theme$header$sticky.zIndex);
            header.style.transition = "top 0.6s";
          }
          scrollTop = nextScrollTop;
        }
      };
      if (sticky === "scrollup") {
        updateScrollDir();
        window.addEventListener("resize", updateScrollDir);
        window.addEventListener("scroll", updateScrollDir, true);
      }
      return function() {
        if (sticky === "scrollup") {
          window.removeEventListener("resize", updateScrollDir);
          window.removeEventListener("scroll", updateScrollDir, true);
        }
      };
    }, [headerRef, sticky, (_theme$header2 = theme.header) == null ? void 0 : (_theme$header2$sticky = _theme$header2.sticky) == null ? void 0 : _theme$header2$sticky.zIndex]);
    return /* @__PURE__ */ import_react28.default.createElement(Box, _extends23({
      align: "center",
      as: "header",
      direction: "row",
      flex: false,
      justify: "between",
      gap: "medium",
      ref: headerRef
    }, rest));
  });
  Header.displayName = "Header";

  // node_modules/grommet/es6/components/Footer/Footer.js
  var import_react29 = __toESM(require_react());
  function _objectDestructuringEmpty(obj) {
    if (obj == null)
      throw new TypeError("Cannot destructure " + obj);
  }
  function _extends24() {
    _extends24 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends24.apply(this, arguments);
  }
  var Footer = function Footer2(_ref) {
    var rest = _extends24({}, (_objectDestructuringEmpty(_ref), _ref));
    return /* @__PURE__ */ import_react29.default.createElement(Box, _extends24({
      as: "footer",
      align: "center",
      direction: "row",
      flex: false,
      gap: "medium",
      justify: "between"
    }, rest));
  };

  // node_modules/grommet/es6/contexts/DataContext.js
  var import_react30 = __toESM(require_react());
  var DataContext = /* @__PURE__ */ import_react30.default.createContext({
    data: []
  });

  // node_modules/grommet/es6/components/InfiniteScroll/InfiniteScroll.js
  var import_react31 = __toESM(require_react());

  // node_modules/grommet/es6/components/InfiniteScroll/propTypes.js
  var import_prop_types12 = __toESM(require_prop_types());
  var PropType11 = {};
  if (true) {
    PropType11 = {
      children: import_prop_types12.default.func,
      items: import_prop_types12.default.arrayOf(import_prop_types12.default.any),
      onMore: import_prop_types12.default.func,
      renderMarker: import_prop_types12.default.func,
      replace: import_prop_types12.default.bool,
      show: import_prop_types12.default.number,
      step: import_prop_types12.default.number
    };
  }
  var InfiniteScrollPropTypes = PropType11;

  // node_modules/grommet/es6/components/InfiniteScroll/InfiniteScroll.js
  var calculateLastPageBound = function calculateLastPageBound2(show, step) {
    return show ? Math.floor((show + step) / step) - 1 : 0;
  };
  var InfiniteScroll = function InfiniteScroll2(_ref) {
    var children = _ref.children, _ref$items = _ref.items, items = _ref$items === void 0 ? [] : _ref$items, onMore = _ref.onMore, renderMarker = _ref.renderMarker, replace = _ref.replace, show = _ref.show, _ref$step = _ref.step, step = _ref$step === void 0 ? 50 : _ref$step;
    var _useState = (0, import_react31.useState)(), scrollShow = _useState[0], setScrollShow = _useState[1];
    var lastPage = (0, import_react31.useMemo)(function() {
      return Math.max(0, Math.ceil(items.length / step) - 1);
    }, [items.length, step]);
    var _useState2 = (0, import_react31.useState)([0, calculateLastPageBound(show, step)]), renderPageBounds = _useState2[0], setRenderPageBounds = _useState2[1];
    var _useState3 = (0, import_react31.useState)([]), pageHeights = _useState3[0], setPageHeights = _useState3[1];
    var _useState4 = (0, import_react31.useState)(0), pendingLength = _useState4[0], setPendingLength = _useState4[1];
    var aboveMarkerRef = (0, import_react31.useRef)();
    var belowMarkerRef = (0, import_react31.useRef)();
    (0, import_react31.useEffect)(function() {
      var scrollParents;
      var evaluate = function evaluate2() {
        if (!scrollParents)
          return;
        var scrollParent = scrollParents[0];
        var top2;
        var height;
        if (scrollParent === document) {
          top2 = document.documentElement.scrollTop || document.body.scrollTop;
          height = window.innerHeight;
        } else {
          top2 = scrollParent.scrollTop;
          var rect = scrollParent.getBoundingClientRect();
          height = rect.height;
        }
        var offset2 = height / 4;
        var nextBeginPage = 0;
        var index = 0;
        var pagesHeight = pageHeights[index] || 0;
        while (pageHeights[index + 1] && pagesHeight < top2 - offset2) {
          index += 1;
          nextBeginPage += 1;
          pagesHeight += pageHeights[index];
        }
        var nextEndPage = nextBeginPage;
        while (pageHeights[index] !== void 0 && pagesHeight < top2 + height + offset2) {
          index += 1;
          nextEndPage += 1;
          pagesHeight += pageHeights[index] || 0;
        }
        if (!replace) {
          nextBeginPage = 0;
          nextEndPage = Math.max(renderPageBounds[1], nextEndPage);
        }
        if (show) {
          var showPage = calculateLastPageBound(show, step);
          nextBeginPage = Math.min(showPage, nextBeginPage);
          nextEndPage = Math.max(showPage, nextEndPage);
        }
        if (nextBeginPage !== renderPageBounds[0] || nextEndPage !== renderPageBounds[1]) {
          setRenderPageBounds([nextBeginPage, nextEndPage]);
        }
      };
      var timer;
      var debounce3 = function debounce4() {
        clearTimeout(timer);
        timer = setTimeout(evaluate, 10);
      };
      if (belowMarkerRef.current) {
        scrollParents = findScrollParents(belowMarkerRef.current);
        scrollParents.forEach(function(sp) {
          return sp.addEventListener("scroll", debounce3);
        });
      }
      window.addEventListener("resize", debounce3);
      evaluate();
      return function() {
        if (scrollParents) {
          scrollParents.forEach(function(sp) {
            return sp.removeEventListener("scroll", debounce3);
          });
        }
        window.removeEventListener("resize", debounce3);
        clearTimeout(timer);
      };
    }, [pageHeights, renderPageBounds, replace, show, step]);
    (0, import_react31.useEffect)(function() {
      if (onMore && renderPageBounds[1] === lastPage && items.length >= pendingLength && items.length > 0) {
        setPendingLength(items.length + 1);
        onMore();
      }
    }, [items.length, lastPage, onMore, pendingLength, renderPageBounds, step]);
    (0, import_react31.useEffect)(function() {
      if (items.length === 0 && lastPage === 0 && pendingLength !== 0) {
        setPageHeights([]);
        setPendingLength(0);
        setRenderPageBounds([0, calculateLastPageBound(show, step)]);
      }
    }, [lastPage, pendingLength, show, step, items.length]);
    useLayoutEffect(function() {
      var timer = setTimeout(function() {
        if (show && belowMarkerRef.current && show !== scrollShow) {
          var showIndex = show - renderPageBounds[0] * step + (renderPageBounds[0] ? 1 : 0);
          var showNode = belowMarkerRef.current.parentNode.children.item(showIndex);
          if (showNode) {
            var scrollParent = findScrollParent(showNode);
            if (isNodeBeforeScroll(showNode, scrollParent)) {
              showNode.scrollIntoView(true);
            } else if (isNodeAfterScroll(showNode, scrollParent)) {
              showNode.scrollIntoView(false);
            }
            setScrollShow(show);
          }
        }
      }, 100);
      return function() {
        return clearTimeout(timer);
      };
    }, [renderPageBounds, show, step]);
    useLayoutEffect(function() {
      if (!belowMarkerRef.current)
        return;
      var rendered = belowMarkerRef.current.parentNode.children;
      if ((aboveMarkerRef.current ? 1 : 0) + (renderPageBounds[1] - renderPageBounds[0] + 1) * step + 1 === rendered.length) {
        var nextPageHeights;
        var i = renderPageBounds[0];
        var lastBottom;
        while (i <= renderPageBounds[1]) {
          var topIndex = (aboveMarkerRef.current ? 1 : 0) + (i - renderPageBounds[0]) * step;
          var bottomIndex = Math.min(topIndex + step - 1, rendered.length - 1);
          var top2 = lastBottom !== void 0 ? lastBottom : rendered.item(topIndex).getBoundingClientRect().top;
          var _rendered$item$getBou = rendered.item(bottomIndex).getBoundingClientRect(), bottom2 = _rendered$item$getBou.bottom;
          var height = bottom2 - top2;
          if (bottom2 && (!pageHeights || pageHeights[i] !== height)) {
            if (!nextPageHeights)
              nextPageHeights = [].concat(pageHeights || []);
            nextPageHeights[i] = height;
          }
          lastBottom = bottom2;
          i += 1;
        }
        while (replace && i <= lastPage) {
          if (!pageHeights[i] && pageHeights[i] !== pageHeights[0]) {
            if (!nextPageHeights)
              nextPageHeights = [].concat(pageHeights || []);
            var _nextPageHeights = nextPageHeights;
            nextPageHeights[i] = _nextPageHeights[0];
          }
          i += 1;
        }
        if (nextPageHeights)
          setPageHeights(nextPageHeights);
      }
    }, [lastPage, pageHeights, renderPageBounds, replace, step]);
    var aboveHeight = (0, import_react31.useMemo)(function() {
      if (!replace)
        return 0;
      var height = 0;
      var i = 0;
      while (i < renderPageBounds[0]) {
        height += pageHeights[i] || 0;
        i += 1;
      }
      return height;
    }, [pageHeights, renderPageBounds, replace]);
    var belowHeight = (0, import_react31.useMemo)(function() {
      if (!replace)
        return 0;
      var height = 0;
      var i = renderPageBounds[1] + 1;
      while (i <= lastPage) {
        height += pageHeights[i] || 0;
        i += 1;
      }
      return height;
    }, [lastPage, pageHeights, renderPageBounds, replace]);
    var firstIndex = renderPageBounds[0] * step;
    var lastIndex = Math.min((renderPageBounds[1] + 1) * step, items.length) - 1;
    var result = [];
    if (aboveHeight) {
      var marker = /* @__PURE__ */ import_react31.default.createElement(Box, {
        key: "above",
        ref: aboveMarkerRef,
        flex: false,
        height: aboveHeight + "px"
      });
      if (renderMarker) {
        marker = /* @__PURE__ */ import_react31.default.cloneElement(renderMarker(marker), {
          key: "above"
        });
      }
      result.push(marker);
    }
    items.slice(firstIndex, lastIndex + 1).forEach(function(item, index) {
      var itemsIndex = firstIndex + index;
      var child = children(item, itemsIndex);
      result.push(child);
    });
    if (replace || renderPageBounds[1] < lastPage || onMore) {
      var _marker = /* @__PURE__ */ import_react31.default.createElement(Box, {
        key: "below",
        ref: !renderMarker && belowMarkerRef || void 0,
        flex: false,
        height: (belowHeight || 0) + "px"
      });
      if (renderMarker) {
        var renderedMarker = renderMarker(_marker);
        _marker = /* @__PURE__ */ import_react31.default.cloneElement(renderedMarker, {
          key: "below",
          // We need to make sure our belowMarkerRef is tied to a component
          // that has the same parent as the items being rendered. This is so
          // we can use belowMarkerRef.current.parentNode.children to
          // get a reference to the items in the DOM for calculating pageHeights.
          //
          // Since the caller might have included a ref in what their
          // renderMarker returns, we have to take care of both refs.
          // https://github.com/facebook/react/issues/8873#issuecomment-489579878
          ref: function ref(node) {
            belowMarkerRef.current = node;
            var ref2 = renderedMarker.ref;
            if (typeof ref2 === "function") {
              ref2(node);
            } else if (ref2 !== null) {
              ref2.current = node;
            }
          }
        });
      }
      result.push(_marker);
    }
    return result;
  };
  InfiniteScroll.propTypes = InfiniteScrollPropTypes;

  // node_modules/grommet/es6/components/Pagination/Pagination.js
  var import_react34 = __toESM(require_react());
  var import_styled_components26 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/Nav/Nav.js
  var import_react32 = __toESM(require_react());
  function _objectDestructuringEmpty2(obj) {
    if (obj == null)
      throw new TypeError("Cannot destructure " + obj);
  }
  function _extends25() {
    _extends25 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends25.apply(this, arguments);
  }
  var Nav = function Nav2(_ref) {
    var rest = _extends25({}, (_objectDestructuringEmpty2(_ref), _ref));
    return /* @__PURE__ */ import_react32.default.createElement(Box, _extends25({
      as: "nav",
      flex: false,
      gap: "medium"
    }, rest));
  };

  // node_modules/grommet/es6/components/Pagination/PageControl.js
  var import_react33 = __toESM(require_react());
  var import_styled_components25 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/Pagination/StyledPageControl.js
  var import_styled_components24 = __toESM(require_styled_components_browser_cjs());
  var sizeStyle7 = function sizeStyle8(props) {
    var style = props.theme.pagination.button && props.theme.pagination.button.size && props.theme.pagination.button.size[props.size || "medium"];
    return style ? {
      content: {
        fontSize: style.font && style.font.size,
        lineHeight: style.font && style.font.height
      },
      container: {
        height: style.height,
        minWidth: style.width
      }
    } : "";
  };
  var StyledPaginationButton = (0, import_styled_components24.default)(Button2).withConfig({
    displayName: "StyledPageControl__StyledPaginationButton",
    componentId: "sc-1vlfaez-0"
  })(["> svg{margin:0 auto;}", ";"], function(props) {
    return sizeStyle7(props).content;
  });
  var StyledContainer = import_styled_components24.default.div.withConfig({
    displayName: "StyledPageControl__StyledContainer",
    componentId: "sc-1vlfaez-1"
  })(["display:flex;align-items:center;justify-content:center;max-width:100%;", ";", ";"], function(props) {
    return sizeStyle7(props).container;
  }, function(props) {
    return props.theme.pagination.control && props.theme.pagination.control.extend;
  });
  var StyledSeparator = (0, import_styled_components24.default)(Text).withConfig({
    displayName: "StyledPageControl__StyledSeparator",
    componentId: "sc-1vlfaez-2"
  })(["font-weight:bold;", ";", ";"], function(props) {
    return "font-size: " + (sizeStyle7(props).content && sizeStyle7(props).content.fontSize);
  }, function(props) {
    return "line-height: " + (sizeStyle7(props).content && sizeStyle7(props).content.lineHeight);
  });

  // node_modules/grommet/es6/components/Pagination/PageControl.js
  var _excluded14 = ["control", "separator", "size"];
  function _extends26() {
    _extends26 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends26.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose14(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var PageControl = function PageControl2(_ref) {
    var control = _ref.control, separator = _ref.separator, sizeProp = _ref.size, rest = _objectWithoutPropertiesLoose14(_ref, _excluded14);
    var theme = (0, import_react33.useContext)(import_styled_components25.ThemeContext);
    var size = sizeProp || "medium";
    return /* @__PURE__ */ import_react33.default.createElement(StyledContainer, {
      as: "li",
      size
    }, separator ? /* @__PURE__ */ import_react33.default.createElement(StyledSeparator, {
      size
    }, "\u2026") : /* @__PURE__ */ import_react33.default.createElement(StyledPaginationButton, _extends26({
      a11yTitle: "Go to page " + control,
      fill: true,
      kind: theme.pagination.button,
      label: control,
      size
    }, rest)));
  };

  // node_modules/grommet/es6/components/Pagination/propTypes.js
  var import_prop_types13 = __toESM(require_prop_types());
  function _extends27() {
    _extends27 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends27.apply(this, arguments);
  }
  var PropType12 = {};
  if (true) {
    PropType12 = _extends27({}, genericProps, {
      numberEdgePages: import_prop_types13.default.number,
      numberItems: import_prop_types13.default.number,
      numberMiddlePages: import_prop_types13.default.number,
      onChange: import_prop_types13.default.func,
      page: import_prop_types13.default.number,
      size: import_prop_types13.default.oneOf(["small", "medium", "large"]),
      step: import_prop_types13.default.number
    });
  }
  var PaginationPropTypes = PropType12;

  // node_modules/grommet/es6/components/Pagination/Pagination.js
  var _excluded15 = ["a11yTitle", "aria-label", "numberItems", "numberEdgePages", "numberMiddlePages", "onChange", "page", "size", "step"];
  function _extends28() {
    _extends28 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends28.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose15(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var StyledPaginationContainer = (0, import_styled_components26.default)(Box).withConfig({
    displayName: "Pagination__StyledPaginationContainer",
    componentId: "sc-rnlw6m-0"
  })(["", ""], function(props) {
    return props.theme.pagination.container && props.theme.pagination.container.extend;
  });
  var getPageIndices = function getPageIndices2(begin, end2) {
    var indices = [];
    for (var i = begin; i <= end2; i += 1) {
      indices.push(i);
    }
    return indices;
  };
  var Pagination = /* @__PURE__ */ (0, import_react34.forwardRef)(function(_ref, ref) {
    var _ref2;
    var a11yTitle = _ref.a11yTitle, ariaLabel = _ref["aria-label"], numberItems = _ref.numberItems, _ref$numberEdgePages = _ref.numberEdgePages, numberEdgePages = _ref$numberEdgePages === void 0 ? 1 : _ref$numberEdgePages, _ref$numberMiddlePage = _ref.numberMiddlePages, numberMiddlePagesProp = _ref$numberMiddlePage === void 0 ? 3 : _ref$numberMiddlePage, onChange2 = _ref.onChange, pageProp = _ref.page, size = _ref.size, stepProp = _ref.step, rest = _objectWithoutPropertiesLoose15(_ref, _excluded15);
    var theme = (0, import_react34.useContext)(import_styled_components26.ThemeContext) || defaultProps2.theme;
    var _useContext = (0, import_react34.useContext)(DataContext), onView = _useContext.onView, filteredTotal = _useContext.filteredTotal, view = _useContext.view;
    var step = stepProp || (view == null ? void 0 : view.step) || 10;
    var total = (_ref2 = numberItems != null ? numberItems : filteredTotal) != null ? _ref2 : 0;
    var page = pageProp || (view == null ? void 0 : view.page) || 1;
    var totalPages = Math.ceil(total / step);
    var _useState = (0, import_react34.useState)(Math.min(page, totalPages) || 1), activePage = _useState[0], setActivePage = _useState[1];
    (0, import_react34.useEffect)(function() {
      return setActivePage(page);
    }, [page]);
    (0, import_react34.useEffect)(function() {
      if (onView && ((view == null ? void 0 : view.step) !== step || (view == null ? void 0 : view.page) !== page))
        onView(_extends28({}, view, {
          page,
          step
        }));
    }, [onView, page, step, view]);
    var beginPages = getPageIndices(1, Math.min(numberEdgePages, totalPages));
    var endPages = getPageIndices(Math.max(totalPages - numberEdgePages + 1, numberEdgePages + 1), totalPages);
    var numberMiddlePages;
    if (numberMiddlePagesProp < 1) {
      numberMiddlePages = 1;
      console.warn(
        // eslint-disable-next-line max-len
        'Property "numberMiddlePages" should not be < 1. One middle page button will be shown. Set "numberMiddlePages" >= 1 to remove this warning.'
      );
    } else
      numberMiddlePages = numberMiddlePagesProp;
    var startingMiddlePages;
    if (numberMiddlePages % 2)
      startingMiddlePages = Math.min(activePage - Math.floor(numberMiddlePages / 2), totalPages - numberEdgePages - numberMiddlePages);
    else
      startingMiddlePages = Math.min(activePage - Math.floor(numberMiddlePages / 2) + 1, totalPages - numberEdgePages - numberMiddlePages);
    var middlePagesBegin = Math.max(startingMiddlePages, numberEdgePages + 2);
    var middlePagesEnd = Math.min(Math.max(activePage + Math.floor(numberMiddlePages / 2), numberEdgePages + numberMiddlePages + 1), endPages.length > 0 ? endPages[0] - 2 : totalPages - 1);
    var middlePages = getPageIndices(middlePagesBegin, middlePagesEnd);
    var beginFlex = [];
    if (middlePagesBegin > numberEdgePages + 2)
      beginFlex = ["more-prev"];
    else if (numberEdgePages + 1 < totalPages - numberEdgePages)
      beginFlex = [numberEdgePages + 1];
    var endFlex = [];
    if (middlePagesEnd < totalPages - numberEdgePages - 1)
      endFlex = ["more-next"];
    else if (totalPages - numberEdgePages > numberEdgePages)
      endFlex = [totalPages - numberEdgePages];
    var getItemIndices = function getItemIndices2(nextPage) {
      var startIndex = step * (nextPage - 1);
      var endIndex = startIndex + step;
      return {
        startIndex,
        endIndex
      };
    };
    var handleClick = function handleClick2(event, nextPage) {
      setActivePage(nextPage);
      if (onView)
        onView(_extends28({}, view, {
          page: nextPage
        }));
      if (onChange2) {
        event.persist();
        var adjustedEvent = event;
        adjustedEvent.page = nextPage;
        var _getItemIndices = getItemIndices(nextPage), startIndex = _getItemIndices.startIndex, endIndex = _getItemIndices.endIndex;
        adjustedEvent.startIndex = startIndex;
        adjustedEvent.endIndex = endIndex;
        onChange2(adjustedEvent);
      }
    };
    var NextIcon = theme.pagination.icons.next;
    var PreviousIcon = theme.pagination.icons.previous;
    var iconColor = theme.pagination.icons.color;
    var navProps = {
      next: {
        // https://a11y-style-guide.com/style-guide/section-navigation.html#kssref-navigation-pagination
        "aria-disabled": activePage === totalPages ? "true" : void 0,
        disabled: activePage === totalPages || !total,
        icon: /* @__PURE__ */ import_react34.default.createElement(NextIcon, {
          color: iconColor
        }),
        onClick: function onClick(event) {
          var nextPage = activePage + 1;
          handleClick(event, nextPage);
        },
        label: void 0
      },
      previous: {
        "aria-disabled": activePage === 1 ? "true" : void 0,
        disabled: activePage === 1 || !total,
        icon: /* @__PURE__ */ import_react34.default.createElement(PreviousIcon, {
          color: iconColor
        }),
        onClick: function onClick(event) {
          var previousPage = activePage - 1;
          handleClick(event, previousPage);
        },
        label: void 0
      }
    };
    var controls = ["previous"].concat(beginPages, beginFlex, middlePages, endFlex, endPages, ["next"]);
    controls = controls.map(function(control) {
      return _extends28({
        active: control === activePage,
        a11yTitle: typeof control === "number" ? "Go to page " + control : "Go to " + control + " page",
        // https://a11y-style-guide.com/style-guide/section-navigation.html#kssref-navigation-pagination
        // https://www.w3.org/TR/wai-aria-1.1/#aria-current
        "aria-current": control === activePage ? "page" : void 0,
        control,
        onClick: function onClick(event) {
          handleClick(event, control);
        },
        separator: control === "more-prev" || control === "more-next"
      }, navProps[control]);
    });
    return /* @__PURE__ */ import_react34.default.createElement(StyledPaginationContainer, _extends28({
      flex: false
    }, theme.pagination.container, rest), /* @__PURE__ */ import_react34.default.createElement(Nav, {
      a11yTitle: ariaLabel || a11yTitle || "Pagination Navigation",
      ref
    }, /* @__PURE__ */ import_react34.default.createElement(Box, _extends28({
      as: "ul"
    }, theme.pagination.controls), controls.map(function(control, index) {
      return (
        /* Using index as key (as opposed to a unique id) seems to
         * help React prioritize rendering the updated controls as
         * desired. Whereas, using a unique id resulted in rendering
         * the active control with an undesired lag. */
        // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */ import_react34.default.createElement(PageControl, _extends28({
          key: index,
          size
        }, control))
      );
    }))));
  });
  Pagination.displayName = "Pagination";
  Pagination.propTypes = PaginationPropTypes;

  // node_modules/grommet/es6/contexts/ResponsiveContext/ResponsiveContext.js
  var import_react35 = __toESM(require_react());

  // node_modules/grommet/es6/contexts/ResponsiveContext/propTypes.js
  var import_prop_types14 = __toESM(require_prop_types());
  var PropType13 = {};
  if (true) {
    PropType13 = {
      children: import_prop_types14.default.func
    };
  }
  var ResponsiveContextPropTypes = PropType13;

  // node_modules/grommet/es6/contexts/ResponsiveContext/ResponsiveContext.js
  var ResponsiveContext = /* @__PURE__ */ import_react35.default.createContext(void 0);
  ResponsiveContext.propTypes = ResponsiveContextPropTypes;

  // node_modules/grommet/es6/contexts/ThemeContext/ThemeContext.js
  var import_react36 = __toESM(require_react());
  var import_prop_types16 = __toESM(require_prop_types());
  var import_styled_components27 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/contexts/ThemeContext/propTypes.js
  var import_prop_types15 = __toESM(require_prop_types());
  var PropType14 = {};
  if (true) {
    PropType14 = {
      value: import_prop_types15.default.shape({})
    };
  }
  var ThemeContextPropTypes = PropType14;

  // node_modules/grommet/es6/contexts/ThemeContext/ThemeContext.js
  import_styled_components27.ThemeContext.Extend = function(_ref) {
    var children = _ref.children, value = _ref.value;
    return /* @__PURE__ */ import_react36.default.createElement(import_styled_components27.ThemeContext.Consumer, null, function(theme) {
      return /* @__PURE__ */ import_react36.default.createElement(import_styled_components27.ThemeContext.Provider, {
        value: deepMerge(theme, value)
      }, children);
    });
  };
  import_styled_components27.ThemeContext.Extend.propTypes = {
    children: import_prop_types16.default.node.isRequired,
    value: import_prop_types16.default.shape({}).isRequired
  };
  import_styled_components27.ThemeContext.propTypes = ThemeContextPropTypes;

  // node_modules/grommet/es6/components/CheckBoxGroup/CheckBoxGroup.js
  var import_react39 = __toESM(require_react());
  var import_styled_components31 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/CheckBox/CheckBox.js
  var import_react38 = __toESM(require_react());
  var import_styled_components29 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/Form/FormContext.js
  var import_react37 = __toESM(require_react());
  var useFormInput = function useFormInput2(_ref) {
    var valueProp = _ref.value, initialValue = _ref.initialValue;
    var _useState = (0, import_react37.useState)(valueProp !== void 0 ? valueProp : initialValue), value = _useState[0], setValue3 = _useState[1];
    return [valueProp !== void 0 ? valueProp : value, function(nextValue) {
      if (initialValue !== void 0)
        setValue3(nextValue);
    }];
  };
  var useFormField = function useFormField2(_ref2) {
    var error2 = _ref2.error, info = _ref2.info, disabled = _ref2.disabled;
    return {
      error: error2,
      info,
      disabled
    };
  };
  var FormContext = /* @__PURE__ */ import_react37.default.createContext({
    useFormField,
    useFormInput,
    noForm: true
  });

  // node_modules/grommet/es6/components/CheckBox/propTypes.js
  var import_prop_types17 = __toESM(require_prop_types());
  var PropType15 = {};
  if (true) {
    PropType15 = {
      a11yTitle: import_prop_types17.default.string,
      checked: import_prop_types17.default.bool,
      disabled: import_prop_types17.default.bool,
      fill: import_prop_types17.default.bool,
      id: import_prop_types17.default.string,
      label: import_prop_types17.default.node,
      name: import_prop_types17.default.string,
      onChange: import_prop_types17.default.func,
      pad: padPropType,
      reverse: import_prop_types17.default.bool,
      toggle: import_prop_types17.default.bool,
      indeterminate: import_prop_types17.default.bool
    };
  }
  var CheckBoxPropTypes = PropType15;

  // node_modules/grommet/es6/components/CheckBox/StyledCheckBox.js
  var import_styled_components28 = __toESM(require_styled_components_browser_cjs());
  var fillStyle8 = function fillStyle9() {
    return "\n      width: 100%;\n      height: 100%;\n      max-width: none;\n      flex: 1 0 auto;\n      justify-content: space-between;\n    ";
  };
  var disabledStyle3 = "\n  opacity: 0.5;\n  cursor: default;\n";
  var hoverStyle2 = (0, import_styled_components28.css)([":hover input:not([disabled]) + div,:hover input:not([disabled]) + span{border-color:", ";", "}:hover{background-color:", ";}"], function(props) {
    var _props$theme$checkBox, _props$theme$checkBox2;
    return normalizeColor((_props$theme$checkBox = props.theme.checkBox.hover) == null ? void 0 : (_props$theme$checkBox2 = _props$theme$checkBox.border) == null ? void 0 : _props$theme$checkBox2.color, props.theme);
  }, function(props) {
    var _props$theme$checkBox3;
    return (_props$theme$checkBox3 = props.theme.checkBox.hover) == null ? void 0 : _props$theme$checkBox3.extend;
  }, function(props) {
    var _props$theme$checkBox4, _props$theme$checkBox5;
    return normalizeColor(!props.disabled && ((_props$theme$checkBox4 = props.theme.checkBox.hover) == null ? void 0 : (_props$theme$checkBox5 = _props$theme$checkBox4.background) == null ? void 0 : _props$theme$checkBox5.color), props.theme);
  });
  var StyledCheckBoxIcon = import_styled_components28.default.svg.withConfig({
    displayName: "StyledCheckBox__StyledCheckBoxIcon",
    componentId: "sc-1dbk5ju-0"
  })(["box-sizing:border-box;stroke-width:", ";stroke:", ";width:", ";height:", ";", ";"], function(props) {
    return props.theme.checkBox.check.thickness;
  }, function(props) {
    return normalizeColor(props.theme.checkBox.color || "control", props.theme);
  }, function(props) {
    return props.theme.checkBox.icon.size || props.theme.checkBox.size;
  }, function(props) {
    return props.theme.checkBox.icon.size || props.theme.checkBox.size;
  }, function(props) {
    return props.theme.checkBox.icon.extend;
  });
  StyledCheckBoxIcon.defaultProps = {};
  Object.setPrototypeOf(StyledCheckBoxIcon.defaultProps, defaultProps2);
  var StyledCheckBoxContainer = import_styled_components28.default.label.withConfig({
    displayName: "StyledCheckBox__StyledCheckBoxContainer",
    componentId: "sc-1dbk5ju-1"
  })(["display:flex;flex-direction:row;align-items:", ";user-select:none;", " ", " ", " ", " ", " ", " ", ""], function(props) {
    return typeof props.label === "string" ? props.theme.checkBox.label.align : void 0;
  }, function(props) {
    return props.fillProp ? fillStyle8() : "width: fit-content;";
  }, function(props) {
    return (props.pad || props.theme.checkBox.pad) && edgeStyle("padding", props.pad || props.theme.checkBox.pad, props.responsive, props.theme.box.responsiveBreakpoint, props.theme);
  }, function(props) {
    return props.disabled && disabledStyle3;
  }, function(props) {
    return !props.disabled && "cursor: pointer;";
  }, hoverStyle2, function(props) {
    var _props$theme$checkBox6, _props$theme$checkBox7, _props$theme$checkBox8, _props$theme$checkBox9;
    return props.focus && !props.focusIndicator && "\n    input:not([disabled]) + div,\n    input:not([disabled]) + span {\n      border-color: " + normalizeColor((_props$theme$checkBox6 = props.theme.checkBox.hover) == null ? void 0 : (_props$theme$checkBox7 = _props$theme$checkBox6.border) == null ? void 0 : _props$theme$checkBox7.color, props.theme) + ";\n    }\n     \n    background-color: " + normalizeColor(!props.disabled && ((_props$theme$checkBox8 = props.theme.checkBox.hover) == null ? void 0 : (_props$theme$checkBox9 = _props$theme$checkBox8.background) == null ? void 0 : _props$theme$checkBox9.color), props.theme) + ";";
  }, function(props) {
    return props.theme.checkBox.extend;
  });
  StyledCheckBoxContainer.defaultProps = {};
  Object.setPrototypeOf(StyledCheckBoxContainer.defaultProps, defaultProps2);
  var StyledCheckBoxInput = import_styled_components28.default.input.withConfig({
    displayName: "StyledCheckBox__StyledCheckBoxInput",
    componentId: "sc-1dbk5ju-2"
  })(["opacity:0;-moz-appearance:none;width:0;height:0;margin:0;", ":checked + span > span{", ":calc( ", " - ", " );background:", ";}"], function(props) {
    return !props.disabled && "cursor: pointer;";
  }, function(props) {
    return !props.theme.dir ? "left" : "right";
  }, function(props) {
    return props.theme.checkBox.toggle.size;
  }, function(props) {
    return props.theme.checkBox.size;
  }, function(props) {
    return normalizeColor(props.theme.checkBox.color || "control", props.theme);
  });
  StyledCheckBoxInput.defaultProps = {};
  Object.setPrototypeOf(StyledCheckBoxInput.defaultProps, defaultProps2);
  var StyledCheckBoxBox = import_styled_components28.default.div.withConfig({
    displayName: "StyledCheckBox__StyledCheckBoxBox",
    componentId: "sc-1dbk5ju-3"
  })(["", ";", ";"], function(props) {
    return props.focus && props.focusIndicator && focusStyle();
  }, function(props) {
    return props.theme.checkBox.check.extend;
  });
  StyledCheckBoxBox.defaultProps = {};
  Object.setPrototypeOf(StyledCheckBoxBox.defaultProps, defaultProps2);
  var StyledCheckBoxToggle = import_styled_components28.default.span.withConfig({
    displayName: "StyledCheckBox__StyledCheckBoxToggle",
    componentId: "sc-1dbk5ju-4"
  })(["box-sizing:border-box;vertical-align:middle;display:inline-block;width:", ";height:", ";border:", " solid;border-color:", ";border-radius:", ";background-color:", ";", ";", ";"], function(props) {
    return props.theme.checkBox.toggle.size;
  }, function(props) {
    return props.theme.checkBox.size;
  }, function(props) {
    return props.theme.checkBox.border.width;
  }, function(props) {
    return normalizeColor(props.theme.checkBox.border.color, props.theme);
  }, function(props) {
    return props.theme.checkBox.toggle.radius;
  }, function(props) {
    return props.theme.checkBox.toggle.background ? normalizeColor(props.theme.checkBox.toggle.background, props.theme) : "transparent";
  }, function(props) {
    return props.focus && props.focusIndicator && focusStyle();
  }, function(props) {
    return props.theme.checkBox.toggle.extend;
  });
  StyledCheckBoxToggle.defaultProps = {};
  Object.setPrototypeOf(StyledCheckBoxToggle.defaultProps, defaultProps2);
  var StyledCheckBoxKnob = import_styled_components28.default.span.withConfig({
    displayName: "StyledCheckBox__StyledCheckBoxKnob",
    componentId: "sc-1dbk5ju-5"
  })(["box-sizing:border-box;position:relative;display:inherit;top:-", ";", ":-", ";transition:all 0.3s;width:", ";height:", ";background:", ";border-radius:", ";", ";"], function(props) {
    return props.theme.checkBox.border.width;
  }, function(props) {
    return !props.theme.dir ? "left" : "right";
  }, function(props) {
    return props.theme.checkBox.border.width;
  }, function(props) {
    return props.theme.checkBox.size;
  }, function(props) {
    return props.theme.checkBox.size;
  }, function(props) {
    return normalizeColor(props.theme.checkBox.toggle.color, props.theme);
  }, function(props) {
    return props.theme.checkBox.toggle.radius;
  }, function(props) {
    return props.theme.checkBox.toggle.knob.extend;
  });
  StyledCheckBoxKnob.defaultProps = {};
  Object.setPrototypeOf(StyledCheckBoxKnob.defaultProps, defaultProps2);
  var StyledCheckBox = import_styled_components28.default.div.withConfig({
    displayName: "StyledCheckBox",
    componentId: "sc-1dbk5ju-6"
  })(["flex-shrink:0;"]);
  StyledCheckBox.defaultProps = {};
  Object.setPrototypeOf(StyledCheckBox.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/CheckBox/CheckBox.js
  var _excluded16 = ["a11yTitle", "aria-label", "checked", "children", "defaultChecked", "disabled", "fill", "focus", "focusIndicator", "id", "label", "name", "onBlur", "onChange", "onFocus", "onMouseEnter", "onMouseLeave", "onMouseOut", "onMouseOver", "pad", "reverse", "toggle", "indeterminate"];
  function _extends29() {
    _extends29 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends29.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose16(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var stopLabelClick = function stopLabelClick2(event) {
    if (event.target.type !== "checkbox") {
      event.stopPropagation();
    }
  };
  var CheckBox = /* @__PURE__ */ (0, import_react38.forwardRef)(function(_ref, ref) {
    var _ref2;
    var a11yTitle = _ref.a11yTitle, ariaLabel = _ref["aria-label"], checkedProp = _ref.checked, children = _ref.children, _ref$defaultChecked = _ref.defaultChecked, defaultChecked = _ref$defaultChecked === void 0 ? false : _ref$defaultChecked, disabled = _ref.disabled, fill = _ref.fill, focusProp = _ref.focus, _ref$focusIndicator = _ref.focusIndicator, focusIndicator = _ref$focusIndicator === void 0 ? true : _ref$focusIndicator, id = _ref.id, label = _ref.label, name = _ref.name, _onBlur = _ref.onBlur, _onChange = _ref.onChange, _onFocus = _ref.onFocus, _onMouseEnter = _ref.onMouseEnter, _onMouseLeave = _ref.onMouseLeave, _onMouseOut = _ref.onMouseOut, _onMouseOver = _ref.onMouseOver, pad = _ref.pad, reverse = _ref.reverse, toggle = _ref.toggle, indeterminate = _ref.indeterminate, rest = _objectWithoutPropertiesLoose16(_ref, _excluded16);
    var theme = (0, import_react38.useContext)(import_styled_components29.ThemeContext) || defaultProps2.theme;
    var formContext = (0, import_react38.useContext)(FormContext);
    var _formContext$useFormI = formContext.useFormInput({
      name,
      value: checkedProp,
      initialValue: defaultChecked
    }), checked = _formContext$useFormI[0], setChecked = _formContext$useFormI[1];
    var _useState = (0, import_react38.useState)(focusProp), focus = _useState[0], setFocus = _useState[1];
    (0, import_react38.useEffect)(function() {
      if (disabled && focusProp)
        setFocus(false);
      else
        setFocus(focusProp);
    }, [disabled, focusProp]);
    (0, import_react38.useEffect)(function() {
      if (checkedProp && indeterminate) {
        console.warn('Checkbox cannot be "checked" and "indeterminate" at the same time.');
      }
      if (toggle && indeterminate) {
        console.warn('Checkbox of type toggle does not have "indeterminate" state.');
      }
    }, [checkedProp, toggle, indeterminate]);
    var themeableProps = {
      checked,
      disabled,
      focus,
      // when contained in a FormField, focusIndicator = false,
      // so that the FormField has focus style. However, we still
      // need to visually indicate when a CheckBox is active.
      // If focus = true but focusIndicator = false,
      // we will apply the hover treament.
      focusIndicator,
      reverse,
      toggle,
      indeterminate
    };
    var hidden;
    if (disabled && checked) {
      hidden = /* @__PURE__ */ import_react38.default.createElement("input", {
        name,
        type: "hidden",
        value: "true"
      });
    }
    var _theme$checkBox$icons = theme.checkBox.icons, CheckedIcon = _theme$checkBox$icons.checked, IndeterminateIcon = _theme$checkBox$icons.indeterminate;
    var borderColor = normalizeColor(theme.checkBox.border.color, theme);
    if (checked) {
      borderColor = normalizeColor(theme.checkBox.color || "control", theme);
    }
    var visual = toggle ? /* @__PURE__ */ import_react38.default.createElement(StyledCheckBoxToggle, themeableProps, /* @__PURE__ */ import_react38.default.createElement(StyledCheckBoxKnob, themeableProps)) : /* @__PURE__ */ import_react38.default.createElement(StyledCheckBoxBox, _extends29({
      as: Box,
      align: "center",
      justify: "center",
      width: theme.checkBox.size,
      height: theme.checkBox.size,
      border: {
        size: theme.checkBox.border.width,
        color: borderColor
      },
      round: theme.checkBox.check.radius
    }, themeableProps), !indeterminate && checked && (CheckedIcon ? /* @__PURE__ */ import_react38.default.createElement(CheckedIcon, {
      theme,
      as: StyledCheckBoxIcon
    }) : /* @__PURE__ */ import_react38.default.createElement(StyledCheckBoxIcon, _extends29({
      theme,
      viewBox: "0 0 24 24",
      preserveAspectRatio: "xMidYMid meet"
    }, themeableProps), /* @__PURE__ */ import_react38.default.createElement("path", {
      fill: "none",
      d: "M6,11.3 L10.3,16 L18,6.2"
    }))), !checked && indeterminate && (IndeterminateIcon ? /* @__PURE__ */ import_react38.default.createElement(IndeterminateIcon, {
      theme,
      as: StyledCheckBoxIcon
    }) : /* @__PURE__ */ import_react38.default.createElement(StyledCheckBoxIcon, _extends29({
      theme,
      viewBox: "0 0 24 24",
      preserveAspectRatio: "xMidYMid meet"
    }, themeableProps), /* @__PURE__ */ import_react38.default.createElement("path", {
      fill: "none",
      d: "M6,12 L18,12"
    }))));
    var side = !reverse !== !theme.dir ? "left" : "right";
    var checkBoxNode = /* @__PURE__ */ import_react38.default.createElement(StyledCheckBox, _extends29({
      as: Box,
      align: "center",
      justify: "center",
      margin: label && (_ref2 = {}, _ref2[side] = theme.checkBox.gap || "small", _ref2)
    }, themeableProps), /* @__PURE__ */ import_react38.default.createElement(StyledCheckBoxInput, _extends29({
      "aria-label": ariaLabel || a11yTitle
    }, rest, {
      ref,
      type: "checkbox"
    }, removeUndefined({
      id,
      name,
      checked,
      disabled
    }), themeableProps, {
      onFocus: function onFocus(event) {
        setFocus(true);
        if (_onFocus)
          _onFocus(event);
      },
      onBlur: function onBlur(event) {
        setFocus(false);
        if (_onBlur)
          _onBlur(event);
      },
      onChange: function onChange2(event) {
        setChecked(event.target.checked);
        if (_onChange)
          _onChange(event);
      }
    })), children ? children({
      checked,
      indeterminate
    }) : visual, hidden);
    var normalizedLabel = typeof label === "string" ? /* @__PURE__ */ import_react38.default.createElement("span", null, label) : label;
    var first = reverse ? normalizedLabel : checkBoxNode;
    var second = reverse ? checkBoxNode : normalizedLabel;
    return /* @__PURE__ */ import_react38.default.createElement(StyledCheckBoxContainer, _extends29({
      fillProp: fill,
      reverse
    }, removeUndefined({
      htmlFor: id,
      disabled
    }), {
      checked,
      label,
      onClick: stopLabelClick,
      pad,
      onMouseEnter: function onMouseEnter(event) {
        return _onMouseEnter == null ? void 0 : _onMouseEnter(event);
      },
      onMouseOver: function onMouseOver(event) {
        return _onMouseOver == null ? void 0 : _onMouseOver(event);
      },
      onMouseLeave: function onMouseLeave(event) {
        return _onMouseLeave == null ? void 0 : _onMouseLeave(event);
      },
      onMouseOut: function onMouseOut(event) {
        return _onMouseOut == null ? void 0 : _onMouseOut(event);
      }
    }, themeableProps), first, second);
  });
  CheckBox.displayName = "CheckBox";
  CheckBox.propTypes = CheckBoxPropTypes;

  // node_modules/grommet/es6/components/CheckBoxGroup/StyledCheckBoxGroup.js
  var import_styled_components30 = __toESM(require_styled_components_browser_cjs());
  var StyledCheckBoxGroup = (0, import_styled_components30.default)(Box).withConfig({
    displayName: "StyledCheckBoxGroup",
    componentId: "sc-2nhc5d-0"
  })(["", ""], function(props) {
    return props.theme.checkBoxGroup && props.theme.checkBoxGroup.container && props.theme.checkBoxGroup.container.extend;
  });
  StyledCheckBoxGroup.defaultProps = {};
  Object.setPrototypeOf(StyledCheckBoxGroup.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/CheckBoxGroup/propTypes.js
  var import_prop_types18 = __toESM(require_prop_types());
  var PropType16 = {};
  if (true) {
    PropType16 = {
      value: import_prop_types18.default.arrayOf(import_prop_types18.default.oneOfType([import_prop_types18.default.number, import_prop_types18.default.string])),
      defaultValue: import_prop_types18.default.arrayOf(import_prop_types18.default.oneOfType([import_prop_types18.default.string, import_prop_types18.default.number])),
      disabled: import_prop_types18.default.bool,
      labelKey: import_prop_types18.default.string,
      name: import_prop_types18.default.string,
      onChange: import_prop_types18.default.func,
      options: import_prop_types18.default.oneOfType([import_prop_types18.default.arrayOf(import_prop_types18.default.string), import_prop_types18.default.arrayOf(import_prop_types18.default.shape({}))]),
      valueKey: import_prop_types18.default.string
    };
  }
  var CheckBoxGroupPropTypes = PropType16;

  // node_modules/grommet/es6/components/CheckBoxGroup/CheckBoxGroup.js
  var _excluded17 = ["children", "defaultValue", "value", "disabled", "focusIndicator", "gap", "labelKey", "valueKey", "onChange", "options", "name"];
  var _excluded23 = ["value"];
  function _extends30() {
    _extends30 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends30.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose17(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var CheckBoxGroup = /* @__PURE__ */ (0, import_react39.forwardRef)(function(_ref, ref) {
    var children = _ref.children, defaultValue6 = _ref.defaultValue, valueProp = _ref.value, disabledProp = _ref.disabled, _ref$focusIndicator = _ref.focusIndicator, focusIndicator = _ref$focusIndicator === void 0 ? true : _ref$focusIndicator, gap = _ref.gap, labelKey = _ref.labelKey, valueKey = _ref.valueKey, onChange2 = _ref.onChange, optionsProp = _ref.options, name = _ref.name, rest = _objectWithoutPropertiesLoose17(_ref, _excluded17);
    var formContext = (0, import_react39.useContext)(FormContext);
    var theme = (0, import_react39.useContext)(import_styled_components31.ThemeContext) || defaultProps.theme;
    var options2 = optionsProp.map(function(option) {
      return typeof option === "string" ? {
        disabled: disabledProp,
        value: option,
        label: option
      } : option;
    });
    var _formContext$useFormI = formContext.useFormInput({
      name,
      value: valueProp,
      initialValue: defaultValue6 || []
    }), value = _formContext$useFormI[0], setValue3 = _formContext$useFormI[1];
    var onCheckBoxChange = function onCheckBoxChange2(event, optionValue, option) {
      var nextValue = JSON.parse(JSON.stringify(value)) || [];
      var optionIndex = nextValue.indexOf(optionValue);
      if (optionIndex < 0)
        nextValue.push(optionValue);
      else
        nextValue.splice(optionIndex, 1);
      setValue3(nextValue);
      if (onChange2) {
        event.persist();
        var adjustedEvent = event;
        adjustedEvent.value = nextValue;
        adjustedEvent.option = option;
        onChange2(adjustedEvent);
      }
    };
    return /* @__PURE__ */ import_react39.default.createElement(StyledCheckBoxGroup, _extends30({
      ref,
      role: "group"
    }, theme.checkBoxGroup.container, {
      gap: gap || (theme.checkBoxGroup.container && theme.checkBoxGroup.container.gap ? theme.checkBoxGroup.container.gap : "small")
      // consistent with RadioButtonGroup default
    }, rest), options2.map(function(option, index) {
      var optionValue = option.value;
      var label = labelKey ? option[labelKey] : option.label;
      var valueOption = valueKey ? option[valueKey] : optionValue;
      var checked = value.indexOf(valueOption) >= 0;
      var disabled = disabledProp || option.disabled;
      var key = label + "-" + valueOption;
      if (option.checked)
        console.warn(
          // eslint-disable-next-line max-len
          "'checked' prop of an individual CheckBox shouldn't be used in a CheckBoxGroup component. Use the CheckBoxGroup 'value' prop instead."
        );
      var omit10 = option.value, optionRest = _objectWithoutPropertiesLoose17(option, _excluded23);
      var optionProps = _extends30({}, optionRest, {
        label,
        disabled
      });
      return /* @__PURE__ */ import_react39.default.createElement(CheckBox, _extends30({
        key
      }, optionProps, {
        disabled,
        checked,
        focusIndicator,
        label,
        onChange: function onChange3(event) {
          return onCheckBoxChange(event, valueOption, optionProps);
        }
      }), children ? function(state) {
        return children(options2[index], state);
      } : null);
    }));
  });
  CheckBoxGroup.displayName = "CheckBoxGroup";
  CheckBoxGroup.propTypes = CheckBoxGroupPropTypes;

  // node_modules/grommet/es6/components/Data/Data.js
  var import_react67 = __toESM(require_react());

  // node_modules/grommet/es6/components/DataFilters/DataFilters.js
  var import_react62 = __toESM(require_react());
  var import_Filter = __toESM(require_Filter());
  var import_FormClose2 = __toESM(require_FormClose());

  // node_modules/grommet/es6/components/DataFilter/DataFilter.js
  var import_react54 = __toESM(require_react());

  // node_modules/grommet/es6/components/FormField/FormField.js
  var import_react43 = __toESM(require_react());
  var import_styled_components37 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/RadioButtonGroup/RadioButtonGroup.js
  var import_react41 = __toESM(require_react());
  var import_styled_components34 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/RadioButton/RadioButton.js
  var import_react40 = __toESM(require_react());
  var import_styled_components33 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/RadioButton/StyledRadioButton.js
  var import_styled_components32 = __toESM(require_styled_components_browser_cjs());
  var disabledStyle4 = "\n  opacity: 0.5;\n  cursor: default;\n";
  var StyledRadioButtonContainer = import_styled_components32.default.label.withConfig({
    displayName: "StyledRadioButton__StyledRadioButtonContainer",
    componentId: "sc-g1f6ld-0"
  })(["display:flex;flex-direction:row;align-items:center;user-select:none;width:fit-content;", " ", ":hover input:not([disabled]) + div,:hover input:not([disabled]) + span{border-color:", ";}:hover{background-color:", ";}", " ", ";"], function(props) {
    return props.disabled && disabledStyle4;
  }, function(props) {
    return !props.disabled && "cursor: pointer;";
  }, function(props) {
    return normalizeColor(props.theme.radioButton.hover.border.color, props.theme);
  }, function(props) {
    return normalizeColor(!props.disabled && props.theme.radioButton.hover && props.theme.radioButton.hover.background && props.theme.radioButton.hover.background.color, props.theme);
  }, function(props) {
    return props.focus && !props.focusIndicator && "\n      input:not([disabled]) + div,\n      input:not([disabled]) + span {\n      border-color: " + normalizeColor(props.theme.radioButton.hover.border.color, props.theme) + ";\n    }\n    background-color: " + normalizeColor(!props.disabled && props.theme.radioButton.hover && props.theme.radioButton.hover.background && props.theme.radioButton.hover.background.color, props.theme) + ";\n    ";
  }, function(props) {
    return props.theme.radioButton.container.extend;
  });
  StyledRadioButtonContainer.defaultProps = {};
  Object.setPrototypeOf(StyledRadioButtonContainer.defaultProps, defaultProps2);
  var StyledRadioButtonInput = import_styled_components32.default.input.withConfig({
    displayName: "StyledRadioButton__StyledRadioButtonInput",
    componentId: "sc-g1f6ld-1"
  })(["opacity:0;-moz-appearance:none;width:0;height:0;margin:0;", ";"], function(props) {
    return !props.disabled && "cursor: pointer;";
  });
  StyledRadioButtonInput.defaultProps = {};
  Object.setPrototypeOf(StyledRadioButtonInput.defaultProps, defaultProps2);
  var StyledRadioButtonLabel = import_styled_components32.default.span.withConfig({
    displayName: "StyledRadioButton__StyledRadioButtonLabel",
    componentId: "sc-g1f6ld-2"
  })(["", ""], function(props) {
    return props.theme.radioButton.font.weight && (0, import_styled_components32.css)(["font-weight:", ";"], props.theme.radioButton.font.weight);
  });
  StyledRadioButtonLabel.defaultProps = {};
  Object.setPrototypeOf(StyledRadioButtonLabel.defaultProps, defaultProps2);
  var StyledRadioButtonIcon = import_styled_components32.default.svg.withConfig({
    displayName: "StyledRadioButton__StyledRadioButtonIcon",
    componentId: "sc-g1f6ld-3"
  })(["box-sizing:border-box;width:", ";height:", ";fill:", ";", ";"], function(props) {
    return props.theme.radioButton.icon.size || props.theme.radioButton.size;
  }, function(props) {
    return props.theme.radioButton.icon.size || props.theme.radioButton.size;
  }, function(props) {
    return normalizeColor(props.theme.radioButton.check.color || "control", props.theme);
  }, function(props) {
    return props.theme.radioButton.icon.extend;
  });
  StyledRadioButtonIcon.defaultProps = {};
  Object.setPrototypeOf(StyledRadioButtonIcon.defaultProps, defaultProps2);
  var StyledRadioButtonBox = import_styled_components32.default.div.withConfig({
    displayName: "StyledRadioButton__StyledRadioButtonBox",
    componentId: "sc-g1f6ld-4"
  })(["background-color:", ";", ";", ";"], function(props) {
    var _props$theme$radioBut;
    return normalizeColor((_props$theme$radioBut = props.theme.radioButton.check.background) == null ? void 0 : _props$theme$radioBut.color, props.theme);
  }, function(props) {
    return props.focus && focusStyle();
  }, function(props) {
    return props.theme.radioButton.check.extend;
  });
  StyledRadioButtonBox.defaultProps = {};
  Object.setPrototypeOf(StyledRadioButtonBox.defaultProps, defaultProps2);
  var StyledRadioButton = import_styled_components32.default.div.withConfig({
    displayName: "StyledRadioButton",
    componentId: "sc-g1f6ld-5"
  })(["", ";"], function(props) {
    return props.theme.radioButton && props.theme.radioButton.extend;
  });
  StyledRadioButton.defaultProps = {};
  Object.setPrototypeOf(StyledRadioButton.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/RadioButton/propTypes.js
  var import_prop_types19 = __toESM(require_prop_types());
  var PropType17 = {};
  if (true) {
    PropType17 = {
      a11yTitle: import_prop_types19.default.string,
      checked: import_prop_types19.default.bool,
      children: import_prop_types19.default.func,
      disabled: import_prop_types19.default.bool,
      id: import_prop_types19.default.string,
      label: import_prop_types19.default.node,
      name: import_prop_types19.default.string.isRequired,
      onChange: import_prop_types19.default.func
    };
  }
  var RadioButtonPropTypes = PropType17;

  // node_modules/grommet/es6/components/RadioButton/RadioButton.js
  var _excluded18 = ["a11yTitle", "checked", "children", "disabled", "focus", "focusIndicator", "id", "label", "name", "onChange"];
  function _extends31() {
    _extends31 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends31.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose18(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var RadioButton = /* @__PURE__ */ (0, import_react40.forwardRef)(function(_ref, ref) {
    var a11yTitle = _ref.a11yTitle, checked = _ref.checked, children = _ref.children, disabled = _ref.disabled, focus = _ref.focus, focusIndicator = _ref.focusIndicator, id = _ref.id, label = _ref.label, name = _ref.name, onChange2 = _ref.onChange, rest = _objectWithoutPropertiesLoose18(_ref, _excluded18);
    var theme = (0, import_react40.useContext)(import_styled_components33.ThemeContext) || defaultProps2.theme;
    var _useState = (0, import_react40.useState)(), hover = _useState[0], setHover = _useState[1];
    var normalizedLabel = typeof label === "string" ? /* @__PURE__ */ import_react40.default.createElement(StyledRadioButtonLabel, null, label) : label;
    var Icon = theme.radioButton.icons.circle;
    var borderColor = normalizeColor(theme.radioButton.border.color, theme);
    if (checked) {
      borderColor = normalizeColor(theme.radioButton.color || "control", theme);
    }
    return /* @__PURE__ */ import_react40.default.createElement(StyledRadioButtonContainer, _extends31({}, removeUndefined({
      htmlFor: id,
      disabled
    }), {
      onClick: function onClick(event) {
        if (event.target.type !== "radio") {
          event.stopPropagation();
        }
      },
      focus,
      focusIndicator,
      onMouseEnter: function onMouseEnter() {
        return setHover(true);
      },
      onMouseLeave: function onMouseLeave() {
        return setHover(false);
      }
    }), /* @__PURE__ */ import_react40.default.createElement(StyledRadioButton, {
      as: Box,
      flex: false,
      margin: label ? {
        right: theme.radioButton.gap || "small"
      } : void 0
    }, /* @__PURE__ */ import_react40.default.createElement(StyledRadioButtonInput, _extends31({
      "aria-label": a11yTitle
    }, rest, {
      ref,
      type: "radio"
    }, removeUndefined({
      id,
      name,
      checked,
      disabled,
      onChange: onChange2
    }))), children ? children({
      checked,
      focus: focus && focusIndicator,
      hover
    }) : /* @__PURE__ */ import_react40.default.createElement(StyledRadioButtonBox, {
      focus: focus && focusIndicator,
      as: Box,
      align: "center",
      justify: "center",
      width: theme.radioButton.size,
      height: theme.radioButton.size,
      border: {
        size: theme.radioButton.border.width,
        color: borderColor
      },
      round: theme.radioButton.check.radius
    }, checked && (Icon ? /* @__PURE__ */ import_react40.default.createElement(Icon, {
      theme,
      as: StyledRadioButtonIcon
    }) : /* @__PURE__ */ import_react40.default.createElement(StyledRadioButtonIcon, {
      viewBox: "0 0 24 24",
      preserveAspectRatio: "xMidYMid meet"
    }, /* @__PURE__ */ import_react40.default.createElement("circle", {
      cx: 12,
      cy: 12,
      r: 6
    }))))), normalizedLabel);
  });
  RadioButton.displayName = "RadioButton";
  RadioButton.propTypes = RadioButtonPropTypes;

  // node_modules/grommet/es6/components/RadioButtonGroup/propTypes.js
  var import_prop_types20 = __toESM(require_prop_types());
  var PropType18 = {};
  if (true) {
    PropType18 = {
      children: import_prop_types20.default.func,
      disabled: import_prop_types20.default.bool,
      name: import_prop_types20.default.string.isRequired,
      onChange: import_prop_types20.default.func,
      options: import_prop_types20.default.oneOfType([import_prop_types20.default.arrayOf(import_prop_types20.default.string), import_prop_types20.default.arrayOf(import_prop_types20.default.number), import_prop_types20.default.arrayOf(import_prop_types20.default.bool), import_prop_types20.default.arrayOf(import_prop_types20.default.shape({
        disabled: import_prop_types20.default.bool,
        id: import_prop_types20.default.string,
        label: import_prop_types20.default.oneOfType([import_prop_types20.default.string, import_prop_types20.default.element]),
        value: import_prop_types20.default.oneOfType([import_prop_types20.default.string, import_prop_types20.default.number, import_prop_types20.default.bool]).isRequired
      }))]).isRequired,
      value: import_prop_types20.default.oneOfType([import_prop_types20.default.string, import_prop_types20.default.number, import_prop_types20.default.bool, import_prop_types20.default.object])
    };
  }
  var RadioButtonGroupPropTypes = PropType18;

  // node_modules/grommet/es6/components/RadioButtonGroup/RadioButtonGroup.js
  var _excluded19 = ["children", "defaultValue", "disabled", "focusIndicator", "name", "onChange", "options", "value", "gap"];
  var _excluded24 = ["disabled", "id", "label", "value"];
  function _extends32() {
    _extends32 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends32.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose19(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var RadioButtonGroup = /* @__PURE__ */ (0, import_react41.forwardRef)(function(_ref, ref) {
    var children = _ref.children, defaultValue6 = _ref.defaultValue, disabled = _ref.disabled, _ref$focusIndicator = _ref.focusIndicator, focusIndicator = _ref$focusIndicator === void 0 ? true : _ref$focusIndicator, name = _ref.name, _onChange = _ref.onChange, optionsProp = _ref.options, valueProp = _ref.value, gap = _ref.gap, rest = _objectWithoutPropertiesLoose19(_ref, _excluded19);
    var formContext = (0, import_react41.useContext)(FormContext);
    var theme = (0, import_react41.useContext)(import_styled_components34.ThemeContext) || defaultProps2.theme;
    var options2 = optionsProp.map(function(o) {
      return typeof o !== "object" ? {
        disabled,
        id: rest.id ? rest.id + "-" + o : "" + o,
        // force string
        label: typeof o !== "string" ? JSON.stringify(o) : o,
        value: o
      } : _extends32({
        disabled
      }, o);
    });
    var _formContext$useFormI = formContext.useFormInput({
      name,
      value: valueProp,
      initialValue: defaultValue6 || ""
    }), value = _formContext$useFormI[0], setValue3 = _formContext$useFormI[1];
    var _useState = (0, import_react41.useState)(), focus = _useState[0], setFocus = _useState[1];
    var optionRefs = (0, import_react41.useRef)([]);
    var valueIndex = import_react41.default.useMemo(function() {
      var result;
      options2.some(function(option, index) {
        if (option.value === value) {
          result = index;
          return true;
        }
        return false;
      });
      return result;
    }, [options2, value]);
    (0, import_react41.useEffect)(function() {
      if (focus && !valueIndex) {
        optionRefs.current[0].focus();
      }
    }, [focus, valueIndex]);
    var onNext = function onNext2() {
      if (valueIndex !== void 0 && valueIndex < options2.length - 1) {
        var nextIndex = valueIndex + 1;
        optionRefs.current[nextIndex].click();
      }
    };
    var onPrevious = function onPrevious2() {
      if (valueIndex > 0) {
        var nextIndex = valueIndex - 1;
        optionRefs.current[nextIndex].click();
      }
    };
    var onFocus = function onFocus2() {
      setTimeout(function() {
        setFocus(true);
      }, 1);
    };
    var onBlur = function onBlur2() {
      return setFocus(false);
    };
    return /* @__PURE__ */ import_react41.default.createElement(Keyboard, {
      target: "document",
      onUp: focus ? onPrevious : void 0,
      onDown: focus ? onNext : void 0,
      onLeft: focus ? onPrevious : void 0,
      onRight: focus ? onNext : void 0
    }, /* @__PURE__ */ import_react41.default.createElement(Box, _extends32({
      ref,
      role: "radiogroup"
    }, theme.radioButtonGroup.container, {
      gap: gap || (theme.radioButtonGroup.container && theme.radioButtonGroup.container.gap ? theme.radioButtonGroup.container.gap : "small")
    }, rest), options2.map(function(_ref2, index) {
      var optionDisabled = _ref2.disabled, id = _ref2.id, label = _ref2.label, optionValue = _ref2.value, optionRest = _objectWithoutPropertiesLoose19(_ref2, _excluded24);
      var focusable = optionValue === value || value === void 0 && !index || // when nothing has been selected, show focus
      // on the first radiobutton
      value === "" && index === 0;
      return /* @__PURE__ */ import_react41.default.createElement(RadioButton, _extends32({
        ref: function ref2(aRef) {
          optionRefs.current[index] = aRef;
        },
        key: optionValue,
        name,
        label: !children ? label : void 0,
        disabled: optionDisabled,
        checked: optionValue === value,
        focus: focus && focusable,
        focusIndicator,
        id,
        value: optionValue,
        onFocus,
        onBlur,
        onChange: function onChange2(event) {
          setValue3(optionValue);
          if (_onChange)
            _onChange(event);
        },
        tabIndex: focusable ? "0" : "-1"
        // necessary for Firefox
      }, optionRest), children ? function(state) {
        return children(optionsProp[index], state);
      } : null);
    })));
  });
  RadioButtonGroup.displayName = "RadioButtonGroup";
  RadioButtonGroup.propTypes = RadioButtonGroupPropTypes;

  // node_modules/grommet/es6/components/TextInput/TextInput.js
  var import_react42 = __toESM(require_react());
  var import_styled_components36 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/TextInput/StyledTextInput.js
  var import_styled_components35 = __toESM(require_styled_components_browser_cjs());
  var getPlainStyle = function getPlainStyle2(plain) {
    if (plain === "full") {
      return (0, import_styled_components35.css)(["", " padding:0;"], plainInputStyle);
    }
    return plain && plainInputStyle;
  };
  var StyledTextInput = import_styled_components35.default.input.withConfig({
    displayName: "StyledTextInput",
    componentId: "sc-1x30a0s-0"
  })(["", " ", " ", " ", " ", " ", " ", ";"], inputStyle, function(props) {
    return getPlainStyle(props.plain);
  }, function(props) {
    return props.icon && (props.reverse ? "padding-right: " + props.theme.global.edgeSize.large + ";" : "padding-left: " + props.theme.global.edgeSize.large + ";");
  }, function(props) {
    return props.disabled && disabledStyle(props.theme.textInput.disabled && props.theme.textInput.disabled.opacity);
  }, function(props) {
    return props.textAlign && textAlignStyle;
  }, function(props) {
    return props.widthProp && widthStyle(props.widthProp, props.theme);
  }, function(props) {
    return props.theme.textInput && props.theme.textInput.extend;
  });
  StyledTextInput.defaultProps = {};
  Object.setPrototypeOf(StyledTextInput.defaultProps, defaultProps2);
  var StyledTextInputContainer = import_styled_components35.default.div.withConfig({
    displayName: "StyledTextInput__StyledTextInputContainer",
    componentId: "sc-1x30a0s-1"
  })(["position:relative;width:100%;", ";"], function(props) {
    return props.theme.textInput && props.theme.textInput.container && props.theme.textInput.container.extend;
  });
  StyledTextInputContainer.defaultProps = {};
  Object.setPrototypeOf(StyledTextInputContainer.defaultProps, defaultProps2);
  var StyledPlaceholder = import_styled_components35.default.div.withConfig({
    displayName: "StyledTextInput__StyledPlaceholder",
    componentId: "sc-1x30a0s-2"
  })(["position:absolute;left:", "px;top:50%;transform:translateY(-50%);display:flex;justify-content:center;pointer-events:none;", ";"], function(props) {
    return parseMetricToNum(getInputPadBySide(props, "left")) - parseMetricToNum(props.theme.global.control.border.width);
  }, function(props) {
    return props.theme.textInput && props.theme.textInput.placeholder && props.theme.textInput.placeholder.extend;
  });
  StyledPlaceholder.defaultProps = {};
  Object.setPrototypeOf(StyledPlaceholder.defaultProps, defaultProps2);
  var StyledIcon = import_styled_components35.default.div.withConfig({
    displayName: "StyledTextInput__StyledIcon",
    componentId: "sc-1x30a0s-3"
  })(["position:absolute;display:flex;justify:center;top:50%;transform:translateY(-50%);pointer-events:none;", ""], function(props) {
    return props.reverse ? "right: " + getInputPadBySide(props, "right") + ";" : "left: " + getInputPadBySide(props, "left") + ";";
  });
  var StyledSuggestions = import_styled_components35.default.ol.withConfig({
    displayName: "StyledTextInput__StyledSuggestions",
    componentId: "sc-1x30a0s-4"
  })(["border-top-left-radius:0;border-top-right-radius:0;margin:0;padding:0;list-style-type:none;", ";"], function(props) {
    return props.theme.textInput && props.theme.textInput.suggestions && props.theme.textInput.suggestions.extend;
  });
  StyledSuggestions.defaultProps = {};
  Object.setPrototypeOf(StyledSuggestions.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/TextInput/propTypes.js
  var import_prop_types21 = __toESM(require_prop_types());
  var PropType19 = {};
  if (true) {
    PropType19 = {
      a11yTitle: import_prop_types21.default.string,
      defaultSuggestion: import_prop_types21.default.number,
      dropAlign: import_prop_types21.default.shape({
        top: import_prop_types21.default.oneOf(["top", "bottom"]),
        bottom: import_prop_types21.default.oneOf(["top", "bottom"]),
        right: import_prop_types21.default.oneOf(["left", "right"]),
        left: import_prop_types21.default.oneOf(["left", "right"])
      }),
      dropHeight: import_prop_types21.default.oneOfType([import_prop_types21.default.oneOf(["xsmall", "small", "medium", "large", "xlarge"]), import_prop_types21.default.string]),
      dropTarget: import_prop_types21.default.object,
      dropProps: import_prop_types21.default.object,
      icon: import_prop_types21.default.element,
      id: import_prop_types21.default.string,
      focusIndicator: import_prop_types21.default.bool,
      messages: import_prop_types21.default.shape({
        enterSelect: import_prop_types21.default.string,
        suggestionsCount: import_prop_types21.default.string,
        suggestionsExist: import_prop_types21.default.string,
        suggestionIsOpen: import_prop_types21.default.string
      }),
      name: import_prop_types21.default.string,
      onChange: import_prop_types21.default.func,
      onSelect: import_prop_types21.default.func,
      onSuggestionSelect: import_prop_types21.default.func,
      onSuggestionsOpen: import_prop_types21.default.func,
      onSuggestionsClose: import_prop_types21.default.func,
      placeholder: import_prop_types21.default.node,
      plain: import_prop_types21.default.oneOfType([import_prop_types21.default.bool, import_prop_types21.default.oneOf(["full"])]),
      reverse: import_prop_types21.default.bool,
      size: import_prop_types21.default.oneOfType([import_prop_types21.default.oneOf(["xsmall", "small", "medium", "large", "xlarge", "xxlarge", "2xl", "3xl", "4xl", "5xl", "6xl"]), import_prop_types21.default.string]),
      suggestions: import_prop_types21.default.arrayOf(import_prop_types21.default.oneOfType([import_prop_types21.default.shape({
        label: import_prop_types21.default.node,
        // eslint-disable-next-line
        value: import_prop_types21.default.any
        // this is intentional any
      }), import_prop_types21.default.string])),
      textAlign: import_prop_types21.default.oneOf(["start", "center", "end"]),
      value: import_prop_types21.default.oneOfType([import_prop_types21.default.string, import_prop_types21.default.number]),
      width: widthPropType
    };
  }
  var TextInputPropTypes = PropType19;

  // node_modules/grommet/es6/components/TextInput/TextInput.js
  var _excluded20 = ["a11yTitle", "defaultSuggestion", "defaultValue", "dropAlign", "dropHeight", "dropTarget", "dropProps", "focusIndicator", "icon", "id", "messages", "name", "onBlur", "onChange", "onFocus", "onKeyDown", "onSelect", "onSuggestionSelect", "onSuggestionsClose", "onSuggestionsOpen", "placeholder", "plain", "readOnly", "reverse", "suggestions", "textAlign", "value", "width"];
  function _extends33() {
    _extends33 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends33.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose20(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var renderLabel = function renderLabel2(suggestion) {
    if (suggestion && typeof suggestion === "object") {
      return suggestion.label || suggestion.value;
    }
    return suggestion;
  };
  var stringLabel = function stringLabel2(suggestion) {
    if (suggestion && typeof suggestion === "object") {
      if (suggestion.label && typeof suggestion.label === "string") {
        return suggestion.label;
      }
      return suggestion.value;
    }
    return suggestion;
  };
  var ContainerBox = (0, import_styled_components36.default)(Box).withConfig({
    displayName: "TextInput__ContainerBox",
    componentId: "sc-1ai0c08-0"
  })(["", ";@media screen and (-ms-high-contrast:active),(-ms-high-contrast:none){width:100%;}"], function(props) {
    return props.dropHeight ? sizeStyle("max-height", props.dropHeight, props.theme) : "max-height: inherit;";
  });
  var defaultDropAlign = {
    top: "bottom",
    left: "left"
  };
  var TextInput = /* @__PURE__ */ (0, import_react42.forwardRef)(function(_ref, ref) {
    var _inputRef$current;
    var a11yTitle = _ref.a11yTitle, defaultSuggestion = _ref.defaultSuggestion, defaultValue6 = _ref.defaultValue, _ref$dropAlign = _ref.dropAlign, dropAlign = _ref$dropAlign === void 0 ? defaultDropAlign : _ref$dropAlign, dropHeight = _ref.dropHeight, dropTarget = _ref.dropTarget, dropProps4 = _ref.dropProps, _ref$focusIndicator = _ref.focusIndicator, focusIndicator = _ref$focusIndicator === void 0 ? true : _ref$focusIndicator, icon = _ref.icon, id = _ref.id, messages = _ref.messages, name = _ref.name, _onBlur = _ref.onBlur, onChange2 = _ref.onChange, _onFocus = _ref.onFocus, onKeyDown = _ref.onKeyDown, onSelect = _ref.onSelect, onSuggestionSelect = _ref.onSuggestionSelect, onSuggestionsClose = _ref.onSuggestionsClose, onSuggestionsOpen = _ref.onSuggestionsOpen, placeholder = _ref.placeholder, plain = _ref.plain, readOnly = _ref.readOnly, reverse = _ref.reverse, suggestions = _ref.suggestions, textAlign = _ref.textAlign, valueProp = _ref.value, widthProp = _ref.width, rest = _objectWithoutPropertiesLoose20(_ref, _excluded20);
    var theme = (0, import_react42.useContext)(import_styled_components36.ThemeContext) || defaultProps2.theme;
    var _useContext = (0, import_react42.useContext)(MessageContext), format4 = _useContext.format;
    var announce = (0, import_react42.useContext)(AnnounceContext);
    var formContext = (0, import_react42.useContext)(FormContext);
    var inputRef = useForwardedRef(ref);
    var dropRef = (0, import_react42.useRef)();
    var suggestionsRef = (0, import_react42.useRef)();
    var _formContext$useFormI = formContext.useFormInput({
      name: readOnly ? void 0 : name,
      value: valueProp
    }), value = _formContext$useFormI[0], setValue3 = _formContext$useFormI[1];
    var _useState = (0, import_react42.useState)(), focus = _useState[0], setFocus = _useState[1];
    var _useState2 = (0, import_react42.useState)(false), showDrop = _useState2[0], setShowDrop = _useState2[1];
    var handleSuggestionSelect = (0, import_react42.useMemo)(function() {
      return onSelect && !onSuggestionSelect ? onSelect : onSuggestionSelect;
    }, [onSelect, onSuggestionSelect]);
    var handleTextSelect = (0, import_react42.useMemo)(function() {
      return onSelect && onSuggestionSelect ? onSelect : void 0;
    }, [onSelect, onSuggestionSelect]);
    var _useState3 = (0, import_react42.useState)(), suggestionsAtClose = _useState3[0], setSuggestionsAtClose = _useState3[1];
    var openDrop = (0, import_react42.useCallback)(function() {
      setShowDrop(true);
      announce(format4({
        id: "textInput.suggestionIsOpen",
        messages
      }));
      announce(suggestions.length + " " + format4({
        id: "textInput.suggestionsCount",
        messages
      }));
      if (onSuggestionsOpen)
        onSuggestionsOpen();
    }, [announce, messages, format4, onSuggestionsOpen, suggestions]);
    var closeDrop = (0, import_react42.useCallback)(function() {
      setSuggestionsAtClose(suggestions);
      setShowDrop(false);
      if (onSuggestionsClose)
        onSuggestionsClose();
    }, [onSuggestionsClose, suggestions]);
    var clickOutside = (0, import_react42.useCallback)(function(event) {
      if (event.target !== inputRef.current)
        closeDrop();
    }, [inputRef, closeDrop]);
    (0, import_react42.useEffect)(function() {
      if (focus && !showDrop && suggestions && suggestions.length && (!suggestionsAtClose || suggestionsAtClose.length !== suggestions.length)) {
        openDrop();
      }
    }, [focus, openDrop, showDrop, suggestions, suggestionsAtClose]);
    (0, import_react42.useEffect)(function() {
      if (showDrop && (!suggestions || !suggestions.length)) {
        closeDrop();
      }
    }, [closeDrop, showDrop, suggestions]);
    var valueSuggestionIndex = (0, import_react42.useMemo)(function() {
      return suggestions ? suggestions.map(function(suggestion) {
        return typeof suggestion === "object" ? suggestion.value : suggestion;
      }).indexOf(value) : -1;
    }, [suggestions, value]);
    var resetSuggestionIndex = (0, import_react42.useMemo)(function() {
      if (valueSuggestionIndex === -1 && typeof defaultSuggestion === "number") {
        return defaultSuggestion;
      }
      return valueSuggestionIndex;
    }, [defaultSuggestion, valueSuggestionIndex]);
    var _useState4 = (0, import_react42.useState)(resetSuggestionIndex), activeSuggestionIndex = _useState4[0], setActiveSuggestionIndex = _useState4[1];
    var _useState5 = (0, import_react42.useState)(), mouseMovedSinceLastKey = _useState5[0], setMouseMovedSinceLastKey = _useState5[1];
    (0, import_react42.useEffect)(function() {
      return setActiveSuggestionIndex(valueSuggestionIndex);
    }, [valueSuggestionIndex]);
    (0, import_react42.useEffect)(function() {
      if (!showDrop)
        setActiveSuggestionIndex(resetSuggestionIndex);
    }, [resetSuggestionIndex, showDrop]);
    (0, import_react42.useEffect)(function() {
      if (activeSuggestionIndex >= 0) {
        var label = stringLabel(suggestions[activeSuggestionIndex]);
        announce(label + " " + format4({
          id: "textInput.enterSelect",
          messages
        }));
      }
    }, [activeSuggestionIndex, announce, messages, format4, suggestions]);
    (0, import_react42.useEffect)(function() {
      var timer = setTimeout(function() {
        var list = suggestionsRef.current;
        if (showDrop && activeSuggestionIndex !== -1 && list) {
          var container = list.parentNode;
          var item = list.children[activeSuggestionIndex];
          if (container.scrollTo) {
            if (isNodeAfterScroll(item, container))
              container.scrollTo(0, item.offsetTop - (container.getBoundingClientRect().height - item.getBoundingClientRect().height));
            else if (isNodeBeforeScroll(item, container))
              container.scrollTo(0, item.offsetTop);
          }
        }
      }, 50);
      return function() {
        return clearTimeout(timer);
      };
    }, [activeSuggestionIndex, showDrop]);
    var setValueFromSuggestion = function setValueFromSuggestion2(event, suggestion) {
      inputRef.current.focus();
      inputRef.current.value = suggestion;
      closeDrop();
      if (handleSuggestionSelect) {
        if (event.persist)
          event.persist();
        var adjustedEvent = event;
        adjustedEvent.suggestion = suggestion;
        handleSuggestionSelect(adjustedEvent);
      }
      setValue3(suggestion);
    };
    var onNextSuggestion = (0, import_react42.useCallback)(function(event) {
      event.preventDefault();
      var nextActiveIndex = Math.min(activeSuggestionIndex + 1, suggestions.length - 1);
      setActiveSuggestionIndex(nextActiveIndex);
      setMouseMovedSinceLastKey(false);
    }, [activeSuggestionIndex, suggestions]);
    var onPreviousSuggestion = (0, import_react42.useCallback)(function(event) {
      event.preventDefault();
      var nextActiveIndex = Math.max(activeSuggestionIndex - 1, 0);
      setActiveSuggestionIndex(nextActiveIndex);
      setMouseMovedSinceLastKey(false);
    }, [activeSuggestionIndex]);
    var hasValue = value || ((_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.value);
    var showStyledPlaceholder = (0, import_react42.useMemo)(function() {
      return placeholder && typeof placeholder !== "string" && !hasValue;
    }, [hasValue, placeholder]);
    var drop;
    var extraProps = {
      onSelect: handleTextSelect
    };
    if (showDrop) {
      drop = /* @__PURE__ */ import_react42.default.createElement(Drop, _extends33({
        ref: dropRef,
        id: id ? "text-input-drop__" + id : void 0,
        align: dropAlign,
        responsive: false,
        target: dropTarget || inputRef.current,
        onClickOutside: clickOutside,
        onEsc: closeDrop
      }, dropProps4), /* @__PURE__ */ import_react42.default.createElement(ContainerBox, {
        id: id ? "listbox__" + id : void 0,
        role: "listbox",
        overflow: "auto",
        dropHeight,
        onMouseMove: function onMouseMove() {
          return setMouseMovedSinceLastKey(true);
        }
      }, /* @__PURE__ */ import_react42.default.createElement(StyledSuggestions, {
        ref: suggestionsRef
      }, /* @__PURE__ */ import_react42.default.createElement(InfiniteScroll, {
        items: suggestions,
        step: theme.select.step,
        show: activeSuggestionIndex !== -1 ? activeSuggestionIndex : void 0
      }, function(suggestion, index, itemRef) {
        var active = activeSuggestionIndex === index;
        var selected = suggestion === value;
        var renderedLabel = renderLabel(suggestion);
        var child;
        if (typeof renderedLabel !== "string")
          child = renderedLabel;
        else if (!theme.button.option)
          child = /* @__PURE__ */ import_react42.default.createElement(Box, {
            align: "start",
            pad: "small"
          }, renderedLabel);
        return /* @__PURE__ */ import_react42.default.createElement("li", {
          key: stringLabel(suggestion) + "-" + index,
          ref: itemRef
        }, /* @__PURE__ */ import_react42.default.createElement(Button2, {
          id: id ? "listbox-option-" + index + "__" + id : void 0,
          role: "option",
          "aria-selected": selected ? "true" : "false",
          active,
          fill: "horizontal",
          plain: !child ? void 0 : true,
          align: "start",
          kind: !child ? "option" : void 0,
          label: !child ? renderedLabel : void 0,
          onClick: function onClick(event) {
            return setValueFromSuggestion(event, suggestion);
          },
          onMouseMove: mouseMovedSinceLastKey && activeSuggestionIndex !== index ? function() {
            return setActiveSuggestionIndex(index);
          } : void 0
        }, child));
      }))));
    }
    var keyboardProps = {
      onKeyDown
    };
    if (showDrop) {
      keyboardProps.onEnter = function(event) {
        event.preventDefault();
        if (activeSuggestionIndex >= 0)
          setValueFromSuggestion(event, suggestions[activeSuggestionIndex]);
        else
          closeDrop();
      };
      if (activeSuggestionIndex > 0)
        keyboardProps.onUp = onPreviousSuggestion;
      if (activeSuggestionIndex < suggestions.length - 1)
        keyboardProps.onDown = onNextSuggestion;
      keyboardProps.onTab = closeDrop;
    } else if (suggestions && suggestions.length > 0) {
      keyboardProps.onDown = openDrop;
    }
    var comboboxProps = {};
    var activeOptionID;
    if (id && (suggestions == null ? void 0 : suggestions.length) > -1) {
      if (showDrop && activeSuggestionIndex > -1) {
        activeOptionID = "listbox-option-" + activeSuggestionIndex + "__" + id;
      }
      comboboxProps = {
        "aria-activedescendant": activeOptionID,
        "aria-autocomplete": "list",
        "aria-expanded": showDrop ? "true" : "false",
        "aria-controls": showDrop ? "listbox__" + id : void 0,
        role: "combobox"
      };
    }
    return /* @__PURE__ */ import_react42.default.createElement(StyledTextInputContainer, {
      plain
    }, showStyledPlaceholder && /* @__PURE__ */ import_react42.default.createElement(StyledPlaceholder, null, placeholder), icon && /* @__PURE__ */ import_react42.default.createElement(StyledIcon, {
      reverse,
      theme
    }, icon), /* @__PURE__ */ import_react42.default.createElement(Keyboard, _extends33({
      target: focus ? "document" : void 0
    }, keyboardProps), /* @__PURE__ */ import_react42.default.createElement(StyledTextInput, _extends33({
      "aria-label": a11yTitle,
      ref: inputRef,
      id,
      name,
      autoComplete: "off",
      plain,
      placeholder: typeof placeholder === "string" ? placeholder : void 0,
      icon,
      reverse,
      focus,
      focusIndicator,
      textAlign,
      widthProp
    }, rest, extraProps, comboboxProps, {
      defaultValue: renderLabel(defaultValue6),
      value: renderLabel(value),
      readOnly,
      onFocus: function onFocus(event) {
        if (!focus) {
          setFocus(true);
          if (suggestions && suggestions.length > 0) {
            announce(format4({
              id: "textInput.suggestionsExist",
              messages
            }));
            openDrop();
          }
          if (_onFocus)
            _onFocus(event);
        }
      },
      onBlur: function onBlur(event) {
        if (!event.relatedTarget || event.relatedTarget !== dropRef.current) {
          setFocus(false);
          if (_onBlur)
            _onBlur(event);
        }
      },
      onChange: readOnly ? void 0 : function(event) {
        if (suggestions && focus && !showDrop) {
          openDrop();
        }
        setValue3(event.target.value);
        setActiveSuggestionIndex(resetSuggestionIndex);
        if (onChange2)
          onChange2(event);
      }
    }))), drop);
  });
  TextInput.displayName = "TextInput";
  TextInput.propTypes = TextInputPropTypes;

  // node_modules/grommet/es6/components/FormField/propTypes.js
  var import_prop_types22 = __toESM(require_prop_types());
  var PropType20 = {};
  if (true) {
    PropType20 = {
      a11yTitle: import_prop_types22.default.string,
      component: import_prop_types22.default.oneOfType([import_prop_types22.default.func, import_prop_types22.default.object]),
      contentProps: import_prop_types22.default.object,
      disabled: import_prop_types22.default.bool,
      error: import_prop_types22.default.oneOfType([import_prop_types22.default.string, import_prop_types22.default.node]),
      help: import_prop_types22.default.oneOfType([import_prop_types22.default.string, import_prop_types22.default.node]),
      htmlFor: import_prop_types22.default.string,
      info: import_prop_types22.default.oneOfType([import_prop_types22.default.string, import_prop_types22.default.node]),
      label: import_prop_types22.default.oneOfType([import_prop_types22.default.string, import_prop_types22.default.node]),
      name: import_prop_types22.default.string,
      margin: marginProp,
      pad: import_prop_types22.default.bool,
      required: import_prop_types22.default.oneOfType([import_prop_types22.default.bool, import_prop_types22.default.shape({
        indicator: import_prop_types22.default.bool
      })]),
      validate: import_prop_types22.default.oneOfType([import_prop_types22.default.shape({
        regexp: import_prop_types22.default.instanceOf(RegExp),
        // regular expression
        message: import_prop_types22.default.oneOfType([import_prop_types22.default.string, import_prop_types22.default.node]),
        status: import_prop_types22.default.oneOf(["error", "info"])
      }), import_prop_types22.default.func, import_prop_types22.default.arrayOf(import_prop_types22.default.oneOfType([import_prop_types22.default.shape({
        regexp: import_prop_types22.default.instanceOf(RegExp),
        // regular expression
        message: import_prop_types22.default.oneOfType([import_prop_types22.default.string, import_prop_types22.default.node]),
        status: import_prop_types22.default.oneOf(["error", "info"])
      }), import_prop_types22.default.func]))])
    };
  }
  var FormFieldPropTypes = PropType20;

  // node_modules/grommet/es6/components/FormField/FormField.js
  var _excluded21 = ["error", "info", "message", "type"];
  var _excluded25 = ["component", "disabled", "invalid", "name", "onChange"];
  var _excluded32 = ["children", "className", "component", "contentProps", "disabled", "error", "help", "htmlFor", "info", "label", "margin", "name", "onBlur", "onChange", "onFocus", "pad", "required", "style", "validate"];
  function _extends34() {
    _extends34 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends34.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose21(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var grommetInputNames = ["CheckBox", "CheckBoxGroup", "TextInput", "Select", "MaskedInput", "SelectMultiple", "TextArea", "DateInput", "FileInput", "RadioButtonGroup", "RangeInput", "RangeSelector", "StarRating", "ThumbsRating"];
  var grommetInputPadNames = ["CheckBox", "CheckBoxGroup", "RadioButtonGroup", "RangeInput", "RangeSelector"];
  var isGrommetInput = function isGrommetInput2(comp) {
    return comp && (grommetInputNames.indexOf(comp.displayName) !== -1 || grommetInputPadNames.indexOf(comp.displayName) !== -1);
  };
  var FormFieldBox = (0, import_styled_components37.default)(Box).withConfig({
    displayName: "FormField__FormFieldBox",
    componentId: "sc-m9hood-0"
  })(["", " ", ""], function(props) {
    return props.focus && focusStyle({
      justBorder: true
    });
  }, function(props) {
    return props.theme.formField && props.theme.formField.extend;
  });
  var FormFieldContentBox = (0, import_styled_components37.default)(Box).withConfig({
    displayName: "FormField__FormFieldContentBox",
    componentId: "sc-m9hood-1"
  })(["", ""], function(props) {
    return props.focus && focusStyle({
      justBorder: true
    });
  });
  var StyledMessageContainer = (0, import_styled_components37.default)(Box).withConfig({
    displayName: "FormField__StyledMessageContainer",
    componentId: "sc-m9hood-2"
  })(["", ""], function(props) {
    return props.messageType && props.theme.formField[props.messageType].container && props.theme.formField[props.messageType].container.extend;
  });
  var RequiredText = (0, import_styled_components37.default)(Text).withConfig({
    displayName: "FormField__RequiredText",
    componentId: "sc-m9hood-3"
  })(["color:inherit;font-weight:inherit;line-height:inherit;"]);
  var ScreenReaderOnly = (0, import_styled_components37.default)(Text).withConfig({
    displayName: "FormField__ScreenReaderOnly",
    componentId: "sc-m9hood-4"
  })(["position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0;"]);
  var Message = function Message2(_ref) {
    var error2 = _ref.error, info = _ref.info, message = _ref.message, type = _ref.type, rest = _objectWithoutPropertiesLoose21(_ref, _excluded21);
    var theme = (0, import_react43.useContext)(import_styled_components37.ThemeContext) || defaultProps2.theme;
    if (message) {
      var icon;
      var containerProps;
      if (type) {
        icon = theme.formField[type] && theme.formField[type].icon;
        containerProps = theme.formField[type] && theme.formField[type].container;
      }
      var messageContent;
      if (typeof message === "string")
        messageContent = /* @__PURE__ */ import_react43.default.createElement(Text, rest, message);
      else
        messageContent = /* @__PURE__ */ import_react43.default.createElement(Box, rest, message);
      return icon || containerProps ? /* @__PURE__ */ import_react43.default.createElement(StyledMessageContainer, _extends34({
        direction: "row",
        messageType: type
      }, containerProps), icon && /* @__PURE__ */ import_react43.default.createElement(Box, {
        flex: false
      }, icon), messageContent) : messageContent;
    }
    return null;
  };
  var Input = function Input2(_ref2) {
    var component = _ref2.component, disabled = _ref2.disabled, invalid = _ref2.invalid, name = _ref2.name, _onChange = _ref2.onChange, rest = _objectWithoutPropertiesLoose21(_ref2, _excluded25);
    var formContext = (0, import_react43.useContext)(FormContext);
    var _formContext$useFormI = formContext.useFormInput({
      name,
      value: rest.value
    }), value = _formContext$useFormI[0], setValue3 = _formContext$useFormI[1];
    var InputComponent = component || TextInput;
    var extraProps = isGrommetInput(InputComponent) ? {
      focusIndicator: false,
      onChange: _onChange,
      plain: true
    } : {
      value,
      onChange: function onChange2(event) {
        setValue3(event.value !== void 0 ? event.value : event.target.value);
        if (_onChange)
          _onChange(event);
      }
    };
    return /* @__PURE__ */ import_react43.default.createElement(InputComponent, _extends34({
      name,
      disabled,
      "aria-invalid": invalid || void 0
    }, rest, extraProps));
  };
  var useDebounce = function useDebounce2() {
    var _useState = (0, import_react43.useState)(), func = _useState[0], setFunc3 = _useState[1];
    var theme = (0, import_react43.useContext)(import_styled_components37.ThemeContext) || defaultProps2.theme;
    (0, import_react43.useEffect)(function() {
      var timer;
      if (func)
        timer = setTimeout(function() {
          return func();
        }, theme.global.debounceDelay);
      return function() {
        return clearTimeout(timer);
      };
    }, [func, theme.global.debounceDelay]);
    return setFunc3;
  };
  var FormField = /* @__PURE__ */ (0, import_react43.forwardRef)(function(_ref3, ref) {
    var children = _ref3.children, className = _ref3.className, component = _ref3.component, contentProps = _ref3.contentProps, disabled = _ref3.disabled, errorProp = _ref3.error, help = _ref3.help, htmlFor = _ref3.htmlFor, infoProp = _ref3.info, label = _ref3.label, margin = _ref3.margin, name = _ref3.name, _onBlur = _ref3.onBlur, onChange2 = _ref3.onChange, _onFocus = _ref3.onFocus, pad = _ref3.pad, required = _ref3.required, style = _ref3.style, validate3 = _ref3.validate, rest = _objectWithoutPropertiesLoose21(_ref3, _excluded32);
    var theme = (0, import_react43.useContext)(import_styled_components37.ThemeContext) || defaultProps2.theme;
    var formContext = (0, import_react43.useContext)(FormContext);
    var _formContext$useFormF = formContext.useFormField({
      disabled,
      error: errorProp,
      info: infoProp,
      name,
      required,
      validate: validate3
    }), error2 = _formContext$useFormF.error, info = _formContext$useFormF.info, inForm = _formContext$useFormF.inForm, contextOnBlur = _formContext$useFormF.onBlur, contextOnChange = _formContext$useFormF.onChange;
    var formKind = formContext.kind;
    var _useState2 = (0, import_react43.useState)(), focus = _useState2[0], setFocus = _useState2[1];
    var formFieldRef = useForwardedRef(ref);
    var formFieldTheme = theme.formField;
    var themeBorder = formFieldTheme.border;
    var debounce3 = useDebounce();
    var portalContext = (0, import_react43.useContext)(PortalContext);
    var wantContentPad = component && (component === CheckBox || component === CheckBoxGroup || component === RadioButtonGroup);
    var contents = themeBorder && children && import_react43.Children.map(children, function(child) {
      if (child && child.type && grommetInputPadNames.indexOf(child.type.displayName) !== -1) {
        wantContentPad = true;
      }
      if (child && child.type && grommetInputNames.indexOf(child.type.displayName) !== -1 && child.props.plain === void 0 && child.props.focusIndicator === void 0) {
        var _formFieldTheme$check;
        return /* @__PURE__ */ (0, import_react43.cloneElement)(child, {
          plain: true,
          focusIndicator: false,
          pad: "CheckBox".indexOf(child.type.displayName) !== -1 ? formFieldTheme == null ? void 0 : (_formFieldTheme$check = formFieldTheme.checkBox) == null ? void 0 : _formFieldTheme$check.pad : void 0
        });
      }
      return child;
    }) || children;
    var containerRest = rest;
    if (inForm) {
      if (!contents)
        containerRest = {};
      contents = contents || /* @__PURE__ */ import_react43.default.createElement(Input, _extends34({
        component,
        disabled,
        invalid: !!error2,
        name,
        label: component === CheckBox ? label : void 0
      }, rest));
    }
    var themeContentProps = _extends34({}, formFieldTheme.content);
    if (!pad && !wantContentPad) {
      themeContentProps.pad = void 0;
    }
    if (themeBorder && themeBorder.position === "inner") {
      if (error2 && formFieldTheme.error) {
        themeContentProps.background = formFieldTheme.error.background;
      } else if (disabled && formFieldTheme.disabled) {
        themeContentProps.background = formFieldTheme.disabled.background;
      }
    }
    var isFileInputComponent;
    if (children && import_react43.Children.forEach(children, function(child) {
      if (child && child.type && "FileInput".indexOf(child.type.displayName) !== -1)
        isFileInputComponent = true;
    }))
      ;
    if (component && component.displayName === "FileInput" && !isFileInputComponent) {
      isFileInputComponent = true;
    }
    if (!themeBorder) {
      contents = /* @__PURE__ */ import_react43.default.createElement(Box, _extends34({}, themeContentProps, contentProps), contents);
    }
    var borderColor;
    if (disabled && formFieldTheme.disabled.border && formFieldTheme.disabled.border.color) {
      borderColor = formFieldTheme.disabled.border.color;
    } else if (
      // backward compatibility check
      error2 && themeBorder && themeBorder.error.color || error2 && formFieldTheme.error && formFieldTheme.error.border
    ) {
      if (themeBorder.error.color && formFieldTheme.error.border === void 0) {
        borderColor = themeBorder.error.color || "status-critical";
      } else if (formFieldTheme.error.border && formFieldTheme.error.border.color) {
        borderColor = formFieldTheme.error.border.color || "status-critical";
      }
    } else if (focus && formFieldTheme.focus && formFieldTheme.focus.border && formFieldTheme.focus.border.color) {
      borderColor = formFieldTheme.focus.border.color;
    } else {
      borderColor = themeBorder && themeBorder.color || "border";
    }
    var labelStyle;
    if (formKind) {
      labelStyle = _extends34({}, formFieldTheme[formKind].label);
    } else
      labelStyle = _extends34({}, formFieldTheme.label);
    if (disabled) {
      labelStyle.color = formFieldTheme.disabled && formFieldTheme.disabled.label ? formFieldTheme.disabled.label.color : labelStyle.color;
    }
    var abut;
    var abutMargin;
    var outerStyle = style;
    if (themeBorder) {
      var innerProps = themeBorder.position === "inner" ? {
        border: _extends34({}, themeBorder, {
          size: isFileInputComponent ? theme.fileInput.border.size : void 0,
          style: isFileInputComponent ? theme.fileInput.border.style : void 0,
          side: isFileInputComponent ? theme.fileInput.border.side : themeBorder.side || "bottom",
          color: borderColor
        }),
        round: formFieldTheme.round,
        focus: isFileInputComponent ? void 0 : focus
      } : {};
      contents = /* @__PURE__ */ import_react43.default.createElement(FormFieldContentBox, _extends34({}, themeContentProps, innerProps, contentProps), contents);
      var mergedMargin = margin || formFieldTheme.margin;
      abut = themeBorder.position === "outer" && (themeBorder.side === "all" || themeBorder.side === "horizontal" || !themeBorder.side) && !(mergedMargin && (typeof mergedMargin === "string" && mergedMargin !== "none" || mergedMargin.bottom && mergedMargin.bottom !== "none" || mergedMargin.horizontal && mergedMargin.horizontal !== "none"));
      if (abut) {
        abutMargin = {
          bottom: "-1px"
        };
        if (margin) {
          abutMargin = margin;
        } else if (themeBorder.size) {
          abutMargin = {
            bottom: "-" + parseMetricToNum(theme.global.borderSize[themeBorder.size] || themeBorder.size) + "px"
          };
        }
        outerStyle = _extends34({
          position: focus ? "relative" : void 0,
          zIndex: focus ? 10 : void 0
        }, style);
      }
    }
    var outerBackground;
    if (themeBorder && themeBorder.position === "outer") {
      if (error2 && formFieldTheme.error && formFieldTheme.error.background) {
        outerBackground = formFieldTheme.error.background;
      } else if (focus && formFieldTheme.focus && formFieldTheme.focus.background && formFieldTheme.focus.background.color) {
        outerBackground = formFieldTheme.focus.background.color;
      } else if (disabled && formFieldTheme.disabled && formFieldTheme.disabled.background) {
        outerBackground = formFieldTheme.disabled.background;
      }
    }
    var outerProps = themeBorder && themeBorder.position === "outer" ? {
      border: _extends34({}, themeBorder, {
        color: borderColor
      }),
      round: formFieldTheme.round,
      focus
    } : {};
    var requiredIndicator = theme.formField.label.requiredIndicator;
    if (requiredIndicator === true)
      requiredIndicator = /* @__PURE__ */ import_react43.default.createElement(import_react43.default.Fragment, null, /* @__PURE__ */ import_react43.default.createElement(RequiredText, {
        "aria-hidden": "true"
      }, "*"), /* @__PURE__ */ import_react43.default.createElement(ScreenReaderOnly, null, "required"));
    var showRequiredIndicator = required && requiredIndicator;
    if (typeof required === "object" && required.indicator === false)
      showRequiredIndicator = false;
    return /* @__PURE__ */ import_react43.default.createElement(FormFieldBox, _extends34({
      ref: formFieldRef,
      className,
      flex: false,
      background: outerBackground,
      margin: abut ? abutMargin : margin || _extends34({}, formFieldTheme.margin)
    }, outerProps, {
      style: outerStyle,
      onFocus: function onFocus(event) {
        var _formFieldRef$current;
        var root = (_formFieldRef$current = formFieldRef.current) == null ? void 0 : _formFieldRef$current.getRootNode();
        if (root) {
          setFocus(containsFocus(formFieldRef.current) && shouldKeepFocus(root));
        }
        if (_onFocus)
          _onFocus(event);
      },
      onBlur: function onBlur(event) {
        setFocus(false);
        if (contextOnBlur && !formFieldRef.current.contains(event.relatedTarget) && !withinDropPortal(event.relatedTarget, portalContext)) {
          contextOnBlur(event);
        }
        if (_onBlur)
          _onBlur(event);
      },
      onChange: contextOnChange || onChange2 ? function(event) {
        event.persist();
        if (onChange2)
          onChange2(event);
        if (contextOnChange)
          debounce3(function() {
            return function() {
              return contextOnChange(event);
            };
          });
      } : void 0
    }, containerRest), label && component !== CheckBox || help ? /* @__PURE__ */ import_react43.default.createElement(import_react43.default.Fragment, null, label && component !== CheckBox && /* @__PURE__ */ import_react43.default.createElement(Text, _extends34({
      as: "label",
      htmlFor
    }, labelStyle), label, showRequiredIndicator ? requiredIndicator : void 0), /* @__PURE__ */ import_react43.default.createElement(Message, _extends34({
      message: help
    }, formFieldTheme.help))) : void 0, contents, /* @__PURE__ */ import_react43.default.createElement(Message, _extends34({
      type: "error",
      message: error2
    }, formFieldTheme.error)), /* @__PURE__ */ import_react43.default.createElement(Message, _extends34({
      type: "info",
      message: info
    }, formFieldTheme.info)));
  });
  FormField.displayName = "FormField";
  FormField.propTypes = FormFieldPropTypes;

  // node_modules/grommet/es6/components/RangeSelector/RangeSelector.js
  var import_react45 = __toESM(require_react());
  var import_styled_components39 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/RangeSelector/EdgeControl.js
  var import_react44 = __toESM(require_react());
  var import_styled_components38 = __toESM(require_styled_components_browser_cjs());
  var _excluded26 = ["color", "direction", "edge", "onDecrease", "onIncrease", "thickness"];
  function _extends35() {
    _extends35 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends35.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose22(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var DIRECTION_PROPS = {
    horizontal: {
      cursor: "col-resize",
      fill: "vertical"
    },
    vertical: {
      cursor: "row-resize",
      fill: "horizontal"
    }
  };
  var StyledBox2 = (0, import_styled_components38.default)(Box).withConfig({
    displayName: "EdgeControl__StyledBox",
    componentId: "sc-1xo2yt9-0"
  })(["", ""], function(props) {
    return props.focus && focusStyle();
  });
  var EdgeControl = /* @__PURE__ */ (0, import_react44.forwardRef)(function(_ref, ref) {
    var color = _ref.color, direction = _ref.direction, edge = _ref.edge, onDecrease = _ref.onDecrease, onIncrease = _ref.onIncrease, thickness = _ref.thickness, rest = _objectWithoutPropertiesLoose22(_ref, _excluded26);
    var theme = (0, import_react44.useContext)(import_styled_components38.ThemeContext);
    var _useState = (0, import_react44.useState)(false), focus = _useState[0], setFocus = _useState[1];
    var _DIRECTION_PROPS$dire = DIRECTION_PROPS[direction], cursor = _DIRECTION_PROPS$dire.cursor, fill = _DIRECTION_PROPS$dire.fill;
    var size = parseMetricToNum(theme.global.spacing) / 2;
    var keyboardProps = direction === "vertical" ? {
      onUp: onDecrease,
      onDown: onIncrease
    } : {
      onLeft: onDecrease,
      onRight: onIncrease
    };
    var boxDirection = direction === "vertical" ? "row" : "column";
    var type = theme.rangeSelector && theme.rangeSelector.edge && theme.rangeSelector.edge.type || "disc";
    var node;
    var backgroundColor = normalizeColor(color || "control", theme);
    if (type === "bar") {
      node = /* @__PURE__ */ import_react44.default.createElement(StyledBox2, {
        flex: !thickness,
        justifySelf: "stretch",
        width: direction === "vertical" ? thickness : size + "px",
        height: direction === "vertical" ? size + "px" : thickness,
        background: backgroundColor,
        focus
      });
    } else if (type === "disc") {
      node = /* @__PURE__ */ import_react44.default.createElement(StyledBox2, {
        width: size + "px",
        height: size + "px",
        round: "full",
        background: backgroundColor,
        focus
      });
    } else {
      node = type;
    }
    return /* @__PURE__ */ import_react44.default.createElement(Keyboard, keyboardProps, /* @__PURE__ */ import_react44.default.createElement(Box, {
      direction: boxDirection,
      style: {
        flex: "0 0 1px"
      },
      overflow: "visible",
      align: "center",
      justify: "center",
      alignSelf: "stretch"
    }, /* @__PURE__ */ import_react44.default.createElement(Box, _extends35({
      ref,
      direction: boxDirection,
      justify: "center",
      align: "center",
      basis: "full",
      fill,
      style: {
        cursor,
        outline: "none",
        minWidth: size,
        minHeight: size,
        zIndex: 1
      },
      tabIndex: 0,
      onFocus: function onFocus() {
        return setFocus(true);
      },
      onBlur: function onBlur() {
        return setFocus(false);
      }
    }, rest), node)));
  });
  EdgeControl.displayName = "EdgeControl";
  EdgeControl.defaultProps = {};
  Object.setPrototypeOf(EdgeControl.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/RangeSelector/propTypes.js
  var import_prop_types23 = __toESM(require_prop_types());
  var PropType21 = {};
  if (true) {
    PropType21 = {
      color: colorPropType,
      defaultValues: import_prop_types23.default.arrayOf(import_prop_types23.default.number),
      direction: import_prop_types23.default.oneOf(["horizontal", "vertical"]),
      invert: import_prop_types23.default.bool,
      label: import_prop_types23.default.oneOfType([import_prop_types23.default.bool, import_prop_types23.default.func]),
      max: import_prop_types23.default.number,
      messages: import_prop_types23.default.shape({
        lower: import_prop_types23.default.string,
        upper: import_prop_types23.default.string
      }),
      min: import_prop_types23.default.number,
      onChange: import_prop_types23.default.func,
      opacity: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf(["weak", "medium", "strong"]), import_prop_types23.default.string, import_prop_types23.default.bool]),
      round: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf(["xsmall", "small", "medium", "large", "full"]), import_prop_types23.default.string]),
      size: import_prop_types23.default.oneOfType([import_prop_types23.default.oneOf(["xxsmall", "xsmall", "small", "medium", "large", "xlarge", "full"]), import_prop_types23.default.string]),
      step: import_prop_types23.default.number,
      values: import_prop_types23.default.arrayOf(import_prop_types23.default.number)
    };
  }
  var RangeSelectorPropTypes = PropType21;

  // node_modules/grommet/es6/components/RangeSelector/RangeSelector.js
  var _excluded27 = ["color", "defaultValues", "direction", "invert", "label", "max", "messages", "min", "name", "onChange", "opacity", "round", "size", "step", "values"];
  function _extends36() {
    _extends36 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends36.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose23(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Container = (0, import_styled_components39.default)(Box).withConfig({
    displayName: "RangeSelector__Container",
    componentId: "sc-siof5p-0"
  })(["user-select:none;"]);
  var RangeSelector = /* @__PURE__ */ (0, import_react45.forwardRef)(function(_ref, ref) {
    var color = _ref.color, _ref$defaultValues = _ref.defaultValues, defaultValues = _ref$defaultValues === void 0 ? [] : _ref$defaultValues, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? "horizontal" : _ref$direction, invert = _ref.invert, label = _ref.label, _ref$max = _ref.max, max2 = _ref$max === void 0 ? 100 : _ref$max, messages = _ref.messages, _ref$min = _ref.min, min2 = _ref$min === void 0 ? 0 : _ref$min, name = _ref.name, onChange2 = _ref.onChange, _ref$opacity = _ref.opacity, opacity = _ref$opacity === void 0 ? "medium" : _ref$opacity, round2 = _ref.round, _ref$size = _ref.size, size = _ref$size === void 0 ? "medium" : _ref$size, _ref$step = _ref.step, step = _ref$step === void 0 ? 1 : _ref$step, valuesProp = _ref.values, rest = _objectWithoutPropertiesLoose23(_ref, _excluded27);
    var theme = (0, import_react45.useContext)(import_styled_components39.ThemeContext) || defaultProps.theme;
    var _useContext = (0, import_react45.useContext)(MessageContext), format4 = _useContext.format;
    var formContext = (0, import_react45.useContext)(FormContext);
    var _useState = (0, import_react45.useState)(), changing = _useState[0], setChanging = _useState[1];
    var _useState2 = (0, import_react45.useState)(), lastChange = _useState2[0], setLastChange = _useState2[1];
    var _useState3 = (0, import_react45.useState)(), moveValue = _useState3[0], setMoveValue = _useState3[1];
    var containerRef = (0, import_react45.useRef)();
    var maxRef = (0, import_react45.useRef)();
    var minRef = (0, import_react45.useRef)();
    var labelWidthRef = (0, import_react45.useRef)(0);
    var _formContext$useFormI = formContext.useFormInput({
      name,
      // ensure values are within min/max
      value: valuesProp == null ? void 0 : valuesProp.map(function(n) {
        return Math.min(max2, Math.max(min2, n));
      }),
      initialValue: defaultValues
    }), values = _formContext$useFormI[0], setValues = _formContext$useFormI[1];
    var change = (0, import_react45.useCallback)(function(nextValues) {
      setValues(nextValues);
      if (onChange2)
        onChange2(nextValues);
    }, [onChange2, setValues]);
    var valueForMouseCoord = (0, import_react45.useCallback)(function(event) {
      var rect = containerRef.current.getBoundingClientRect();
      var value;
      if (direction === "vertical") {
        var y = event.clientY - (rect.top || 0);
        var scaleY = rect.height / (max2 - min2 + 1) || 1;
        value = Math.floor(y / scaleY) + min2;
      } else {
        var x = event.clientX - (rect.left || 0);
        var scaleX = rect.width / (max2 - min2 + 1) || 1;
        value = Math.floor(x / scaleX) + min2;
      }
      var result = Math.ceil(value / step) * step;
      if (result < min2) {
        return min2;
      }
      if (result > max2) {
        return max2;
      }
      return result;
    }, [direction, max2, min2, step]);
    var onMouseMove = (0, import_react45.useCallback)(function(event) {
      var value = valueForMouseCoord(event);
      var nextValues;
      if (changing === "lower" && value <= values[1] && value !== moveValue) {
        nextValues = [value, values[1]];
      } else if (changing === "upper" && value >= values[0] && value !== moveValue) {
        nextValues = [values[0], value];
      } else if (changing === "selection" && value !== moveValue) {
        if (value === max2) {
          nextValues = [max2 - (values[1] - values[0]), max2];
        } else if (value === min2) {
          nextValues = [min2, min2 + (values[1] - values[0])];
        } else {
          var delta = value - moveValue;
          if (values[0] + delta >= min2 && values[1] + delta <= max2) {
            nextValues = [values[0] + delta, values[1] + delta];
          }
        }
      }
      if (nextValues) {
        setMoveValue(value);
        change(nextValues);
      }
    }, [values, change, changing, moveValue, max2, min2, setMoveValue, valueForMouseCoord]);
    (0, import_react45.useEffect)(function() {
      var onMouseUp = function onMouseUp2() {
        return setChanging(void 0);
      };
      if (changing) {
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("mouseup", onMouseUp);
        return function() {
          window.removeEventListener("mousemove", onMouseMove);
          window.removeEventListener("mouseup", onMouseUp);
        };
      }
      return void 0;
    }, [changing, onMouseMove]);
    var onClick = (0, import_react45.useCallback)(function(event) {
      var value = valueForMouseCoord(event);
      if (value <= values[0] || value < values[1] && lastChange === "lower") {
        setLastChange("lower");
        change([value, values[1]]);
      } else if (value >= values[1] || value > values[0] && lastChange === "upper") {
        setLastChange("upper");
        change([values[0], value]);
      }
    }, [change, lastChange, valueForMouseCoord, values]);
    var onTouchMove = (0, import_react45.useCallback)(function(event) {
      var touchEvent = event.changedTouches[0];
      onMouseMove(touchEvent);
    }, [onMouseMove]);
    useLayoutEffect(function() {
      if (maxRef.current && minRef.current) {
        maxRef.current.style.width = "";
        minRef.current.style.width = "";
        var width = Math.max(labelWidthRef.current, maxRef.current.getBoundingClientRect().width, minRef.current.getBoundingClientRect().width);
        maxRef.current.style.width = width + "px";
        minRef.current.style.width = width + "px";
        labelWidthRef.current = width;
      }
    });
    var lower = values[0], upper = values[1];
    var thickness = size === "full" ? void 0 : parseMetricToNum(theme.global.edgeSize[size] || size) + "px";
    var layoutProps = {
      fill: direction,
      round: round2
    };
    if (direction === "vertical")
      layoutProps.width = thickness;
    else
      layoutProps.height = thickness;
    if (size === "full")
      layoutProps.alignSelf = "stretch";
    var content = /* @__PURE__ */ import_react45.default.createElement(Container, _extends36({
      ref: containerRef,
      direction: direction === "vertical" ? "column" : "row",
      align: "center",
      fill: true
    }, label ? {} : rest, {
      tabIndex: "-1",
      onClick,
      onTouchMove
    }), /* @__PURE__ */ import_react45.default.createElement(Box, _extends36({
      style: {
        flex: lower - min2 + " 0 0"
      },
      background: invert ? (
        // preserve existing dark, instead of using darknes
        // of this color
        {
          color: color || theme.rangeSelector.background.invert.color,
          opacity,
          dark: theme.dark
        }
      ) : void 0
    }, layoutProps)), /* @__PURE__ */ import_react45.default.createElement(EdgeControl, {
      a11yTitle: format4({
        id: "rangeSelector.lower",
        messages
      }),
      role: "slider",
      "aria-valuenow": lower,
      "aria-valuemin": min2,
      "aria-valuemax": max2,
      tabIndex: 0,
      ref,
      color,
      direction,
      thickness,
      edge: "lower",
      onMouseDown: function onMouseDown() {
        return setChanging("lower");
      },
      onTouchStart: function onTouchStart() {
        return setChanging("lower");
      },
      onDecrease: lower - step >= min2 ? function() {
        return change([lower - step, upper]);
      } : void 0,
      onIncrease: lower + step <= upper ? function() {
        return change([lower + step, upper]);
      } : void 0
    }), /* @__PURE__ */ import_react45.default.createElement(Box, _extends36({
      style: {
        flex: upper - lower + 1 + " 0 0",
        cursor: direction === "vertical" ? "ns-resize" : "ew-resize"
      },
      background: invert ? void 0 : (
        // preserve existing dark, instead of using darknes of
        // this color
        {
          color: color || "control",
          opacity,
          dark: theme.dark
        }
      )
    }, layoutProps, {
      onMouseDown: function onMouseDown(event) {
        var nextMoveValue = valueForMouseCoord(event);
        setChanging("selection");
        setMoveValue(nextMoveValue);
      }
    })), /* @__PURE__ */ import_react45.default.createElement(EdgeControl, {
      a11yTitle: format4({
        id: "rangeSelector.upper",
        messages
      }),
      role: "slider",
      "aria-valuenow": upper,
      "aria-valuemin": min2,
      "aria-valuemax": max2,
      tabIndex: 0,
      color,
      direction,
      thickness,
      edge: "upper",
      onMouseDown: function onMouseDown() {
        return setChanging("upper");
      },
      onTouchStart: function onTouchStart() {
        return setChanging("upper");
      },
      onDecrease: upper - step >= lower ? function() {
        return change([lower, upper - step]);
      } : void 0,
      onIncrease: upper + step <= max2 ? function() {
        return change([lower, upper + step]);
      } : void 0
    }), /* @__PURE__ */ import_react45.default.createElement(Box, _extends36({
      style: {
        flex: max2 - upper + " 0 0"
      },
      background: invert ? (
        // preserve existing dark, instead of using darknes of this
        // color
        {
          color: color || theme.rangeSelector.background.invert.color,
          opacity,
          dark: theme.dark
        }
      ) : void 0
    }, layoutProps, {
      round: round2
    })));
    if (label) {
      content = /* @__PURE__ */ import_react45.default.createElement(Box, _extends36({
        direction: direction === "vertical" ? "column" : "row",
        align: "center",
        fill: true
      }, rest), /* @__PURE__ */ import_react45.default.createElement(Text, {
        ref: minRef,
        textAlign: "end",
        size: "small",
        margin: {
          horizontal: "small"
        }
      }, typeof label === "function" ? label(lower) : lower), content, /* @__PURE__ */ import_react45.default.createElement(Text, {
        ref: maxRef,
        size: "small",
        margin: {
          horizontal: "small"
        }
      }, typeof label === "function" ? label(upper) : upper));
    }
    return content;
  });
  RangeSelector.displayName = "RangeSelector";
  RangeSelector.propTypes = RangeSelectorPropTypes;

  // node_modules/grommet/es6/components/SelectMultiple/SelectMultiple.js
  var import_react53 = __toESM(require_react());
  var import_styled_components42 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/DropButton/DropButton.js
  var import_react46 = __toESM(require_react());

  // node_modules/grommet/es6/components/DropButton/propTypes.js
  var import_prop_types24 = __toESM(require_prop_types());
  function _extends37() {
    _extends37 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends37.apply(this, arguments);
  }
  var PropType22 = {};
  if (true) {
    PropType22 = _extends37({}, genericProps, {
      disabled: import_prop_types24.default.bool,
      dropAlign: import_prop_types24.default.shape({
        top: import_prop_types24.default.oneOf(["top", "bottom"]),
        bottom: import_prop_types24.default.oneOf(["top", "bottom"]),
        right: import_prop_types24.default.oneOf(["left", "right"]),
        left: import_prop_types24.default.oneOf(["left", "right"])
      }),
      dropContent: import_prop_types24.default.element.isRequired,
      dropTarget: import_prop_types24.default.object,
      dropProps: import_prop_types24.default.object,
      onClose: import_prop_types24.default.func,
      onOpen: import_prop_types24.default.func,
      open: import_prop_types24.default.bool
    });
  }
  var DropButtonPropTypes = PropType22;

  // node_modules/grommet/es6/components/DropButton/DropButton.js
  var _excluded28 = ["a11yTitle", "onAlign", "disabled", "dropAlign", "dropProps", "dropContent", "dropTarget", "id", "open", "onClick", "onClose", "onOpen"];
  function _extends38() {
    _extends38 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends38.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose24(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var defaultDropAlign2 = {
    top: "top",
    left: "left"
  };
  var DropButton = /* @__PURE__ */ (0, import_react46.forwardRef)(function(_ref, ref) {
    var _ref$a11yTitle = _ref.a11yTitle, a11yTitle = _ref$a11yTitle === void 0 ? "Open Drop" : _ref$a11yTitle, onAlign = _ref.onAlign, disabled = _ref.disabled, _ref$dropAlign = _ref.dropAlign, dropAlign = _ref$dropAlign === void 0 ? defaultDropAlign2 : _ref$dropAlign, dropProps4 = _ref.dropProps, dropContent = _ref.dropContent, dropTarget = _ref.dropTarget, id = _ref.id, open = _ref.open, onClick = _ref.onClick, onClose = _ref.onClose, onOpen = _ref.onOpen, rest = _objectWithoutPropertiesLoose24(_ref, _excluded28);
    var buttonRef = useForwardedRef(ref);
    var _useState = (0, import_react46.useState)(), show = _useState[0], setShow = _useState[1];
    (0, import_react46.useEffect)(function() {
      if (open !== void 0 && open !== show) {
        setShow(open);
      }
    }, [open, show]);
    var onDropClose = (0, import_react46.useCallback)(function(event) {
      var node = event.target;
      while (node !== document && node !== buttonRef.current) {
        node = node.parentNode;
      }
      if (node !== buttonRef.current) {
        if (open === void 0)
          setShow(false);
        if (onClose)
          onClose(event);
      }
    }, [buttonRef, onClose, open]);
    var onClickInternal = (0, import_react46.useCallback)(function(event) {
      if (!show) {
        setShow(true);
        if (onOpen)
          onOpen(event);
      } else {
        setShow(false);
        if (onClose)
          onClose(event);
      }
      if (onClick)
        onClick(event);
    }, [onClick, onClose, onOpen, show]);
    return /* @__PURE__ */ import_react46.default.createElement(import_react46.default.Fragment, null, /* @__PURE__ */ import_react46.default.createElement(Button2, _extends38({
      id,
      ref: buttonRef,
      a11yTitle,
      disabled
    }, rest, {
      onClick: onClickInternal
    })), show && buttonRef.current && /* @__PURE__ */ import_react46.default.createElement(Drop, _extends38({
      id: id ? id + "__drop" : void 0,
      onAlign,
      restrictFocus: true,
      align: dropAlign,
      target: dropTarget || buttonRef,
      onClickOutside: onDropClose,
      onEsc: onDropClose
    }, dropProps4), dropContent));
  });
  DropButton.displayName = "DropButton";
  DropButton.propTypes = DropButtonPropTypes;

  // node_modules/grommet/es6/components/SelectMultiple/SelectMultipleValue.js
  var import_react48 = __toESM(require_react());

  // node_modules/grommet/es6/components/Select/StyledSelect.js
  var import_styled_components40 = __toESM(require_styled_components_browser_cjs());
  var StyledContainer2 = import_styled_components40.default.div.withConfig({
    displayName: "StyledSelect__StyledContainer",
    componentId: "sc-znp66n-0"
  })(["@media screen and (-ms-high-contrast:active),(-ms-high-contrast:none){width:100%;}", ";", ";"], function(props) {
    return props.dropHeight ? sizeStyle("max-height", props.dropHeight, props.theme) : "max-height: inherit;";
  }, function(props) {
    return props.theme.select.container && props.theme.select.container.extend;
  });
  var OptionsContainer = import_styled_components40.default.div.withConfig({
    displayName: "StyledSelect__OptionsContainer",
    componentId: "sc-znp66n-1"
  })(["position:relative;scroll-behavior:smooth;overflow:auto;outline:none;"]);
  var HiddenInput = import_styled_components40.default.input.withConfig({
    displayName: "StyledSelect__HiddenInput",
    componentId: "sc-znp66n-2"
  })(["display:none;"]);
  var SelectOption = (0, import_styled_components40.default)(Button2).withConfig({
    displayName: "StyledSelect__SelectOption",
    componentId: "sc-znp66n-3"
  })(["", " ", " &:focus{", "}display:block;width:100%;", ";"], function(props) {
    return props.selected && props.textComponent && selectedStyle;
  }, function(props) {
    return props.active && getHoverIndicatorStyle(!props.children && !props.theme.select.options ? void 0 : "background", props.theme);
  }, function(props) {
    return props.active && getHoverIndicatorStyle(!props.children && !props.theme.select.options ? void 0 : "background", props.theme);
  }, function(props) {
    return props["aria-disabled"] && "cursor: default";
  });
  var SelectTextInput = (0, import_styled_components40.default)(TextInput).withConfig({
    displayName: "StyledSelect__SelectTextInput",
    componentId: "sc-znp66n-4"
  })(["cursor:", ";"], function(props) {
    return props.defaultCursor ? "default" : "pointer";
  });
  var StyledSelectDropButton = (0, import_styled_components40.default)(DropButton).withConfig({
    displayName: "StyledSelect__StyledSelectDropButton",
    componentId: "sc-znp66n-5"
  })(["", ";", ";", ";"], function(props) {
    return !props.plainSelect && controlBorderStyle;
  }, function(props) {
    var _props$theme$select, _props$theme$select$c;
    return (_props$theme$select = props.theme.select) == null ? void 0 : (_props$theme$select$c = _props$theme$select.control) == null ? void 0 : _props$theme$select$c.extend;
  }, function(props) {
    var _props$theme$select2, _props$theme$select2$;
    return props.open && ((_props$theme$select2 = props.theme.select) == null ? void 0 : (_props$theme$select2$ = _props$theme$select2.control) == null ? void 0 : _props$theme$select2$.open);
  });

  // node_modules/grommet/es6/components/Select/utils.js
  var import_react47 = __toESM(require_react());
  var applyKey = function applyKey2(option, key) {
    if (option === void 0 || option === null)
      return void 0;
    if (typeof key === "object")
      return applyKey2(option, key.key);
    if (typeof key === "function")
      return key(option);
    if (key !== void 0 && typeof option === "object")
      return option[key];
    if (typeof option === "object" && Object.keys(option))
      return option[Object.keys(option)[0]];
    return option;
  };
  var getOptionLabel = function getOptionLabel2(index, options2, labelKey) {
    return applyKey(options2[index], labelKey);
  };
  var getOptionValue = function getOptionValue2(index, options2, valueKey) {
    return applyKey(options2[index], valueKey);
  };
  var getOptionIndex = function getOptionIndex2(options2, i, valueKey) {
    if (options2) {
      if (typeof i === "object")
        return options2.findIndex(function(x) {
          return applyKey(x, valueKey) === applyKey(i, valueKey);
        });
      return options2.indexOf(i);
    }
    return void 0;
  };
  var arrayIncludes = function arrayIncludes2(arr, i, valueKey) {
    if (arr) {
      if (typeof i === "object")
        return arr.some(function(x) {
          return applyKey(x, valueKey) === applyKey(i, valueKey);
        });
      return arr.includes(i);
    }
    return void 0;
  };
  var useDisabled = function useDisabled2(disabled, disabledKey, options2, valueKey) {
    return (0, import_react47.useCallback)(function(index) {
      var option = options2[index];
      var result;
      if (disabledKey) {
        result = applyKey(option, disabledKey);
      } else if (Array.isArray(disabled)) {
        if (typeof disabled[0] === "number") {
          result = disabled.indexOf(index) !== -1;
        } else {
          var optionVal = getOptionValue(index, options2, valueKey);
          result = getOptionIndex(disabled, options2[index], valueKey) !== -1 || getOptionIndex(disabled, optionVal, valueKey) !== -1;
        }
      }
      return result;
    }, [disabled, disabledKey, options2, valueKey]);
  };
  var getNormalizedValue = function getNormalizedValue2(value, valueKey) {
    if (Array.isArray(value))
      return value.map(function(v) {
        return valueKey && valueKey.reduce ? v : applyKey(v, valueKey);
      });
    return valueKey && valueKey.reduce ? value : applyKey(value, valueKey);
  };
  var changeEvent = function changeEvent2(inputRef, nextValue) {
    var nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value").set;
    nativeInputValueSetter.call(inputRef.current, nextValue);
    var event = new Event("input", {
      bubbles: true
    });
    inputRef.current.dispatchEvent(event);
  };
  var getSelectIcon = function getSelectIcon2(icon, theme, open) {
    var SelectIcon;
    switch (icon) {
      case false:
        break;
      case true:
      case void 0:
        SelectIcon = open && theme.select.icons.up ? theme.select.icons.up : theme.select.icons.down;
        break;
      default:
        SelectIcon = icon;
    }
    return SelectIcon;
  };
  var getDisplayLabelKey = function getDisplayLabelKey2(labelKey, allOptions, optionIndexesInValue, selectValue) {
    var optionLabelKey = applyKey(allOptions[optionIndexesInValue[0]], labelKey);
    if (!selectValue && optionIndexesInValue.length === 1 && typeof optionLabelKey === "object")
      return optionLabelKey;
    return void 0;
  };
  var getIconColor3 = function getIconColor4(theme) {
    return normalizeColor(theme.select.icons.color || "control", theme);
  };

  // node_modules/grommet/es6/components/SelectMultiple/SelectMultipleValue.js
  var SelectMultipleValue = function SelectMultipleValue2(_ref) {
    var allOptions = _ref.allOptions, children = _ref.children, disabled = _ref.disabled, disabledKey = _ref.disabledKey, dropButtonRef = _ref.dropButtonRef, labelKey = _ref.labelKey, onRequestOpen = _ref.onRequestOpen, onSelectChange = _ref.onSelectChange, theme = _ref.theme, value = _ref.value, valueKey = _ref.valueKey;
    var _useState = (0, import_react48.useState)(false), showA11yDiv = _useState[0], setShowA11yDiv = _useState[1];
    var isDisabled2 = useDisabled(disabled, disabledKey, allOptions, valueKey || labelKey);
    var visibleValue = (0, import_react48.useCallback)(function(i) {
      var optionValue = valueKey && valueKey.reduce ? applyKey(i, valueKey) : i;
      var optionSelected = arrayIncludes(value, optionValue, valueKey || labelKey);
      var indexOptions = getOptionIndex(allOptions, i, valueKey || labelKey);
      var optionLabel = getOptionLabel(indexOptions, allOptions, labelKey || valueKey);
      var optionDisabled = isDisabled2(indexOptions);
      var valueIndex = getOptionIndex(value, optionValue, valueKey || labelKey);
      if (valueIndex < theme.selectMultiple.maxInline) {
        var child;
        if (children) {
          child = children(i, indexOptions, allOptions, {
            active: false,
            disabled: optionDisabled,
            selected: true
          });
        }
        return /* @__PURE__ */ import_react48.default.createElement(SelectOption, {
          role: "option",
          a11yTitle: optionSelected ? optionLabel + " selected" : optionLabel + " not selected",
          "aria-setsize": value.length,
          "aria-posinset": valueIndex + 1,
          "aria-selected": optionSelected,
          "aria-disabled": optionDisabled,
          plain: true,
          hoverIndicator: !optionDisabled,
          fill: "horizontal",
          tabIndex: "0",
          onClick: function onClick(event) {
            if (!optionDisabled) {
              var intermediate = [].concat(value);
              if (arrayIncludes(intermediate, optionValue, valueKey || labelKey)) {
                onSelectChange(event, {
                  option: optionValue,
                  value: intermediate.filter(function(v) {
                    return typeof v === "object" ? applyKey(v, valueKey || labelKey) === applyKey(optionValue, valueKey || labelKey) : v !== optionValue;
                  })
                });
                if (valueIndex !== intermediate.length - 1) {
                  setTimeout(function() {
                    var nextFocus = document.getElementById("selected-" + intermediate[valueIndex + 1]);
                    if (nextFocus)
                      nextFocus.focus();
                    var result = intermediate[valueIndex + 1];
                    setShowA11yDiv("Unselected " + optionLabel + ". \n                        Focus moved to " + getOptionLabel(getOptionIndex(allOptions, result, valueKey || labelKey), allOptions, labelKey || valueKey));
                  }, 200);
                } else if (intermediate.length !== 1) {
                  setTimeout(function() {
                    var nextFocus = document.getElementById("selected-" + intermediate[valueIndex - 1]);
                    if (nextFocus)
                      nextFocus.focus();
                    var result = intermediate[valueIndex - 1];
                    setShowA11yDiv("Unselected " + optionLabel + ". Focus moved to \n                          " + getOptionLabel(getOptionIndex(allOptions, result, valueKey || labelKey), allOptions, labelKey || valueKey));
                  }, 200);
                } else if (dropButtonRef.current)
                  dropButtonRef.current.focus();
              }
            }
          },
          key: optionLabel,
          id: "selected-" + optionValue
        }, child || /* @__PURE__ */ import_react48.default.createElement(CheckBox, {
          disabled: optionDisabled,
          label: /* @__PURE__ */ import_react48.default.createElement(Box, {
            alignSelf: "center",
            align: "start"
          }, optionLabel),
          key: optionLabel,
          pad: "xsmall",
          tabIndex: "-1",
          checked: optionSelected
        }));
      }
      return void 0;
    }, [valueKey, allOptions, children, dropButtonRef, isDisabled2, labelKey, onSelectChange, value, theme.selectMultiple.maxInline]);
    (0, import_react48.useEffect)(function() {
      if (showA11yDiv !== void 0) {
        setTimeout(function() {
          setShowA11yDiv(void 0);
        }, 1e3);
      }
    }, [showA11yDiv]);
    return /* @__PURE__ */ import_react48.default.createElement(import_react48.default.Fragment, null, /* @__PURE__ */ import_react48.default.createElement(Box, {
      width: "100%",
      role: "listbox",
      "aria-multiselectable": true,
      a11yTitle: "Selected Options"
    }, value && allOptions.filter(function(i) {
      return arrayIncludes(value, valueKey && valueKey.reduce ? applyKey(i, valueKey) : i, valueKey || labelKey);
    }).map(function(i) {
      return visibleValue(i);
    }), showA11yDiv && /* @__PURE__ */ import_react48.default.createElement(Box, {
      height: "0px",
      width: "0px",
      overflow: "hidden",
      "aria-live": "assertive",
      role: "alert"
    }, showA11yDiv)), value && value.length > theme.selectMultiple.maxInline && /* @__PURE__ */ import_react48.default.createElement(Box, {
      pad: {
        horizontal: "small",
        bottom: "small",
        top: "xsmall"
      },
      alignSelf: "start"
    }, /* @__PURE__ */ import_react48.default.createElement(Button2, {
      onClick: onRequestOpen,
      size: "small",
      label: "+ " + (value.length - theme.selectMultiple.maxInline) + " more"
    })));
  };

  // node_modules/grommet/es6/components/SelectMultiple/SelectMultipleContainer.js
  var import_react51 = __toESM(require_react());
  var import_styled_components41 = __toESM(require_styled_components_browser_cjs());
  var import_FormUp2 = __toESM(require_FormUp());

  // node_modules/grommet/es6/components/SelectMultiple/SelectionSummary.js
  var import_react49 = __toESM(require_react());
  var SelectionSummary = function SelectionSummary2(_ref) {
    var allOptions = _ref.allOptions, clearRef = _ref.clearRef, disabled = _ref.disabled, disabledKey = _ref.disabledKey, isSelected = _ref.isSelected, labelKey = _ref.labelKey, limit = _ref.limit, onChange2 = _ref.onChange, onMore = _ref.onMore, options2 = _ref.options, search = _ref.search, setActiveIndex = _ref.setActiveIndex, showSelectedInline = _ref.showSelectedInline, value = _ref.value, valueKey = _ref.valueKey;
    var isDisabled2 = useDisabled(disabled, disabledKey, options2, valueKey || labelKey);
    var selectedValuesDisabled = (0, import_react49.useCallback)(function() {
      var disabledSelected = 0;
      if (value) {
        for (var i = 0; i < allOptions.length; i += 1) {
          if (arrayIncludes(value, getOptionValue(i, options2, valueKey || labelKey), valueKey || labelKey) && isDisabled2(i))
            disabledSelected += 1;
        }
        if (value.length === disabledSelected)
          return true;
      }
      return false;
    }, [value, allOptions, options2, valueKey, labelKey, isDisabled2]);
    var selectedInSearch = (0, import_react49.useCallback)(function() {
      return options2 == null ? void 0 : options2.filter(function(option) {
        return arrayIncludes(value, option, valueKey || labelKey);
      });
    }, [options2, value, valueKey, labelKey]);
    var showSelectAll = !!((value == null ? void 0 : value.length) === 0 || selectedValuesDisabled() || !value || selectedInSearch().length === 0);
    var summaryText = (value == null ? void 0 : value.length) === 0 || onMore || !value || search !== "" && search !== void 0 ? ((value == null ? void 0 : value.length) || 0) + " selected" : ((value == null ? void 0 : value.length) || 0) + " selected of " + options2.length;
    var summaryButtonClick = function summaryButtonClick2(event) {
      if (onChange2) {
        var nextSelected = options2.filter(function(i, index) {
          return showSelectAll ? !isDisabled2(index) || isSelected(index) : isDisabled2(index) && isSelected(index);
        });
        if (search !== "" && search !== void 0 && value) {
          if (showSelectAll) {
            nextSelected = nextSelected.concat(value);
          } else {
            value.forEach(function(item) {
              if (!arrayIncludes(options2, item, valueKey || labelKey)) {
                nextSelected.push(item);
              }
            });
          }
        }
        var nextValue = nextSelected.map(function(i) {
          return valueKey && valueKey.reduce ? applyKey(i, valueKey) : i;
        });
        onChange2(event, {
          option: options2,
          value: nextValue,
          selected: nextSelected
        });
      }
      if (limit && !showSelectAll)
        setActiveIndex(0);
    };
    return /* @__PURE__ */ import_react49.default.createElement(Box, {
      pad: showSelectedInline ? {
        left: "xsmall",
        vertical: "xsmall"
      } : "xsmall",
      direction: "row",
      justify: "between",
      gap: "small",
      fill: "horizontal",
      flex: showSelectedInline,
      align: "center",
      height: {
        min: "xxsmall"
      }
    }, /* @__PURE__ */ import_react49.default.createElement(Text, {
      size: "small"
    }, summaryText), (options2.length && (!limit || !(!value || (value == null ? void 0 : value.length) === 0 && selectedValuesDisabled()))) > 0 && (!onMore || onMore && (value == null ? void 0 : value.length) !== 0) && /* @__PURE__ */ import_react49.default.createElement(Button2, {
      a11yTitle: showSelectAll ? "Select all " + options2.length + " options" : (value == null ? void 0 : value.length) + " options selected. Clear all?",
      label: showSelectAll ? "Select All" : "Clear All",
      onClick: function onClick(event) {
        return summaryButtonClick(event);
      },
      onFocus: function onFocus() {
        return setActiveIndex(-1);
      },
      ref: clearRef
    }));
  };

  // node_modules/grommet/es6/components/Select/EmptySearchOption.js
  var import_react50 = __toESM(require_react());
  function _extends39() {
    _extends39 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends39.apply(this, arguments);
  }
  var EmptySearchOption = function EmptySearchOption2(_ref) {
    var emptySearchMessage = _ref.emptySearchMessage, selectOptionsStyle = _ref.selectOptionsStyle, theme = _ref.theme;
    return /* @__PURE__ */ import_react50.default.createElement(SelectOption, {
      key: "search_empty",
      tabIndex: "0",
      role: "menuitem",
      hoverIndicator: "background",
      disabled: true
    }, /* @__PURE__ */ import_react50.default.createElement(Box, selectOptionsStyle, /* @__PURE__ */ import_react50.default.createElement(Text, _extends39({
      "aria-live": "polite",
      role: "alert"
    }, theme.select.container.text), emptySearchMessage)));
  };

  // node_modules/grommet/es6/components/SelectMultiple/SelectMultipleContainer.js
  function _extends40() {
    _extends40 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends40.apply(this, arguments);
  }
  var SelectMultipleContainer = /* @__PURE__ */ (0, import_react51.forwardRef)(function(_ref, ref) {
    var _optionsRef$current;
    var allOptions = _ref.allOptions, _ref$children = _ref.children, children = _ref$children === void 0 ? null : _ref$children, disabledProp = _ref.disabled, disabledKey = _ref.disabledKey, dropHeight = _ref.dropHeight, _ref$emptySearchMessa = _ref.emptySearchMessage, emptySearchMessage = _ref$emptySearchMessa === void 0 ? "No matches found" : _ref$emptySearchMessa, help = _ref.help, id = _ref.id, labelKey = _ref.labelKey, limit = _ref.limit, onChange2 = _ref.onChange, onClose = _ref.onClose, onKeyDown = _ref.onKeyDown, onMore = _ref.onMore, onSearch = _ref.onSearch, optionIndexesInValue = _ref.optionIndexesInValue, options2 = _ref.options, _ref$replace = _ref.replace, replace = _ref$replace === void 0 ? true : _ref$replace, searchPlaceholder = _ref.searchPlaceholder, search = _ref.search, setSearch = _ref.setSearch, usingKeyboard = _ref.usingKeyboard, _ref$value = _ref.value, value = _ref$value === void 0 ? [] : _ref$value, valueKey = _ref.valueKey, showSelectedInline = _ref.showSelectedInline;
    var theme = (0, import_react51.useContext)(import_styled_components41.ThemeContext) || defaultProps2.theme;
    var _useState = (0, import_react51.useState)(-1), activeIndex = _useState[0], setActiveIndex = _useState[1];
    var _useState2 = (0, import_react51.useState)(usingKeyboard), keyboardNavigation = _useState2[0], setKeyboardNavigation = _useState2[1];
    var searchRef = (0, import_react51.useRef)();
    var optionsRef = (0, import_react51.useRef)();
    var _useState3 = (0, import_react51.useState)(disabledProp), disabled = _useState3[0], setDisabled = _useState3[1];
    var activeRef = (0, import_react51.useRef)();
    var _useState4 = (0, import_react51.useState)(), showA11yLimit = _useState4[0], setShowA11yLimit = _useState4[1];
    var clearRef = (0, import_react51.useRef)();
    var isDisabled2 = useDisabled(disabled, disabledKey, options2, valueKey || labelKey);
    (0, import_react51.useEffect)(function() {
      var _activeRef$current;
      if (activeIndex)
        (_activeRef$current = activeRef.current) == null ? void 0 : _activeRef$current.focus();
    }, [activeIndex]);
    (0, import_react51.useEffect)(function() {
      var timer = setTimeout(function() {
        var clearButton = clearRef.current;
        if (clearButton && clearButton.focus) {
          setFocusWithoutScroll(clearButton);
        } else if (searchRef && searchRef.current) {
          var searchInput = searchRef.current;
          if (searchInput && searchInput.focus) {
            setFocusWithoutScroll(searchInput);
          }
        } else if (activeRef.current) {
          setFocusWithoutScroll(activeRef.current);
        } else if (optionsRef.current) {
          setActiveIndex(0);
        }
      }, 100);
      return function() {
        return clearTimeout(timer);
      };
    }, []);
    (0, import_react51.useEffect)(function() {
      var optionsNode = optionsRef.current;
      if (optionsNode.children) {
        var optionNode = optionsNode.children[activeIndex];
        if (optionNode)
          optionNode.focus();
      }
    }, [activeIndex]);
    var isSelected = (0, import_react51.useCallback)(function(index) {
      var result;
      var optionVal = getOptionValue(index, options2, valueKey || labelKey);
      if (value) {
        if (value.length === 0) {
          result = false;
        } else if (typeof value[0] !== "object") {
          result = value.indexOf(optionVal) !== -1;
        } else if (valueKey) {
          result = value.some(function(valueItem) {
            var valueValue = typeof valueKey === "function" ? valueKey(valueItem) : valueItem[valueKey];
            return valueValue === optionVal;
          });
        }
      }
      return result;
    }, [value, valueKey, options2, labelKey]);
    var selectOption = (0, import_react51.useCallback)(function(index) {
      return function(event) {
        if (onChange2) {
          var nextOptionIndexesInValue = optionIndexesInValue.slice(0);
          var allOptionsIndex = getOptionIndex(allOptions, options2[index], valueKey || labelKey);
          var valueIndex = optionIndexesInValue.indexOf(allOptionsIndex);
          if (valueIndex === -1 && (!limit || (value == null ? void 0 : value.length) < limit)) {
            nextOptionIndexesInValue.push(allOptionsIndex);
          } else {
            nextOptionIndexesInValue.splice(valueIndex, 1);
          }
          var nextValue = nextOptionIndexesInValue.map(function(i) {
            return valueKey && valueKey.reduce ? applyKey(allOptions[i], valueKey) : allOptions[i];
          });
          var nextSelected = nextOptionIndexesInValue;
          onChange2(event, {
            option: options2[index],
            value: nextValue,
            selected: nextSelected
          });
        }
      };
    }, [labelKey, limit, onChange2, optionIndexesInValue, options2, allOptions, valueKey, value]);
    var onNextOption = (0, import_react51.useCallback)(function(event) {
      event.preventDefault();
      var nextActiveIndex = activeIndex + 1;
      if (nextActiveIndex !== options2.length) {
        setActiveIndex(nextActiveIndex);
        setKeyboardNavigation(true);
      }
    }, [activeIndex, options2]);
    var onPreviousOption = (0, import_react51.useCallback)(function(event) {
      event.preventDefault();
      var nextActiveIndex = activeIndex - 1;
      if (nextActiveIndex === -1) {
        var searchInput = searchRef.current;
        if (searchInput && searchInput.focus) {
          setActiveIndex(nextActiveIndex);
          setFocusWithoutScroll(searchInput);
        }
      }
      if (nextActiveIndex >= 0) {
        setActiveIndex(nextActiveIndex);
        setKeyboardNavigation(true);
      }
    }, [activeIndex]);
    var onKeyDownOption = (0, import_react51.useCallback)(function(event) {
      if (!onSearch) {
        var nextActiveIndex = options2.findIndex(function(e) {
          var label;
          if (typeof e === "object") {
            label = e.label || applyKey(e, labelKey);
          } else {
            label = e;
          }
          return typeof label === "string" && label.charAt(0).toLowerCase() === event.key.toLowerCase();
        });
        if (nextActiveIndex >= 0) {
          event.preventDefault();
          setActiveIndex(nextActiveIndex);
          setKeyboardNavigation(true);
        }
      }
      if (onKeyDown) {
        onKeyDown(event);
      }
    }, [onKeyDown, options2, onSearch, labelKey]);
    var onActiveOption = (0, import_react51.useCallback)(function(index) {
      return function() {
        if (!keyboardNavigation)
          setActiveIndex(index);
      };
    }, [keyboardNavigation]);
    var onSelectOption = (0, import_react51.useCallback)(function(event) {
      if (!isDisabled2(activeIndex) && activeIndex >= 0 && activeIndex < options2.length) {
        event.preventDefault();
        selectOption(activeIndex)(event);
      }
    }, [activeIndex, selectOption, options2, isDisabled2]);
    var customSearchInput = theme.select.searchInput;
    var SelectTextInput2 = customSearchInput || TextInput;
    var selectOptionsStyle = theme.select.options ? _extends40({}, theme.select.options.box, theme.select.options.container) : {};
    (0, import_react51.useEffect)(function() {
      var originallyDisabled = function originallyDisabled2(index) {
        var option = allOptions[index];
        var result;
        if (disabledKey) {
          result = applyKey(option, disabledKey);
        } else if (Array.isArray(disabledProp)) {
          if (typeof disabledProp[0] === "number") {
            result = disabledProp.indexOf(index) !== -1;
          } else {
            result = getOptionIndex(disabledProp, getOptionValue(index, options2, valueKey || labelKey), valueKey || labelKey) !== -1;
          }
        }
        return result;
      };
      if (value && limit) {
        if (value.length === limit) {
          var newDisabled = [].concat(disabledProp);
          for (var i = 0; i < options2.length; i += 1) {
            if (!isSelected(i) && !originallyDisabled(i)) {
              newDisabled.push(options2[i]);
            }
          }
          if (usingKeyboard)
            setShowA11yLimit("Selected. Maximum selection limit reached.");
          setDisabled(newDisabled);
        } else {
          if (usingKeyboard)
            setShowA11yLimit(void 0);
          setDisabled(disabledProp);
        }
      }
    }, [isSelected, value, limit, disabledProp, allOptions, disabledKey, labelKey, options2, usingKeyboard, valueKey]);
    (0, import_react51.useEffect)(function() {
      if (showA11yLimit !== void 0) {
        setTimeout(function() {
          setShowA11yLimit(void 0);
        }, 2e3);
      }
    }, [showA11yLimit]);
    var summaryContent = /* @__PURE__ */ import_react51.default.createElement(SelectionSummary, {
      allOptions,
      clearRef,
      disabled,
      disabledKey,
      isSelected,
      labelKey,
      limit,
      onChange: onChange2,
      onMore,
      options: options2,
      search,
      setActiveIndex,
      showSelectedInline,
      value,
      valueKey
    });
    if (showSelectedInline)
      summaryContent = /* @__PURE__ */ import_react51.default.createElement(Box, {
        direction: "row",
        justify: "between",
        flex: false
      }, summaryContent, /* @__PURE__ */ import_react51.default.createElement(Button2, {
        onClick: onClose,
        a11yTitle: "Close Select"
      }, /* @__PURE__ */ import_react51.default.createElement(Box, {
        fill: true,
        alignSelf: "start",
        pad: {
          right: "small",
          top: "small"
        }
      }, /* @__PURE__ */ import_react51.default.createElement(import_FormUp2.FormUp, null))));
    return /* @__PURE__ */ import_react51.default.createElement(Keyboard, {
      onEnter: onSelectOption,
      onSpace: onSelectOption,
      onUp: onPreviousOption,
      onDown: onNextOption,
      onKeyDown: onKeyDownOption,
      onEsc: onClose
    }, /* @__PURE__ */ import_react51.default.createElement(StyledContainer2, {
      ref,
      as: Box,
      id: id ? id + "__select-drop" : void 0,
      dropHeight,
      a11yTitle: "Select dropdown"
    }, summaryContent, onSearch && /* @__PURE__ */ import_react51.default.createElement(Box, {
      pad: !customSearchInput ? "xsmall" : void 0,
      flex: false
    }, /* @__PURE__ */ import_react51.default.createElement(Keyboard, {
      onEnter: function onEnter(event) {
        onNextOption(event);
      }
    }, /* @__PURE__ */ import_react51.default.createElement(SelectTextInput2, {
      a11yTitle: "Search to filter options.",
      focusIndicator: !customSearchInput,
      size: "small",
      ref: searchRef,
      type: "search",
      value: search || "",
      placeholder: searchPlaceholder,
      onChange: function onChange3(event) {
        var nextSearch = event.target.value;
        setSearch(nextSearch);
        setActiveIndex(-1);
        onSearch(nextSearch);
      }
    }))), /* @__PURE__ */ import_react51.default.createElement(Box, {
      flex: false
    }, help), /* @__PURE__ */ import_react51.default.createElement(OptionsContainer, {
      role: "listbox",
      tabIndex: "0",
      ref: optionsRef,
      "aria-multiselectable": true,
      onMouseMove: function onMouseMove() {
        return setKeyboardNavigation(false);
      },
      "aria-activedescendant": optionsRef == null ? void 0 : (_optionsRef$current = optionsRef.current) == null ? void 0 : _optionsRef$current.children[activeIndex]
    }, options2.length > 0 ? /* @__PURE__ */ import_react51.default.createElement(InfiniteScroll, {
      items: options2,
      step: theme.select.step,
      onMore,
      replace,
      show: activeIndex !== -1 ? activeIndex : void 0
    }, function(option, index, optionRef) {
      var optionDisabled = isDisabled2(index);
      var optionSelected = value ? arrayIncludes(value, valueKey && valueKey.reduce ? applyKey(option, valueKey) : option, valueKey || labelKey) : false;
      var optionActive = activeIndex === index;
      var optionLabel = getOptionLabel(index, options2, labelKey || valueKey);
      var child;
      var textComponent = false;
      if (children) {
        child = children(option, index, options2, {
          active: optionActive,
          disabled: optionDisabled,
          selected: optionSelected
        });
        if (typeof child === "string" || child.props && child.props.children && typeof child.props.children === "string")
          textComponent = true;
      } else {
        child = /* @__PURE__ */ import_react51.default.createElement(CheckBox, {
          label: /* @__PURE__ */ import_react51.default.createElement(Box, {
            alignSelf: "center",
            width: "100%",
            align: "start"
          }, optionLabel),
          pad: "xsmall",
          tabIndex: "-1",
          checked: optionSelected,
          disabled: optionDisabled
        });
      }
      if (!children && search) {
        var searchText = search.toLowerCase();
        if (typeof optionLabel === "string" && optionLabel.toLowerCase().indexOf(searchText) >= 0) {
          var boldIndex = optionLabel.toLowerCase().indexOf(searchText);
          var childBeginning = optionLabel.substring(0, boldIndex);
          var childBold = optionLabel.substring(boldIndex, boldIndex + searchText.length);
          childBold = /* @__PURE__ */ import_react51.default.createElement("b", null, childBold);
          var childEnd = optionLabel.substring(boldIndex + searchText.length);
          child = /* @__PURE__ */ import_react51.default.createElement(CheckBox, {
            label: /* @__PURE__ */ import_react51.default.createElement(Box, {
              alignSelf: "center",
              width: "100%",
              align: "start",
              direction: "row"
            }, /* @__PURE__ */ import_react51.default.createElement(Text, null, childBeginning, childBold, childEnd)),
            pad: "xsmall",
            tabIndex: "-1",
            checked: optionSelected,
            disabled: optionDisabled
          });
        }
      }
      return /* @__PURE__ */ import_react51.default.createElement(SelectOption, {
        a11yTitle: optionSelected ? optionLabel + " selected" : optionLabel + " not selected",
        key: index,
        ref: function ref2(node) {
          if (optionRef)
            optionRef.current = node;
          if (optionActive)
            activeRef.current = node;
        },
        tabIndex: optionSelected ? "0" : "-1",
        role: "option",
        id: "option" + index,
        "aria-setsize": options2.length,
        "aria-posinset": index + 1,
        "aria-selected": optionSelected,
        focusIndicator: false,
        "aria-disabled": optionDisabled || void 0,
        plain: !child ? void 0 : true,
        align: "start",
        kind: !child ? "option" : void 0,
        active: optionActive,
        selected: optionSelected,
        onMouseOver: !optionDisabled ? onActiveOption(index) : void 0,
        onClick: !optionDisabled ? selectOption(index) : void 0,
        onFocus: function onFocus() {
          return setActiveIndex(index);
        },
        textComponent
      }, child);
    }) : /* @__PURE__ */ import_react51.default.createElement(EmptySearchOption, {
      emptySearchMessage,
      selectOptionsStyle,
      theme
    })), usingKeyboard && showA11yLimit && /* @__PURE__ */ import_react51.default.createElement(Box, {
      height: "0px",
      width: "0px",
      overflow: "hidden",
      "aria-live": "assertive",
      role: "alert"
    }, showA11yLimit)));
  });

  // node_modules/grommet/es6/components/Select/DefaultSelectTextInput.js
  var import_react52 = __toESM(require_react());
  var _excluded29 = ["disabled", "id"];
  function _extends41() {
    _extends41 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends41.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose25(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var DefaultSelectTextInput = /* @__PURE__ */ (0, import_react52.forwardRef)(function(_ref, ref) {
    var disabled = _ref.disabled, id = _ref.id, rest = _objectWithoutPropertiesLoose25(_ref, _excluded29);
    return /* @__PURE__ */ import_react52.default.createElement(
      SelectTextInput,
      _extends41({
        defaultCursor: disabled === true || void 0,
        focusIndicator: false,
        id: id ? id + "__input" : void 0,
        ref
      }, rest, {
        tabIndex: "-1",
        type: "text",
        plain: true,
        readOnly: true
      })
    );
  });

  // node_modules/grommet/es6/components/SelectMultiple/propTypes.js
  var import_prop_types26 = __toESM(require_prop_types());

  // node_modules/grommet/es6/components/Select/propTypes.js
  var import_prop_types25 = __toESM(require_prop_types());
  function _extends42() {
    _extends42 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends42.apply(this, arguments);
  }
  var genericSelectProps = _extends42({}, genericProps, {
    children: import_prop_types25.default.func,
    disabled: import_prop_types25.default.oneOfType([import_prop_types25.default.bool, import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.number, import_prop_types25.default.string, import_prop_types25.default.object]))]),
    disabledKey: import_prop_types25.default.oneOfType([import_prop_types25.default.string, import_prop_types25.default.func]),
    dropAlign: import_prop_types25.default.shape({
      top: import_prop_types25.default.oneOf(["top", "bottom"]),
      bottom: import_prop_types25.default.oneOf(["top", "bottom"]),
      right: import_prop_types25.default.oneOf(["left", "right"]),
      left: import_prop_types25.default.oneOf(["left", "right"])
    }),
    dropHeight: import_prop_types25.default.oneOfType([import_prop_types25.default.oneOf(["xsmall", "small", "medium", "large", "xlarge"]), import_prop_types25.default.string]),
    dropTarget: import_prop_types25.default.object,
    dropProps: import_prop_types25.default.object,
    emptySearchMessage: import_prop_types25.default.oneOfType([import_prop_types25.default.string, import_prop_types25.default.node]),
    focusIndicator: import_prop_types25.default.bool,
    icon: import_prop_types25.default.oneOfType([import_prop_types25.default.bool, import_prop_types25.default.func, import_prop_types25.default.node, import_prop_types25.default.elementType]),
    labelKey: import_prop_types25.default.oneOfType([import_prop_types25.default.string, import_prop_types25.default.func]),
    messages: import_prop_types25.default.shape({
      multiple: import_prop_types25.default.string
    }),
    name: import_prop_types25.default.string,
    onChange: import_prop_types25.default.func,
    onClose: import_prop_types25.default.func,
    onOpen: import_prop_types25.default.func,
    onSearch: import_prop_types25.default.func,
    onMore: import_prop_types25.default.func,
    options: import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.string, import_prop_types25.default.number, import_prop_types25.default.bool, import_prop_types25.default.element, import_prop_types25.default.object])).isRequired,
    open: import_prop_types25.default.bool,
    placeholder: import_prop_types25.default.oneOfType([import_prop_types25.default.string, import_prop_types25.default.element, import_prop_types25.default.node]),
    plain: import_prop_types25.default.bool,
    replace: import_prop_types25.default.bool,
    searchPlaceholder: import_prop_types25.default.string,
    size: import_prop_types25.default.oneOfType([import_prop_types25.default.oneOf(["small", "medium", "large", "xlarge"]), import_prop_types25.default.string]),
    valueLabel: import_prop_types25.default.oneOfType([import_prop_types25.default.node, import_prop_types25.default.func]),
    valueKey: import_prop_types25.default.oneOfType([import_prop_types25.default.string, import_prop_types25.default.func, import_prop_types25.default.shape({
      key: import_prop_types25.default.string,
      reduce: import_prop_types25.default.bool
    })])
  });
  var PropType23 = {};
  if (true) {
    PropType23 = _extends42({}, genericSelectProps, {
      clear: import_prop_types25.default.oneOfType([import_prop_types25.default.bool, import_prop_types25.default.shape({
        position: import_prop_types25.default.oneOf(["top", "bottom"]),
        label: import_prop_types25.default.string
      })]),
      closeOnChange: import_prop_types25.default.bool,
      defaultValue: import_prop_types25.default.oneOfType([import_prop_types25.default.string, import_prop_types25.default.object, import_prop_types25.default.number, import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.string, import_prop_types25.default.object, import_prop_types25.default.number]))]),
      multiple: import_prop_types25.default.bool,
      selected: import_prop_types25.default.oneOfType([import_prop_types25.default.number, import_prop_types25.default.arrayOf(import_prop_types25.default.number)]),
      value: import_prop_types25.default.oneOfType([
        import_prop_types25.default.string,
        import_prop_types25.default.element,
        // deprecated, use valueLabel
        import_prop_types25.default.object,
        import_prop_types25.default.number,
        import_prop_types25.default.arrayOf(import_prop_types25.default.oneOfType([import_prop_types25.default.string, import_prop_types25.default.object, import_prop_types25.default.number]))
      ])
    });
  }
  var SelectPropTypes = PropType23;

  // node_modules/grommet/es6/components/SelectMultiple/propTypes.js
  function _extends43() {
    _extends43 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends43.apply(this, arguments);
  }
  var PropType24 = {};
  if (true) {
    PropType24 = _extends43({}, genericSelectProps, {
      defaultValue: import_prop_types26.default.arrayOf(import_prop_types26.default.oneOfType([import_prop_types26.default.string, import_prop_types26.default.object, import_prop_types26.default.number])),
      help: import_prop_types26.default.node,
      limit: import_prop_types26.default.number,
      value: import_prop_types26.default.arrayOf(import_prop_types26.default.oneOfType([import_prop_types26.default.string, import_prop_types26.default.object, import_prop_types26.default.number])),
      showSelectedInline: import_prop_types26.default.bool,
      sortSelectedOnClose: import_prop_types26.default.bool
    });
  }
  var SelectMultiplePropTypes = PropType24;

  // node_modules/grommet/es6/components/SelectMultiple/SelectMultiple.js
  var _excluded30 = ["a11yTitle", "aria-label", "alignSelf", "children", "defaultValue", "disabled", "disabledKey", "dropAlign", "dropHeight", "dropProps", "dropTarget", "emptySearchMessage", "focusIndicator", "gridArea", "help", "id", "icon", "labelKey", "limit", "margin", "messages", "name", "onBlur", "onChange", "onClick", "onClose", "onFocus", "onKeyDown", "onMore", "onOpen", "onSearch", "open", "options", "placeholder", "plain", "replace", "searchPlaceholder", "size", "sortSelectedOnClose", "value", "valueKey", "valueLabel", "showSelectedInline", "width"];
  function _extends44() {
    _extends44 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends44.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose26(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var StyledSelectBox = (0, import_styled_components42.default)(Box).withConfig({
    displayName: "SelectMultiple__StyledSelectBox",
    componentId: "sc-18zwyth-0"
  })(["", ";", ";", ";"], function(props) {
    return !props.plainSelect && controlBorderStyle;
  }, function(props) {
    var _props$theme$select, _props$theme$select$c;
    return (_props$theme$select = props.theme.select) == null ? void 0 : (_props$theme$select$c = _props$theme$select.control) == null ? void 0 : _props$theme$select$c.extend;
  }, function(props) {
    var _props$theme$select$c2;
    return props.open && ((_props$theme$select$c2 = props.theme.select.control) == null ? void 0 : _props$theme$select$c2.open);
  });
  StyledSelectDropButton.defaultProps = {};
  Object.setPrototypeOf(StyledSelectDropButton.defaultProps, defaultProps2);
  var SelectMultiple = /* @__PURE__ */ (0, import_react53.forwardRef)(function(_ref, ref) {
    var a11yTitle = _ref.a11yTitle, ariaLabel = _ref["aria-label"], alignSelf = _ref.alignSelf, children = _ref.children, defaultValue6 = _ref.defaultValue, disabled = _ref.disabled, disabledKey = _ref.disabledKey, dropAlign = _ref.dropAlign, dropHeight = _ref.dropHeight, dropProps4 = _ref.dropProps, dropTarget = _ref.dropTarget, emptySearchMessage = _ref.emptySearchMessage, focusIndicator = _ref.focusIndicator, gridArea = _ref.gridArea, help = _ref.help, id = _ref.id, icon = _ref.icon, labelKey = _ref.labelKey, limit = _ref.limit, margin = _ref.margin, messages = _ref.messages, name = _ref.name, onBlur = _ref.onBlur, onChange2 = _ref.onChange, onClick = _ref.onClick, onClose = _ref.onClose, onFocus = _ref.onFocus, onKeyDown = _ref.onKeyDown, onMore = _ref.onMore, onOpen = _ref.onOpen, onSearch = _ref.onSearch, openProp = _ref.open, optionsProp = _ref.options, placeholder = _ref.placeholder, plain = _ref.plain, replace = _ref.replace, searchPlaceholder = _ref.searchPlaceholder, size = _ref.size, _ref$sortSelectedOnCl = _ref.sortSelectedOnClose, sortSelectedOnClose = _ref$sortSelectedOnCl === void 0 ? true : _ref$sortSelectedOnCl, valueProp = _ref.value, valueKey = _ref.valueKey, valueLabel = _ref.valueLabel, _ref$showSelectedInli = _ref.showSelectedInline, showSelectedInline = _ref$showSelectedInli === void 0 ? false : _ref$showSelectedInli, width = _ref.width, rest = _objectWithoutPropertiesLoose26(_ref, _excluded30);
    var theme = (0, import_react53.useContext)(import_styled_components42.ThemeContext) || defaultProps2.theme;
    var inputRef = (0, import_react53.useRef)();
    var formContext = (0, import_react53.useContext)(FormContext);
    var _useContext = (0, import_react53.useContext)(MessageContext), format4 = _useContext.format;
    var selectBoxRef = (0, import_react53.useRef)();
    var dropButtonRef = useForwardedRef(ref);
    var usingKeyboard = useKeyboard();
    var _formContext$useFormI = formContext.useFormInput({
      name,
      value: valueProp,
      initialValue: defaultValue6 || ""
    }), value = _formContext$useFormI[0], setValue3 = _formContext$useFormI[1];
    var normalizedValue = (0, import_react53.useMemo)(function() {
      return getNormalizedValue(value, valueKey);
    }, [value, valueKey]);
    var _useState = (0, import_react53.useState)(), search = _useState[0], setSearch = _useState[1];
    var _useState2 = (0, import_react53.useState)(optionsProp), allOptions = _useState2[0], setAllOptions = _useState2[1];
    var _useState3 = (0, import_react53.useState)(), orderedOptions = _useState3[0], setOrderedOptions = _useState3[1];
    (0, import_react53.useEffect)(function() {
      if (!search)
        setAllOptions(optionsProp);
    }, [optionsProp, search]);
    (0, import_react53.useEffect)(function() {
      if (sortSelectedOnClose)
        setOrderedOptions(optionsProp);
    }, [optionsProp, sortSelectedOnClose]);
    var optionIndexesInValue = (0, import_react53.useMemo)(function() {
      var result = [];
      allOptions.forEach(function(option, index) {
        if (normalizedValue != null && normalizedValue.some != null && normalizedValue.some(function(v) {
          return v === applyKey(option, valueKey);
        })) {
          result.push(index);
        }
      });
      return result;
    }, [allOptions, valueKey, normalizedValue]);
    var _useState4 = (0, import_react53.useState)(openProp), open = _useState4[0], setOpen = _useState4[1];
    (0, import_react53.useEffect)(function() {
      return setOpen(openProp);
    }, [openProp]);
    var onRequestOpen = (0, import_react53.useCallback)(function() {
      if (open)
        return;
      setOpen(true);
      if (onOpen)
        onOpen();
    }, [onOpen, open]);
    (0, import_react53.useEffect)(function() {
      if (sortSelectedOnClose && value && !open) {
        var selectedOptions = optionsProp.filter(function(option) {
          return arrayIncludes(value, valueKey && valueKey.reduce ? applyKey(option, valueKey) : option, valueKey || labelKey);
        });
        var unselectedOptions = optionsProp.filter(function(i) {
          return !arrayIncludes(selectedOptions, i, valueKey || labelKey);
        });
        var nextOrderedOptions = selectedOptions.concat(unselectedOptions);
        setOrderedOptions(nextOrderedOptions);
      }
    }, [labelKey, open, sortSelectedOnClose, optionsProp, value, valueKey]);
    var onRequestClose = (0, import_react53.useCallback)(function() {
      setOpen(false);
      if (onClose)
        onClose();
      setSearch();
    }, [onClose]);
    var triggerChangeEvent = (0, import_react53.useCallback)(function(nextValue) {
      return changeEvent(inputRef, nextValue);
    }, []);
    var onSelectChange = (0, import_react53.useCallback)(function(event, _ref2) {
      var option = _ref2.option, nextValue = _ref2.value;
      if (typeof nextValue !== "object" && nextValue !== event.target.value && inputRef.current) {
        triggerChangeEvent(nextValue);
      }
      setValue3(nextValue);
      if (onChange2) {
        event.persist();
        var adjustedEvent;
        if (event instanceof Event) {
          adjustedEvent = new event.constructor(event.type, event);
          Object.defineProperties(adjustedEvent, {
            target: {
              value: inputRef.current
            },
            value: {
              value: nextValue
            },
            option: {
              value: option
            }
          });
        } else {
          adjustedEvent = event;
          adjustedEvent.target = inputRef.current;
          adjustedEvent.value = nextValue;
          adjustedEvent.option = option;
        }
        onChange2(adjustedEvent);
      }
    }, [onChange2, setValue3, triggerChangeEvent]);
    var SelectIcon = getSelectIcon(icon, theme, open);
    var selectValue = (0, import_react53.useMemo)(function() {
      var result;
      if (valueLabel) {
        result = value && valueLabel instanceof Function ? valueLabel(value) : valueLabel;
      } else if ((value == null ? void 0 : value.length) > 0 && showSelectedInline) {
        result = /* @__PURE__ */ import_react53.default.createElement(SelectMultipleValue, {
          allOptions,
          disabled,
          disabledKey,
          dropButtonRef,
          labelKey,
          onRequestOpen,
          onSelectChange,
          theme,
          value,
          valueKey
        }, children);
      }
      return result;
    }, [valueKey, value, valueLabel, showSelectedInline, onRequestOpen, allOptions, children, labelKey, onSelectChange, disabled, disabledKey, dropButtonRef, theme]);
    var displayLabelKey = (0, import_react53.useMemo)(function() {
      return getDisplayLabelKey(labelKey, allOptions, optionIndexesInValue, selectValue);
    }, [labelKey, allOptions, optionIndexesInValue, selectValue]);
    var inputValue = (0, import_react53.useMemo)(function() {
      if (!selectValue) {
        if (optionIndexesInValue.length === 0)
          return "";
        if (optionIndexesInValue.length === 1)
          return applyKey(allOptions[optionIndexesInValue[0]], labelKey);
        if (messages)
          return format4({
            id: "select.multiple",
            messages
          });
        return optionIndexesInValue.length + " selected";
      }
      return void 0;
    }, [labelKey, messages, format4, optionIndexesInValue, allOptions, selectValue]);
    var iconColor = getIconColor3(theme);
    var dropContent = /* @__PURE__ */ import_react53.default.createElement(SelectMultipleContainer, {
      allOptions,
      disabled,
      disabledKey,
      dropHeight,
      emptySearchMessage,
      help,
      id,
      labelKey,
      limit,
      onChange: onSelectChange,
      onClose: onRequestClose,
      onKeyDown,
      onMore,
      onSearch,
      options: orderedOptions || optionsProp,
      optionIndexesInValue,
      replace,
      searchPlaceholder,
      search,
      setSearch,
      usingKeyboard,
      value,
      valueKey,
      showSelectedInline
    }, children);
    var dropButtonProps = {
      ref: dropButtonRef,
      a11yTitle: (ariaLabel || a11yTitle || placeholder || "Open Drop") + ". " + ((value == null ? void 0 : value.length) || 0) + " selected.",
      "aria-expanded": Boolean(open),
      "aria-haspopup": "listbox",
      id,
      disabled: disabled === true || void 0,
      open,
      focusIndicator,
      onFocus,
      onBlur,
      gridArea,
      margin,
      onOpen: onRequestOpen,
      onClose: onRequestClose,
      onClick,
      plainSelect: plain,
      plain,
      // Button should be plain
      dropProps: dropProps4,
      dropContent,
      theme
    };
    var displaySelectIcon = SelectIcon && /* @__PURE__ */ import_react53.default.createElement(Box, {
      alignSelf: "center",
      margin: theme.select.icons.margin,
      width: {
        min: "auto"
      }
    }, /* @__PURE__ */ (0, import_react53.isValidElement)(SelectIcon) ? SelectIcon : /* @__PURE__ */ import_react53.default.createElement(SelectIcon, {
      color: iconColor,
      size
    }));
    return /* @__PURE__ */ import_react53.default.createElement(Keyboard, {
      onDown: onRequestOpen,
      onUp: onRequestOpen
    }, showSelectedInline ? /* @__PURE__ */ import_react53.default.createElement(StyledSelectBox, {
      disabled: disabled === true || void 0,
      alignSelf,
      direction: "row",
      alignContent: "start",
      background: theme.select.background,
      ref: selectBoxRef,
      flex: false,
      plainSelect: plain,
      width
    }, /* @__PURE__ */ import_react53.default.createElement(Box, {
      width: "100%"
    }, /* @__PURE__ */ import_react53.default.createElement(DropButton, _extends44({
      fill: "horizontal",
      alignSelf: "start"
    }, dropButtonProps, {
      dropAlign: dropAlign || {
        top: "top",
        right: "right",
        left: "left"
      },
      dropTarget: dropTarget || selectBoxRef.current
    }), selectValue || displayLabelKey ? /* @__PURE__ */ import_react53.default.createElement(import_react53.default.Fragment, null, /* @__PURE__ */ import_react53.default.createElement(Box, {
      direction: "row"
    }, /* @__PURE__ */ import_react53.default.createElement(SelectTextInput, _extends44({
      a11yTitle: ariaLabel || a11yTitle,
      defaultCursor: disabled === true || void 0,
      focusIndicator: false,
      id: id ? id + "__input" : void 0,
      name,
      width: "100%"
    }, rest, {
      tabIndex: "-1",
      type: "text",
      placeholder: (
        // eslint-disable-next-line no-nested-ternary
        !value || (value == null ? void 0 : value.length) === 0 ? placeholder || selectValue || displayLabelKey : onMore ? ((value == null ? void 0 : value.length) || "0") + " selected" : ((value == null ? void 0 : value.length) || "0") + " selected of " + allOptions.length
      ),
      plain: true,
      readOnly: true,
      value: "",
      theme
    })), displaySelectIcon), /* @__PURE__ */ import_react53.default.createElement(HiddenInput, {
      type: "text",
      name,
      id: id ? id + "__input" : void 0,
      value: inputValue,
      ref: inputRef,
      readOnly: true
    })) : /* @__PURE__ */ import_react53.default.createElement(Box, {
      direction: "row"
    }, /* @__PURE__ */ import_react53.default.createElement(DefaultSelectTextInput, _extends44({
      a11yTitle: ariaLabel || a11yTitle,
      disabled,
      id,
      name,
      ref: inputRef,
      placeholder: placeholder || "Select",
      value: inputValue,
      size,
      theme
    }, rest)), displaySelectIcon)), !open && (value == null ? void 0 : value.length) > 0 && (selectValue || displayLabelKey))) : /* @__PURE__ */ import_react53.default.createElement(Box, {
      width
    }, /* @__PURE__ */ import_react53.default.createElement(StyledSelectDropButton, _extends44({}, dropButtonProps, {
      dropAlign: dropAlign || {
        top: "bottom",
        left: "left"
      },
      dropTarget,
      alignSelf,
      tabIndex: "0"
    }), /* @__PURE__ */ import_react53.default.createElement(Box, {
      align: "center",
      direction: "row",
      justify: "between",
      background: theme.select.background
    }, /* @__PURE__ */ import_react53.default.createElement(Box, {
      direction: "row",
      flex: true,
      basis: "auto"
    }, selectValue || displayLabelKey ? /* @__PURE__ */ import_react53.default.createElement(import_react53.default.Fragment, null, selectValue || displayLabelKey, /* @__PURE__ */ import_react53.default.createElement(HiddenInput, {
      type: "text",
      name,
      id: id ? id + "__input" : void 0,
      value: inputValue,
      ref: inputRef,
      readOnly: true
    })) : /* @__PURE__ */ import_react53.default.createElement(DefaultSelectTextInput, _extends44({
      a11yTitle: ariaLabel || a11yTitle,
      disabled,
      id,
      name,
      ref: inputRef,
      placeholder,
      value: inputValue,
      size,
      theme
    }, rest))), displaySelectIcon))));
  });
  SelectMultiple.defaultProps = _extends44({}, defaultProps2);
  SelectMultiple.displayName = "SelectMultiple";
  SelectMultiple.propTypes = SelectMultiplePropTypes;

  // node_modules/grommet/es6/components/DataFilter/propTypes.js
  var import_prop_types27 = __toESM(require_prop_types());
  var PropType25 = {};
  if (true) {
    PropType25 = {
      options: import_prop_types27.default.arrayOf(import_prop_types27.default.oneOfType([import_prop_types27.default.string, import_prop_types27.default.number, import_prop_types27.default.shape({
        label: import_prop_types27.default.string,
        value: import_prop_types27.default.oneOfType([import_prop_types27.default.string, import_prop_types27.default.number, import_prop_types27.default.bool])
      })])),
      property: import_prop_types27.default.string
    };
  }
  var DataFilterPropTypes = PropType25;

  // node_modules/grommet/es6/components/DataFilter/DataFilter.js
  var _excluded31 = ["children", "options", "property", "range"];
  function _extends45() {
    _extends45 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends45.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose27(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var getValueAt = function getValueAt2(valueObject, pathArg) {
    if (valueObject === void 0)
      return void 0;
    var path = Array.isArray(pathArg) ? pathArg : pathArg.split(".");
    if (path.length === 1)
      return valueObject[path];
    return getValueAt2(valueObject[path.shift()], path);
  };
  var generateOptions = function generateOptions2(data, property) {
    return Array.from(new Set(data.map(function(d) {
      return getValueAt(d, property);
    }))).filter(function(v) {
      return v !== void 0 && v !== "";
    }).sort();
  };
  var alignMax = function alignMax2(value, interval) {
    if (value > 0)
      return value - value % interval + interval;
    if (value < 0)
      return value + value % interval;
    return value;
  };
  var alignMin = function alignMin2(value, interval) {
    if (value > 0)
      return value - value % interval;
    if (value < 0)
      return value - value % interval - interval;
    return value;
  };
  var booleanOptions = [{
    label: "true",
    value: true
  }, {
    label: "false",
    value: false
  }];
  var DataFilter = function DataFilter2(_ref) {
    var _properties$property3;
    var children = _ref.children, optionsProp = _ref.options, property = _ref.property, rangeProp = _ref.range, rest = _objectWithoutPropertiesLoose27(_ref, _excluded31);
    var _useContext = (0, import_react54.useContext)(DataContext), data = _useContext.data, dataId = _useContext.id, properties = _useContext.properties, unfilteredData = _useContext.unfilteredData;
    var _useMemo = (0, import_react54.useMemo)(function() {
      var _properties$property, _properties$property2;
      if (children)
        return [void 0, void 0];
      var optionsIn = optionsProp || (properties == null ? void 0 : (_properties$property = properties[property]) == null ? void 0 : _properties$property.options);
      var rangeIn = rangeProp || (properties == null ? void 0 : (_properties$property2 = properties[property]) == null ? void 0 : _properties$property2.range);
      if (optionsIn)
        return [optionsIn, void 0];
      if (rangeIn)
        return [void 0, [rangeIn.min, rangeIn.max]];
      var uniqueValues = generateOptions(unfilteredData || data, property);
      if (uniqueValues.some(function(v) {
        return v && typeof v !== "number";
      }))
        return [uniqueValues, void 0];
      var delta = uniqueValues[uniqueValues.length - 1] - uniqueValues[0];
      var interval = Number.parseFloat((delta / 3).toPrecision(1));
      var min2 = alignMin(uniqueValues[0], interval);
      var max2 = alignMax(uniqueValues[uniqueValues.length - 1], interval);
      return [void 0, [min2, max2]];
    }, [children, data, optionsProp, properties, property, rangeProp, unfilteredData]), options2 = _useMemo[0], range3 = _useMemo[1];
    var id = dataId + "-" + property;
    var content = children;
    if (!content) {
      if (range3) {
        content = /* @__PURE__ */ import_react54.default.createElement(RangeSelector, {
          id,
          name: property + "._range",
          defaultValues: range3,
          label: true,
          min: range3[0],
          max: range3[1],
          step: (range3[1] - range3[0]) / 20,
          size: "full",
          round: "small"
        });
      } else if (options2.length === 2 && options2[1] === true && options2[0] === false) {
        content = /* @__PURE__ */ import_react54.default.createElement(CheckBoxGroup, {
          id,
          name: property,
          options: booleanOptions
        });
      } else if (options2.length < 7) {
        content = /* @__PURE__ */ import_react54.default.createElement(CheckBoxGroup, {
          id,
          name: property,
          options: options2
        });
      } else {
        content = /* @__PURE__ */ import_react54.default.createElement(SelectMultiple, {
          id,
          name: property,
          showSelectedInline: true,
          options: options2
        });
      }
    }
    return /* @__PURE__ */ import_react54.default.createElement(FormField, _extends45({
      htmlFor: id,
      name: property,
      label: (properties == null ? void 0 : (_properties$property3 = properties[property]) == null ? void 0 : _properties$property3.label) || property
    }, rest), content);
  };
  DataFilter.propTypes = DataFilterPropTypes;

  // node_modules/grommet/es6/components/Data/DataForm.js
  var import_react56 = __toESM(require_react());
  var import_styled_components43 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/Form/Form.js
  var import_react55 = __toESM(require_react());

  // node_modules/grommet/es6/components/Form/propTypes.js
  var import_prop_types28 = __toESM(require_prop_types());
  var PropType26 = {};
  if (true) {
    PropType26 = {
      errors: import_prop_types28.default.shape({}),
      infos: import_prop_types28.default.shape({}),
      kind: import_prop_types28.default.string,
      messages: import_prop_types28.default.shape({
        invalid: import_prop_types28.default.string,
        required: import_prop_types28.default.string
      }),
      onChange: import_prop_types28.default.func,
      onSubmit: import_prop_types28.default.func,
      onReset: import_prop_types28.default.func,
      onValidate: import_prop_types28.default.func,
      validate: import_prop_types28.default.oneOf(["blur", "submit", "change"]),
      value: import_prop_types28.default.shape({})
    };
  }
  var FormPropTypes = PropType26;

  // node_modules/grommet/es6/components/Form/Form.js
  var _excluded33 = ["children", "errors", "infos", "messages", "kind", "onChange", "onReset", "onSubmit", "onValidate", "validate", "value"];
  function _objectWithoutPropertiesLoose28(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _extends46() {
    _extends46 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends46.apply(this, arguments);
  }
  var defaultValue2 = {};
  var defaultTouched = {};
  var defaultValidationResults = {
    errors: {},
    infos: {}
  };
  var stringToArray = function stringToArray2(string) {
    var match2 = string == null ? void 0 : string.match(/^(.+)\[([0-9]+)\]\.(.*)$/);
    if (match2) {
      var arrayName = match2[1], indexOfArray = match2[2], arrayObjName = match2[3];
      return {
        indexOfArray,
        arrayName,
        arrayObjName
      };
    }
    return void 0;
  };
  var getValueAt3 = function getValueAt4(valueObject, pathArg) {
    if (valueObject === void 0)
      return void 0;
    var path = Array.isArray(pathArg) ? pathArg : pathArg.split(".");
    if (path.length === 1)
      return valueObject[path];
    return getValueAt4(valueObject[path.shift()], path);
  };
  var setValueAt = function setValueAt2(valueObject, pathArg, value) {
    var object = valueObject;
    var path = Array.isArray(pathArg) ? pathArg : pathArg.split(".");
    if (path.length === 1)
      object[path] = value;
    else {
      var key = path.shift();
      if (!object[key])
        object[key] = {};
      setValueAt2(object[key], path, value);
    }
  };
  var getFieldValue = function getFieldValue2(name, value) {
    var isArrayField = stringToArray(name);
    if (isArrayField) {
      var _value$arrayName;
      var indexOfArray = isArrayField.indexOfArray, arrayName = isArrayField.arrayName, arrayObjName = isArrayField.arrayObjName;
      var obj = (_value$arrayName = value[arrayName]) == null ? void 0 : _value$arrayName[indexOfArray];
      return arrayObjName ? obj == null ? void 0 : obj[arrayObjName] : obj;
    }
    return getValueAt3(value, name);
  };
  var setFieldValue = function setFieldValue2(name, componentValue, prevValue) {
    var nextValue = _extends46({}, prevValue);
    var isArrayField = stringToArray(name);
    if (isArrayField) {
      var indexOfArray = isArrayField.indexOfArray, arrayName = isArrayField.arrayName, arrayObjName = isArrayField.arrayObjName;
      if (!nextValue[arrayName])
        nextValue[arrayName] = [];
      if (arrayObjName) {
        var _nextValue$arrayName$;
        if (!nextValue[arrayName][indexOfArray])
          nextValue[arrayName][indexOfArray] = (_nextValue$arrayName$ = {}, _nextValue$arrayName$[arrayObjName] = componentValue, _nextValue$arrayName$);
        nextValue[arrayName][indexOfArray][arrayObjName] = componentValue;
      } else
        nextValue[arrayName][indexOfArray] = componentValue;
    } else {
      setValueAt(nextValue, name, componentValue);
    }
    return nextValue;
  };
  var validate = function validate2(rule3, fieldValue, formValue, format4, messages) {
    var result;
    if (typeof rule3 === "function") {
      result = rule3(fieldValue, formValue);
    } else if (rule3.regexp) {
      if (!rule3.regexp.test(fieldValue)) {
        result = rule3.message || format4({
          id: "form.invalid",
          messages
        });
        if (rule3.status) {
          result = {
            message: result,
            status: rule3.status
          };
        }
      }
    }
    return result;
  };
  var validateName = function validateName2(validationRules, required) {
    return function(name, formValue, format4, messages) {
      var fieldValue = getFieldValue(name, formValue);
      var validationResult;
      if (required && // false is for CheckBox
      (fieldValue === void 0 || fieldValue === "" || fieldValue === false || Array.isArray(fieldValue) && !fieldValue.length)) {
        validationResult = format4({
          id: "form.required",
          messages
        });
      } else if (validationRules) {
        if (Array.isArray(validationRules)) {
          validationRules.some(function(rule3) {
            validationResult = validate(rule3, fieldValue, formValue, format4, messages);
            return !!validationResult;
          });
        } else {
          validationResult = validate(validationRules, fieldValue, formValue, format4, messages);
        }
      }
      return validationResult;
    };
  };
  var validateForm = function validateForm2(validationRules, formValue, format4, messages, omitValid) {
    var nextErrors = {};
    var nextInfos = {};
    validationRules.forEach(function(_ref) {
      var name = _ref[0], _ref$ = _ref[1], field = _ref$.field, input = _ref$.input;
      if (!omitValid) {
        nextErrors[name] = void 0;
        nextInfos[name] = void 0;
      }
      var result;
      if (input) {
        result = input(name, formValue, format4, messages);
      }
      if (field && !result) {
        result = field(name, formValue, format4, messages);
      }
      if (typeof result === "object") {
        if (result.status === "info") {
          nextInfos[name] = result.message;
        } else {
          nextErrors[name] = result.message || result;
        }
      } else if (typeof result === "string") {
        nextErrors[name] = result;
      }
    });
    return [nextErrors, nextInfos];
  };
  var Form = /* @__PURE__ */ (0, import_react55.forwardRef)(function(_ref2, ref) {
    var children = _ref2.children, _ref2$errors = _ref2.errors, errorsProp = _ref2$errors === void 0 ? defaultValidationResults.errors : _ref2$errors, _ref2$infos = _ref2.infos, infosProp = _ref2$infos === void 0 ? defaultValidationResults.infos : _ref2$infos, messages = _ref2.messages, kind = _ref2.kind, onChange2 = _ref2.onChange, _onReset = _ref2.onReset, _onSubmit = _ref2.onSubmit, onValidate = _ref2.onValidate, _ref2$validate = _ref2.validate, validateOn = _ref2$validate === void 0 ? "submit" : _ref2$validate, valueProp = _ref2.value, rest = _objectWithoutPropertiesLoose28(_ref2, _excluded33);
    var formRef = useForwardedRef(ref);
    var _useContext = (0, import_react55.useContext)(MessageContext), format4 = _useContext.format;
    var _useState = (0, import_react55.useState)(valueProp || defaultValue2), valueState = _useState[0], setValueState = _useState[1];
    var value = (0, import_react55.useMemo)(function() {
      return valueProp || valueState;
    }, [valueProp, valueState]);
    var _useState2 = (0, import_react55.useState)(defaultTouched), touched = _useState2[0], setTouched = _useState2[1];
    var _useState3 = (0, import_react55.useState)({
      errors: errorsProp,
      infos: infosProp
    }), validationResults = _useState3[0], setValidationResults = _useState3[1];
    var validationResultsRef = (0, import_react55.useRef)({});
    var _useState4 = (0, import_react55.useState)("unmounted"), mounted = _useState4[0], setMounted = _useState4[1];
    (0, import_react55.useEffect)(function() {
      if (!mounted)
        setMounted("mounting");
      else if (mounted === "mounting")
        setMounted("mounted");
    }, [mounted]);
    var _useState5 = (0, import_react55.useState)(void 0), pendingValidation = _useState5[0], setPendingValidation = _useState5[1];
    var validationRulesRef = (0, import_react55.useRef)({});
    var requiredFields = (0, import_react55.useRef)([]);
    var analyticsRef = (0, import_react55.useRef)({
      start: /* @__PURE__ */ new Date(),
      errors: {}
    });
    var sendAnalytics = useAnalytics();
    var buildValid = (0, import_react55.useCallback)(function(nextErrors) {
      var valid = false;
      valid = requiredFields.current.filter(function(n) {
        return Object.keys(validationRulesRef.current).includes(n);
      }).every(function(field) {
        return value[field] && (value[field] !== "" || value[field] !== false);
      });
      if (Object.keys(nextErrors).length > 0)
        valid = false;
      return valid;
    }, [value]);
    var filterRemovedFields = function filterRemovedFields2(prevValidations) {
      var nextValidations = prevValidations;
      return Object.keys(nextValidations).filter(function(n) {
        return !validationRulesRef.current[n] || nextValidations[n] === void 0;
      }).forEach(function(n) {
        return delete nextValidations[n];
      });
    };
    var updateAnalytics = function updateAnalytics2() {
      var _validationResultsRef;
      var errorFields = Object.keys((_validationResultsRef = validationResultsRef.current) == null ? void 0 : _validationResultsRef.errors);
      var errorCounts = analyticsRef.current.errors;
      if (errorFields.length > 0) {
        errorFields.forEach(function(key) {
          errorCounts[key] = (errorCounts[key] || 0) + 1;
        });
      }
    };
    var applyValidationRules = (0, import_react55.useCallback)(function(validationRules) {
      var _validateForm = validateForm(validationRules, value, format4, messages), validatedErrors = _validateForm[0], validatedInfos = _validateForm[1];
      setValidationResults(function(prevValidationResults) {
        var nextErrors = _extends46({}, prevValidationResults.errors, validatedErrors);
        var nextInfos = _extends46({}, prevValidationResults.infos, validatedInfos);
        filterRemovedFields(nextErrors);
        filterRemovedFields(nextInfos);
        var nextValidationResults = {
          errors: nextErrors,
          infos: nextInfos
        };
        if (onValidate)
          onValidate(_extends46({}, nextValidationResults, {
            valid: buildValid(nextErrors)
          }));
        validationResultsRef.current = nextValidationResults;
        updateAnalytics();
        return nextValidationResults;
      });
    }, [buildValid, format4, messages, onValidate, value]);
    (0, import_react55.useEffect)(function() {
      var validationRules = Object.entries(validationRulesRef.current);
      if (mounted !== "mounted" && ["blur", "change"].includes(validateOn) && Object.keys(value).length > 0 && Object.keys(touched).length === 0) {
        applyValidationRules(validationRules.filter(function(_ref3) {
          var n = _ref3[0];
          return value[n];
        }).filter(function(_ref4) {
          var n = _ref4[0];
          return !(Array.isArray(value[n]) && value[n].length === 0);
        }));
      }
    }, [applyValidationRules, mounted, touched, validateOn, value]);
    (0, import_react55.useEffect)(function() {
      var validationRules = Object.entries(validationRulesRef.current);
      var timer = setTimeout(function() {
        if (pendingValidation && ["blur", "change"].includes(validateOn)) {
          applyValidationRules(validationRules.filter(function(_ref5) {
            var n = _ref5[0];
            return touched[n] || pendingValidation.includes(n);
          }));
          setPendingValidation(void 0);
        }
      }, 120);
      return function() {
        return clearTimeout(timer);
      };
    }, [applyValidationRules, pendingValidation, touched, validateOn]);
    (0, import_react55.useEffect)(function() {
      var _validationResultsRef2;
      var validationRules = Object.entries(validationRulesRef.current);
      if ((_validationResultsRef2 = validationResultsRef.current) != null && _validationResultsRef2.errors && Object.keys(validationResultsRef.current.errors).length > 0) {
        applyValidationRules(validationRules.filter(function(_ref6) {
          var n = _ref6[0];
          return touched[n] && validationResultsRef.current.errors[n];
        }));
      }
    }, [applyValidationRules, touched]);
    (0, import_react55.useEffect)(function() {
      var element = formRef.current;
      analyticsRef.current = {
        start: /* @__PURE__ */ new Date(),
        errors: {}
      };
      sendAnalytics({
        type: "formOpen",
        element
      });
      return function() {
        if (!analyticsRef.current.submitted) {
          sendAnalytics({
            type: "formClose",
            element,
            errors: analyticsRef.current.errors,
            elapsed: (/* @__PURE__ */ new Date()).getTime() - analyticsRef.current.start.getTime()
          });
        }
      };
    }, [sendAnalytics, formRef]);
    var formContextValue = (0, import_react55.useMemo)(function() {
      var useFormInput3 = function useFormInput4(_ref7) {
        var name = _ref7.name, componentValue = _ref7.value, initialValue = _ref7.initialValue, validateArg = _ref7.validate;
        var _useState6 = (0, import_react55.useState)(initialValue), inputValue = _useState6[0], setInputValue = _useState6[1];
        var formValue = name ? getFieldValue(name, value) : void 0;
        var keyCreated = (0, import_react55.useRef)(false);
        (0, import_react55.useEffect)(function() {
          if (name && // we have somewhere to put this
          componentValue !== void 0 && // input driving
          componentValue !== formValue) {
            setValueState(function(prevValue) {
              return setFieldValue(name, componentValue, prevValue);
            });
          }
        }, [componentValue, formValue, name]);
        (0, import_react55.useEffect)(
          function() {
            return function() {
              if (keyCreated.current) {
                keyCreated.current = false;
                setValueState(function(prevValue) {
                  var nextValue = _extends46({}, prevValue);
                  var isArrayField = stringToArray(name);
                  if (isArrayField) {
                    var arrayName = isArrayField.arrayName;
                    delete nextValue[arrayName];
                  } else {
                    delete nextValue[name];
                  }
                  return nextValue;
                });
              }
            };
          },
          // eslint-disable-next-line react-hooks/exhaustive-deps
          []
          // only run onmount and unmount
        );
        (0, import_react55.useEffect)(function() {
          if (validateArg) {
            if (!validationRulesRef.current[name]) {
              validationRulesRef.current[name] = {};
            }
            validationRulesRef.current[name].input = validateName(validateArg);
            return function() {
              return delete validationRulesRef.current[name].input;
            };
          }
          return void 0;
        }, [validateArg, name]);
        var useValue;
        if (componentValue !== void 0)
          useValue = componentValue;
        else if (valueProp && name && formValue !== void 0)
          useValue = formValue;
        else if (formValue === void 0 && name)
          useValue = initialValue;
        else
          useValue = inputValue;
        return [useValue, function(nextComponentValue) {
          if (name) {
            var nextTouched = _extends46({}, touched);
            nextTouched[name] = true;
            if (!touched[name]) {
              setTouched(nextTouched);
            }
            if (!(name in value))
              keyCreated.current = true;
            var nextValue = setFieldValue(name, nextComponentValue, value);
            setValueState(nextValue);
            if (onChange2)
              onChange2(nextValue, {
                touched: nextTouched
              });
          }
          if (initialValue !== void 0)
            setInputValue(nextComponentValue);
        }];
      };
      var useFormField3 = function useFormField4(_ref8) {
        var errorArg = _ref8.error, infoArg = _ref8.info, name = _ref8.name, required = _ref8.required, disabled = _ref8.disabled, validateArg = _ref8.validate;
        var error2 = disabled ? void 0 : errorArg || validationResults.errors[name];
        var info = infoArg || validationResults.infos[name];
        (0, import_react55.useEffect)(function() {
          var index = requiredFields.current.indexOf(name);
          if (required) {
            if (index === -1)
              requiredFields.current.push(name);
          } else if (index !== -1)
            requiredFields.current.splice(index, 1);
          if (validateArg || required) {
            if (!validationRulesRef.current[name]) {
              validationRulesRef.current[name] = {};
            }
            validationRulesRef.current[name].field = validateName(validateArg, required);
            return function() {
              delete validationRulesRef.current[name].field;
              var requiredFieldIndex = requiredFields.current.indexOf(name);
              if (requiredFieldIndex !== -1) {
                requiredFields.current.splice(requiredFieldIndex, 1);
              }
            };
          }
          return void 0;
        }, [error2, name, required, validateArg, disabled]);
        return {
          error: error2,
          info,
          inForm: true,
          onBlur: validateOn === "blur" ? function() {
            return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);
          } : void 0,
          onChange: validateOn === "change" ? function() {
            return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);
          } : void 0
        };
      };
      return {
        useFormField: useFormField3,
        useFormInput: useFormInput3,
        kind
      };
    }, [onChange2, kind, pendingValidation, touched, validateOn, validationResults.errors, validationResults.infos, value, valueProp]);
    return /* @__PURE__ */ import_react55.default.createElement("form", _extends46({
      ref: formRef
    }, rest, {
      onReset: function onReset(event) {
        sendAnalytics({
          type: "formReset",
          element: formRef.current,
          data: event,
          errors: analyticsRef.current.errors,
          elapsed: (/* @__PURE__ */ new Date()).getTime() - analyticsRef.current.start.getTime()
        });
        setPendingValidation(void 0);
        if (!valueProp) {
          setValueState(defaultValue2);
          if (onChange2)
            onChange2(defaultValue2, {
              touched: defaultTouched
            });
        }
        setTouched(defaultTouched);
        setValidationResults(defaultValidationResults);
        analyticsRef.current = {
          start: /* @__PURE__ */ new Date(),
          errors: {}
        };
        if (_onReset) {
          event.persist();
          var adjustedEvent = event;
          adjustedEvent.value = defaultValue2;
          _onReset(adjustedEvent);
        }
      },
      onSubmit: function onSubmit(event) {
        event.preventDefault();
        setPendingValidation(void 0);
        var _validateForm2 = validateForm(Object.entries(validationRulesRef.current), value, format4, messages, true), nextErrors = _validateForm2[0], nextInfos = _validateForm2[1];
        setValidationResults(function() {
          var nextValidationResults = {
            errors: nextErrors,
            infos: nextInfos,
            // Show form's validity when clicking on Submit
            valid: buildValid(nextErrors)
          };
          if (onValidate)
            onValidate(nextValidationResults);
          validationResultsRef.current = nextValidationResults;
          updateAnalytics();
          return nextValidationResults;
        });
        if (Object.keys(nextErrors).length === 0 && _onSubmit) {
          event.persist();
          var adjustedEvent = event;
          adjustedEvent.value = value;
          adjustedEvent.touched = touched;
          _onSubmit(adjustedEvent);
          sendAnalytics({
            type: "formSubmit",
            element: formRef.current,
            data: adjustedEvent,
            errors: analyticsRef.current.errors,
            elapsed: (/* @__PURE__ */ new Date()).getTime() - analyticsRef.current.start.getTime()
          });
          analyticsRef.current.errors = {};
          analyticsRef.current.submitted = true;
        }
      }
    }), /* @__PURE__ */ import_react55.default.createElement(FormContext.Provider, {
      value: formContextValue
    }, children));
  });
  Form.displayName = "Form";
  Form.propTypes = FormPropTypes;

  // node_modules/grommet/es6/components/Data/DataForm.js
  var _excluded34 = ["children", "footer", "onDone", "onTouched", "pad", "updateOn"];
  function _objectWithoutPropertiesLoose29(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _extends47() {
    _extends47 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends47.apply(this, arguments);
  }
  var HideableButton = (0, import_styled_components43.default)(Button2).withConfig({
    displayName: "DataForm__HideableButton",
    componentId: "sc-v64e1r-0"
  })(["", ""], function(props) {
    return props.disabled && "\n  opacity: 0;";
  });
  var MaxForm = (0, import_styled_components43.default)(Form).withConfig({
    displayName: "DataForm__MaxForm",
    componentId: "sc-v64e1r-1"
  })(["max-width:100%;", ""], function(props) {
    return props.fill && "max-height: 100%;";
  });
  var hideButtonProps = {
    "aria-hidden": true,
    disabled: true,
    tabIndex: -1
  };
  var formSearchKey = "_search";
  var formSortKey = "_sort";
  var formRangeKey = "_range";
  var formStepKey = "_step";
  var formPageKey = "_page";
  var formColumnsKey = "_columns";
  var formViewNameKey = "_view";
  var viewFormKeyMap = {
    search: formSearchKey,
    sort: formSortKey,
    step: formStepKey,
    page: formPageKey,
    columns: formColumnsKey,
    view: formViewNameKey
  };
  var flatten = function flatten2(formValue, options2) {
    var result = JSON.parse(JSON.stringify(formValue));
    Object.keys(result).forEach(function(k) {
      var name = k;
      while (typeof result[name] === "object" && !Array.isArray(result[name]) && (options2 != null && options2.full || !result[name][formRangeKey])) {
        var subPath = Object.keys(result[name])[0];
        var path = name + "." + subPath;
        result[path] = result[name][subPath];
        delete result[name];
        name = path;
      }
    });
    return result;
  };
  var unflatten = function unflatten2(formValue) {
    var result = JSON.parse(JSON.stringify(formValue));
    var specialKeys = Object.values(viewFormKeyMap);
    Object.keys(result).filter(function(k) {
      return !specialKeys.includes(k);
    }).forEach(function(k) {
      var parts2 = k.split(".");
      var val = result[k];
      delete result[k];
      var parent = result;
      while (parts2.length > 1) {
        var sub = parts2.shift();
        if (!parent[sub])
          parent[sub] = {};
        parent = parent[sub];
      }
      parent[parts2.shift()] = val;
    });
    return result;
  };
  var viewToFormValue = function viewToFormValue2(view) {
    var result = _extends47({}, (view == null ? void 0 : view.properties) || {});
    Object.keys(result).forEach(function(key) {
      var _result$key, _result$key2;
      if (typeof ((_result$key = result[key]) == null ? void 0 : _result$key.min) === "number" || typeof ((_result$key2 = result[key]) == null ? void 0 : _result$key2.max) === "number") {
        var _result$key3;
        result[key] = (_result$key3 = {}, _result$key3[formRangeKey] = [result[key].min, result[key].max], _result$key3);
      }
    });
    Object.keys(viewFormKeyMap).forEach(function(key) {
      if (view != null && view[key])
        result[viewFormKeyMap[key]] = view[key];
    });
    if (!result[formSearchKey])
      result[formSearchKey] = "";
    if (view != null && view.sort)
      result[formSortKey] = view.sort;
    if (view != null && view.name)
      result[formViewNameKey] = view.name;
    if (view != null && view.columns)
      result[formColumnsKey] = view.columns;
    return unflatten(result);
  };
  var formValueToView = function formValueToView2(value, views) {
    var result = {};
    if (value[formViewNameKey])
      result = JSON.parse(JSON.stringify(views.find(function(v) {
        return v.name === value[formViewNameKey];
      })));
    var valueCopy = _extends47({}, value);
    Object.keys(viewFormKeyMap).forEach(function(key) {
      if (valueCopy[viewFormKeyMap[key]]) {
        result[key] = valueCopy[viewFormKeyMap[key]];
      }
      delete valueCopy[viewFormKeyMap[key]];
    });
    var flatValue = flatten(valueCopy);
    result.properties = _extends47({}, result.properties || {}, flatValue);
    Object.keys(result.properties).forEach(function(key) {
      if (result.properties[key][formRangeKey]) {
        result.properties[key] = {
          min: result.properties[key][formRangeKey][0],
          max: result.properties[key][formRangeKey][1]
        };
      }
    });
    return result;
  };
  var clearEmpty = function clearEmpty2(formValue) {
    var value = formValue;
    Object.keys(value).forEach(function(k) {
      if (Array.isArray(value[k]) && value[k].length === 0)
        delete value[k];
    });
    return value;
  };
  var resetPage = function resetPage2(nextFormValue, prevFormValue) {
    if (prevFormValue[formPageKey] && prevFormValue[formPageKey] > 1)
      nextFormValue[formPageKey] = 1;
  };
  var transformTouched = function transformTouched2(touched, value) {
    var result = {};
    Object.keys(touched).forEach(function(key) {
      var parts2 = key.split(".");
      if (parts2[1] === formRangeKey)
        result[key] = value[parts2[0]];
      else
        result[key] = flatten(value, {
          full: true
        })[key];
    });
    return result;
  };
  var normalizeValue = function normalizeValue2(nextValue, prevValue, views) {
    if (nextValue[formViewNameKey] && nextValue[formViewNameKey] !== prevValue[formViewNameKey]) {
      return viewToFormValue(views.find(function(v) {
        return v.name === nextValue[formViewNameKey];
      }));
    }
    var result = clearEmpty(nextValue);
    if (result[formViewNameKey]) {
      var view = views.find(function(v) {
        return v.name === result[formViewNameKey];
      });
      var viewValue = viewToFormValue(view);
      clearEmpty(viewValue);
      if (Object.keys(viewValue).some(function(k) {
        return (
          // allow mismatch between empty and set strings
          viewValue[k] && result[k] && JSON.stringify(result[k]) !== JSON.stringify(viewValue[k])
        );
      })) {
        delete result[formViewNameKey];
      }
    }
    return result;
  };
  var DataForm = function DataForm2(_ref) {
    var children = _ref.children, footer = _ref.footer, onDone = _ref.onDone, onTouched = _ref.onTouched, pad = _ref.pad, updateOnProp = _ref.updateOn, rest = _objectWithoutPropertiesLoose29(_ref, _excluded34);
    var _useContext = (0, import_react56.useContext)(DataContext), messages = _useContext.messages, onView = _useContext.onView, updateOnData = _useContext.updateOn, view = _useContext.view, views = _useContext.views;
    var updateOn = updateOnProp != null ? updateOnProp : updateOnData;
    var _useContext2 = (0, import_react56.useContext)(MessageContext), format4 = _useContext2.format;
    var _useState = (0, import_react56.useState)(viewToFormValue(view)), formValue = _useState[0], setFormValue = _useState[1];
    var _useState2 = (0, import_react56.useState)(), changed = _useState2[0], setChanged = _useState2[1];
    var onSubmit = (0, import_react56.useCallback)(function(_ref2) {
      var value = _ref2.value, touched = _ref2.touched;
      var nextValue = normalizeValue(value, formValue, views);
      resetPage(nextValue, formValue);
      setFormValue(nextValue);
      setChanged(false);
      if (onTouched)
        onTouched(transformTouched(touched, nextValue));
      onView(formValueToView(nextValue, views));
      if (onDone)
        onDone();
    }, [formValue, onDone, onTouched, onView, views]);
    var onChange2 = (0, import_react56.useCallback)(function(value, _ref3) {
      var touched = _ref3.touched;
      var nextValue = normalizeValue(value, formValue, views);
      resetPage(nextValue, formValue);
      setFormValue(nextValue);
      setChanged(true);
      if (updateOn === "change") {
        if (onTouched)
          onTouched(transformTouched(touched, nextValue));
        onView(formValueToView(nextValue, views));
      }
    }, [formValue, onTouched, onView, updateOn, views]);
    var onReset = (0, import_react56.useCallback)(function() {
      setFormValue(viewToFormValue(view));
      setChanged(false);
    }, [view]);
    (0, import_react56.useEffect)(function() {
      return setFormValue(viewToFormValue(view));
    }, [view]);
    return /* @__PURE__ */ import_react56.default.createElement(MaxForm, _extends47({}, rest, {
      value: formValue,
      onSubmit: updateOn === "submit" ? onSubmit : void 0,
      onChange: onChange2
    }), /* @__PURE__ */ import_react56.default.createElement(Box, {
      fill: "vertical"
    }, /* @__PURE__ */ import_react56.default.createElement(Box, {
      flex: true,
      overflow: "auto",
      pad: {
        horizontal: pad,
        top: pad
      }
    }, children), footer !== false && updateOn === "submit" && /* @__PURE__ */ import_react56.default.createElement(Footer, {
      flex: false,
      margin: {
        top: "small"
      },
      pad: {
        horizontal: pad,
        bottom: pad
      },
      gap: "small"
    }, /* @__PURE__ */ import_react56.default.createElement(Button2, {
      label: format4({
        id: "dataForm.submit",
        messages: messages == null ? void 0 : messages.dataForm
      }),
      type: "submit",
      primary: true
    }), /* @__PURE__ */ import_react56.default.createElement(HideableButton, _extends47({
      label: format4({
        id: "dataForm.reset",
        messages: messages == null ? void 0 : messages.dataForm
      }),
      type: "reset",
      onClick: onReset
    }, !changed ? hideButtonProps : {})))));
  };

  // node_modules/grommet/es6/components/DataSort/DataSort.js
  var import_react59 = __toESM(require_react());
  var import_Descend = __toESM(require_Descend());

  // node_modules/grommet/es6/components/Select/Select.js
  var import_react58 = __toESM(require_react());
  var import_styled_components45 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/Select/SelectContainer.js
  var import_react57 = __toESM(require_react());
  var import_styled_components44 = __toESM(require_styled_components_browser_cjs());
  var _excluded35 = ["clear", "onClear", "name", "theme"];
  function _extends48() {
    _extends48 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends48.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose30(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var StyledButton2 = (0, import_styled_components44.default)(Button2).withConfig({
    displayName: "SelectContainer__StyledButton",
    componentId: "sc-1wi0ul8-0"
  })(["&:focus{", "}"], function(props) {
    return getHoverIndicatorStyle("background", props.theme);
  });
  var ClearButton = /* @__PURE__ */ (0, import_react57.forwardRef)(function(_ref, ref) {
    var clear = _ref.clear, onClear = _ref.onClear, name = _ref.name, theme = _ref.theme, rest = _objectWithoutPropertiesLoose30(_ref, _excluded35);
    var label = clear.label, position = clear.position;
    var align = position !== "bottom" ? "start" : "center";
    var buttonLabel = label || "Clear " + (name || "selection");
    return /* @__PURE__ */ import_react57.default.createElement(StyledButton2, _extends48({
      a11yTitle: buttonLabel + ". Or, press " + (position === "bottom" ? "shift tab" : "down arrow") + " to move to select options",
      fill: "horizontal",
      ref,
      onClick: onClear,
      focusIndicator: false
    }, rest), /* @__PURE__ */ import_react57.default.createElement(Box, _extends48({}, theme.select.clear.container, {
      align
    }), /* @__PURE__ */ import_react57.default.createElement(Text, theme.select.clear.text, buttonLabel)));
  });
  var SelectContainer = /* @__PURE__ */ (0, import_react57.forwardRef)(function(_ref2, ref) {
    var clear = _ref2.clear, _ref2$children = _ref2.children, children = _ref2$children === void 0 ? null : _ref2$children, disabled = _ref2.disabled, disabledKey = _ref2.disabledKey, dropHeight = _ref2.dropHeight, _ref2$emptySearchMess = _ref2.emptySearchMessage, emptySearchMessage = _ref2$emptySearchMess === void 0 ? "No matches found" : _ref2$emptySearchMess, id = _ref2.id, labelKey = _ref2.labelKey, multiple = _ref2.multiple, name = _ref2.name, onChange2 = _ref2.onChange, onKeyDown = _ref2.onKeyDown, onMore = _ref2.onMore, onSearch = _ref2.onSearch, optionIndexesInValue = _ref2.optionIndexesInValue, options2 = _ref2.options, allOptions = _ref2.allOptions, searchPlaceholder = _ref2.searchPlaceholder, search = _ref2.search, setSearch = _ref2.setSearch, selected = _ref2.selected, usingKeyboard = _ref2.usingKeyboard, _ref2$value = _ref2.value, value = _ref2$value === void 0 ? "" : _ref2$value, valueKey = _ref2.valueKey, _ref2$replace = _ref2.replace, replace = _ref2$replace === void 0 ? true : _ref2$replace;
    var theme = (0, import_react57.useContext)(import_styled_components44.ThemeContext) || defaultProps2.theme;
    var shouldShowClearButton = (0, import_react57.useCallback)(function(position) {
      var hasValue = Boolean(multiple && value ? value.length : value);
      var showAtPosition = position === "bottom" ? (clear == null ? void 0 : clear.position) === "bottom" : (clear == null ? void 0 : clear.position) !== "bottom";
      return clear && hasValue && showAtPosition;
    }, [clear, multiple, value]);
    var isDisabled2 = useDisabled(disabled, disabledKey, options2, valueKey || labelKey);
    var _useState = (0, import_react57.useState)(usingKeyboard && !shouldShowClearButton("top") ? 0 : -1), activeIndex = _useState[0], setActiveIndex = _useState[1];
    var _useState2 = (0, import_react57.useState)(usingKeyboard), keyboardNavigation = _useState2[0], setKeyboardNavigation = _useState2[1];
    var searchRef = (0, import_react57.useRef)();
    var optionsRef = (0, import_react57.useRef)();
    var clearRef = (0, import_react57.useRef)();
    var activeRef = (0, import_react57.useRef)();
    (0, import_react57.useEffect)(function() {
      var _activeRef$current;
      if (activeIndex >= 0)
        (_activeRef$current = activeRef.current) == null ? void 0 : _activeRef$current.focus();
    }, [activeIndex]);
    (0, import_react57.useEffect)(function() {
      var timer = setTimeout(function() {
        var optionsNode = optionsRef.current;
        var clearButton = clearRef.current;
        if (onSearch) {
          var searchInput = searchRef.current;
          if (searchInput && searchInput.focus) {
            setFocusWithoutScroll(searchInput);
          }
        } else if (clear && clearButton && clearButton.focus && clear.position !== "bottom") {
          setFocusWithoutScroll(clearButton);
        } else if (usingKeyboard && activeRef.current) {
          setFocusWithoutScroll(activeRef.current);
        } else if (optionsNode) {
          setFocusWithoutScroll(optionsNode);
        }
      }, 100);
      return function() {
        return clearTimeout(timer);
      };
    }, [onSearch, usingKeyboard, clear]);
    var isSelected = (0, import_react57.useCallback)(function(index) {
      var result;
      if (selected) {
        result = selected.indexOf(index) !== -1;
      } else {
        var optionVal = getOptionValue(index, options2, valueKey);
        if (Array.isArray(value)) {
          if (value.length === 0) {
            result = false;
          } else if (typeof value[0] !== "object") {
            result = value.indexOf(optionVal) !== -1;
          } else if (valueKey) {
            result = value.some(function(valueItem) {
              var valueValue2 = typeof valueKey === "function" ? valueKey(valueItem) : valueItem[valueKey] || valueItem[valueKey.key];
              return valueValue2 === optionVal;
            });
          }
        } else if (valueKey && value !== null && typeof value === "object") {
          var valueValue = typeof valueKey === "function" ? valueKey(value) : value[valueKey];
          result = valueValue === optionVal;
        } else {
          result = value === optionVal;
        }
      }
      return result;
    }, [selected, value, valueKey, options2]);
    var selectOption = (0, import_react57.useCallback)(function(index) {
      return function(event) {
        if (onChange2) {
          var nextValue;
          var nextSelected;
          if (multiple) {
            var nextOptionIndexesInValue = optionIndexesInValue.slice(0);
            var allOptionsIndex = allOptions.indexOf(options2[index]);
            var valueIndex = optionIndexesInValue.indexOf(allOptionsIndex);
            if (valueIndex === -1) {
              nextOptionIndexesInValue.push(allOptionsIndex);
            } else {
              nextOptionIndexesInValue.splice(valueIndex, 1);
            }
            nextValue = nextOptionIndexesInValue.map(function(i) {
              return valueKey && valueKey.reduce ? applyKey(allOptions[i], valueKey) : allOptions[i];
            });
            nextSelected = nextOptionIndexesInValue;
          } else {
            nextValue = valueKey && valueKey.reduce ? applyKey(options2[index], valueKey) : options2[index];
            nextSelected = index;
          }
          onChange2(event, {
            option: options2[index],
            value: nextValue,
            selected: nextSelected
          });
        }
      };
    }, [multiple, onChange2, optionIndexesInValue, options2, allOptions, valueKey]);
    var onClear = (0, import_react57.useCallback)(function(event) {
      onChange2(event, {
        option: void 0,
        value: "",
        selected: ""
      });
    }, [onChange2]);
    var onNextOption = (0, import_react57.useCallback)(function(event) {
      event.preventDefault();
      var nextActiveIndex = activeIndex + 1;
      while (nextActiveIndex < options2.length && isDisabled2(nextActiveIndex)) {
        nextActiveIndex += 1;
      }
      if (nextActiveIndex !== options2.length) {
        setActiveIndex(nextActiveIndex);
        setKeyboardNavigation(true);
      }
    }, [activeIndex, options2, isDisabled2]);
    var onPreviousOption = (0, import_react57.useCallback)(function(event) {
      event.preventDefault();
      var nextActiveIndex = activeIndex - 1;
      if (nextActiveIndex === -1) {
        var searchInput = searchRef.current;
        var clearButton = clearRef.current;
        if (clearButton && clearButton.focus && shouldShowClearButton("top")) {
          setActiveIndex(nextActiveIndex);
          setFocusWithoutScroll(clearButton);
        } else if (searchInput && searchInput.focus) {
          setActiveIndex(nextActiveIndex);
          setFocusWithoutScroll(searchInput);
        }
      }
      while (nextActiveIndex >= 0 && isDisabled2(nextActiveIndex)) {
        nextActiveIndex -= 1;
      }
      if (nextActiveIndex >= 0) {
        setActiveIndex(nextActiveIndex);
        setKeyboardNavigation(true);
      }
    }, [activeIndex, isDisabled2, shouldShowClearButton]);
    var onKeyDownOption = (0, import_react57.useCallback)(function(event) {
      if (!onSearch) {
        var nextActiveIndex = options2.findIndex(function(e, index) {
          var label;
          if (typeof e === "object") {
            label = e.label || applyKey(e, labelKey);
          } else {
            label = e;
          }
          return typeof label === "string" && label.charAt(0).toLowerCase() === event.key.toLowerCase() && !isDisabled2(index);
        });
        if (nextActiveIndex >= 0) {
          event.preventDefault();
          setActiveIndex(nextActiveIndex);
          setKeyboardNavigation(true);
        }
      }
      if (onKeyDown) {
        onKeyDown(event);
      }
    }, [isDisabled2, labelKey, onKeyDown, options2, onSearch]);
    var onActiveOption = (0, import_react57.useCallback)(function(index) {
      return function() {
        if (!keyboardNavigation)
          setActiveIndex(index);
      };
    }, [keyboardNavigation]);
    var onSelectOption = (0, import_react57.useCallback)(function(event) {
      if ((shouldShowClearButton("bottom") || shouldShowClearButton("top")) && containsFocus(clearRef.current)) {
        onChange2(event, {
          option: void 0,
          value: "",
          selected: ""
        });
      } else if (activeIndex >= 0 && activeIndex < options2.length) {
        event.preventDefault();
        selectOption(activeIndex)(event);
      }
    }, [activeIndex, selectOption, options2, onChange2, shouldShowClearButton]);
    var customSearchInput = theme.select.searchInput;
    var SelectTextInput2 = customSearchInput || TextInput;
    var selectOptionsStyle = theme.select.options ? _extends48({}, theme.select.options.box, theme.select.options.container) : {};
    return /* @__PURE__ */ import_react57.default.createElement(Keyboard, {
      onEnter: onSelectOption,
      onSpace: onSelectOption,
      onUp: onPreviousOption,
      onDown: onNextOption,
      onKeyDown: onKeyDownOption
    }, /* @__PURE__ */ import_react57.default.createElement(StyledContainer2, {
      ref,
      as: Box,
      id: id ? id + "__select-drop" : void 0,
      dropHeight
    }, onSearch && /* @__PURE__ */ import_react57.default.createElement(Box, {
      pad: !customSearchInput ? "xsmall" : void 0,
      flex: false
    }, /* @__PURE__ */ import_react57.default.createElement(SelectTextInput2, {
      focusIndicator: !customSearchInput,
      size: "small",
      ref: searchRef,
      type: "search",
      value: search || "",
      placeholder: searchPlaceholder,
      onChange: function onChange3(event) {
        var nextSearch = event.target.value;
        setSearch(nextSearch);
        setActiveIndex(-1);
        onSearch(nextSearch);
      }
    })), shouldShowClearButton("top") && /* @__PURE__ */ import_react57.default.createElement(ClearButton, {
      ref: clearRef,
      clear,
      name,
      onClear,
      onFocus: function onFocus() {
        return setActiveIndex(-1);
      },
      onMouseOver: function onMouseOver() {
        return setActiveIndex(-1);
      },
      theme
    }), /* @__PURE__ */ import_react57.default.createElement(OptionsContainer, {
      role: "listbox",
      tabIndex: "-1",
      ref: optionsRef,
      "aria-multiselectable": multiple,
      onMouseMove: function onMouseMove() {
        return setKeyboardNavigation(false);
      }
    }, options2.length > 0 ? /* @__PURE__ */ import_react57.default.createElement(InfiniteScroll, {
      items: options2,
      step: theme.select.step,
      onMore,
      replace,
      show: activeIndex !== -1 ? activeIndex : void 0
    }, function(option, index, optionRef) {
      var optionDisabled = isDisabled2(index);
      var optionSelected = isSelected(index);
      var optionActive = activeIndex === index;
      var child;
      var textComponent = false;
      if (children) {
        child = children(option, index, options2, {
          active: optionActive,
          disabled: optionDisabled,
          selected: optionSelected
        });
        if (typeof child === "string" || child.props && child.props.children && typeof child.props.children === "string")
          textComponent = true;
      } else if (theme.select.options) {
        child = /* @__PURE__ */ import_react57.default.createElement(Box, selectOptionsStyle, /* @__PURE__ */ import_react57.default.createElement(Text, theme.select.options.text, getOptionLabel(index, options2, labelKey)));
        textComponent = true;
      }
      return /* @__PURE__ */ import_react57.default.createElement(
        SelectOption,
        {
          key: index,
          ref: function ref2(node) {
            if (optionRef)
              optionRef.current = node;
            if (optionActive)
              activeRef.current = node;
          },
          tabIndex: optionSelected ? "0" : "-1",
          role: "option",
          "aria-setsize": options2.length,
          "aria-posinset": index + 1,
          "aria-selected": optionSelected,
          focusIndicator: false,
          "aria-disabled": optionDisabled || void 0,
          plain: !child ? void 0 : true,
          align: "start",
          kind: !child ? "option" : void 0,
          label: !child ? getOptionLabel(index, options2, labelKey || valueKey) : void 0,
          disabled: optionDisabled || void 0,
          active: optionActive,
          selected: optionSelected,
          onFocus: function onFocus() {
            return setActiveIndex(index);
          },
          onMouseOver: !optionDisabled ? onActiveOption(index) : void 0,
          onClick: !optionDisabled ? selectOption(index) : void 0,
          textComponent
        },
        child
      );
    }) : /* @__PURE__ */ import_react57.default.createElement(EmptySearchOption, {
      emptySearchMessage,
      selectOptionsStyle,
      theme
    })), shouldShowClearButton("bottom") && /* @__PURE__ */ import_react57.default.createElement(ClearButton, {
      ref: clearRef,
      clear,
      name,
      onClear,
      onFocus: function onFocus() {
        return setActiveIndex(-1);
      },
      onMouseOver: function onMouseOver() {
        return setActiveIndex(-1);
      },
      theme
    })));
  });

  // node_modules/grommet/es6/components/Select/Select.js
  var _excluded36 = ["a11yTitle", "aria-label", "alignSelf", "children", "clear", "closeOnChange", "defaultValue", "disabled", "disabledKey", "dropAlign", "dropHeight", "dropProps", "dropTarget", "emptySearchMessage", "focusIndicator", "gridArea", "id", "icon", "labelKey", "margin", "messages", "multiple", "name", "onBlur", "onChange", "onClick", "onClose", "onFocus", "onKeyDown", "onMore", "onOpen", "onSearch", "open", "options", "placeholder", "plain", "replace", "searchPlaceholder", "selected", "size", "value", "valueKey", "valueLabel"];
  function _extends49() {
    _extends49 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends49.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose31(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  StyledSelectDropButton.defaultProps = {};
  Object.setPrototypeOf(StyledSelectDropButton.defaultProps, defaultProps2);
  var defaultDropAlign3 = {
    top: "bottom",
    left: "left"
  };
  var Select = /* @__PURE__ */ (0, import_react58.forwardRef)(function(_ref, ref) {
    var a11yTitle = _ref.a11yTitle, ariaLabel = _ref["aria-label"], alignSelf = _ref.alignSelf, children = _ref.children, _ref$clear = _ref.clear, clear = _ref$clear === void 0 ? false : _ref$clear, _ref$closeOnChange = _ref.closeOnChange, closeOnChange = _ref$closeOnChange === void 0 ? true : _ref$closeOnChange, defaultValue6 = _ref.defaultValue, disabled = _ref.disabled, disabledKey = _ref.disabledKey, _ref$dropAlign = _ref.dropAlign, dropAlign = _ref$dropAlign === void 0 ? defaultDropAlign3 : _ref$dropAlign, dropHeight = _ref.dropHeight, dropProps4 = _ref.dropProps, dropTarget = _ref.dropTarget, emptySearchMessage = _ref.emptySearchMessage, focusIndicator = _ref.focusIndicator, gridArea = _ref.gridArea, id = _ref.id, icon = _ref.icon, labelKeyProp = _ref.labelKey, margin = _ref.margin, messages = _ref.messages, multiple = _ref.multiple, name = _ref.name, onBlur = _ref.onBlur, onChange2 = _ref.onChange, onClick = _ref.onClick, onClose = _ref.onClose, onFocus = _ref.onFocus, onKeyDown = _ref.onKeyDown, onMore = _ref.onMore, onOpen = _ref.onOpen, onSearch = _ref.onSearch, propOpen = _ref.open, optionsProp = _ref.options, placeholder = _ref.placeholder, plain = _ref.plain, replace = _ref.replace, searchPlaceholder = _ref.searchPlaceholder, selected = _ref.selected, size = _ref.size, valueProp = _ref.value, valueKeyProp = _ref.valueKey, valueLabel = _ref.valueLabel, rest = _objectWithoutPropertiesLoose31(_ref, _excluded36);
    var theme = (0, import_react58.useContext)(import_styled_components45.ThemeContext) || defaultProps2.theme;
    var inputRef = (0, import_react58.useRef)();
    var formContext = (0, import_react58.useContext)(FormContext);
    var _useContext = (0, import_react58.useContext)(MessageContext), format4 = _useContext.format;
    var valueKey = valueKeyProp || labelKeyProp;
    var labelKey = labelKeyProp || valueKeyProp;
    var usingKeyboard = useKeyboard();
    var _formContext$useFormI = formContext.useFormInput({
      name,
      value: valueProp,
      initialValue: defaultValue6 || ""
    }), value = _formContext$useFormI[0], setValue3 = _formContext$useFormI[1];
    var normalizedValue = (0, import_react58.useMemo)(function() {
      return getNormalizedValue(value, valueKey);
    }, [value, valueKey]);
    var _useState = (0, import_react58.useState)(), search = _useState[0], setSearch = _useState[1];
    var _useState2 = (0, import_react58.useState)(optionsProp), allOptions = _useState2[0], setAllOptions = _useState2[1];
    (0, import_react58.useEffect)(function() {
      if (!search)
        setAllOptions(optionsProp);
    }, [optionsProp, search]);
    var optionIndexesInValue = (0, import_react58.useMemo)(function() {
      var result = [];
      allOptions.forEach(function(option, index) {
        if (selected !== void 0) {
          if (Array.isArray(selected)) {
            if (selected.indexOf(index) !== -1)
              result.push(index);
          } else if (index === selected) {
            result.push(index);
          }
        } else if (Array.isArray(normalizedValue)) {
          if (normalizedValue.some(function(v) {
            return v === applyKey(option, valueKey);
          })) {
            result.push(index);
          }
        } else if (normalizedValue === applyKey(option, valueKey)) {
          result.push(index);
        }
      });
      return result;
    }, [allOptions, selected, valueKey, normalizedValue]);
    var _useState3 = (0, import_react58.useState)(propOpen), open = _useState3[0], setOpen = _useState3[1];
    (0, import_react58.useEffect)(function() {
      return setOpen(propOpen);
    }, [propOpen]);
    var onRequestOpen = (0, import_react58.useCallback)(function() {
      if (open)
        return;
      setOpen(true);
      if (onOpen)
        onOpen();
    }, [onOpen, open]);
    var onRequestClose = (0, import_react58.useCallback)(function() {
      setOpen(false);
      if (onClose)
        onClose();
      setSearch();
    }, [onClose]);
    var triggerChangeEvent = (0, import_react58.useCallback)(function(nextValue) {
      return changeEvent(inputRef, nextValue);
    }, []);
    var onSelectChange = (0, import_react58.useCallback)(function(event, _ref2) {
      var option = _ref2.option, nextValue = _ref2.value, nextSelected = _ref2.selected;
      if (closeOnChange)
        onRequestClose();
      if ((typeof nextValue !== "object" || multiple) && nextValue !== event.target.value && inputRef.current) {
        triggerChangeEvent(nextValue);
      }
      setValue3(nextValue);
      if (onChange2) {
        event.persist();
        var adjustedEvent;
        if (event instanceof Event) {
          adjustedEvent = new event.constructor(event.type, event);
          Object.defineProperties(adjustedEvent, {
            target: {
              value: inputRef.current
            },
            value: {
              value: nextValue
            },
            option: {
              value: option
            },
            selected: {
              value: nextSelected
            }
          });
        } else {
          adjustedEvent = event;
          adjustedEvent.target = inputRef.current;
          adjustedEvent.value = nextValue;
          adjustedEvent.option = option;
          adjustedEvent.selected = nextSelected;
        }
        onChange2(adjustedEvent);
      }
    }, [closeOnChange, multiple, onChange2, onRequestClose, setValue3, triggerChangeEvent]);
    var SelectIcon = getSelectIcon(icon, theme, open);
    var selectValue = (0, import_react58.useMemo)(function() {
      if (valueLabel instanceof Function) {
        if (value)
          return valueLabel(value);
      } else if (valueLabel)
        return valueLabel;
      else if (/* @__PURE__ */ import_react58.default.isValidElement(value))
        return value;
      return void 0;
    }, [value, valueLabel]);
    var displayLabelKey = (0, import_react58.useMemo)(function() {
      return getDisplayLabelKey(labelKey, allOptions, optionIndexesInValue, selectValue);
    }, [labelKey, allOptions, optionIndexesInValue, selectValue]);
    var inputValue = (0, import_react58.useMemo)(function() {
      if (!selectValue) {
        if (optionIndexesInValue.length === 0)
          return "";
        if (optionIndexesInValue.length === 1)
          return applyKey(allOptions[optionIndexesInValue[0]], labelKey);
        return format4({
          id: "select.multiple",
          messages
        });
      }
      return void 0;
    }, [labelKey, messages, format4, optionIndexesInValue, allOptions, selectValue]);
    var iconColor = getIconColor3(theme);
    return /* @__PURE__ */ import_react58.default.createElement(Keyboard, {
      onDown: onRequestOpen,
      onUp: onRequestOpen
    }, /* @__PURE__ */ import_react58.default.createElement(StyledSelectDropButton, {
      ref,
      a11yTitle: "" + (ariaLabel || a11yTitle || placeholder || "Open Drop") + (value ? format4({
        id: "select.selected",
        messages,
        values: {
          currentSelectedValue: value
        }
      }) : ""),
      "aria-expanded": Boolean(open),
      "aria-haspopup": "listbox",
      id,
      disabled: disabled === true || void 0,
      dropAlign,
      dropTarget,
      open,
      alignSelf,
      focusIndicator,
      onFocus,
      onBlur,
      gridArea,
      margin,
      onOpen: onRequestOpen,
      onClose: onRequestClose,
      onClick,
      dropContent: /* @__PURE__ */ import_react58.default.createElement(SelectContainer, {
        clear,
        disabled,
        disabledKey,
        dropHeight,
        emptySearchMessage,
        id,
        labelKey,
        multiple,
        name,
        onChange: onSelectChange,
        onKeyDown,
        onMore,
        onSearch,
        options: optionsProp,
        allOptions,
        optionIndexesInValue,
        replace,
        searchPlaceholder,
        search,
        setSearch,
        selected,
        usingKeyboard,
        value,
        valueKey
      }, children),
      plainSelect: plain,
      plain: true,
      dropProps: dropProps4,
      theme
    }, /* @__PURE__ */ import_react58.default.createElement(Box, {
      align: "center",
      direction: "row",
      justify: "between",
      background: theme.select.background
    }, /* @__PURE__ */ import_react58.default.createElement(Box, {
      direction: "row",
      flex: true,
      basis: "auto"
    }, selectValue || displayLabelKey ? /* @__PURE__ */ import_react58.default.createElement(import_react58.default.Fragment, null, selectValue || displayLabelKey, /* @__PURE__ */ import_react58.default.createElement(HiddenInput, {
      type: "text",
      name,
      id: id ? id + "__input" : void 0,
      value: inputValue,
      ref: inputRef,
      readOnly: true
    })) : /* @__PURE__ */ import_react58.default.createElement(DefaultSelectTextInput, _extends49({
      a11yTitle: (ariaLabel || a11yTitle) && "" + (ariaLabel || a11yTitle) + (value && typeof value === "string" ? ", " + value : ""),
      disabled,
      id,
      name,
      ref: inputRef,
      placeholder,
      value: inputValue,
      size,
      theme
    }, rest))), SelectIcon && /* @__PURE__ */ import_react58.default.createElement(Box, {
      margin: theme.select.icons.margin,
      flex: false,
      style: {
        minWidth: "auto"
      }
    }, /* @__PURE__ */ (0, import_react58.isValidElement)(SelectIcon) ? SelectIcon : /* @__PURE__ */ import_react58.default.createElement(SelectIcon, {
      color: iconColor,
      size
    })))));
  });
  Select.defaultProps = _extends49({}, defaultProps2);
  Select.displayName = "Select";
  Select.propTypes = SelectPropTypes;

  // node_modules/grommet/es6/components/DataSort/propTypes.js
  var import_prop_types29 = __toESM(require_prop_types());
  var PropType27 = {};
  if (true) {
    PropType27 = {
      drop: import_prop_types29.default.bool
    };
  }
  var DataSortPropTypes = PropType27;

  // node_modules/grommet/es6/components/DataSort/DataSort.js
  var _excluded37 = ["drop", "options"];
  function _extends50() {
    _extends50 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends50.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose32(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var dropProps = {
    align: {
      top: "bottom",
      left: "left"
    }
  };
  var Content = function Content2(_ref) {
    var optionsArg = _ref.options;
    var _useContext = (0, import_react59.useContext)(DataContext), data = _useContext.data, dataId = _useContext.id, messages = _useContext.messages, properties = _useContext.properties;
    var _useContext2 = (0, import_react59.useContext)(MessageContext), format4 = _useContext2.format;
    var options2 = (0, import_react59.useMemo)(function() {
      return optionsArg || properties && Object.keys(properties).sort() || Object.keys(data[0]).sort();
    }, [data, optionsArg, properties]);
    var directionOptions = [{
      label: format4({
        id: "dataSort.ascending",
        messages: messages == null ? void 0 : messages.dataSort
      }),
      value: "asc"
    }, {
      label: format4({
        id: "dataSort.descending",
        messages: messages == null ? void 0 : messages.dataSort
      }),
      value: "desc"
    }];
    var sortPropertyId = dataId + "--sort-property";
    var sortDirectionId = dataId + "--sort-direction";
    return [/* @__PURE__ */ import_react59.default.createElement(FormField, {
      key: "by",
      htmlFor: sortPropertyId,
      label: format4({
        id: "dataSort.by",
        messages: messages == null ? void 0 : messages.dataSort
      })
    }, /* @__PURE__ */ import_react59.default.createElement(Select, {
      id: sortPropertyId,
      name: "_sort.property",
      options: options2
    })), /* @__PURE__ */ import_react59.default.createElement(FormField, {
      key: "dir",
      htmlFor: sortDirectionId,
      label: format4({
        id: "dataSort.direction",
        messages: messages == null ? void 0 : messages.dataSort
      })
    }, /* @__PURE__ */ import_react59.default.createElement(RadioButtonGroup, {
      id: sortDirectionId,
      name: "_sort.direction",
      options: directionOptions
    }))];
  };
  var DataSort = function DataSort2(_ref2) {
    var drop = _ref2.drop, options2 = _ref2.options, rest = _objectWithoutPropertiesLoose32(_ref2, _excluded37);
    var _useContext3 = (0, import_react59.useContext)(DataContext), dataId = _useContext3.id, messages = _useContext3.messages;
    var _useContext4 = (0, import_react59.useContext)(FormContext), noForm = _useContext4.noForm;
    var _useContext5 = (0, import_react59.useContext)(MessageContext), format4 = _useContext5.format;
    var _useState = (0, import_react59.useState)(), showContent = _useState[0], setShowContent = _useState[1];
    var content = /* @__PURE__ */ import_react59.default.createElement(Content, {
      options: options2
    });
    if (noForm)
      content = /* @__PURE__ */ import_react59.default.createElement(DataForm, {
        footer: false
      }, content);
    if (!drop)
      return content;
    var control = /* @__PURE__ */ import_react59.default.createElement(DropButton, _extends50({
      id: dataId + "--sort-control",
      "aria-label": format4({
        id: "dataSort.open",
        messages: messages == null ? void 0 : messages.dataSort
      }),
      kind: "toolbar",
      icon: /* @__PURE__ */ import_react59.default.createElement(import_Descend.Descend, null),
      dropProps,
      dropContent: /* @__PURE__ */ import_react59.default.createElement(Box, {
        pad: "small"
      }, content),
      open: showContent,
      onOpen: function onOpen() {
        return setShowContent(void 0);
      },
      onClose: function onClose() {
        return setShowContent(void 0);
      }
    }, rest));
    return control;
  };
  DataSort.propTypes = DataSortPropTypes;

  // node_modules/grommet/es6/components/Layer/Layer.js
  var import_react61 = __toESM(require_react());
  var import_react_dom2 = __toESM(require_react_dom());

  // node_modules/grommet/es6/components/Layer/LayerContainer.js
  var import_react60 = __toESM(require_react());
  var import_styled_components47 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/Layer/StyledLayer.js
  var import_styled_components46 = __toESM(require_styled_components_browser_cjs());
  var hiddenPositionStyle = (0, import_styled_components46.css)(["left:-100%;right:100%;z-index:-1;position:fixed;"]);
  var desktopLayerStyle = "\n  position: fixed;\n  top: 0px;\n  left: 0px;\n  right: 0px;\n  bottom: 0px;\n";
  var responsiveLayerStyle = "\n  position: fixed;\n  width: 100%;\n  height: 100%;\n  min-height: 100vh;\n";
  var StyledLayer = import_styled_components46.default.div.withConfig({
    displayName: "StyledLayer",
    componentId: "sc-rmtehz-0"
  })(["", " background:transparent;position:relative;z-index:", ";pointer-events:none;outline:none;", " ", ";"], baseStyle, function(props) {
    return props.theme.layer.zIndex;
  }, function(props) {
    if (props.position === "hidden") {
      return hiddenPositionStyle;
    }
    var styles = [];
    styles.push(desktopLayerStyle);
    if (props.responsive && props.theme.layer.responsiveBreakpoint && !props.layerTarget) {
      var breakpoint = props.theme.global.breakpoints[props.theme.layer.responsiveBreakpoint];
      styles.push(breakpointStyle(breakpoint, responsiveLayerStyle));
    }
    return styles;
  }, function(props) {
    return props.theme.layer && props.theme.layer.extend;
  });
  StyledLayer.defaultProps = {};
  Object.setPrototypeOf(StyledLayer.defaultProps, defaultProps2);
  var StyledOverlay = import_styled_components46.default.div.withConfig({
    displayName: "StyledLayer__StyledOverlay",
    componentId: "sc-rmtehz-1"
  })(["position:absolute;", " top:0px;left:0px;right:0px;bottom:0px;", " ", " pointer-events:all;will-change:transform;"], function(props) {
    if (props.responsive && props.theme.layer.responsiveBreakpoint) {
      var breakpoint = props.theme.global.breakpoints[props.theme.layer.responsiveBreakpoint];
      return breakpointStyle(breakpoint, "position: relative;");
    }
    return "";
  }, function(props) {
    return props.theme.layer.overlay.backdropFilter && "backdrop-filter: " + props.theme.layer.overlay.backdropFilter + ";";
  }, function(props) {
    return !props.plain && props.theme.layer.overlay.background && backgroundStyle(props.theme.layer.overlay.background, props.theme);
  });
  var getMargin = function getMargin2(margin, theme, position) {
    var axis = position.indexOf("top") !== -1 || position.indexOf("bottom") !== -1 ? "vertical" : "horizontal";
    var marginValue = margin[position] || margin[axis] || margin;
    var marginApplied = theme.global.edgeSize[marginValue] || marginValue;
    var marginInTheme = !!theme.global.edgeSize[marginValue];
    return !marginInTheme && typeof marginValue !== "string" ? 0 : parseMetricToNum(marginApplied);
  };
  var getBounds = function getBounds2(bounds2, margin, theme, position) {
    if (position === void 0) {
      position = void 0;
    }
    if (position) {
      return bounds2[position] + getMargin(margin, theme, position);
    }
    return {
      bottom: bounds2.bottom + getMargin(margin, theme, "bottom"),
      // 'bottom-left': getMargin(margin, theme, 'bottom-left'),
      // 'bottom-right': getMargin(margin, theme, 'bottom-right'),
      end: bounds2.right + getMargin(margin, theme, "end"),
      left: bounds2.left + getMargin(margin, theme, "left"),
      right: bounds2.right + getMargin(margin, theme, "right"),
      start: bounds2.left + getMargin(margin, theme, "start"),
      top: bounds2.top + getMargin(margin, theme, "top")
      // 'top-right': getMargin(margin, theme, 'top-right'),
      // 'top-left': getMargin(margin, theme, 'top-left'),
    };
  };
  var KEYFRAMES = {
    center: {
      vertical: (0, import_styled_components46.keyframes)(["0%{transform:translateX(-50%) scale(0.8);}100%{transform:translateX(-50%) scale(1);}"]),
      horizontal: (0, import_styled_components46.keyframes)(["0%{transform:translateY(-50%) scale(0.8);}100%{transform:translateY(-50) scale(1);}"]),
      "true": (0, import_styled_components46.keyframes)(["0%{transform:scale(0.8);}100%{transform:scale(1);}"]),
      "false": (0, import_styled_components46.keyframes)(["0%{transform:translate(-50%,-50%) scale(0.8);}100%{transform:translate(-50%,-50%) scale(1);}"])
    },
    top: {
      vertical: (0, import_styled_components46.keyframes)(["0%{transform:translate(-50%,-100%);}100%{transform:translate(-50%,0);}"]),
      horizontal: (0, import_styled_components46.keyframes)(["0%{transform:translateY(-100%);}100%{transform:translateY(0);}"]),
      "true": (0, import_styled_components46.keyframes)(["0%{transform:translateY(-100%);}100%{transform:translateY(0);}"]),
      "false": (0, import_styled_components46.keyframes)(["0%{transform:translate(-50%,-100%);}100%{transform:translate(-50%,0);}"])
    },
    bottom: {
      vertical: (0, import_styled_components46.keyframes)(["0%{transform:translate(-50%,100%);}100%{transform:translate(-50%,0);}"]),
      horizontal: (0, import_styled_components46.keyframes)(["0%{transform:translateY(100%);}100%{transform:translateY(0);}"]),
      "true": (0, import_styled_components46.keyframes)(["0%{transform:translateY(100%);}100%{transform:translateY(0);}"]),
      "false": (0, import_styled_components46.keyframes)(["0%{transform:translate(-50%,100%);}100%{transform:translate(-50%,0);}"])
    },
    left: {
      vertical: (0, import_styled_components46.keyframes)(["0%{transform:translateX(-100%);}100%{transform:translateX(0);}"]),
      horizontal: (0, import_styled_components46.keyframes)(["0%{transform:translate(-100%,-50%);}100%{transform:translate(0,-50%);}"]),
      "true": (0, import_styled_components46.keyframes)(["0%{transform:translateX(-100%);}100%{transform:translateX(0);}"]),
      "false": (0, import_styled_components46.keyframes)(["0%{transform:translate(-100%,-50%);}100%{transform:translate(0,-50%);}"])
    },
    right: {
      vertical: (0, import_styled_components46.keyframes)(["0%{transform:translateX(100%);}100%{transform:translateX(0);}"]),
      horizontal: (0, import_styled_components46.keyframes)(["0%{transform:translate(100%,-50%);}100%{transform:translate(0,-50%);}"]),
      "true": (0, import_styled_components46.keyframes)(["0%{transform:translateX(100%);}100%{transform:translateX(0);}"]),
      "false": (0, import_styled_components46.keyframes)(["0%{transform:translate(100%,-50%);}100%{transform:translate(0,-50%);}"])
    },
    start: {
      vertical: (0, import_styled_components46.keyframes)(["0%{transform:translateX(-100%);}100%{transform:translateX(0);}"]),
      horizontal: (0, import_styled_components46.keyframes)(["0%{transform:translate(-100%,-50%);}100%{transform:translate(0,-50%);}"]),
      "true": (0, import_styled_components46.keyframes)(["0%{transform:translateX(-100%);}100%{transform:translateX(0);}"]),
      "false": (0, import_styled_components46.keyframes)(["0%{transform:translate(-100%,-50%);}100%{transform:translate(0,-50%);}"])
    },
    end: {
      vertical: (0, import_styled_components46.keyframes)(["0%{transform:translateX(100%);}100%{transform:translateX(0);}"]),
      horizontal: (0, import_styled_components46.keyframes)(["0%{transform:translate(100%,-50%);}100%{transform:translate(0,-50%);}"]),
      "true": (0, import_styled_components46.keyframes)(["0%{transform:translateX(100%);}100%{transform:translateX(0);}"]),
      "false": (0, import_styled_components46.keyframes)(["0%{transform:translate(100%,-50%);}100%{transform:translate(0,-50%);}"])
    }
  };
  var animationDuration = 200;
  var getAnimationStyle = function getAnimationStyle2(props, position, full) {
    var animation = props.animation !== void 0 ? props.animation : props.animate;
    if (animation === void 0)
      animation = "slide";
    var keys5;
    if (animation === "slide" || animation === true) {
      keys5 = KEYFRAMES[position][full];
    } else if (animation === "fadeIn") {
      keys5 = (0, import_styled_components46.keyframes)(["0%{opacity:0}100%{opacity:1}"]);
    }
    return keys5 ? (0, import_styled_components46.css)(["animation:", " ", "s ease-in-out forwards;"], keys5, animationDuration / 1e3) : "";
  };
  var POSITIONS = {
    center: {
      vertical: function vertical(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;left:50%;transform:translateX(-50%);", ""], bounds2.top, bounds2.bottom, function(props) {
          return getAnimationStyle(props, "center", "vertical");
        });
      },
      horizontal: function horizontal(bounds2) {
        return (0, import_styled_components46.css)(["left:", "px;right:", "px;top:50%;transform:translateY(-50%);", ""], bounds2.left, bounds2.right, function(props) {
          return getAnimationStyle(props, "center", "horizontal");
        });
      },
      "true": function _true(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;left:", "px;right:", "px;", ""], bounds2.top, bounds2.bottom, bounds2.left, bounds2.right, function(props) {
          return getAnimationStyle(props, "center", "true");
        });
      },
      "false": function _false() {
        return (0, import_styled_components46.css)(["top:50%;left:50%;transform:translate(-50%,-50%);", ""], function(props) {
          return getAnimationStyle(props, "center", "false");
        });
      }
    },
    top: {
      vertical: function vertical2(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;left:50%;transform:translate(-50%,0%);", ""], bounds2.top, bounds2.bottom, function(props) {
          return getAnimationStyle(props, "top", "vertical");
        });
      },
      horizontal: function horizontal2(bounds2) {
        return (0, import_styled_components46.css)(["left:", "px;right:", "px;top:", "px;transform:translateY(0);", ""], bounds2.left, bounds2.right, bounds2.top, function(props) {
          return getAnimationStyle(props, "top", "horizontal");
        });
      },
      "true": function _true2(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;left:", "px;right:", "px;transform:translateY(0);", ""], bounds2.top, bounds2.bottom, bounds2.left, bounds2.right, function(props) {
          return getAnimationStyle(props, "top", "true");
        });
      },
      "false": function _false2(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;left:50%;transform:translate(-50%,0);", ""], bounds2.top, function(props) {
          return getAnimationStyle(props, "top", "false");
        });
      }
    },
    bottom: {
      vertical: function vertical3(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;left:50%;transform:translate(-50%,0);", ""], bounds2.top, bounds2.bottom, function(props) {
          return getAnimationStyle(props, "bottom", "vertical");
        });
      },
      horizontal: function horizontal3(bounds2) {
        return (0, import_styled_components46.css)(["left:", "px;right:", "px;bottom:", "px;transform:translateY(0);", ""], bounds2.left, bounds2.top, bounds2.bottom, function(props) {
          return getAnimationStyle(props, "bottom", "horizontal");
        });
      },
      "true": function _true3(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;left:", "px;right:", "px;transform:translateY(0);", ""], bounds2.top, bounds2.bottom, bounds2.left, bounds2.right, function(props) {
          return getAnimationStyle(props, "bottom", "true");
        });
      },
      "false": function _false3(bounds2) {
        return (0, import_styled_components46.css)(["bottom:", "px;left:50%;transform:translate(-50%,0);", ""], bounds2.bottom, function(props) {
          return getAnimationStyle(props, "bottom", "false");
        });
      }
    },
    left: {
      vertical: function vertical4(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;left:", "px;transform:translateX(0);", ""], bounds2.top, bounds2.bottom, bounds2.left, function(props) {
          return getAnimationStyle(props, "left", "vertical");
        });
      },
      horizontal: function horizontal4(bounds2) {
        return (0, import_styled_components46.css)(["left:", "px;right:", "px;top:50%;transform:translate(0,-50%);", ""], bounds2.left, bounds2.right, function(props) {
          return getAnimationStyle(props, "left", "horizontal");
        });
      },
      "true": function _true4(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;left:", "px;right:", "px;transform:translateX(0);", ""], bounds2.top, bounds2.bottom, bounds2.left, bounds2.right, function(props) {
          return getAnimationStyle(props, "left", "true");
        });
      },
      "false": function _false4(bounds2) {
        return (0, import_styled_components46.css)(["left:", "px;top:50%;transform:translate(0,-50%);", ""], bounds2.left, function(props) {
          return getAnimationStyle(props, "left", "false");
        });
      }
    },
    right: {
      vertical: function vertical5(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;right:", "px;transform:translateX(0);", ""], bounds2.top, bounds2.bottom, bounds2.right, function(props) {
          return getAnimationStyle(props, "right", "vertical");
        });
      },
      horizontal: function horizontal5(bounds2) {
        return (0, import_styled_components46.css)(["left:", "px;right:", "px;top:50%;transform:translate(0,-50%);", ""], bounds2.left, bounds2.right, function(props) {
          return getAnimationStyle(props, "right", "horizontal");
        });
      },
      "true": function _true5(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;left:", "px;right:", "px;transform:translateX(0);", ""], bounds2.top, bounds2.bottom, bounds2.left, bounds2.right, function(props) {
          return getAnimationStyle(props, "right", "true");
        });
      },
      "false": function _false5(bounds2) {
        return (0, import_styled_components46.css)(["right:", "px;top:50%;transform:translate(0,-50%);", ""], bounds2.right, function(props) {
          return getAnimationStyle(props, "right", "false");
        });
      }
    },
    start: {
      vertical: function vertical6(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;inset-inline-start:", "px;transform:translateX(0);", ""], bounds2.top, bounds2.bottom, bounds2.start, function(props) {
          return getAnimationStyle(props, "start", "vertical");
        });
      },
      horizontal: function horizontal6(bounds2) {
        return (0, import_styled_components46.css)(["inset-inline-start:", "px;inset-inline-end:", "px;top:50%;transform:translate(0,-50%);", ""], bounds2.start, bounds2.end, function(props) {
          return getAnimationStyle(props, "start", "horizontal");
        });
      },
      "true": function _true6(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;inset-inline-start:", "px;inset-inline-end:", "px;transform:translateX(0);", ""], bounds2.top, bounds2.bottom, bounds2.start, bounds2.end, function(props) {
          return getAnimationStyle(props, "start", "true");
        });
      },
      "false": function _false6(bounds2) {
        return (0, import_styled_components46.css)(["inset-inline-start:", "px;top:50%;transform:translate(0,-50%);", ""], bounds2.start, function(props) {
          return getAnimationStyle(props, "start", "false");
        });
      }
    },
    end: {
      vertical: function vertical7(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;inset-inline-end:", "px;transform:translateX(0);", ""], bounds2.top, bounds2.bottom, bounds2.end, function(props) {
          return getAnimationStyle(props, "end", "vertical");
        });
      },
      horizontal: function horizontal7(bounds2) {
        return (0, import_styled_components46.css)(["inset-inline-start:", "px;inset-inline-end:", "px;top:50%;transform:translate(0,-50%);", ""], bounds2.start, bounds2.end, function(props) {
          return getAnimationStyle(props, "end", "horizontal");
        });
      },
      "true": function _true7(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;inset-inline-start:", "px;inset-inline-end:", "px;transform:translateX(0);", ""], bounds2.top, bounds2.bottom, bounds2.start, bounds2.end, function(props) {
          return getAnimationStyle(props, "end", "true");
        });
      },
      "false": function _false7(bounds2) {
        return (0, import_styled_components46.css)(["inset-inline-end:", "px;top:50%;transform:translate(0,-50%);", ""], bounds2.end, function(props) {
          return getAnimationStyle(props, "end", "false");
        });
      }
    },
    "top-right": {
      vertical: function vertical8(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;right:", "px;transform:translateX(0);", ";"], bounds2.top, bounds2.bottom, bounds2.right, function(props) {
          return getAnimationStyle(props, "top", "true");
        });
      },
      horizontal: function horizontal8(bounds2) {
        return (0, import_styled_components46.css)(["left:", "px;right:", "px;top:0;transform:translateX(0);", ";"], bounds2.left, bounds2.right, function(props) {
          return getAnimationStyle(props, "top", "true");
        });
      },
      "true": function _true8(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;left:", "px;right:", "px;transform:translateX(0);", ";"], bounds2.top, bounds2.bottom, bounds2.left, bounds2.right, function(props) {
          return getAnimationStyle(props, "top", "true");
        });
      },
      "false": function _false8(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;right:", "px;transform:translateY(0);", ";"], bounds2.top, bounds2.right, function(props) {
          return getAnimationStyle(props, "top", "true");
        });
      }
    },
    "top-left": {
      vertical: function vertical9(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;left:", "px;transform:translateX(0);", ""], bounds2.top, bounds2.bottom, bounds2.left, function(props) {
          return getAnimationStyle(props, "top", "true");
        });
      },
      horizontal: function horizontal9(bounds2) {
        return (0, import_styled_components46.css)(["left:", "px;right:", "px;top:0;transform:translateX(0);", ""], bounds2.left, bounds2.right, function(props) {
          return getAnimationStyle(props, "top", "true");
        });
      },
      "true": function _true9(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;left:", "px;right:", "px;transform:translateX(0);", ""], bounds2.top, bounds2.bottom, bounds2.left, bounds2.right, function(props) {
          return getAnimationStyle(props, "top", "true");
        });
      },
      "false": function _false9(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;left:", "px;transform:translateY(0);", ""], bounds2.top, bounds2.left, function(props) {
          return getAnimationStyle(props, "top", "true");
        });
      }
    },
    "bottom-right": {
      vertical: function vertical10(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;right:", "px;transform:translateX(0);", ""], bounds2.top, bounds2.bottom, bounds2.right, function(props) {
          return getAnimationStyle(props, "bottom", "true");
        });
      },
      horizontal: function horizontal10(bounds2) {
        return (0, import_styled_components46.css)(["left:", "px;right:", "px;bottom:", "px;transform:translateY(0);", ""], bounds2.left, bounds2.right, bounds2.bottom, function(props) {
          return getAnimationStyle(props, "bottom", "true");
        });
      },
      "true": function _true10(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;left:", "px;right:", "px;transform:translateX(0);", ""], bounds2.top, bounds2.bottom, bounds2.left, bounds2.right, function(props) {
          return getAnimationStyle(props, "bottom", "true");
        });
      },
      "false": function _false10(bounds2) {
        return (0, import_styled_components46.css)(["bottom:", "px;right:", "px;transform:translateY(0);", ""], bounds2.bottom, bounds2.right, function(props) {
          return getAnimationStyle(props, "bottom", "true");
        });
      }
    },
    "bottom-left": {
      vertical: function vertical11(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;left:", "px;transform:translateX(0);", ""], bounds2.top, bounds2.bottom, bounds2.left, function(props) {
          return getAnimationStyle(props, "bottom", "true");
        });
      },
      horizontal: function horizontal11(bounds2) {
        return (0, import_styled_components46.css)(["left:", "px;right:", "px;bottom:", "px;transform:translateY(0);", ""], bounds2.left, bounds2.right, bounds2.bottom, function(props) {
          return getAnimationStyle(props, "bottom", "true");
        });
      },
      "true": function _true11(bounds2) {
        return (0, import_styled_components46.css)(["top:", "px;bottom:", "px;left:", "px;right:", "px;transform:translateX(0);", ""], bounds2.top, bounds2.bottom, bounds2.left, bounds2.right, function(props) {
          return getAnimationStyle(props, "bottom", "true");
        });
      },
      "false": function _false11(bounds2) {
        return (0, import_styled_components46.css)(["bottom:", "px;left:", "px;transform:translateY(0);", ""], bounds2.bottom, bounds2.left, function(props) {
          return getAnimationStyle(props, "bottom", "true");
        });
      }
    }
  };
  var roundStyle3 = function roundStyle4(data, theme, position, margin) {
    var styles = [];
    var size = data === true ? "medium" : data;
    var round2 = theme.global.edgeSize[size] || size;
    var customCSS = round2.split(" ").length > 1;
    if (margin === "none" && !customCSS && theme.layer.border.intelligentRounding === true) {
      if (position === "bottom") {
        styles.push((0, import_styled_components46.css)(["border-radius:", " ", " 0 0;"], round2, round2));
      } else if (position === "bottom-left") {
        styles.push((0, import_styled_components46.css)(["border-radius:0 ", " 0 0;"], round2));
      } else if (position === "bottom-right") {
        styles.push((0, import_styled_components46.css)(["border-radius:", " 0 0 0;"], round2));
      } else if (position === "end") {
        styles.push((0, import_styled_components46.css)(["border-start-start-radius:", ";border-end-start-radius:", ";"], round2, round2));
      } else if (position === "left") {
        styles.push((0, import_styled_components46.css)(["border-radius:0 ", " ", " 0;"], round2, round2));
      } else if (position === "right") {
        styles.push((0, import_styled_components46.css)(["border-radius:", " 0 0 ", ";"], round2, round2));
      } else if (position === "start") {
        styles.push((0, import_styled_components46.css)(["border-end-end-radius:", ";border-start-end-radius:", ";"], round2, round2));
      } else if (position === "top") {
        styles.push((0, import_styled_components46.css)(["border-radius:0 0 ", " ", ";"], round2, round2));
      } else if (position === "top-left") {
        styles.push((0, import_styled_components46.css)(["border-radius:0 0 ", " 0;"], round2));
      } else if (position === "top-right") {
        styles.push((0, import_styled_components46.css)(["border-radius:0 0 0 ", ";"], round2));
      } else {
        styles.push((0, import_styled_components46.css)(["border-radius:", ";"], round2));
      }
    } else {
      styles.push((0, import_styled_components46.css)(["border-radius:", ";"], round2));
    }
    return styles;
  };
  var bounds = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };
  var desktopContainerStyle = (0, import_styled_components46.css)(["", " max-height:", ";max-width:", ";", ";", ";"], function(props) {
    if (!props.modal && props.position === "hidden") {
      return hiddenPositionStyle;
    }
    return (0, import_styled_components46.css)(["position:", ";"], props.modal || props.layerTarget ? "absolute" : "fixed");
  }, function(props) {
    return "calc(100% - " + getBounds(bounds, props.margin, props.theme, "top") + "px - " + getBounds(bounds, props.margin, props.theme, "bottom") + "px)";
  }, function(props) {
    return "calc(100% - " + getBounds(bounds, props.margin, props.theme, "left") + "px - " + getBounds(bounds, props.margin, props.theme, "right") + "px)";
  }, function(props) {
    return props.plain || props.full && props.margin === "none" ? "border-radius: 0;" : roundStyle3(props.theme.layer.border.radius, props.theme, props.position, props.margin);
  }, function(props) {
    return props.position !== "hidden" && POSITIONS[props.position][props.full](getBounds(bounds, props.margin, props.theme), bounds) || "";
  });
  var responsiveContainerStyle = function responsiveContainerStyle2(props) {
    return (0, import_styled_components46.css)(["position:relative;max-height:none;max-width:none;border-radius:0;height:", ";width:", ";"], !props.layerTarget ? "100vh" : "100%", !props.layerTarget ? "100vw" : "100%");
  };
  var elevationStyle3 = (0, import_styled_components46.css)(["box-shadow:", ";"], function(props) {
    return props.theme.global.elevation[props.theme.dark ? "dark" : "light"][props.theme.layer.container.elevation];
  });
  var StyledContainer3 = import_styled_components46.default.div.withConfig({
    // don't let elevation leak to DOM
    // https://styled-components.com/docs/api#shouldforwardprop
    shouldForwardProp: function shouldForwardProp3(prop, defaultValidatorFn) {
      return !["elevation"].includes(prop) && defaultValidatorFn(prop);
    }
  }).withConfig({
    displayName: "StyledLayer__StyledContainer",
    componentId: "sc-rmtehz-2"
  })(["", " display:flex;flex-direction:column;min-height:", ";", " outline:none;pointer-events:all;z-index:", ";", " ", " ", ";", ";"], function(props) {
    return !props.modal ? baseStyle : "";
  }, function(props) {
    return props.theme.global.size.xxsmall;
  }, function(props) {
    return !props.plain && (props.background || props.theme.layer.background) && backgroundStyle(props.background || props.theme.layer.background, props.theme);
  }, function(props) {
    return props.theme.layer.container.zIndex;
  }, function(props) {
    return !props.plain && props.theme.layer.container.elevation && elevationStyle3;
  }, desktopContainerStyle, function(props) {
    if (props.responsive && props.theme.layer.responsiveBreakpoint) {
      var breakpoint = props.theme.global.breakpoints[props.theme.layer.responsiveBreakpoint];
      if (breakpoint) {
        return breakpointStyle(breakpoint, responsiveContainerStyle);
      }
    }
    return "";
  }, function(props) {
    return props.theme.layer.container && props.theme.layer.container.extend;
  });
  StyledContainer3.defaultProps = {};
  Object.setPrototypeOf(StyledContainer3.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/Layer/LayerContainer.js
  var _excluded38 = ["background", "children", "full", "id", "margin", "modal", "onClickOutside", "onEsc", "plain", "position", "responsive", "target"];
  function _extends51() {
    _extends51 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends51.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose33(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var HiddenAnchor = import_styled_components47.default.a.withConfig({
    displayName: "LayerContainer__HiddenAnchor",
    componentId: "sc-1srj14c-0"
  })(["width:0;height:0;overflow:hidden;position:absolute;"]);
  var LayerContainer = /* @__PURE__ */ (0, import_react60.forwardRef)(function(_ref, ref) {
    var background = _ref.background, children = _ref.children, _ref$full = _ref.full, full = _ref$full === void 0 ? false : _ref$full, id = _ref.id, _ref$margin = _ref.margin, margin = _ref$margin === void 0 ? "none" : _ref$margin, _ref$modal = _ref.modal, modal = _ref$modal === void 0 ? true : _ref$modal, onClickOutside = _ref.onClickOutside, onEsc = _ref.onEsc, plain = _ref.plain, _ref$position = _ref.position, position = _ref$position === void 0 ? "center" : _ref$position, _ref$responsive = _ref.responsive, responsive = _ref$responsive === void 0 ? true : _ref$responsive, layerTarget = _ref.target, rest = _objectWithoutPropertiesLoose33(_ref, _excluded38);
    var containerTarget = (0, import_react60.useContext)(ContainerTargetContext);
    var theme = (0, import_react60.useContext)(import_styled_components47.ThemeContext) || defaultProps2.theme;
    var size = (0, import_react60.useContext)(ResponsiveContext);
    var _useContext = (0, import_react60.useContext)(OptionsContext), layerOptions = _useContext.layer;
    var anchorRef = (0, import_react60.useRef)();
    var containerRef = (0, import_react60.useRef)();
    var layerRef = (0, import_react60.useRef)();
    var portalContext = (0, import_react60.useContext)(PortalContext);
    var portalId = (0, import_react60.useMemo)(function() {
      return portalContext.length;
    }, [portalContext]);
    var nextPortalContext = (0, import_react60.useMemo)(function() {
      return [].concat(portalContext, [portalId]);
    }, [portalContext, portalId]);
    var sendAnalytics = useAnalytics();
    (0, import_react60.useEffect)(function() {
      var start3 = /* @__PURE__ */ new Date();
      var element = layerRef.current;
      var isHidden = position === "hidden";
      if (!isHidden) {
        sendAnalytics({
          type: "layerOpen",
          element
        });
      }
      return function() {
        if (!isHidden) {
          sendAnalytics({
            type: "layerClose",
            element,
            elapsed: (/* @__PURE__ */ new Date()).getTime() - start3.getTime()
          });
        }
      };
    }, [sendAnalytics, layerRef, position]);
    (0, import_react60.useEffect)(function() {
      if (position !== "hidden") {
        var node = layerRef.current || containerRef.current || ref.current;
        if (node && node.scrollIntoView)
          node.scrollIntoView();
        var element = document.activeElement;
        while (element) {
          if (element === containerRef.current) {
            break;
          }
          element = element.parentElement;
        }
        if (modal && !element && anchorRef.current) {
          anchorRef.current.focus();
        }
      }
    }, [modal, position, ref]);
    (0, import_react60.useEffect)(function() {
      if (position !== "hidden") {
        var node = layerRef.current || containerRef.current || ref.current;
        if (node && node.scrollIntoView)
          node.scrollIntoView();
      }
    }, [position, ref]);
    (0, import_react60.useEffect)(function() {
      var onClickDocument = function onClickDocument2(event) {
        var clickedPortalId = null;
        var node = containerTarget === document.body ? event.target : event == null ? void 0 : event.composedPath()[0];
        while (clickedPortalId === null && node !== document && node !== null) {
          var attr = node.getAttribute("data-g-portal-id");
          if (attr !== null && attr !== "")
            clickedPortalId = parseInt(attr, 10);
          else
            node = node.parentNode;
        }
        if ((clickedPortalId === null || portalContext.indexOf(clickedPortalId) !== -1) && node !== null) {
          onClickOutside(event);
        }
      };
      if (onClickOutside) {
        document.addEventListener("mousedown", onClickDocument);
      }
      if (layerTarget) {
        var updateBounds = function updateBounds2() {
          var windowWidth = window.innerWidth;
          var windowHeight = window.innerHeight;
          var target = findVisibleParent(layerTarget);
          var layer = layerRef.current;
          if (layer && target) {
            layer.style.left = "";
            layer.style.top = "";
            layer.style.bottom = "";
            layer.style.width = "";
            var targetRect = target.getBoundingClientRect();
            var layerRect = layer.getBoundingClientRect();
            layer.style.left = targetRect.left + "px";
            layer.style.right = windowWidth - targetRect.right + "px";
            layer.style.top = targetRect.top + "px";
            layer.style.bottom = windowHeight - targetRect.bottom + "px";
            layer.style.maxHeight = targetRect.height;
            layer.style.maxWidth = Math.min(layerRect.width, windowWidth);
          }
        };
        updateBounds();
        window.addEventListener("resize", updateBounds);
        window.addEventListener("scroll", updateBounds, true);
        return function() {
          window.removeEventListener("resize", updateBounds);
          window.removeEventListener("scroll", updateBounds, true);
          if (onClickOutside) {
            document.removeEventListener("mousedown", onClickDocument);
          }
        };
      }
      return function() {
        if (onClickOutside) {
          document.removeEventListener("mousedown", onClickDocument);
        }
      };
    }, [containerTarget, layerTarget, onClickOutside, portalContext, portalId]);
    var content = /* @__PURE__ */ import_react60.default.createElement(StyledContainer3, _extends51({
      ref: ref || containerRef,
      background,
      elevation: theme.layer.container.elevation,
      id: layerOptions && layerOptions.singleId ? id + "__container" : id,
      full,
      margin,
      modal
    }, rest, {
      position,
      plain,
      responsive,
      layerTarget,
      dir: theme.dir,
      "data-g-portal-id": portalId
    }), /* @__PURE__ */ import_react60.default.createElement(HiddenAnchor, {
      ref: anchorRef,
      tabIndex: "-1",
      "aria-hidden": "true"
    }), children);
    content = /* @__PURE__ */ import_react60.default.createElement(StyledLayer, {
      ref: layerRef,
      id,
      plain,
      position,
      responsive,
      layerTarget,
      tabIndex: "-1",
      dir: theme.dir
    }, modal && /* @__PURE__ */ import_react60.default.createElement(StyledOverlay, {
      plain,
      responsive,
      onMouseDown: onClickOutside
    }), content);
    if (onEsc) {
      content = /* @__PURE__ */ import_react60.default.createElement(Keyboard, {
        onEsc: onEsc ? function(event) {
          event.stopPropagation();
          onEsc(event);
        } : void 0,
        target: modal === false ? "document" : void 0
      }, content);
    }
    var themeContextValue = (0, import_react60.useMemo)(function() {
      var dark2 = backgroundIsDark(theme.layer.background, theme);
      return _extends51({}, theme, {
        dark: dark2
      });
    }, [theme]);
    if (theme.layer.background) {
      var dark = themeContextValue.dark;
      if (dark !== void 0 && dark !== theme.dark) {
        content = /* @__PURE__ */ import_react60.default.createElement(import_styled_components47.ThemeContext.Provider, {
          value: themeContextValue
        }, content);
      }
    }
    content = /* @__PURE__ */ import_react60.default.createElement(PortalContext.Provider, {
      value: nextPortalContext
    }, content);
    var hitResponsiveBreakpoint = responsive && size === theme.layer.responsiveBreakpoint;
    if (modal || hitResponsiveBreakpoint) {
      content = /* @__PURE__ */ import_react60.default.createElement(FocusedContainer, {
        hidden: position === "hidden",
        restrictScroll: !layerTarget && hitResponsiveBreakpoint ? true : void 0,
        trapFocus: true
      }, content);
    }
    return content;
  });

  // node_modules/grommet/es6/components/Layer/propTypes.js
  var import_prop_types30 = __toESM(require_prop_types());
  var PAD_SIZES2 = ["xxsmall", "xsmall", "small", "medium", "large"];
  var PropType28 = {};
  if (true) {
    PropType28 = {
      animate: import_prop_types30.default.bool,
      animation: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["slide", "fadeIn", "none"]), import_prop_types30.default.bool]),
      background: backgroundDoc,
      full: import_prop_types30.default.oneOfType([import_prop_types30.default.bool, import_prop_types30.default.oneOf(["vertical", "horizontal"])]),
      margin: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["none"].concat(PAD_SIZES2)), import_prop_types30.default.shape({
        bottom: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(PAD_SIZES2), import_prop_types30.default.string]),
        end: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(PAD_SIZES2), import_prop_types30.default.string]),
        horizontal: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(PAD_SIZES2), import_prop_types30.default.string]),
        left: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(PAD_SIZES2), import_prop_types30.default.string]),
        right: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(PAD_SIZES2), import_prop_types30.default.string]),
        start: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(PAD_SIZES2), import_prop_types30.default.string]),
        top: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(PAD_SIZES2), import_prop_types30.default.string]),
        vertical: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(PAD_SIZES2), import_prop_types30.default.string])
      }), import_prop_types30.default.string]),
      modal: import_prop_types30.default.bool,
      onClickOutside: import_prop_types30.default.func,
      onEsc: import_prop_types30.default.func,
      plain: import_prop_types30.default.bool,
      position: import_prop_types30.default.oneOf(["bottom", "bottom-left", "bottom-right", "center", "end", "hidden", "left", "right", "start", "top", "top-left", "top-right"]),
      responsive: import_prop_types30.default.bool,
      target: import_prop_types30.default.object
    };
  }
  var LayerPropTypes = PropType28;

  // node_modules/grommet/es6/components/Layer/Layer.js
  function _extends52() {
    _extends52 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends52.apply(this, arguments);
  }
  var Layer = /* @__PURE__ */ (0, import_react61.forwardRef)(function(props, ref) {
    var animate = props.animate, animation = props.animation, targetChildPosition = props.targetChildPosition;
    var _useState = (0, import_react61.useState)(), originalFocusedElement = _useState[0], setOriginalFocusedElement = _useState[1];
    (0, import_react61.useEffect)(function() {
      return setOriginalFocusedElement(document.activeElement);
    }, []);
    var _useState2 = (0, import_react61.useState)(), layerContainer = _useState2[0], setLayerContainer = _useState2[1];
    var containerTarget = (0, import_react61.useContext)(ContainerTargetContext);
    (0, import_react61.useEffect)(function() {
      return setLayerContainer(getNewContainer(containerTarget, targetChildPosition));
    }, [containerTarget, targetChildPosition]);
    useLayoutEffect(function() {
      return function() {
        if (originalFocusedElement) {
          if (originalFocusedElement.focus) {
            setTimeout(function() {
              return originalFocusedElement.focus();
            }, 0);
          } else if (originalFocusedElement.parentNode && originalFocusedElement.parentNode.focus) {
            originalFocusedElement.parentNode.focus();
          }
        }
        if (layerContainer) {
          var activeAnimation = animation !== void 0 ? animation : animate;
          if (activeAnimation !== false) {
            var layerClone = layerContainer.cloneNode(true);
            layerClone.id = "layerClone";
            containerTarget.appendChild(layerClone);
            var clonedContainer = layerClone.querySelector('[class*="StyledLayer__StyledContainer"]');
            if (clonedContainer && clonedContainer.style) {
              clonedContainer.style.animationDirection = "reverse";
            }
            setTimeout(function() {
              var clone5 = containerTarget === document.body ? document.getElementById("layerClone") : containerTarget.getElementById("layerClone");
              if (clone5) {
                containerTarget.removeChild(clone5);
                layerContainer.remove();
              }
            }, animationDuration);
          } else {
            containerTarget.removeChild(layerContainer);
          }
        }
      };
    }, [animate, animation, containerTarget, layerContainer, originalFocusedElement]);
    return layerContainer ? /* @__PURE__ */ (0, import_react_dom2.createPortal)(/* @__PURE__ */ import_react61.default.createElement(LayerContainer, _extends52({
      ref
    }, props)), layerContainer) : null;
  });
  Layer.displayName = "Layer";
  Layer.propTypes = LayerPropTypes;

  // node_modules/grommet/es6/components/DataFilters/propTypes.js
  var import_prop_types31 = __toESM(require_prop_types());
  var PropType29 = {};
  if (true) {
    PropType29 = {
      drop: import_prop_types31.default.bool,
      heading: import_prop_types31.default.string,
      layer: import_prop_types31.default.bool
    };
  }
  var DataFiltersPropTypes = PropType29;

  // node_modules/grommet/es6/components/DataFilters/DataFilters.js
  var _excluded39 = ["drop", "children", "heading", "layer"];
  function _extends53() {
    _extends53 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends53.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose34(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var dropProps2 = {
    align: {
      top: "bottom",
      right: "right"
    }
  };
  var layerProps = {
    full: "vertical",
    position: "right"
  };
  var DataFilters = function DataFilters2(_ref) {
    var drop = _ref.drop, children = _ref.children, heading = _ref.heading, layer = _ref.layer, rest = _objectWithoutPropertiesLoose34(_ref, _excluded39);
    var _useContext = (0, import_react62.useContext)(DataContext), clearFilters = _useContext.clearFilters, data = _useContext.data, dataId = _useContext.id, messages = _useContext.messages, properties = _useContext.properties, view = _useContext.view;
    var _useContext2 = (0, import_react62.useContext)(MessageContext), format4 = _useContext2.format;
    var _useState = (0, import_react62.useState)(), showContent = _useState[0], setShowContent = _useState[1];
    var _useState2 = (0, import_react62.useState)({}), touched = _useState2[0], setTouched = _useState2[1];
    var controlled = (0, import_react62.useMemo)(function() {
      return drop || layer;
    }, [drop, layer]);
    var badge = (0, import_react62.useMemo)(function() {
      return controlled && Object.keys(touched).filter(function(k) {
        return touched[k];
      }).length || void 0;
    }, [controlled, touched]);
    var clearControl = badge && /* @__PURE__ */ import_react62.default.createElement(Box, {
      flex: false,
      margin: {
        start: "small"
      }
    }, /* @__PURE__ */ import_react62.default.createElement(Button2, {
      label: format4({
        id: "dataFilters.clear",
        messages: messages == null ? void 0 : messages.dataFilters
      }),
      onClick: function onClick() {
        setTouched({});
        clearFilters();
      }
    }));
    var content = children;
    if (import_react62.Children.count(children) === 0) {
      var filtersFor;
      if (!properties && data && data.length)
        filtersFor = Object.keys(data[0]).filter(function(k) {
          return typeof data[0][k] !== "object";
        });
      else if (Array.isArray(properties))
        filtersFor = properties;
      else if (typeof properties === "object")
        filtersFor = Object.keys(properties);
      else
        filtersFor = [];
      content = filtersFor.map(function(property) {
        return /* @__PURE__ */ import_react62.default.createElement(DataFilter, {
          key: property,
          property
        });
      });
      if (view != null && view.sort) {
        content.push(/* @__PURE__ */ import_react62.default.createElement(DataSort, {
          key: "_sort"
        }));
      }
    }
    content = /* @__PURE__ */ import_react62.default.createElement(DataForm, _extends53({
      pad: controlled ? "medium" : void 0,
      onDone: function onDone() {
        return setShowContent(false);
      },
      onTouched: controlled ? function(currentTouched) {
        return (
          // we merge this with our prior state to handle the case where the
          // user opens and closes the drop multiple times and we want to
          // track both new changes and prior changes.
          setTouched(function(prevTouched) {
            return _extends53({}, prevTouched, currentTouched);
          })
        );
      } : void 0
    }, !controlled ? rest : {
      fill: "vertical"
    }), !drop && /* @__PURE__ */ import_react62.default.createElement(Header, null, /* @__PURE__ */ import_react62.default.createElement(Heading, {
      margin: "none",
      level: 2,
      size: "small"
    }, heading || format4({
      id: "dataFilters.heading",
      messages: messages == null ? void 0 : messages.dataFilters
    })), !controlled && clearControl, layer && /* @__PURE__ */ import_react62.default.createElement(Button2, {
      icon: /* @__PURE__ */ import_react62.default.createElement(import_FormClose2.FormClose, null),
      hoverIndicator: true,
      onClick: function onClick() {
        return setShowContent(void 0);
      }
    })), content);
    if (!controlled)
      return content;
    var control;
    if (drop) {
      control = /* @__PURE__ */ import_react62.default.createElement(DropButton, {
        id: dataId + "--filters-control",
        "aria-label": format4({
          id: "dataFilters.open",
          messages: messages == null ? void 0 : messages.dataFilters
        }),
        kind: "toolbar",
        icon: /* @__PURE__ */ import_react62.default.createElement(import_Filter.Filter, null),
        hoverIndicator: true,
        dropProps: dropProps2,
        dropContent: content,
        badge,
        open: showContent,
        onOpen: function onOpen() {
          return setShowContent(void 0);
        },
        onClose: function onClose() {
          return setShowContent(void 0);
        }
      });
    } else if (layer) {
      control = /* @__PURE__ */ import_react62.default.createElement(Button2, {
        id: dataId + "--filters-control",
        "aria-label": format4({
          id: "dataFilters.open",
          messages: messages == null ? void 0 : messages.dataFilters
        }),
        kind: "toolbar",
        hoverIndicator: true,
        icon: /* @__PURE__ */ import_react62.default.createElement(import_Filter.Filter, null),
        badge,
        onClick: function onClick() {
          return setShowContent(true);
        }
      });
    }
    return /* @__PURE__ */ import_react62.default.createElement(Box, _extends53({
      flex: false,
      direction: "row"
    }, rest), control, clearControl, layer && showContent && /* @__PURE__ */ import_react62.default.createElement(Layer, _extends53({
      id: dataId + "--filters-layer"
    }, typeof layer === "object" ? layer : layerProps, {
      onClickOutside: function onClickOutside() {
        return setShowContent(void 0);
      },
      onEsc: function onEsc() {
        return setShowContent(void 0);
      }
    }), content));
  };
  DataFilters.propTypes = DataFiltersPropTypes;

  // node_modules/grommet/es6/components/DataSearch/DataSearch.js
  var import_react63 = __toESM(require_react());
  var import_Search = __toESM(require_Search());

  // node_modules/grommet/es6/components/DataSearch/propTypes.js
  var import_prop_types32 = __toESM(require_prop_types());
  var PropType30 = {};
  if (true) {
    PropType30 = {
      drop: import_prop_types32.default.bool,
      responsive: import_prop_types32.default.bool
    };
  }
  var DataSearchPropTypes = PropType30;

  // node_modules/grommet/es6/components/DataSearch/DataSearch.js
  var _excluded40 = ["drop", "id", "responsive"];
  function _extends54() {
    _extends54 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends54.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose35(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var dropProps3 = {
    align: {
      top: "bottom",
      left: "left"
    }
  };
  var DataSearch = function DataSearch2(_ref) {
    var drop = _ref.drop, idProp = _ref.id, responsive = _ref.responsive, rest = _objectWithoutPropertiesLoose35(_ref, _excluded40);
    var _useContext = (0, import_react63.useContext)(DataContext), dataId = _useContext.id, messages = _useContext.messages, addToolbarKey = _useContext.addToolbarKey;
    var _useContext2 = (0, import_react63.useContext)(FormContext), noForm = _useContext2.noForm;
    var _useContext3 = (0, import_react63.useContext)(MessageContext), format4 = _useContext3.format;
    var size = (0, import_react63.useContext)(ResponsiveContext);
    var skeleton = useSkeleton();
    var _useState = (0, import_react63.useState)(), showContent = _useState[0], setShowContent = _useState[1];
    var id = idProp || dataId + "--search";
    (0, import_react63.useEffect)(function() {
      if (noForm)
        addToolbarKey("_search");
    }, [addToolbarKey, noForm]);
    var content = skeleton ? null : /* @__PURE__ */ import_react63.default.createElement(TextInput, _extends54({
      "aria-label": format4({
        id: "dataSearch.label",
        messages: messages == null ? void 0 : messages.dataSearch
      }),
      id,
      name: "_search",
      icon: /* @__PURE__ */ import_react63.default.createElement(import_Search.Search, null),
      type: "search"
    }, rest));
    if (noForm)
      content = /* @__PURE__ */ import_react63.default.createElement(DataForm, {
        footer: false,
        updateOn: "change"
      }, content);
    else
      content = /* @__PURE__ */ import_react63.default.createElement(FormField, {
        htmlFor: id,
        label: format4({
          id: "dataSearch.label",
          messages: messages == null ? void 0 : messages.dataSearch
        })
      }, content);
    if (!drop && (!responsive || size !== "small" && size !== "xsmall"))
      return content;
    var control = /* @__PURE__ */ import_react63.default.createElement(DropButton, _extends54({
      id: dataId + "--search-control",
      "aria-label": format4({
        id: "dataSearch.open",
        messages: messages == null ? void 0 : messages.dataSort
      }),
      kind: "toolbar",
      icon: /* @__PURE__ */ import_react63.default.createElement(import_Search.Search, null),
      dropProps: dropProps3,
      dropContent: /* @__PURE__ */ import_react63.default.createElement(Box, {
        pad: "small"
      }, content),
      open: showContent,
      onOpen: function onOpen() {
        return setShowContent(void 0);
      },
      onClose: function onClose() {
        return setShowContent(void 0);
      }
    }, rest));
    return control;
  };
  DataSearch.propTypes = DataSearchPropTypes;

  // node_modules/grommet/es6/components/DataSummary/DataSummary.js
  var import_react64 = __toESM(require_react());

  // node_modules/grommet/es6/components/DataSummary/propTypes.js
  var import_prop_types33 = __toESM(require_prop_types());
  var PropType31 = {};
  if (true) {
    PropType31 = {
      messages: import_prop_types33.default.shape({
        filteredTotal: import_prop_types33.default.number,
        total: import_prop_types33.default.number
      })
    };
  }
  var DataSummaryPropTypes = PropType31;

  // node_modules/grommet/es6/components/DataSummary/DataSummary.js
  var _excluded41 = ["messages"];
  function _extends55() {
    _extends55 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends55.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose36(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var DataSummary = function DataSummary2(_ref) {
    var messages = _ref.messages, rest = _objectWithoutPropertiesLoose36(_ref, _excluded41);
    var _useContext = (0, import_react64.useContext)(MessageContext), format4 = _useContext.format;
    var _useContext2 = (0, import_react64.useContext)(DataContext), filteredTotal = _useContext2.filteredTotal, dataMessages = _useContext2.messages, total = _useContext2.total;
    var messageId;
    if (total !== filteredTotal) {
      if (filteredTotal === 1)
        messageId = "dataSummary.filteredSingle";
      else
        messageId = "dataSummary.filtered";
    } else
      messageId = "dataSummary.total";
    return /* @__PURE__ */ import_react64.default.createElement(Text, _extends55({
      margin: {
        vertical: "xsmall"
      }
    }, rest), format4({
      id: messageId,
      messages: messages || (dataMessages == null ? void 0 : dataMessages.dataSummary),
      values: {
        filteredTotal,
        total
      }
    }));
  };
  DataSummary.propTypes = DataSummaryPropTypes;

  // node_modules/grommet/es6/components/DataView/DataView.js
  var import_react65 = __toESM(require_react());

  // node_modules/grommet/es6/components/DataView/propTypes.js
  var PropType32 = {};
  if (true) {
    PropType32 = {};
  }
  var DataViewPropTypes = PropType32;

  // node_modules/grommet/es6/components/DataView/DataView.js
  var _excluded42 = ["id"];
  function _extends56() {
    _extends56 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends56.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose37(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var DataView = function DataView2(_ref) {
    var idProp = _ref.id, rest = _objectWithoutPropertiesLoose37(_ref, _excluded42);
    var _useContext = (0, import_react65.useContext)(DataContext), dataId = _useContext.id, messages = _useContext.messages, view = _useContext.view, views = _useContext.views, addToolbarKey = _useContext.addToolbarKey;
    var _useContext2 = (0, import_react65.useContext)(FormContext), noForm = _useContext2.noForm;
    var _useContext3 = (0, import_react65.useContext)(MessageContext), format4 = _useContext3.format;
    var id = idProp || dataId + "--view";
    (0, import_react65.useEffect)(function() {
      if (noForm)
        addToolbarKey("_view");
    }, [addToolbarKey, noForm]);
    if (!views)
      return null;
    var names = views.map(function(v) {
      return v.name;
    });
    var content;
    if (!noForm && names.length < 7) {
      content = /* @__PURE__ */ import_react65.default.createElement(RadioButtonGroup, _extends56({
        id,
        name: "_view",
        options: names,
        value: view == null ? void 0 : view.name
      }, rest));
    } else {
      content = /* @__PURE__ */ import_react65.default.createElement(Select, _extends56({
        id,
        name: "_view",
        showSelectedInline: true,
        placeholder: noForm ? "Select view ..." : void 0,
        options: names,
        value: view == null ? void 0 : view.name
      }, rest));
    }
    if (noForm)
      content = /* @__PURE__ */ import_react65.default.createElement(DataForm, {
        footer: false,
        updateOn: "change"
      }, content);
    else
      content = /* @__PURE__ */ import_react65.default.createElement(FormField, {
        htmlFor: id,
        label: format4({
          id: "dataView.label",
          messages: messages == null ? void 0 : messages.dataView
        })
      }, content);
    return content;
  };
  DataView.propTypes = DataViewPropTypes;

  // node_modules/grommet/es6/components/Toolbar/Toolbar.js
  var import_react66 = __toESM(require_react());

  // node_modules/grommet/es6/components/Toolbar/propTypes.js
  var PropType33 = {};
  if (true) {
    PropType33 = {};
  }
  var ToolbarPropTypes = PropType33;

  // node_modules/grommet/es6/components/Toolbar/Toolbar.js
  var _excluded43 = ["children"];
  function _extends57() {
    _extends57 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends57.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose38(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var defaultLayoutProps = {
    direction: "row",
    align: "start",
    gap: "small"
  };
  var smallLayoutProps = {
    direction: "row",
    wrap: true,
    align: "start",
    gap: "small"
  };
  var Toolbar = function Toolbar2(_ref) {
    var children = _ref.children, rest = _objectWithoutPropertiesLoose38(_ref, _excluded43);
    var size = (0, import_react66.useContext)(ResponsiveContext);
    var layoutProps = size === "small" || size === "xsmall" ? smallLayoutProps : defaultLayoutProps;
    return /* @__PURE__ */ import_react66.default.createElement(Box, _extends57({
      flex: false,
      cssGap: true
    }, layoutProps, rest), children);
  };
  Toolbar.propTypes = ToolbarPropTypes;
  Toolbar.defaultProps = {};

  // node_modules/grommet/es6/components/Data/propTypes.js
  var import_prop_types34 = __toESM(require_prop_types());
  var viewType = import_prop_types34.default.shape({
    properties: import_prop_types34.default.oneOfType([import_prop_types34.default.arrayOf(import_prop_types34.default.string), import_prop_types34.default.shape({})]),
    search: import_prop_types34.default.string,
    sort: import_prop_types34.default.shape({
      direction: import_prop_types34.default.oneOf(["asc", "desc"]),
      property: import_prop_types34.default.string
    })
  });
  var PropType34 = {};
  if (true) {
    PropType34 = {
      data: import_prop_types34.default.arrayOf(import_prop_types34.default.shape({})),
      defaultView: viewType,
      onView: import_prop_types34.default.func,
      properties: import_prop_types34.default.oneOfType([import_prop_types34.default.arrayOf(import_prop_types34.default.string), import_prop_types34.default.shape({})]),
      toolbar: import_prop_types34.default.oneOfType([import_prop_types34.default.bool, import_prop_types34.default.oneOf(["search", "filters"])]),
      total: import_prop_types34.default.number,
      updateOn: import_prop_types34.default.oneOf(["change", "submit"]),
      view: import_prop_types34.default.oneOfType([import_prop_types34.default.string, viewType])
    };
  }
  var DataPropTypes = PropType34;

  // node_modules/grommet/es6/components/Data/filter.js
  var datumValue = function datumValue2(datum, property) {
    if (!property)
      return void 0;
    var parts2 = property.split(".");
    if (parts2.length === 1)
      return datum[property];
    if (!datum[parts2[0]])
      return void 0;
    return datumValue2(datum[parts2[0]], parts2.slice(1).join("."));
  };
  var filter = function filter2(data, view, properties) {
    var _view$sort, _view$sort2;
    var searchExp = view != null && view.search ? new RegExp(view.search.replace(/[#-.]|[[-^]|[?|{}]/g, "\\$&"), "i") : void 0;
    var searchProperties;
    if (searchExp && properties) {
      searchProperties = Object.keys(properties).filter(function(k) {
        return properties[k].search;
      });
      if (searchProperties.length === 0)
        searchProperties = Object.keys(properties);
    }
    var filteredData = data.filter(function(datum) {
      var matched = true;
      if (searchExp) {
        var searchWith = function searchWith2(property2) {
          var value = datumValue(datum, property2);
          if (value === void 0)
            return false;
          return searchExp.test(value);
        };
        if (searchProperties)
          matched = searchProperties.some(searchWith);
        else
          matched = Object.keys(datum).some(searchWith);
      }
      if (matched && view != null && view.properties) {
        matched = !Object.keys(view.properties).some(function(property2) {
          var filterValue = view.properties[property2];
          var value = datumValue(datum, property2);
          if (typeof (filterValue == null ? void 0 : filterValue.min) === "number" || typeof (filterValue == null ? void 0 : filterValue.max) === "number")
            return typeof value !== "number" || value <= filterValue.min || value >= filterValue.max;
          if (Array.isArray(filterValue))
            return !filterValue.includes(value);
          if (typeof filterValue === "boolean")
            return filterValue === !value;
          return false;
        });
      }
      return matched;
    });
    if (view != null && (_view$sort = view.sort) != null && _view$sort.property || view != null && (_view$sort2 = view.sort) != null && _view$sort2.direction) {
      var _view$sort3 = view.sort, property = _view$sort3.property, direction = _view$sort3.direction;
      var prop = property || filteredData.length && Object.keys(filteredData[0])[0];
      var sortDesc = direction === "desc";
      var before = sortDesc ? -1 : 1;
      var after = sortDesc ? 1 : -1;
      filteredData.sort(function(d1, d2) {
        var d1Val = datumValue(d1, prop);
        var d2Val = datumValue(d2, prop);
        if (typeof d1Val === "string" && typeof d2Val === "string" || typeof d1Val === "string" && !d2Val || typeof d2Val === "string" && !d1Val) {
          var sortResult = (d1Val || "").localeCompare(d2Val || "", void 0, {
            sensitivity: "base"
          });
          return sortDesc ? -sortResult : sortResult;
        }
        if (d1Val > d2Val)
          return before;
        if (d1Val < d2Val)
          return after;
        return 0;
      });
    }
    var pagedData;
    if (view != null && view.step) {
      var _view$page;
      var start3 = view.step * (((_view$page = view == null ? void 0 : view.page) != null ? _view$page : 1) - 1);
      pagedData = filteredData.slice(start3, start3 + view.step);
    }
    return {
      unfilteredData: data,
      data: pagedData || filteredData,
      total: data.length,
      filteredTotal: filteredData.length
    };
  };

  // node_modules/grommet/es6/components/Data/Data.js
  var _excluded44 = ["children", "data", "defaultView", "filteredTotal", "id", "messages", "onView", "properties", "toolbar", "total", "updateOn", "view", "views"];
  function _extends58() {
    _extends58 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends58.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose39(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var defaultDefaultView = {
    search: ""
  };
  var normalizeView = function normalizeView2(viewProp, views) {
    return typeof viewProp === "string" && (views == null ? void 0 : views.find(function(v) {
      return v.name === viewProp;
    })) || typeof viewProp === "object" && viewProp;
  };
  var Data2 = function Data3(_ref) {
    var children = _ref.children, dataProp = _ref.data, _ref$defaultView = _ref.defaultView, defaultView = _ref$defaultView === void 0 ? defaultDefaultView : _ref$defaultView, filteredTotal = _ref.filteredTotal, _ref$id = _ref.id, id = _ref$id === void 0 ? "data" : _ref$id, messages = _ref.messages, onView = _ref.onView, properties = _ref.properties, toolbar = _ref.toolbar, total = _ref.total, _ref$updateOn = _ref.updateOn, updateOn = _ref$updateOn === void 0 ? "submit" : _ref$updateOn, viewProp = _ref.view, views = _ref.views, rest = _objectWithoutPropertiesLoose39(_ref, _excluded44);
    var _useState = (0, import_react67.useState)(normalizeView(viewProp || defaultView, views)), view = _useState[0], setView = _useState[1];
    (0, import_react67.useEffect)(function() {
      return setView(normalizeView(viewProp || defaultView, views));
    }, [defaultView, viewProp, views]);
    var _useState2 = (0, import_react67.useState)([]), toolbarKeys = _useState2[0], setToolbarKeys = _useState2[1];
    var result = (0, import_react67.useMemo)(function() {
      var _ref2;
      if (onView)
        return {
          data: dataProp,
          total,
          filteredTotal: (_ref2 = filteredTotal != null ? filteredTotal : dataProp == null ? void 0 : dataProp.length) != null ? _ref2 : 0
        };
      return filter(dataProp, view, properties);
    }, [dataProp, filteredTotal, onView, properties, total, view]);
    var contextValue = (0, import_react67.useMemo)(function() {
      var value = _extends58({
        id,
        messages,
        properties,
        updateOn,
        view,
        views
      }, result);
      value.clearFilters = function() {
        var nextView = defaultView;
        setView(nextView);
        if (onView)
          onView(nextView);
      };
      value.onView = function(nextView) {
        setView(nextView);
        if (onView)
          onView(nextView);
      };
      value.addToolbarKey = function(key) {
        setToolbarKeys(function(prevKeys) {
          if (prevKeys.includes(key))
            return prevKeys;
          return [].concat(prevKeys, [key]);
        });
      };
      value.toolbarKeys = toolbarKeys;
      return value;
    }, [defaultView, id, messages, onView, properties, result, toolbarKeys, updateOn, view, views]);
    var toolbarContent;
    if (toolbar) {
      toolbarContent = [/* @__PURE__ */ import_react67.default.createElement(Toolbar, {
        key: "toolbar"
      }, (toolbar === true || toolbar === "search") && /* @__PURE__ */ import_react67.default.createElement(DataSearch, null), (toolbar === true || toolbar === "view") && /* @__PURE__ */ import_react67.default.createElement(DataView, null), (toolbar === true || toolbar === "filters") && /* @__PURE__ */ import_react67.default.createElement(DataFilters, {
        drop: true
      })), /* @__PURE__ */ import_react67.default.createElement(DataSummary, {
        key: "summary"
      })];
    }
    return /* @__PURE__ */ import_react67.default.createElement(DataContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ import_react67.default.createElement(Box, _extends58({
      id,
      flex: false
    }, rest), toolbarContent, children));
  };
  Data2.propTypes = DataPropTypes;

  // node_modules/grommet/es6/components/DataTable/DataTable.js
  var import_react84 = __toESM(require_react());
  var import_styled_components57 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/DataTable/Header.js
  var import_react78 = __toESM(require_react());
  var import_styled_components54 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/TableCell/TableCell.js
  var import_react69 = __toESM(require_react());
  var import_styled_components49 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/Table/TableContext.js
  var import_react68 = __toESM(require_react());
  var TableContext = /* @__PURE__ */ import_react68.default.createContext(void 0);

  // node_modules/grommet/es6/components/Table/StyledTable.js
  var import_styled_components48 = __toESM(require_styled_components_browser_cjs());
  var SIZE_MAP = {
    "1/2": "50%",
    "1/4": "25%",
    "2/4": "50%",
    "3/4": "75%",
    "1/3": "33.33%",
    "2/3": "66.66%"
  };
  var sizeStyle9 = (0, import_styled_components48.css)(["width:", ";max-width:", ";overflow:hidden;"], function(props) {
    return props.size === "auto" ? (
      // setting width to a small value will allow
      // the cell to fit width of its content. this
      // is a commonly implemented CSS pattern to
      // allow an auto-width behavior on fixed table
      // layouts (which is what DataTable applies)
      // https://stackoverflow.com/questions/4757844/css-table-column-autowidth?noredirect=1&lq=1
      "1px"
    ) : SIZE_MAP[props.size] || props.theme.global.size[props.size] || props.size;
  }, function(props) {
    return props.size !== "auto" ? SIZE_MAP[props.size] || props.theme.global.size[props.size] || props.size : void 0;
  });
  var StyledTableCell = import_styled_components48.default.td.withConfig({
    displayName: "StyledTable__StyledTableCell",
    componentId: "sc-1m3u5g-0"
  })(["margin:0;padding:0;font-weight:inherit;text-align:inherit;", " ", " ", " ", " ", " ", " ", ""], function(props) {
    return props.size && sizeStyle9;
  }, function(props) {
    return props.verticalAlign && "vertical-align: " + props.verticalAlign + ";";
  }, function(props) {
    return props.align && "text-align: " + props.align + ";";
  }, function(props) {
    return props.background && backgroundStyle(props.background, props.theme);
  }, function(props) {
    return props.border && borderStyle(props.border, props.responsive, props.theme);
  }, function(props) {
    return props.pad && edgeStyle("padding", props.pad, props.responsive, props.theme.box.responsiveBreakpoint, props.theme);
  }, function(props) {
    return props.tableContextTheme && props.tableContextTheme.extend;
  });
  StyledTableCell.defaultProps = {};
  Object.setPrototypeOf(StyledTableCell.defaultProps, defaultProps2);
  var StyledTableDataCaption = import_styled_components48.default.caption.withConfig({
    displayName: "StyledTable__StyledTableDataCaption",
    componentId: "sc-1m3u5g-1"
  })(["margin-bottom:", ";"], function(props) {
    return props.theme.global.edgeSize.xxsmall;
  });
  StyledTableDataCaption.defaultProps = {};
  Object.setPrototypeOf(StyledTableDataCaption.defaultProps, defaultProps2);
  var StyledTableRow = import_styled_components48.default.tr.withConfig({
    displayName: "StyledTable__StyledTableRow",
    componentId: "sc-1m3u5g-2"
  })([""]);
  StyledTableRow.defaultProps = {};
  Object.setPrototypeOf(StyledTableRow.defaultProps, defaultProps2);
  var StyledTableBody = import_styled_components48.default.tbody.withConfig({
    displayName: "StyledTable__StyledTableBody",
    componentId: "sc-1m3u5g-3"
  })([""]);
  StyledTableBody.defaultProps = {};
  Object.setPrototypeOf(StyledTableBody.defaultProps, defaultProps2);
  var StyledTableHeader = import_styled_components48.default.thead.withConfig({
    displayName: "StyledTable__StyledTableHeader",
    componentId: "sc-1m3u5g-4"
  })([""]);
  StyledTableHeader.defaultProps = {};
  Object.setPrototypeOf(StyledTableHeader.defaultProps, defaultProps2);
  var StyledTableFooter = import_styled_components48.default.tfoot.withConfig({
    displayName: "StyledTable__StyledTableFooter",
    componentId: "sc-1m3u5g-5"
  })([""]);
  StyledTableFooter.defaultProps = {};
  Object.setPrototypeOf(StyledTableFooter.defaultProps, defaultProps2);
  var StyledTable = import_styled_components48.default.table.withConfig({
    displayName: "StyledTable",
    componentId: "sc-1m3u5g-6"
  })(["border-spacing:0;border-collapse:collapse;width:inherit;", " ", ";"], genericStyles, function(props) {
    return props.theme.table && props.theme.table.extend;
  });
  StyledTable.defaultProps = {};
  Object.setPrototypeOf(StyledTable.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/TableCell/propTypes.js
  var import_prop_types35 = __toESM(require_prop_types());
  var BORDER_SHAPE2 = import_prop_types35.default.shape({
    color: import_prop_types35.default.oneOfType([import_prop_types35.default.string, import_prop_types35.default.shape({
      dark: import_prop_types35.default.string,
      light: import_prop_types35.default.string
    })]),
    side: import_prop_types35.default.oneOf(["top", "left", "bottom", "right", "start", "end", "horizontal", "vertical", "all", "between"]),
    size: import_prop_types35.default.oneOfType([import_prop_types35.default.oneOf(["xsmall", "small", "medium", "large", "xlarge"]), import_prop_types35.default.string]),
    style: import_prop_types35.default.oneOf(["solid", "dashed", "dotted", "double", "groove", "ridge", "inset", "outset", "hidden"])
  });
  var PropType35 = {};
  if (true) {
    PropType35 = {
      border: import_prop_types35.default.oneOfType([import_prop_types35.default.bool, import_prop_types35.default.oneOf(["top", "left", "bottom", "right", "start", "end", "horizontal", "vertical", "all"]), BORDER_SHAPE2, import_prop_types35.default.arrayOf(BORDER_SHAPE2)]),
      plain: import_prop_types35.default.oneOfType([import_prop_types35.default.bool, import_prop_types35.default.oneOf(["noPad"])]),
      scope: import_prop_types35.default.oneOf(["col", "row"]),
      size: import_prop_types35.default.oneOfType([import_prop_types35.default.oneOf(["xxsmall", "xsmall", "small", "medium", "large", "xlarge", "1/2", "1/3", "2/3", "1/4", "2/4", "3/4"]), import_prop_types35.default.string]),
      verticalAlign: import_prop_types35.default.oneOf(["top", "middle", "bottom"]),
      align: import_prop_types35.default.oneOfType([import_prop_types35.default.oneOf(["left", "right", "center", "justify", "inherit", "start", "end"]), import_prop_types35.default.string])
    };
  }
  var TableCellPropTypes = PropType35;

  // node_modules/grommet/es6/components/TableCell/TableCell.js
  var _excluded45 = ["align", "aria-disabled", "background", "border", "children", "className", "colSpan", "onWidth", "pad", "plain", "rowSpan", "scope", "size", "verticalAlign"];
  function _extends59() {
    _extends59 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends59.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose40(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var verticalAlignToJustify = {
    middle: "center",
    top: "start",
    bottom: "end"
  };
  var TableCell = /* @__PURE__ */ (0, import_react69.forwardRef)(function(_ref, ref) {
    var align = _ref.align, ariaDisabled = _ref["aria-disabled"], background = _ref.background, border = _ref.border, children = _ref.children, className = _ref.className, colSpan = _ref.colSpan, onWidth = _ref.onWidth, pad = _ref.pad, plain = _ref.plain, rowSpan = _ref.rowSpan, scope = _ref.scope, size = _ref.size, verticalAlign2 = _ref.verticalAlign, rest = _objectWithoutPropertiesLoose40(_ref, _excluded45);
    var theme = (0, import_react69.useContext)(import_styled_components49.ThemeContext) || defaultProps2.theme;
    var tableContext = (0, import_react69.useContext)(TableContext);
    var cellRef = useForwardedRef(ref);
    var containerRef = (0, import_react69.useRef)();
    useLayoutEffect(function() {
      if (onWidth) {
        var _cellRef$current$getB = cellRef.current.getBoundingClientRect(), width = _cellRef$current$getB.width;
        onWidth(width);
      }
    }, [cellRef, onWidth]);
    (0, import_react69.useEffect)(function() {
      var updateHeight = function updateHeight2() {
        if (plain === "noPad") {
          var cell = cellRef.current;
          var container = containerRef.current;
          if (cell && container) {
            container.style.height = "";
            var cellRect = cell.getBoundingClientRect();
            container.style.height = Math.max(cellRect.height - (border || theme.table[tableContext].border ? theme.global.borderSize.xsmall.replace("px", "") : 0), 0) + "px";
          }
        }
      };
      window.addEventListener("resize", updateHeight);
      updateHeight();
      return function() {
        window.removeEventListener("resize", updateHeight);
      };
    }, [border, cellRef, plain, tableContext, theme.global.borderSize, theme.table]);
    var tableContextTheme;
    if (tableContext === "header") {
      tableContextTheme = theme.table && theme.table.header;
    } else if (tableContext === "footer") {
      tableContextTheme = theme.table && theme.table.footer;
    } else {
      tableContextTheme = theme.table && theme.table.body;
    }
    var mergedProps = _extends59({}, tableContextTheme, rest);
    Object.keys(mergedProps).forEach(function(key) {
      if (rest[key] === void 0)
        mergedProps[key] = tableContextTheme[key];
    });
    var cellProps = {
      align: align || mergedProps.align || void 0,
      "aria-disabled": ariaDisabled || void 0,
      background: background || mergedProps.background || void 0,
      border: border || mergedProps.border || void 0,
      pad: plain !== "noPad" ? pad || mergedProps.pad || void 0 : void 0,
      verticalAlign: verticalAlign2 || mergedProps.verticalAlign || void 0
    };
    delete mergedProps.align;
    delete mergedProps.ariaDisabled;
    delete mergedProps.background;
    delete mergedProps.border;
    delete mergedProps.pad;
    delete mergedProps.verticalAlign;
    var content = children;
    if (plain === "noPad" && children) {
      content = /* @__PURE__ */ import_react69.default.createElement(Box, {
        ref: containerRef,
        justify: verticalAlign2 ? verticalAlignToJustify[verticalAlign2] : "center"
      }, children);
    }
    var nextTheme = (0, import_react69.useMemo)(function() {
      var result;
      if (cellProps.background || theme.darkChanged) {
        var dark = backgroundIsDark(cellProps.background, theme);
        var darkChanged = dark !== void 0 && dark !== theme.dark;
        if (darkChanged || theme.darkChanged) {
          result = _extends59({}, theme);
          result.dark = dark === void 0 ? theme.dark : dark;
          result.background = cellProps.background;
        } else if (cellProps.background) {
          result = _extends59({}, theme);
          result.background = cellProps.background;
        }
      }
      return result || theme;
    }, [cellProps.background, theme]);
    return /* @__PURE__ */ import_react69.default.createElement(import_styled_components49.ThemeContext.Provider, {
      value: nextTheme
    }, /* @__PURE__ */ import_react69.default.createElement(StyledTableCell, _extends59({
      ref: cellRef,
      as: scope ? "th" : void 0,
      scope,
      size,
      colSpan,
      rowSpan,
      tableContext,
      tableContextTheme
    }, plain === true ? mergedProps : {}, cellProps, {
      className
    }), plain || !Object.keys(mergedProps).length ? content : /* @__PURE__ */ import_react69.default.createElement(Box, _extends59({}, mergedProps, {
      align,
      justify: verticalAlignToJustify[verticalAlign2]
    }), children)));
  });
  TableCell.displayName = "TableCell";
  TableCell.propTypes = TableCellPropTypes;

  // node_modules/grommet/es6/components/DataTable/Resizer.js
  var import_react70 = __toESM(require_react());
  var import_styled_components50 = __toESM(require_styled_components_browser_cjs());
  function _extends60() {
    _extends60 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends60.apply(this, arguments);
  }
  var InteractionBox = (0, import_styled_components50.default)(Box).withConfig({
    displayName: "Resizer__InteractionBox",
    componentId: "sc-8l808w-0"
  })(["cursor:col-resize;> *{opacity:0;}", " &:hover{> *{opacity:1;}}"], function(props) {
    return props.active && "> * { opacity: 1; }";
  });
  var Resizer = function Resizer2(_ref) {
    var onResize = _ref.onResize, property = _ref.property;
    var theme = (0, import_react70.useContext)(import_styled_components50.ThemeContext) || defaultProps2.theme;
    var _useState = (0, import_react70.useState)(false), active = _useState[0], setActive = _useState[1];
    var _useState2 = (0, import_react70.useState)(), start3 = _useState2[0], setStart = _useState2[1];
    var _useState3 = (0, import_react70.useState)(), width = _useState3[0], setWidth = _useState3[1];
    var ref = (0, import_react70.useRef)();
    var onMouseDown = (0, import_react70.useCallback)(function(event) {
      if (ref.current) {
        var element = ref.current;
        while (element && element.nodeName !== "TH")
          element = element.parentNode;
        var rect = element.getBoundingClientRect();
        setStart(event.clientX);
        setWidth(rect.width);
        setActive(true);
      }
    }, []);
    var onMouseMove = (0, import_react70.useCallback)(function(event) {
      var nextWidth = Math.max(12, width + (event.clientX - start3));
      onResize(property, nextWidth);
    }, [onResize, property, start3, width]);
    var onMouseUp = (0, import_react70.useCallback)(function() {
      setActive(false);
      setStart(void 0);
      setWidth(void 0);
    }, []);
    (0, import_react70.useEffect)(function() {
      var remove = function remove2() {
        document.removeEventListener("mouseup", onMouseUp);
        document.removeEventListener("mousemove", onMouseMove);
      };
      if (active) {
        document.addEventListener("mouseup", onMouseUp);
        document.addEventListener("mousemove", onMouseMove);
        return remove;
      }
      remove();
      return void 0;
    }, [active, onMouseMove, onMouseUp]);
    var border;
    if (theme.dataTable.resize.hover && theme.dataTable.resize.hover.border) {
      var _theme$dataTable$resi = theme.dataTable.resize.hover.border, color = _theme$dataTable$resi.color, _theme$dataTable$resi2 = _theme$dataTable$resi.side, side = _theme$dataTable$resi2 === void 0 ? "end" : _theme$dataTable$resi2, size = _theme$dataTable$resi.size;
      border = {
        color,
        side,
        size
      };
    }
    return /* @__PURE__ */ import_react70.default.createElement(Stack, {
      anchor: "right"
    }, /* @__PURE__ */ import_react70.default.createElement(Box, _extends60({
      flex: false,
      responsive: false,
      pad: {
        vertical: "small"
      }
    }, theme.dataTable.resize)), /* @__PURE__ */ import_react70.default.createElement(InteractionBox, {
      active,
      flex: false,
      pad: {
        left: "xsmall"
      },
      ref,
      responsive: false,
      onMouseDown,
      onMouseMove: start3 !== void 0 ? onMouseMove : void 0,
      onMouseUp: start3 !== void 0 ? onMouseUp : void 0
    }, /* @__PURE__ */ import_react70.default.createElement(Box, {
      pad: {
        vertical: "small"
      },
      border
    })));
  };
  Resizer.displayName = "Resizer";
  Resizer.defaultProps = {};
  Object.setPrototypeOf(Resizer.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/DataTable/Searcher.js
  var import_react71 = __toESM(require_react());
  var import_styled_components51 = __toESM(require_styled_components_browser_cjs());
  var import_FormSearch = __toESM(require_FormSearch());
  var Searcher = function Searcher2(_ref) {
    var filtering = _ref.filtering, filters = _ref.filters, onFilter = _ref.onFilter, onFiltering = _ref.onFiltering, property = _ref.property;
    var theme = (0, import_react71.useContext)(import_styled_components51.ThemeContext) || defaultProps2.theme;
    var inputRef = (0, import_react71.useRef)();
    var needsFocus = filtering === property;
    (0, import_react71.useEffect)(function() {
      if (inputRef && needsFocus) {
        inputRef.current.focus();
      }
    }, [needsFocus, inputRef]);
    return filtering === property ? /* @__PURE__ */ import_react71.default.createElement(Keyboard, {
      onEsc: function onEsc() {
        return onFiltering(void 0);
      }
    }, /* @__PURE__ */ import_react71.default.createElement(Box, {
      width: {
        min: "xsmall"
      },
      flex: true,
      pad: {
        horizontal: "small"
      }
    }, /* @__PURE__ */ import_react71.default.createElement(TextInput, {
      name: "search-" + property,
      a11yTitle: "Search by " + property,
      ref: inputRef,
      value: filters[property],
      onChange: function onChange2(event) {
        return onFilter(property, event.target.value);
      },
      onBlur: function onBlur() {
        return onFiltering(void 0);
      }
    }))) : /* @__PURE__ */ import_react71.default.createElement(import_react71.default.Fragment, null, filters[property] ? /* @__PURE__ */ import_react71.default.createElement(Box, {
      flex: false,
      pad: {
        horizontal: "small"
      },
      direction: "row",
      align: "center"
    }, /* @__PURE__ */ import_react71.default.createElement(Text, null, filters[property])) : null, /* @__PURE__ */ import_react71.default.createElement(Button2, {
      a11yTitle: "Open search by " + property,
      icon: /* @__PURE__ */ import_react71.default.createElement(import_FormSearch.FormSearch, {
        color: normalizeColor(filtering === property ? "brand" : "border", theme)
      }),
      hoverIndicator: true,
      onClick: function onClick() {
        return onFiltering(filtering === property ? void 0 : property);
      }
    }));
  };
  Searcher.displayName = "Searcher";
  Searcher.defaultProps = {};
  Object.setPrototypeOf(Searcher.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/DataTable/ExpanderCell.js
  var import_react72 = __toESM(require_react());
  var import_styled_components52 = __toESM(require_styled_components_browser_cjs());
  var import_Blank = __toESM(require_Blank());
  var _excluded46 = ["context", "expanded", "onToggle", "pad"];
  var _excluded210 = ["background", "border", "context"];
  function _extends61() {
    _extends61 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends61.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose41(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var ExpanderControl = function ExpanderControl2(_ref) {
    var context = _ref.context, expanded = _ref.expanded, onToggle = _ref.onToggle, pad = _ref.pad, rest = _objectWithoutPropertiesLoose41(_ref, _excluded46);
    var theme = (0, import_react72.useContext)(import_styled_components52.ThemeContext) || defaultProps2.theme;
    var content;
    if (onToggle) {
      var ExpandIcon = theme.dataTable.icons[expanded ? "contract" : "expand"];
      content = /* @__PURE__ */ import_react72.default.createElement(ExpandIcon, {
        color: normalizeColor("border", theme)
      });
    } else {
      content = /* @__PURE__ */ import_react72.default.createElement(import_Blank.Blank, null);
    }
    var normalizedThemeProps = _extends61({}, theme.table[context], theme.dataTable[context]);
    delete normalizedThemeProps.background;
    delete normalizedThemeProps.border;
    delete normalizedThemeProps.pad;
    content = /* @__PURE__ */ import_react72.default.createElement(Box, _extends61({}, normalizedThemeProps, rest, {
      align: "center",
      fill: true,
      pad
    }), content);
    if (onToggle) {
      content = /* @__PURE__ */ import_react72.default.createElement(Button2, {
        fill: true,
        a11yTitle: expanded ? "collapse" : "expand",
        hoverIndicator: true,
        onClick: onToggle,
        plain: true
      }, content);
    }
    return content;
  };
  var ExpanderCell = function ExpanderCell2(_ref2) {
    var background = _ref2.background, border = _ref2.border, context = _ref2.context, rest = _objectWithoutPropertiesLoose41(_ref2, _excluded210);
    return /* @__PURE__ */ import_react72.default.createElement(TableCell, {
      background,
      border,
      size: "xxsmall",
      plain: "noPad",
      verticalAlign: context === "groupEnd" ? "bottom" : "top"
    }, /* @__PURE__ */ import_react72.default.createElement(ExpanderControl, _extends61({
      context
    }, rest)));
  };
  ExpanderCell.displayName = "ExpanderCell";
  ExpanderCell.defaultProps = {};
  Object.setPrototypeOf(ExpanderCell.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/DataTable/StyledDataTable.js
  var import_styled_components53 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/TableRow/TableRow.js
  var import_react73 = __toESM(require_react());
  function _extends62() {
    _extends62 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends62.apply(this, arguments);
  }
  var TableRow = /* @__PURE__ */ (0, import_react73.forwardRef)(function(props, ref) {
    return /* @__PURE__ */ import_react73.default.createElement(StyledTableRow, _extends62({
      ref
    }, props));
  });
  TableRow.displayName = "TableRow";

  // node_modules/grommet/es6/components/Table/Table.js
  var import_react74 = __toESM(require_react());

  // node_modules/grommet/es6/components/Table/propTypes.js
  var import_prop_types36 = __toESM(require_prop_types());
  function _extends63() {
    _extends63 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends63.apply(this, arguments);
  }
  var PropType36 = {};
  if (true) {
    PropType36 = _extends63({}, genericProps, {
      caption: import_prop_types36.default.string
    });
  }
  var TablePropTypes = PropType36;

  // node_modules/grommet/es6/components/Table/Table.js
  var _excluded47 = ["caption", "children"];
  function _extends64() {
    _extends64 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends64.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose42(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Table = /* @__PURE__ */ (0, import_react74.forwardRef)(function(_ref, ref) {
    var caption = _ref.caption, children = _ref.children, rest = _objectWithoutPropertiesLoose42(_ref, _excluded47);
    return /* @__PURE__ */ import_react74.default.createElement(StyledTable, _extends64({
      ref
    }, rest), caption ? /* @__PURE__ */ import_react74.default.createElement(StyledTableDataCaption, null, caption) : null, children);
  });
  Table.propTypes = TablePropTypes;

  // node_modules/grommet/es6/components/TableBody/TableBody.js
  var import_react75 = __toESM(require_react());
  function _extends65() {
    _extends65 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends65.apply(this, arguments);
  }
  var TableBody = /* @__PURE__ */ (0, import_react75.forwardRef)(function(props, ref) {
    return /* @__PURE__ */ import_react75.default.createElement(TableContext.Provider, {
      value: "body"
    }, /* @__PURE__ */ import_react75.default.createElement(StyledTableBody, _extends65({
      ref
    }, props)));
  });
  TableBody.displayName = "TableBody";

  // node_modules/grommet/es6/components/TableHeader/TableHeader.js
  var import_react76 = __toESM(require_react());
  function _extends66() {
    _extends66 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends66.apply(this, arguments);
  }
  var TableHeader = /* @__PURE__ */ (0, import_react76.forwardRef)(function(props, ref) {
    return /* @__PURE__ */ import_react76.default.createElement(TableContext.Provider, {
      value: "header"
    }, /* @__PURE__ */ import_react76.default.createElement(StyledTableHeader, _extends66({
      ref
    }, props)));
  });
  TableHeader.displayName = "TableHeader";

  // node_modules/grommet/es6/components/TableFooter/TableFooter.js
  var import_react77 = __toESM(require_react());
  function _extends67() {
    _extends67 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends67.apply(this, arguments);
  }
  var TableFooter = /* @__PURE__ */ (0, import_react77.forwardRef)(function(props, ref) {
    return /* @__PURE__ */ import_react77.default.createElement(TableContext.Provider, {
      value: "footer"
    }, /* @__PURE__ */ import_react77.default.createElement(StyledTableFooter, _extends67({
      ref
    }, props)));
  });
  TableFooter.displayName = "TableFooter";

  // node_modules/grommet/es6/components/DataTable/StyledDataTable.js
  var StyledDataTable = (0, import_styled_components53.default)(Table).withConfig({
    displayName: "StyledDataTable",
    componentId: "sc-xrlyjm-0"
  })(["position:relative;border-spacing:0;border-collapse:separate;", " ", " ", ";"], genericStyles, function(props) {
    return props.fillProp && fillStyle(props.fillProp);
  }, function(props) {
    return props.theme.dataTable && props.theme.dataTable.body && props.theme.dataTable.body.extend;
  });
  StyledDataTable.defaultProps = {};
  Object.setPrototypeOf(StyledDataTable.defaultProps, defaultProps2);
  var StyledContainer4 = (0, import_styled_components53.default)(Box).withConfig({
    displayName: "StyledDataTable__StyledContainer",
    componentId: "sc-xrlyjm-1"
  })(["", ";"], function(props) {
    return props.theme.dataTable && props.theme.dataTable.container && props.theme.dataTable.container.extend;
  });
  StyledContainer4.defaultProps = {};
  Object.setPrototypeOf(StyledContainer4.defaultProps, defaultProps2);
  var hoverStyle3 = (0, import_styled_components53.css)(["", " color:", ";"], function(props) {
    return backgroundStyle(normalizeColor(props.theme.table && props.theme.table.row && props.theme.table.row.hover && props.theme.table.row.hover.background || props.theme.global.hover.background, props.theme), props.theme);
  }, function(props) {
    return normalizeColor(props.theme.table && props.theme.table.row && props.theme.table.row.hover && props.theme.table.row.hover.color || props.theme.global.hover.color, props.theme);
  });
  var StyledDataTableRow = (0, import_styled_components53.default)(TableRow).withConfig({
    displayName: "StyledDataTable__StyledDataTableRow",
    componentId: "sc-xrlyjm-2"
  })(["", " ", " ", ""], function(props) {
    return props.size && "\n    display: table;\n    width: 100%;\n    table-layout: fixed;\n  ";
  }, function(props) {
    return props.onClick && "\n    cursor: pointer;\n  ";
  }, function(props) {
    return props.active && hoverStyle3;
  });
  StyledDataTableRow.defaultProps = {};
  Object.setPrototypeOf(StyledDataTableRow.defaultProps, defaultProps2);
  var StyledDataTableBody = (0, import_styled_components53.default)(TableBody).withConfig({
    displayName: "StyledDataTable__StyledDataTableBody",
    componentId: "sc-xrlyjm-3"
  })(["", " &:focus{", "}&:focus:not(:focus-visible){", "}"], function(props) {
    return props.size && "\n    display: block;\n    width: 100%;\n    max-height: " + (props.theme.global.size[props.size] || props.size) + ";\n    overflow: auto;\n  ";
  }, focusStyle({
    skipSvgChildren: true,
    forceOutline: true
  }), unfocusStyle({
    skipSvgChildren: true,
    forceOutline: true
  }));
  StyledDataTableBody.defaultProps = {};
  Object.setPrototypeOf(StyledDataTableBody.defaultProps, defaultProps2);
  var StyledDataTableHeader = (0, import_styled_components53.default)(TableHeader).withConfig({
    displayName: "StyledDataTable__StyledDataTableHeader",
    componentId: "sc-xrlyjm-4"
  })(["", ""], function(props) {
    return props.size && "\n    height: fit-content;\n    display: table;\n    width: calc(100% - " + props.scrollOffset + "px);\n    table-layout: fixed;\n  ";
  });
  StyledDataTableHeader.defaultProps = {};
  Object.setPrototypeOf(StyledDataTableHeader.defaultProps, defaultProps2);
  var StyledDataTableFooter = (0, import_styled_components53.default)(TableFooter).withConfig({
    displayName: "StyledDataTable__StyledDataTableFooter",
    componentId: "sc-xrlyjm-5"
  })(["", " ", ""], function(props) {
    return props.size && "\n    display: table;\n    width: calc(100% - " + props.scrollOffset + "px);\n    table-layout: fixed;\n  ";
  }, function(props) {
    return props.pin && "\n      /* Safari needs the relative positioning of tfoot specified */\n      position: sticky;\n      bottom: 0;\n      z-index: 1;\n  ";
  });
  StyledDataTableFooter.defaultProps = {};
  Object.setPrototypeOf(StyledDataTableFooter.defaultProps, defaultProps2);
  var StyledDataTableCell = (0, import_styled_components53.default)(TableCell).withConfig({
    displayName: "StyledDataTable__StyledDataTableCell",
    componentId: "sc-xrlyjm-6"
  })(["", ";", " ", ""], function(props) {
    return props.context === "header" && props.theme.dataTable && props.theme.dataTable.header && props.theme.dataTable.header.extend;
  }, function(props) {
    return props.pin && props.pin.length > 0 && "position: sticky;\n    " + props.pin.map(function(p) {
      return p + ": " + (props.pinnedOffset && props.pinnedOffset[p] && props.pinnedOffset[p] + "px" || 0) + ";";
    }).join(" ") + "\n    z-index: " + Object.keys(props.pin).length + ";\n  ";
  }, function(props) {
    return props.pin && props.pin.length > 0 && props.theme.dataTable.pinned && props.theme.dataTable.pinned[props.context] && props.theme.dataTable.pinned[props.context].extend ? props.theme.dataTable.pinned[props.context].extend : "";
  });
  StyledDataTableCell.defaultProps = {};
  Object.setPrototypeOf(StyledDataTableCell.defaultProps, defaultProps2);
  var StyledPlaceholder2 = (0, import_styled_components53.default)("caption").withConfig({
    displayName: "StyledDataTable__StyledPlaceholder",
    componentId: "sc-xrlyjm-7"
  })(["position:absolute;", " ", " left:0;right:0;"], function(props) {
    return "top: " + (props.top || 0) + "px;";
  }, function(props) {
    return "bottom: " + (props.bottom || 0) + "px;";
  });

  // node_modules/grommet/es6/components/DataTable/buildState.js
  var set = function set2(obj, path, value) {
    var parts2 = path;
    if (Object(obj) !== obj)
      return obj;
    if (!Array.isArray(path))
      parts2 = path.toString().match(/[^.[\]]+/g) || [];
    parts2.slice(0, -1).reduce(function(acc, item, index) {
      if (Object(acc[item]) === acc[item]) {
        return acc[item];
      }
      acc[item] = Math.abs(parts2[index + 1]) > 0 === +parts2[index + 1] ? [] : {};
      return acc[item];
    }, obj)[parts2[parts2.length - 1]] = value;
    return obj;
  };
  var datumValue3 = function datumValue4(datum, property) {
    if (!property)
      return void 0;
    var parts2 = property.split(".");
    if (parts2.length === 1)
      return datum[property];
    if (!datum[parts2[0]])
      return void 0;
    return datumValue4(datum[parts2[0]], parts2.slice(1).join("."));
  };
  var normalizePrimaryProperty = function normalizePrimaryProperty2(columns, primaryKey) {
    var result;
    columns.forEach(function(column) {
      if (column.primary && !result) {
        result = column.property;
      }
    });
    if (!result) {
      if (primaryKey === false)
        result = void 0;
      else if (primaryKey)
        result = primaryKey;
      else if (columns.length > 0)
        result = columns[0].property;
    }
    return result;
  };
  var initializeFilters = function initializeFilters2(columns) {
    var result = {};
    columns.forEach(function(column) {
      if (column.search) {
        result[column.property] = "";
      }
    });
    return result;
  };
  var escapeRegExp = function escapeRegExp2(input) {
    return input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  };
  var filterAndSortData = function filterAndSortData2(data, filters, onSearch, sort) {
    var result = data;
    if (!onSearch) {
      var regexps = {};
      Object.keys(filters).filter(function(n) {
        return filters[n];
      }).forEach(function(n) {
        regexps[n] = new RegExp(escapeRegExp(filters[n]), "i");
      });
      if (Object.keys(regexps).length > 0) {
        result = data.filter(function(datum) {
          return !Object.keys(regexps).some(function(property2) {
            return !regexps[property2].test(datumValue3(datum, property2));
          });
        });
      }
    }
    if (sort && !sort.external) {
      var property = sort.property, direction = sort.direction;
      result = result === data ? [].concat(data) : result;
      var sortAsc = direction === "asc";
      var before = sortAsc ? 1 : -1;
      var after = sortAsc ? -1 : 1;
      result.sort(function(d1, d2) {
        var d1Val = datumValue3(d1, property);
        var d2Val = datumValue3(d2, property);
        if (typeof d1Val === "string" && typeof d2Val === "string" || typeof d1Val === "string" && !d2Val || typeof d2Val === "string" && !d1Val) {
          var sortResult = (d1Val || "").localeCompare(d2Val || "", void 0, {
            sensitivity: "base"
          });
          return sortAsc ? sortResult : -sortResult;
        }
        if (d1Val > d2Val)
          return before;
        if (d1Val < d2Val)
          return after;
        return 0;
      });
    }
    return result;
  };
  var sumReducer = function sumReducer2(accumulated, next) {
    return accumulated + next;
  };
  var minReducer = function minReducer2(accumulated, next) {
    return accumulated === void 0 ? next : Math.min(accumulated, next);
  };
  var maxReducer = function maxReducer2(accumulated, next) {
    return accumulated === void 0 ? next : Math.max(accumulated, next);
  };
  var reducers = {
    max: maxReducer,
    min: minReducer,
    sum: sumReducer
  };
  var reducersInitValues = {
    min: Number.MAX_VALUE,
    max: Number.MIN_VALUE,
    sum: 0
  };
  var aggregateColumn = function aggregateColumn2(column, data) {
    var value;
    if (column.aggregate === "avg") {
      value = data.map(function(d) {
        return datumValue3(d, column.property);
      }).reduce(sumReducer);
      value /= data.length;
    } else {
      value = data.map(function(d) {
        return datumValue3(d, column.property);
      }).reduce(reducers[column.aggregate], reducersInitValues[column.aggregate]);
    }
    return value;
  };
  var aggregate = function aggregate2(columns, data) {
    var result = {};
    columns.forEach(function(column) {
      if (column.aggregate) {
        var value = aggregateColumn(column, data);
        result = set(result, column.property, value);
      }
    });
    return result;
  };
  var buildFooterValues = function buildFooterValues2(columns, data) {
    var aggregateValues = aggregate(columns, data);
    var result = {};
    columns.forEach(function(column) {
      if (column.footer) {
        if (column.footer.aggregate) {
          var value = datumValue3(aggregateValues, column.property);
          result = set(result, column.property, value);
        } else {
          result = set(result, column.property, column.footer);
        }
      }
    });
    return result;
  };
  var buildGroups = function buildGroups2(columns, data, groupBy, primaryProperty) {
    var result;
    if (groupBy != null && groupBy.property || typeof groupBy === "string") {
      result = [];
      var groupMap = {};
      data.forEach(function(datum) {
        var _groupBy$expandable;
        var key = datumValue3(datum, primaryProperty);
        var isGroup = key && ((_groupBy$expandable = groupBy.expandable) == null ? void 0 : _groupBy$expandable.includes(key));
        var groupByProperty = groupBy.property ? groupBy.property : groupBy;
        var groupValue = isGroup ? key : datumValue3(datum, groupByProperty);
        if (!groupMap[groupValue]) {
          var group3 = {
            data: [],
            datum: isGroup ? datum : {},
            key: groupValue
          };
          group3.datum[groupByProperty] = groupValue;
          result.push(group3);
          groupMap[groupValue] = group3;
        }
        if (!isGroup)
          groupMap[groupValue].data.push(datum);
      });
      if (!groupBy.expandable) {
        columns.forEach(function(column) {
          if (column.aggregate) {
            result.forEach(function(group3) {
              var datum = group3.datum;
              datum[column.property] = aggregateColumn(column, group3.data);
            });
          }
        });
      }
    } else if (groupBy != null && groupBy.expandable) {
      result = groupBy.expandable.map(function(key) {
        return {
          data: [],
          datum: {},
          key
        };
      });
    }
    return result;
  };
  var buildGroupState = function buildGroupState2(groups, groupBy) {
    var result = {};
    if (groups) {
      groups.forEach(function(_ref) {
        var key = _ref.key;
        if (key)
          result[key] = {
            expanded: false
          };
      });
    }
    if (groupBy && groupBy.expand) {
      groupBy.expand.forEach(function(value) {
        result[value] = {
          expanded: true
        };
      });
    }
    return result;
  };
  var normalizeBackgroundColor3 = function normalizeBackgroundColor4(theme) {
    var background = theme.background;
    if (typeof background === "string")
      return background;
    if (background.light && background.dark)
      return background;
    if (background.color)
      return background.color;
    return void 0;
  };
  var tableContextNames = ["header", "body", "footer"];
  var cellPropertyNames = ["background", "border", "pad"];
  var normalizeCellProps = function normalizeCellProps2(props, theme) {
    var result = {};
    tableContextNames.forEach(function(context) {
      result[context] = {
        pinned: {}
      };
      cellPropertyNames.forEach(function(propName) {
        var _props$propName, _theme$dataTable, _theme$dataTable$cont, _theme$table, _theme$table$context, _props$propName3, _props$propName3$pinn, _props$propName5, _theme$dataTable2, _theme$dataTable2$pin, _theme$dataTable2$pin2;
        var value = (props == null ? void 0 : (_props$propName = props[propName]) == null ? void 0 : _props$propName[context]) || // if the propName is used without context, it applies to all contexts
        tableContextNames.every(function(n) {
          var _props$propName2;
          return !(props != null && (_props$propName2 = props[propName]) != null && _props$propName2[n]);
        }) && (props == null ? void 0 : props[propName]) || (theme == null ? void 0 : (_theme$dataTable = theme.dataTable) == null ? void 0 : (_theme$dataTable$cont = _theme$dataTable[context]) == null ? void 0 : _theme$dataTable$cont[propName]) || (theme == null ? void 0 : (_theme$table = theme.table) == null ? void 0 : (_theme$table$context = _theme$table[context]) == null ? void 0 : _theme$table$context[propName]);
        if (value !== void 0)
          result[context][propName] = value;
        value = (props == null ? void 0 : (_props$propName3 = props[propName]) == null ? void 0 : (_props$propName3$pinn = _props$propName3.pinned) == null ? void 0 : _props$propName3$pinn[context]) || context === "body" && tableContextNames.every(function(n) {
          var _props$propName4, _props$propName4$pinn;
          return !(props != null && (_props$propName4 = props[propName]) != null && (_props$propName4$pinn = _props$propName4.pinned) != null && _props$propName4$pinn[n]);
        }) && (props == null ? void 0 : (_props$propName5 = props[propName]) == null ? void 0 : _props$propName5.pinned) || (theme == null ? void 0 : (_theme$dataTable2 = theme.dataTable) == null ? void 0 : (_theme$dataTable2$pin = _theme$dataTable2.pinned) == null ? void 0 : (_theme$dataTable2$pin2 = _theme$dataTable2$pin[context]) == null ? void 0 : _theme$dataTable2$pin2[propName]);
        if (value !== void 0) {
          if (propName === "background" && theme.background && value.opacity && !value.color)
            value.color = normalizeBackgroundColor3(theme);
          if (context === "body")
            result[context].pinned[propName] = value;
          else if (props.pin === true || props.pin === context)
            result[context][propName] = value;
        }
      });
    });
    return result;
  };
  var normalizeRowCellProps = function normalizeRowCellProps2(rowProps, cellProps, primaryKey, index) {
    var result = {
      pinned: {}
    };
    ["background", "border", "pad"].forEach(function(propName) {
      var _rowProps$primaryKey;
      var row = primaryKey && rowProps && (rowProps == null ? void 0 : (_rowProps$primaryKey = rowProps[primaryKey]) == null ? void 0 : _rowProps$primaryKey[propName]);
      var cell = cellProps[propName];
      var value = row && (Array.isArray(row) ? row[index % row.length] : row) || (Array.isArray(cell) ? cell[index % cell.length] : cell);
      if (value !== void 0)
        result[propName] = value;
      var rowPin = rowProps && rowProps.pinned && rowProps.pinned[propName];
      var cellPin = cellProps.pinned[propName];
      value = rowPin && (Array.isArray(rowPin) ? rowPin[index % rowPin.length] : rowPin) || (Array.isArray(cellPin) ? cellPin[index % cellPin.length] : cellPin);
      if (value !== void 0)
        result.pinned[propName] = value;
    });
    return result;
  };

  // node_modules/grommet/es6/components/DataTable/Header.js
  var _excluded48 = ["background", "border", "color", "font", "gap", "pad", "units"];
  var _excluded211 = ["cellProps", "columns", "data", "disabled", "fill", "filtering", "filters", "groupBy", "groups", "groupState", "onFilter", "onFiltering", "onResize", "onSelect", "onSort", "onToggle", "onWidths", "pin", "pinnedOffset", "primaryProperty", "selected", "rowDetails", "sort", "widths", "verticalAlign"];
  function _extends68() {
    _extends68 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends68.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose43(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var separateThemeProps = function separateThemeProps2(theme) {
    var _theme$dataTable$head = theme.dataTable.header, background = _theme$dataTable$head.background, border = _theme$dataTable$head.border, color = _theme$dataTable$head.color, font = _theme$dataTable$head.font, gap = _theme$dataTable$head.gap, pad = _theme$dataTable$head.pad, units = _theme$dataTable$head.units, rest = _objectWithoutPropertiesLoose43(_theme$dataTable$head, _excluded48);
    var textProps = _extends68({
      color
    }, font);
    var iconProps = {
      color
    };
    var layoutProps = _extends68({}, rest);
    return [layoutProps, textProps, iconProps];
  };
  var buttonStyle = function buttonStyle2(_ref) {
    var pad = _ref.pad, theme = _ref.theme, verticalAlign2 = _ref.verticalAlign;
    var styles = [];
    var _separateThemeProps = separateThemeProps(theme), layoutProps = _separateThemeProps[0], iconProps = _separateThemeProps[2];
    if (pad) {
      styles.push(kindPartStyles({
        pad
      }, theme));
    }
    if (layoutProps) {
      styles.push(kindPartStyles(layoutProps, theme));
    }
    if (layoutProps.hover) {
      var partStyles = kindPartStyles(layoutProps.hover, theme);
      if (partStyles.length > 0)
        styles.push((0, import_styled_components54.css)(["&:hover{", "}"], partStyles));
    }
    if (iconProps.color) {
      styles.push((0, import_styled_components54.css)(["svg{stroke:", ";fill:", ";}"], normalizeColor(iconProps.color, theme), normalizeColor(iconProps.color, theme)));
    }
    var align = "center";
    if (verticalAlign2 === "bottom")
      align = "end";
    if (verticalAlign2 === "top")
      align = "start";
    if (verticalAlign2) {
      styles.push((0, import_styled_components54.css)(["display:inline-flex;align-items:", ";"], align));
    }
    return styles;
  };
  var StyledHeaderCellButton = (0, import_styled_components54.default)(Button2).withConfig({
    displayName: "Header__StyledHeaderCellButton",
    componentId: "sc-1baku5q-0"
  })(["", ""], function(props) {
    return buttonStyle(props);
  });
  var StyledContentBox = (0, import_styled_components54.default)(Box).withConfig({
    displayName: "Header__StyledContentBox",
    componentId: "sc-1baku5q-1"
  })(["", ""], function(props) {
    return props.extend;
  });
  var Header2 = /* @__PURE__ */ (0, import_react78.forwardRef)(function(_ref2, ref) {
    var cellProps = _ref2.cellProps, columns = _ref2.columns, data = _ref2.data, disabled = _ref2.disabled, fill = _ref2.fill, filtering = _ref2.filtering, filters = _ref2.filters, groupBy = _ref2.groupBy, groups = _ref2.groups, groupState = _ref2.groupState, onFilter = _ref2.onFilter, onFiltering = _ref2.onFiltering, onResize = _ref2.onResize, onSelect = _ref2.onSelect, onSort = _ref2.onSort, onToggle = _ref2.onToggle, onWidths = _ref2.onWidths, pinProp = _ref2.pin, pinnedOffset = _ref2.pinnedOffset, primaryProperty = _ref2.primaryProperty, selected = _ref2.selected, rowDetails = _ref2.rowDetails, sort = _ref2.sort, widths = _ref2.widths, verticalAlign2 = _ref2.verticalAlign, rest = _objectWithoutPropertiesLoose43(_ref2, _excluded211);
    var theme = (0, import_react78.useContext)(import_styled_components54.ThemeContext) || defaultProps2.theme;
    var _separateThemeProps2 = separateThemeProps(theme), layoutProps = _separateThemeProps2[0], textProps = _separateThemeProps2[1];
    var _useState = (0, import_react78.useState)([]), cellWidths = _useState[0], setCellWidths = _useState[1];
    var updateWidths = (0, import_react78.useCallback)(function(width) {
      return setCellWidths(function(values) {
        return [].concat(values, [width]);
      });
    }, []);
    (0, import_react78.useEffect)(function() {
      if (onWidths && cellWidths.length !== 0) {
        onWidths(cellWidths);
      }
    }, [cellWidths, onWidths]);
    var pin = pinProp ? ["top"] : [];
    var selectPin = pinnedOffset != null && pinnedOffset._grommetDataTableSelect ? [].concat(pin, ["left"]) : pin;
    var totalSelectedGroups = groupBy != null && groupBy.select ? Object.keys(groupBy.select).reduce(function(total, cur) {
      return cur && groupBy.select[cur] === "all" ? total + 1 : total;
    }, 0) : 0;
    var totalSelected = ((selected == null ? void 0 : selected.length) || 0) + totalSelectedGroups;
    var onChangeSelection = (0, import_react78.useCallback)(function() {
      var nextSelected;
      var nextGroupSelected = {};
      var primaryValues = data.map(function(datum) {
        return datumValue3(datum, primaryProperty);
      }) || [];
      var enabled = disabled && primaryValues.filter(function(v) {
        return !disabled.includes(v);
      }) || primaryValues;
      var enabledSelected = selected && enabled.filter(function(v) {
        return selected.includes(v);
      }) || primaryValues;
      var allSelected = groupBy != null && groupBy.select ? groupBy.select[""] === "all" : enabledSelected.length === enabled.length;
      if (allSelected) {
        nextSelected = disabled ? primaryValues.filter(function(v) {
          return disabled.includes(v) && selected.includes(v);
        }) : [];
        nextGroupSelected[""] = "none";
      } else {
        var _groupBy$expandable;
        nextSelected = disabled ? primaryValues.filter(function(v) {
          return !disabled.includes(v) || selected.includes(v);
        }) : primaryValues;
        nextGroupSelected[""] = "all";
        groupBy == null ? void 0 : (_groupBy$expandable = groupBy.expandable) == null ? void 0 : _groupBy$expandable.forEach(function(key) {
          nextGroupSelected[key] = "all";
        });
      }
      if (groupBy != null && groupBy.onSelect) {
        groupBy.onSelect(nextSelected, void 0, nextGroupSelected);
      } else
        onSelect(nextSelected);
    }, [data, disabled, groupBy, onSelect, primaryProperty, selected]);
    return /* @__PURE__ */ import_react78.default.createElement(StyledDataTableHeader, _extends68({
      ref,
      fillProp: fill
    }, rest), /* @__PURE__ */ import_react78.default.createElement(StyledDataTableRow, null, groups && /* @__PURE__ */ import_react78.default.createElement(ExpanderCell, {
      background: cellProps.background,
      border: cellProps.border,
      context: "header",
      expanded: Object.keys(groupState).filter(function(k) {
        return !groupState[k].expanded;
      }).length === 0,
      onToggle,
      pad: cellProps.pad
    }), (selected || onSelect) && /* @__PURE__ */ import_react78.default.createElement(StyledDataTableCell, {
      background: cellProps.background,
      onWidth: updateWidths,
      plain: "noPad",
      size: "auto",
      context: "header",
      scope: "col",
      pin: selectPin,
      pinnedOffset: pinnedOffset == null ? void 0 : pinnedOffset._grommetDataTableSelect,
      verticalAlign: verticalAlign2
    }, onSelect && /* @__PURE__ */ import_react78.default.createElement(CheckBox, {
      a11yTitle: totalSelected === data.length ? "unselect all" : "select all",
      checked: groupBy != null && groupBy.select ? groupBy.select[""] === "all" : totalSelected > 0 && data.length > 0 && totalSelected === data.length,
      indeterminate: groupBy != null && groupBy.select ? groupBy.select[""] === "some" : totalSelected > 0 && totalSelected < data.length,
      onChange: onChangeSelection,
      pad: cellProps.pad
    })), rowDetails && /* @__PURE__ */ import_react78.default.createElement(TableCell, {
      size: "xxsmall",
      plain: true,
      pad: "none"
    }), columns.map(function(_ref3) {
      var property = _ref3.property, header = _ref3.header, align = _ref3.align, columnPin = _ref3.pin, search = _ref3.search, sortable = _ref3.sortable, columnVerticalAlign = _ref3.verticalAlign, size = _ref3.size, units = _ref3.units;
      var content;
      var unitsContent = units ? /* @__PURE__ */ import_react78.default.createElement(Text, _extends68({}, textProps, theme.dataTable.header.units), units) : void 0;
      if (typeof header === "string") {
        content = /* @__PURE__ */ import_react78.default.createElement(Text, textProps, header);
        if (Object.keys(layoutProps).length && (sortable === false || !onSort)) {
          content = /* @__PURE__ */ import_react78.default.createElement(StyledContentBox, layoutProps, content);
        }
      } else
        content = header;
      if (unitsContent) {
        content = /* @__PURE__ */ import_react78.default.createElement(Box, {
          justify: align,
          direction: "row"
        }, content, unitsContent);
      }
      if (verticalAlign2 || columnVerticalAlign) {
        var vertical12 = verticalAlign2 || columnVerticalAlign;
        content = /* @__PURE__ */ import_react78.default.createElement(Box, {
          height: "100%",
          justify: verticalAlignToJustify[vertical12]
        }, content);
      }
      if (onSort && sortable !== false) {
        var Icon;
        if (onSort && sortable !== false) {
          if (sort && sort.property === property) {
            Icon = theme.dataTable.icons[sort.direction !== "asc" ? "ascending" : "descending"];
          } else if (theme.dataTable.icons.sortable) {
            Icon = theme.dataTable.icons.sortable;
          }
        }
        content = /* @__PURE__ */ import_react78.default.createElement(StyledHeaderCellButton, {
          plain: true,
          column: property,
          fill: "vertical",
          onClick: onSort(property),
          sort,
          pad: cellProps.pad,
          sortable: true,
          verticalAlign: verticalAlign2 || columnVerticalAlign
        }, /* @__PURE__ */ import_react78.default.createElement(Box, {
          direction: "row",
          align: "center",
          gap: "xsmall",
          justify: align
        }, content, Icon && /* @__PURE__ */ import_react78.default.createElement(Icon, null)));
      }
      content = /* @__PURE__ */ import_react78.default.createElement(Box, {
        flex: "grow",
        fill: onResize || search ? "vertical" : false,
        justify: !align && "center" || align
      }, content);
      if (search || onResize) {
        var resizer = onResize ? /* @__PURE__ */ import_react78.default.createElement(Resizer, {
          property,
          onResize
        }) : null;
        var searcher = search && filters ? /* @__PURE__ */ import_react78.default.createElement(Searcher, {
          filtering,
          filters,
          property,
          onFilter,
          onFiltering
        }) : null;
        content = /* @__PURE__ */ import_react78.default.createElement(Box, {
          direction: "row",
          align: "center",
          justify: !align || align === "start" ? "between" : align,
          gap: theme.dataTable.header.gap,
          fill: "vertical",
          style: onResize ? {
            position: "relative"
          } : void 0
        }, content, searcher && resizer ? /* @__PURE__ */ import_react78.default.createElement(Box, {
          flex: "shrink",
          direction: "row",
          align: "center",
          gap: theme.dataTable.header.gap
        }, searcher, resizer) : searcher || resizer);
      }
      var cellPin = [].concat(pin);
      if (columnPin)
        cellPin.push("left");
      return /* @__PURE__ */ import_react78.default.createElement(StyledDataTableCell, {
        key: property,
        align,
        context: "header",
        verticalAlign: verticalAlign2 || columnVerticalAlign,
        background: cellProps.background,
        border: cellProps.border,
        onWidth: updateWidths,
        pad: sortable === false || !onSort ? cellProps.pad : "none",
        pin: cellPin,
        plain: true,
        pinnedOffset: pinnedOffset && pinnedOffset[property],
        scope: "col",
        size: widths && widths[property] ? void 0 : size,
        style: widths && widths[property] ? {
          width: widths[property]
        } : void 0
      }, content);
    })));
  });
  Header2.displayName = "Header";
  Header2.defaultProps = {};
  Object.setPrototypeOf(Header2.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/DataTable/Footer.js
  var import_react80 = __toESM(require_react());

  // node_modules/grommet/es6/components/DataTable/Cell.js
  var import_react79 = __toESM(require_react());
  var import_styled_components55 = __toESM(require_styled_components_browser_cjs());
  var _excluded49 = ["background", "border", "column", "datum", "pad", "pin", "pinnedOffset", "primaryProperty", "scope", "verticalAlign"];
  function _extends69() {
    _extends69 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends69.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose44(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Cell = /* @__PURE__ */ (0, import_react79.memo)(function(_ref) {
    var background = _ref.background, border = _ref.border, _ref$column = _ref.column, align = _ref$column.align, columnPin = _ref$column.pin, plain = _ref$column.plain, footer = _ref$column.footer, property = _ref$column.property, render = _ref$column.render, columnVerticalAlign = _ref$column.verticalAlign, size = _ref$column.size, datum = _ref.datum, pad = _ref.pad, cellPin = _ref.pin, pinnedOffset = _ref.pinnedOffset, primaryProperty = _ref.primaryProperty, scope = _ref.scope, verticalAlign2 = _ref.verticalAlign, rest = _objectWithoutPropertiesLoose44(_ref, _excluded49);
    var theme = (0, import_react79.useContext)(import_styled_components55.ThemeContext) || defaultProps2.theme;
    var value = datumValue3(datum, property);
    var context = (0, import_react79.useContext)(TableContext);
    var renderContexts = context === "body" || context === "footer" && footer && footer.aggregate;
    var content;
    if (render && renderContexts) {
      content = render(datum);
    } else if (value !== void 0) {
      if (typeof value === "string" || typeof value === "number" || /* @__PURE__ */ (0, import_react79.isValidElement)(value))
        content = value;
    }
    if (typeof content === "string" || typeof content === "number") {
      var textProps = property === primaryProperty ? theme.dataTable.primary : {};
      content = /* @__PURE__ */ import_react79.default.createElement(Text, textProps, content);
    }
    var pin = [];
    if (cellPin)
      pin.push.apply(pin, cellPin);
    if (columnPin)
      pin.push("left");
    return /* @__PURE__ */ import_react79.default.createElement(StyledDataTableCell, _extends69({
      scope
    }, theme.dataTable[context], {
      align,
      context,
      verticalAlign: verticalAlign2 || columnVerticalAlign,
      size,
      background,
      pinnedOffset,
      border,
      pad,
      pin,
      plain: plain ? "noPad" : void 0
    }, rest), content);
  });
  Cell.displayName = "Cell";
  Cell.defaultProps = {};
  Object.setPrototypeOf(Cell.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/DataTable/Footer.js
  var _excluded50 = ["cellProps", "columns", "fill", "footerValues", "groups", "onSelect", "pin", "pinnedOffset", "primaryProperty", "selected", "verticalAlign"];
  function _extends70() {
    _extends70 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends70.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose45(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Footer3 = /* @__PURE__ */ (0, import_react80.forwardRef)(function(_ref, ref) {
    var cellProps = _ref.cellProps, columns = _ref.columns, fill = _ref.fill, footerValues = _ref.footerValues, groups = _ref.groups, onSelect = _ref.onSelect, pinProp = _ref.pin, pinnedOffset = _ref.pinnedOffset, primaryProperty = _ref.primaryProperty, selected = _ref.selected, verticalAlign2 = _ref.verticalAlign, rest = _objectWithoutPropertiesLoose45(_ref, _excluded50);
    var pin = pinProp ? ["bottom"] : [];
    return /* @__PURE__ */ import_react80.default.createElement(StyledDataTableFooter, _extends70({
      ref,
      fillProp: fill,
      pin: pinProp
    }, rest), /* @__PURE__ */ import_react80.default.createElement(TableRow, null, groups && /* @__PURE__ */ import_react80.default.createElement(TableCell, {
      plain: true,
      size: "xxsmall",
      pad: "none",
      verticalAlign: "top",
      background: cellProps.background,
      border: cellProps.border
    }), (selected || onSelect) && /* @__PURE__ */ import_react80.default.createElement(StyledDataTableCell, {
      background: cellProps.background,
      context: "footer",
      pin,
      verticalAlign: verticalAlign2
    }), columns.map(function(column) {
      var cellPin = [].concat(pin);
      if (column.pin)
        cellPin.push("left");
      return /* @__PURE__ */ import_react80.default.createElement(Cell, {
        key: column.property,
        background: column.pin && cellProps.pinned.background || cellProps.background,
        border: column.pin && cellProps.pinned.border || cellProps.border,
        context: "footer",
        column,
        datum: footerValues,
        pad: column.pin && cellProps.pinned.pad || cellProps.pad,
        pin: pin.length ? pin : void 0,
        pinnedOffset: pinnedOffset && pinnedOffset[column.property],
        primaryProperty,
        verticalAlign: verticalAlign2
      });
    })));
  });
  Footer3.displayName = "Footer";
  Footer3.defaultProps = {};
  Object.setPrototypeOf(Footer3.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/DataTable/Body.js
  var import_react81 = __toESM(require_react());
  var import_styled_components56 = __toESM(require_styled_components_browser_cjs());
  var _excluded51 = ["cellProps", "columns", "data", "disabled", "onMore", "replace", "onClickRow", "onSelect", "pinnedOffset", "primaryProperty", "rowProps", "selected", "rowDetails", "show", "size", "step", "rowExpand", "setRowExpand", "verticalAlign"];
  function _extends71() {
    _extends71 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends71.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose46(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Row = /* @__PURE__ */ (0, import_react81.memo)(function(_ref) {
    var cellProps = _ref.cellProps, primaryValue = _ref.primaryValue, index = _ref.index, rowRef = _ref.rowRef, size = _ref.size, active = _ref.active, onClickRow = _ref.onClickRow, datum = _ref.datum, selected = _ref.selected, onSelect = _ref.onSelect, isDisabled2 = _ref.isDisabled, isSelected = _ref.isSelected, rowDetails = _ref.rowDetails, isRowExpanded = _ref.isRowExpanded, setActive = _ref.setActive, setRowExpand = _ref.setRowExpand, rowExpand = _ref.rowExpand, columns = _ref.columns, pinnedOffset = _ref.pinnedOffset, primaryProperty = _ref.primaryProperty, data = _ref.data, verticalAlign2 = _ref.verticalAlign;
    return /* @__PURE__ */ import_react81.default.createElement(import_react81.default.Fragment, null, /* @__PURE__ */ import_react81.default.createElement(StyledDataTableRow, {
      ref: rowRef,
      size,
      active,
      "aria-disabled": onClickRow && isDisabled2 || void 0,
      onClick: onClickRow ? function(event) {
        if (onClickRow && !isDisabled2) {
          if (typeof onClickRow === "function") {
            event.persist();
            var adjustedEvent = event;
            adjustedEvent.datum = datum;
            adjustedEvent.index = index;
            onClickRow(adjustedEvent);
          } else if (onClickRow === "select") {
            if (isSelected) {
              onSelect(selected.filter(function(s) {
                return s !== primaryValue;
              }));
            } else
              onSelect([].concat(selected, [primaryValue]));
          }
        }
      } : void 0,
      onMouseEnter: onClickRow && !isDisabled2 ? function() {
        return setActive(index);
      } : void 0,
      onMouseLeave: onClickRow ? function() {
        return setActive(void 0);
      } : void 0
    }, (selected || onSelect) && /* @__PURE__ */ import_react81.default.createElement(Cell, {
      background: (pinnedOffset == null ? void 0 : pinnedOffset._grommetDataTableSelect) && cellProps.pinned.background || cellProps.background,
      pinnedOffset: pinnedOffset == null ? void 0 : pinnedOffset._grommetDataTableSelect,
      "aria-disabled": isDisabled2 || !onSelect || void 0,
      column: {
        pin: Boolean(pinnedOffset == null ? void 0 : pinnedOffset._grommetDataTableSelect),
        plain: "noPad",
        size: "auto",
        render: function render() {
          return /* @__PURE__ */ import_react81.default.createElement(CheckBox, {
            tabIndex: onClickRow === "select" ? -1 : void 0,
            a11yTitle: (isSelected ? "unselect" : "select") + " " + primaryValue,
            checked: isSelected,
            disabled: isDisabled2 || !onSelect,
            onChange: function onChange2() {
              if (isSelected) {
                onSelect(selected.filter(function(s) {
                  return s !== primaryValue;
                }));
              } else
                onSelect([].concat(selected, [primaryValue]));
            },
            pad: cellProps.pad
          });
        }
      },
      verticalAlign: verticalAlign2
    }), rowDetails && /* @__PURE__ */ import_react81.default.createElement(ExpanderCell, {
      context: isRowExpanded ? "groupHeader" : "body",
      expanded: isRowExpanded,
      onToggle: function onToggle() {
        if (isRowExpanded) {
          setRowExpand(rowExpand.filter(function(s) {
            return s !== index;
          }));
        } else {
          setRowExpand([].concat(rowExpand, [index]));
        }
      },
      pad: cellProps.pad,
      verticalAlign: verticalAlign2
    }), columns.map(function(column) {
      return /* @__PURE__ */ import_react81.default.createElement(Cell, {
        key: column.property,
        background: column.pin && cellProps.pinned.background || cellProps.background,
        border: column.pin && cellProps.pinned.border || cellProps.border,
        context: "body",
        column,
        datum,
        pad: column.pin && cellProps.pinned.pad || cellProps.pad,
        pinnedOffset: pinnedOffset && pinnedOffset[column.property],
        primaryProperty,
        scope: column.primary || column.property === primaryProperty ? "row" : void 0,
        verticalAlign: verticalAlign2
      });
    })), rowDetails && isRowExpanded && /* @__PURE__ */ import_react81.default.createElement(StyledDataTableRow, {
      key: index.toString() + "_expand"
    }, (selected || onSelect) && /* @__PURE__ */ import_react81.default.createElement(TableCell, null), /* @__PURE__ */ import_react81.default.createElement(TableCell, {
      colSpan: columns.length + 1
    }, rowDetails(data[index]))));
  });
  var Body = /* @__PURE__ */ (0, import_react81.forwardRef)(function(_ref2, ref) {
    var _ref3;
    var cellPropsProp = _ref2.cellProps, columns = _ref2.columns, data = _ref2.data, disabled = _ref2.disabled, onMore = _ref2.onMore, replace = _ref2.replace, onClickRow = _ref2.onClickRow, onSelect = _ref2.onSelect, pinnedOffset = _ref2.pinnedOffset, primaryProperty = _ref2.primaryProperty, rowProps = _ref2.rowProps, selected = _ref2.selected, rowDetails = _ref2.rowDetails, show = _ref2.show, size = _ref2.size, step = _ref2.step, rowExpand = _ref2.rowExpand, setRowExpand = _ref2.setRowExpand, verticalAlign2 = _ref2.verticalAlign, rest = _objectWithoutPropertiesLoose46(_ref2, _excluded51);
    var theme = (0, import_react81.useContext)(import_styled_components56.ThemeContext) || defaultProps2.theme;
    var _React$useState = import_react81.default.useState(), active = _React$useState[0], setActive = _React$useState[1];
    var _React$useState2 = import_react81.default.useState(), lastActive = _React$useState2[0], setLastActive = _React$useState2[1];
    var usingKeyboard = useKeyboard();
    var onFocusActive = (_ref3 = active != null ? active : lastActive) != null ? _ref3 : usingKeyboard ? 0 : void 0;
    var selectRow = function selectRow2() {
      var _data$active;
      var primaryValue = (_data$active = data[active]) == null ? void 0 : _data$active[primaryProperty];
      if (selected && selected.includes(primaryValue)) {
        onSelect(selected.filter(function(s) {
          return s !== primaryValue;
        }));
      } else
        onSelect([].concat(selected, [primaryValue]));
    };
    var clickableRow = onClickRow && active >= 0 && (!disabled || !disabled.includes(datumValue3(data[active], primaryProperty)));
    return /* @__PURE__ */ import_react81.default.createElement(Keyboard, {
      onEnter: clickableRow ? function(event) {
        if (clickableRow) {
          if (typeof onClickRow === "function") {
            event.persist();
            var adjustedEvent = event;
            adjustedEvent.datum = data[active];
            onClickRow(adjustedEvent);
          } else if (onClickRow === "select") {
            selectRow();
          }
        }
      } : void 0,
      onSpace: function onSpace() {
        if (clickableRow) {
          if (onClickRow === "select") {
            selectRow();
          }
        }
      },
      onUp: onClickRow && active ? function() {
        return setActive(active - 1);
      } : void 0,
      onDown: onClickRow && data.length && active < data.length - 1 ? function() {
        return setActive((active != null ? active : -1) + 1);
      } : void 0
    }, /* @__PURE__ */ import_react81.default.createElement(StyledDataTableBody, _extends71({
      ref,
      size,
      tabIndex: onClickRow ? 0 : void 0,
      onFocus: function onFocus() {
        return setActive(onFocusActive);
      },
      onBlur: function onBlur() {
        setLastActive(active);
        setActive(void 0);
      }
    }, rest), /* @__PURE__ */ import_react81.default.createElement(InfiniteScroll, {
      items: data,
      onMore,
      replace,
      renderMarker: function renderMarker(marker) {
        return /* @__PURE__ */ import_react81.default.createElement(TableRow, null, /* @__PURE__ */ import_react81.default.createElement(TableCell, null, marker));
      },
      show,
      step
    }, function(datum, index, rowRef) {
      var primaryValue = primaryProperty ? datumValue3(datum, primaryProperty) : void 0;
      var isSelected = selected && selected.includes(primaryValue);
      var isDisabled2 = disabled && disabled.includes(primaryValue);
      var isRowExpanded = rowExpand && rowExpand.includes(index);
      var cellProps = normalizeRowCellProps(rowProps, cellPropsProp, primaryValue, index);
      return /* @__PURE__ */ import_react81.default.createElement(Row, {
        key: index,
        setActive,
        rowRef,
        cellProps,
        primaryValue,
        isDisabled: isDisabled2,
        isSelected,
        isRowExpanded,
        index,
        size,
        active: active >= 0 ? active === index : void 0,
        onClickRow,
        datum,
        selected,
        onSelect,
        rowDetails,
        setRowExpand,
        rowExpand,
        columns,
        primaryProperty,
        rowProps,
        data,
        theme,
        pinnedOffset,
        verticalAlign: verticalAlign2
      });
    })));
  });

  // node_modules/grommet/es6/components/DataTable/GroupedBody.js
  var import_react82 = __toESM(require_react());
  var _excluded52 = ["cellProps", "columns", "data", "disabled", "groupBy", "groups", "groupState", "pinnedOffset", "primaryProperty", "onMore", "onSelect", "onToggle", "onUpdate", "replace", "rowProps", "selected", "size", "step", "verticalAlign"];
  function _extends72() {
    _extends72 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends72.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose47(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var GroupedBody = /* @__PURE__ */ (0, import_react82.forwardRef)(function(_ref, ref) {
    var cellPropsProp = _ref.cellProps, columns = _ref.columns, data = _ref.data, disabled = _ref.disabled, groupBy = _ref.groupBy, groups = _ref.groups, groupState = _ref.groupState, pinnedOffset = _ref.pinnedOffset, primaryProperty = _ref.primaryProperty, onMore = _ref.onMore, onSelect = _ref.onSelect, onToggle = _ref.onToggle, onUpdate = _ref.onUpdate, replace = _ref.replace, rowProps = _ref.rowProps, selected = _ref.selected, size = _ref.size, step = _ref.step, verticalAlign2 = _ref.verticalAlign, rest = _objectWithoutPropertiesLoose47(_ref, _excluded52);
    var items = (0, import_react82.useMemo)(function() {
      var nextItems = [];
      groups.forEach(function(group3) {
        var _ref2 = groupState[group3.key] || {
          expanded: true
        }, expanded = _ref2.expanded;
        var memberCount = group3.data.length;
        var groupSelected = [];
        var isGroupSelected = false;
        var groupDisabled = [];
        var isGroupDisabled = false;
        if (memberCount > 1 || onUpdate && group3.key) {
          var primaryKeys = group3.data.map(function(datum) {
            return datum[primaryProperty];
          });
          groupSelected = primaryKeys && selected ? primaryKeys.filter(function(val) {
            return selected.includes(val);
          }) : [];
          isGroupSelected = groupBy.select ? groupBy.select[group3.key] === "all" : groupSelected.length === group3.data.length && groupSelected.length > 0;
          var indeterminate = groupBy.select ? groupBy.select[group3.key] === "some" : groupSelected.length > 0 && groupSelected.length < group3.data.length;
          groupDisabled = primaryKeys && disabled ? primaryKeys.filter(function(val) {
            return disabled.includes(val);
          }) : [];
          isGroupDisabled = groupBy.disable ? groupBy.disable[group3.key] === "all" : groupDisabled.length === group3.data.length && groupDisabled.length > 0;
          nextItems.push({
            expanded,
            key: group3.key,
            primaryValue: group3.key,
            datum: group3.datum,
            context: "groupHeader",
            isDisabled: isGroupDisabled,
            isSelected: isGroupSelected,
            indeterminate,
            onChange: function onChange2() {
              var nextSelected = isGroupSelected || indeterminate ? selected.filter(function(s) {
                return !groupSelected.includes(s);
              }) : [].concat(selected, primaryKeys);
              if (groupBy.onSelect) {
                groupBy.onSelect(nextSelected, group3.datum, groupBy.select);
              } else {
                onSelect(nextSelected, group3.datum);
              }
            }
          });
        }
        if (!onUpdate && memberCount === 1 || expanded) {
          group3.data.forEach(function(datum, index) {
            var primaryValue = primaryProperty ? datumValue3(datum, primaryProperty) : void 0;
            var isSelected = selected == null ? void 0 : selected.includes(primaryValue);
            var isDisabled2 = disabled == null ? void 0 : disabled.includes(primaryValue);
            nextItems.push({
              key: datum[primaryProperty],
              primaryValue: primaryProperty ? datumValue3(datum, primaryProperty) : void 0,
              datum,
              context: memberCount > 1 && index === memberCount - 1 ? "groupEnd" : "body",
              isDisabled: isDisabled2,
              isSelected,
              onChange: function onChange2() {
                var nextSelected = isSelected ? selected.filter(function(s) {
                  return s !== primaryValue;
                }) : [].concat(selected, [primaryValue]);
                onSelect(nextSelected, datum);
              }
            });
          });
        }
      });
      return nextItems;
    }, [disabled, groups, groupBy, groupState, primaryProperty, selected, onSelect, onUpdate]);
    return /* @__PURE__ */ import_react82.default.createElement(StyledDataTableBody, _extends72({
      ref,
      size
    }, rest), /* @__PURE__ */ import_react82.default.createElement(InfiniteScroll, {
      items,
      onMore,
      replace,
      renderMarker: function renderMarker(marker) {
        return /* @__PURE__ */ import_react82.default.createElement(TableRow, null, /* @__PURE__ */ import_react82.default.createElement(TableCell, null, marker));
      },
      step
    }, function(row, index, rowRef) {
      var context = row.context, datum = row.datum, expanded = row.expanded, indeterminate = row.indeterminate, isDisabled2 = row.isDisabled, isSelected = row.isSelected, key = row.key, onChange2 = row.onChange, primaryValue = row.primaryValue;
      var cellProps = normalizeRowCellProps(rowProps, cellPropsProp, primaryValue, index);
      return /* @__PURE__ */ import_react82.default.createElement(StyledDataTableRow, {
        ref: rowRef,
        key,
        size
      }, /* @__PURE__ */ import_react82.default.createElement(ExpanderCell, {
        background: cellProps.background,
        border: cellProps.border,
        context,
        pad: cellProps.pad,
        onToggle: context === "groupHeader" ? onToggle(key) : void 0,
        expanded,
        verticalAlign: verticalAlign2
      }), (selected || onSelect) && /* @__PURE__ */ import_react82.default.createElement(TableCell, {
        background: cellProps.background,
        plain: "noPad",
        size: "auto",
        verticalAlign: verticalAlign2,
        "aria-disabled": isDisabled2 || !onSelect || void 0
      }, /* @__PURE__ */ import_react82.default.createElement(CheckBox, {
        a11yTitle: (isSelected ? "unselect" : "select") + " " + (context === "groupHeader" ? key : primaryValue),
        checked: isSelected,
        indeterminate,
        disabled: isDisabled2 || !onSelect,
        onChange: onChange2,
        pad: cellProps.pad
      })), columns.map(function(column) {
        var scope;
        if (context === "groupHeader") {
          scope = column.property === groupBy.property ? "row" : void 0;
        } else {
          scope = column.primary ? "row" : void 0;
        }
        return /* @__PURE__ */ import_react82.default.createElement(Cell, {
          key: column.property,
          background: cellProps.background,
          border: cellProps.border,
          context,
          column,
          datum,
          pad: cellProps.pad,
          scope,
          pinnedOffset: context === "groupHeader" && pinnedOffset && pinnedOffset[column.property],
          verticalAlign: verticalAlign2
        });
      }));
    }));
  });

  // node_modules/grommet/es6/components/DataTable/propTypes.js
  var import_prop_types37 = __toESM(require_prop_types());
  function _extends73() {
    _extends73 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends73.apply(this, arguments);
  }
  var sizes = ["xxsmall", "xsmall", "small", "medium", "large", "xlarge"];
  var sides = ["horizontal", "vertical", "top", "bottom", "left", "right"];
  var parts = ["header", "body", "footer"];
  var verticalAlign = ["bottom", "middle", "top"];
  var padShapeSides = {};
  sides.forEach(function(side) {
    padShapeSides[side] = import_prop_types37.default.oneOfType([import_prop_types37.default.oneOf(sizes), import_prop_types37.default.string]);
  });
  var padShapeParts = {};
  parts.forEach(function(part) {
    padShapeParts[part] = {};
    sides.forEach(function(side) {
      padShapeParts[part][side] = import_prop_types37.default.oneOf(sizes);
    });
  });
  var backgroundShape = {};
  [].concat(parts, ["pinned"]).forEach(function(part) {
    backgroundShape[part] = import_prop_types37.default.oneOfType([import_prop_types37.default.string, import_prop_types37.default.shape({
      dark: import_prop_types37.default.string,
      light: import_prop_types37.default.string
    }), import_prop_types37.default.arrayOf(import_prop_types37.default.string)]);
  });
  var borderTypes = [import_prop_types37.default.bool, import_prop_types37.default.oneOf(sides), import_prop_types37.default.shape({
    color: import_prop_types37.default.oneOfType([import_prop_types37.default.string, import_prop_types37.default.shape({
      dark: import_prop_types37.default.string,
      light: import_prop_types37.default.string
    })]),
    side: import_prop_types37.default.oneOf(sides),
    size: import_prop_types37.default.oneOfType([import_prop_types37.default.oneOf(sizes), import_prop_types37.default.string])
  })];
  var borderShape = {};
  parts.forEach(function(part) {
    borderShape[part] = import_prop_types37.default.oneOfType(borderTypes);
  });
  var PropType37 = {};
  if (true) {
    PropType37 = _extends73({}, genericProps, {
      background: import_prop_types37.default.oneOfType([import_prop_types37.default.string, import_prop_types37.default.arrayOf(import_prop_types37.default.string), import_prop_types37.default.shape(backgroundShape)]),
      border: import_prop_types37.default.oneOfType([].concat(borderTypes, [import_prop_types37.default.shape(borderShape)])),
      columns: import_prop_types37.default.arrayOf(import_prop_types37.default.shape({
        align: import_prop_types37.default.oneOf(["center", "start", "end"]),
        aggregate: import_prop_types37.default.oneOf(["avg", "max", "min", "sum"]),
        footer: import_prop_types37.default.oneOfType([import_prop_types37.default.node, import_prop_types37.default.shape({
          aggregate: import_prop_types37.default.bool
        })]),
        header: import_prop_types37.default.oneOfType([import_prop_types37.default.string, import_prop_types37.default.node, import_prop_types37.default.shape({
          aggregate: import_prop_types37.default.bool
        })]),
        pin: import_prop_types37.default.bool,
        plain: import_prop_types37.default.bool,
        primary: import_prop_types37.default.bool,
        property: import_prop_types37.default.string.isRequired,
        render: import_prop_types37.default.func,
        search: import_prop_types37.default.bool,
        sortable: import_prop_types37.default.bool,
        size: import_prop_types37.default.oneOfType([import_prop_types37.default.oneOf(["small", "medium", "large", "xlarge", "1/2", "1/4", "2/4", "3/4", "1/3", "2/3"]), import_prop_types37.default.string]),
        units: import_prop_types37.default.string,
        verticalAlign: import_prop_types37.default.oneOf(["middle", "top", "bottom"])
      })),
      data: import_prop_types37.default.arrayOf(import_prop_types37.default.shape({})),
      disabled: import_prop_types37.default.arrayOf(import_prop_types37.default.oneOfType([import_prop_types37.default.string, import_prop_types37.default.number])),
      fill: import_prop_types37.default.oneOfType([import_prop_types37.default.oneOf(["horizontal", "vertical"]), import_prop_types37.default.bool]),
      groupBy: import_prop_types37.default.oneOfType([import_prop_types37.default.string, import_prop_types37.default.shape({
        property: import_prop_types37.default.string,
        expand: import_prop_types37.default.arrayOf(import_prop_types37.default.string),
        expandable: import_prop_types37.default.arrayOf(import_prop_types37.default.string),
        select: import_prop_types37.default.objectOf(import_prop_types37.default.oneOf(["all", "some", "none"])),
        onExpand: import_prop_types37.default.func,
        onSelect: import_prop_types37.default.func
      })]),
      onClickRow: import_prop_types37.default.oneOfType([import_prop_types37.default.func, import_prop_types37.default.oneOf(["select"])]),
      rowDetails: import_prop_types37.default.func,
      onMore: import_prop_types37.default.func,
      onSearch: import_prop_types37.default.func,
      onSelect: import_prop_types37.default.func,
      onSort: import_prop_types37.default.func,
      onUpdate: import_prop_types37.default.func,
      pad: import_prop_types37.default.oneOfType([import_prop_types37.default.oneOf(sizes), import_prop_types37.default.string, import_prop_types37.default.shape(padShapeSides), import_prop_types37.default.shape(padShapeParts)]),
      paginate: import_prop_types37.default.oneOfType([import_prop_types37.default.bool, import_prop_types37.default.object]),
      pin: import_prop_types37.default.oneOfType([import_prop_types37.default.bool, import_prop_types37.default.oneOf(["header", "footer"])]),
      placeholder: import_prop_types37.default.oneOfType([import_prop_types37.default.string, import_prop_types37.default.node]),
      primaryKey: import_prop_types37.default.oneOfType([import_prop_types37.default.string, import_prop_types37.default.bool]),
      replace: import_prop_types37.default.bool,
      resizeable: import_prop_types37.default.bool,
      rowProps: import_prop_types37.default.shape({}),
      select: import_prop_types37.default.arrayOf(import_prop_types37.default.oneOfType([import_prop_types37.default.string, import_prop_types37.default.number])),
      show: import_prop_types37.default.oneOfType([import_prop_types37.default.number, import_prop_types37.default.shape({
        page: import_prop_types37.default.number
      })]),
      size: import_prop_types37.default.oneOfType([import_prop_types37.default.oneOf(["small", "medium", "large", "xlarge"]), import_prop_types37.default.string]),
      sort: import_prop_types37.default.shape({
        direction: import_prop_types37.default.oneOf(["asc", "desc"]),
        external: import_prop_types37.default.bool,
        property: import_prop_types37.default.string.isRequired
      }),
      sortable: import_prop_types37.default.bool,
      step: import_prop_types37.default.number,
      verticalAlign: import_prop_types37.default.oneOfType([import_prop_types37.default.oneOf(verticalAlign), import_prop_types37.default.shape({
        header: import_prop_types37.default.oneOf(verticalAlign),
        body: import_prop_types37.default.oneOf(verticalAlign),
        footer: import_prop_types37.default.oneOf(verticalAlign)
      })])
    });
  }
  var DataTablePropTypes = PropType37;

  // node_modules/grommet/es6/components/DataTable/PlaceholderBody.js
  var import_react83 = __toESM(require_react());
  var PlaceholderBody = /* @__PURE__ */ (0, import_react83.forwardRef)(function(_ref, ref) {
    var _ref$columns = _ref.columns, columns = _ref$columns === void 0 ? [] : _ref$columns, onSelect = _ref.onSelect, children = _ref.children;
    var colSpan = Math.max(columns.length + (onSelect ? 1 : 0), 1);
    return /* @__PURE__ */ import_react83.default.createElement("tbody", {
      ref
    }, /* @__PURE__ */ import_react83.default.createElement("tr", null, /* @__PURE__ */ import_react83.default.createElement("td", {
      colSpan
    }, children)));
  });

  // node_modules/grommet/es6/components/DataTable/DataTable.js
  var _excluded53 = ["background", "border", "columns", "data", "disabled", "fill", "groupBy", "onClickRow", "onMore", "onSearch", "onSelect", "onSort", "onUpdate", "replace", "pad", "paginate", "pin", "placeholder", "primaryKey", "resizeable", "rowProps", "select", "show", "size", "sort", "sortable", "rowDetails", "step", "verticalAlign"];
  function _extends74() {
    _extends74 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends74.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose48(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var emptyData = [];
  function useGroupState(groups, groupBy) {
    var _useState = (0, import_react84.useState)(function() {
      return buildGroupState(groups, groupBy);
    }), groupState = _useState[0], setGroupState = _useState[1];
    var _useState2 = (0, import_react84.useState)({
      groups,
      groupBy
    }), prevDeps = _useState2[0], setPrevDeps = _useState2[1];
    var prevGroups = prevDeps.groups, prevGroupBy = prevDeps.groupBy;
    if (groups !== prevGroups || groupBy !== prevGroupBy) {
      setPrevDeps({
        groups,
        groupBy
      });
      var nextGroupState = buildGroupState(groups, groupBy);
      setGroupState(nextGroupState);
      return [nextGroupState, setGroupState];
    }
    return [groupState, setGroupState];
  }
  var DataTable = function DataTable2(_ref) {
    var background = _ref.background, border = _ref.border, columnsProp = _ref.columns, dataProp = _ref.data, disabled = _ref.disabled, fill = _ref.fill, groupBy = _ref.groupBy, onClickRow = _ref.onClickRow, onMore = _ref.onMore, onSearch = _ref.onSearch, onSelect = _ref.onSelect, onSortProp = _ref.onSort, onUpdate = _ref.onUpdate, replace = _ref.replace, pad = _ref.pad, paginate = _ref.paginate, pin = _ref.pin, placeholder = _ref.placeholder, primaryKey = _ref.primaryKey, resizeable = _ref.resizeable, rowProps = _ref.rowProps, select = _ref.select, showProp = _ref.show, size = _ref.size, sortProp = _ref.sort, sortable = _ref.sortable, rowDetails = _ref.rowDetails, _ref$step = _ref.step, step = _ref$step === void 0 ? 50 : _ref$step, verticalAlign2 = _ref.verticalAlign, rest = _objectWithoutPropertiesLoose48(_ref, _excluded53);
    var theme = (0, import_react84.useContext)(import_styled_components57.ThemeContext) || defaultProps2.theme;
    var _useContext = (0, import_react84.useContext)(DataContext), view = _useContext.view, contextData = _useContext.data, properties = _useContext.properties, onView = _useContext.onView;
    var data = dataProp || contextData || emptyData;
    var columns = (0, import_react84.useMemo)(function() {
      var result = [];
      if (columnsProp)
        result = columnsProp;
      else if (properties)
        result = Object.keys(properties).map(function(p) {
          return _extends74({
            property: p
          }, properties[p]);
        });
      else if (data.length)
        result = Object.keys(data[0]).map(function(p) {
          return {
            property: p
          };
        });
      if (view != null && view.columns)
        result = result.filter(function(c) {
          return view.columns.includes(c.property);
        }).sort(function(c1, c2) {
          return view.columns.indexOf(c1.property) - view.columns.indexOf(c2.property);
        });
      return result;
    }, [columnsProp, data, properties, view]);
    var primaryProperty = (0, import_react84.useMemo)(function() {
      return normalizePrimaryProperty(columns, primaryKey);
    }, [columns, primaryKey]);
    var showFooter = (0, import_react84.useMemo)(function() {
      return columns.filter(function(c) {
        return c.footer;
      }).length > 0;
    }, [columns]);
    var _useState3 = (0, import_react84.useState)(), filtering = _useState3[0], setFiltering = _useState3[1];
    var _useState4 = (0, import_react84.useState)(initializeFilters(columns)), filters = _useState4[0], setFilters = _useState4[1];
    var _useState5 = (0, import_react84.useState)(sortProp || {}), sort = _useState5[0], setSort = _useState5[1];
    (0, import_react84.useEffect)(function() {
      if (sortProp)
        setSort(sortProp);
      else if (view != null && view.sort)
        setSort(view.sort);
    }, [sortProp, view]);
    var adjustedData = (0, import_react84.useMemo)(function() {
      return onUpdate ? data : filterAndSortData(data, filters, onSearch, sort);
    }, [data, filters, onSearch, onUpdate, sort]);
    var footerValues = (0, import_react84.useMemo)(function() {
      return buildFooterValues(columns, adjustedData);
    }, [adjustedData, columns]);
    var cellProps = (0, import_react84.useMemo)(function() {
      return normalizeCellProps({
        background,
        border,
        pad,
        pin
      }, theme);
    }, [background, border, pad, pin, theme]);
    var groups = (0, import_react84.useMemo)(function() {
      return buildGroups(columns, adjustedData, groupBy, primaryProperty);
    }, [adjustedData, columns, groupBy, primaryProperty]);
    var _useGroupState = useGroupState(groups, groupBy), groupState = _useGroupState[0], setGroupState = _useGroupState[1];
    var _useState6 = (0, import_react84.useState)(step), limit = _useState6[0], setLimit = _useState6[1];
    var _useState7 = (0, import_react84.useState)(select || onSelect && [] || void 0), selected = _useState7[0], setSelected = _useState7[1];
    (0, import_react84.useEffect)(function() {
      return setSelected(select || onSelect && [] || void 0);
    }, [onSelect, select]);
    var _useState8 = (0, import_react84.useState)([]), rowExpand = _useState8[0], setRowExpand = _useState8[1];
    var _useState9 = (0, import_react84.useState)({}), widths = _useState9[0], setWidths = _useState9[1];
    var headerRef = (0, import_react84.useRef)();
    var bodyRef = (0, import_react84.useRef)();
    var footerRef = (0, import_react84.useRef)();
    var _useState10 = (0, import_react84.useState)(), headerHeight = _useState10[0], setHeaderHeight = _useState10[1];
    var _useState11 = (0, import_react84.useState)(), footerHeight = _useState11[0], setFooterHeight = _useState11[1];
    var _useState12 = (0, import_react84.useState)(0), scrollOffset = _useState12[0], setScrollOffset = _useState12[1];
    var _useState13 = (0, import_react84.useState)(), pinnedOffset = _useState13[0], setPinnedOffset = _useState13[1];
    var onHeaderWidths = (0, import_react84.useCallback)(function(columnWidths) {
      var hasSelectColumn = Boolean(select || onSelect);
      var pinnedProperties = columns.map(function(pinnedColumn) {
        return pinnedColumn.pin && pinnedColumn.property;
      }).filter(function(n) {
        return n;
      });
      if (hasSelectColumn && pinnedProperties.length > 0) {
        pinnedProperties = ["_grommetDataTableSelect"].concat(pinnedProperties);
      }
      var nextPinnedOffset = {};
      if (columnWidths !== []) {
        pinnedProperties.forEach(function(property, index) {
          var columnIndex = property === "_grommetDataTableSelect" ? 0 : columns.findIndex(function(column) {
            return column.property === property;
          }) + hasSelectColumn;
          if (columnWidths[columnIndex]) {
            nextPinnedOffset[property] = {
              width: columnWidths[columnIndex],
              left: index === 0 ? 0 : nextPinnedOffset[pinnedProperties[index - 1]].left + nextPinnedOffset[pinnedProperties[index - 1]].width
            };
          }
        });
        setPinnedOffset(nextPinnedOffset);
      }
    }, [columns, setPinnedOffset, select, onSelect]);
    useLayoutEffect(function() {
      var _bodyRef$current$pare;
      var nextScrollOffset = (((_bodyRef$current$pare = bodyRef.current.parentElement) == null ? void 0 : _bodyRef$current$pare.clientWidth) || 0) - bodyRef.current.clientWidth;
      if (nextScrollOffset !== scrollOffset)
        setScrollOffset(nextScrollOffset);
    });
    useLayoutEffect(function() {
      if (placeholder) {
        if (headerRef.current) {
          var nextHeaderHeight = headerRef.current.getBoundingClientRect().height;
          setHeaderHeight(nextHeaderHeight);
        } else
          setHeaderHeight(0);
        if (footerRef.current) {
          var nextFooterHeight = footerRef.current.getBoundingClientRect().height;
          setFooterHeight(nextFooterHeight);
        } else
          setFooterHeight(0);
      }
    }, [footerRef, headerRef, placeholder]);
    var onFiltering = function onFiltering2(property) {
      return setFiltering(property);
    };
    var onFilter = function onFilter2(property, value) {
      var nextFilters = _extends74({}, filters);
      nextFilters[property] = value;
      setFilters(nextFilters);
      if (onSearch)
        onSearch(nextFilters);
    };
    var onSort = function onSort2(property) {
      return function() {
        var external = sort ? sort.external : false;
        var direction;
        if (!sort || property !== sort.property)
          direction = "asc";
        else if (sort.direction === "asc")
          direction = "desc";
        else
          direction = "asc";
        var nextSort = {
          property,
          direction,
          external
        };
        setSort(nextSort);
        if (onView) {
          onView(_extends74({}, view, {
            sort: {
              property,
              direction
            }
          }));
        }
        if (onUpdate) {
          var opts = {
            count: limit,
            sort: nextSort
          };
          if (groups) {
            opts.expanded = Object.keys(groupState).filter(function(k) {
              return groupState[k].expanded;
            });
          }
          if (showProp)
            opts.show = showProp;
          onUpdate(opts);
        }
        if (onSortProp)
          onSortProp(nextSort);
      };
    };
    var onToggleGroup = function onToggleGroup2(groupValue) {
      return function() {
        var nextGroupState = _extends74({}, groupState);
        nextGroupState[groupValue] = _extends74({}, nextGroupState[groupValue], {
          expanded: !nextGroupState[groupValue].expanded
        });
        setGroupState(nextGroupState);
        var expandedKeys = Object.keys(nextGroupState).filter(function(k) {
          return nextGroupState[k].expanded;
        });
        if (onUpdate) {
          var opts = {
            expanded: expandedKeys,
            count: limit
          };
          if (sort != null && sort.property)
            opts.sort = sort;
          if (showProp)
            opts.show = showProp;
          onUpdate(opts);
        }
        if (groupBy.onExpand) {
          groupBy.onExpand(expandedKeys);
        }
      };
    };
    var onToggleGroups = function onToggleGroups2() {
      var expanded = Object.keys(groupState).filter(function(k) {
        return !groupState[k].expanded;
      }).length === 0;
      var nextGroupState = {};
      Object.keys(groupState).forEach(function(k) {
        nextGroupState[k] = _extends74({}, groupState[k], {
          expanded: !expanded
        });
      });
      setGroupState(nextGroupState);
      var expandedKeys = Object.keys(nextGroupState).filter(function(k) {
        return nextGroupState[k].expanded;
      });
      if (onUpdate) {
        var opts = {
          expanded: expandedKeys,
          count: limit
        };
        if (showProp)
          opts.show = showProp;
        if (sort != null && sort.property)
          opts.sort = sort;
        onUpdate(opts);
      }
      if (groupBy.onExpand) {
        groupBy.onExpand(expandedKeys);
      }
    };
    var onResize = (0, import_react84.useCallback)(function(property, width) {
      if (widths[property] !== width) {
        var nextWidths = _extends74({}, widths);
        nextWidths[property] = width;
        setWidths(nextWidths);
      }
    }, [widths]);
    if (size && resizeable) {
      console.warn('DataTable cannot combine "size" and "resizeble".');
    }
    if (onUpdate && onMore) {
      console.warn('DataTable cannot combine "onUpdate" and "onMore".');
    }
    var _usePagination = usePagination(_extends74({
      data: adjustedData,
      page: normalizeShow(showProp, step),
      step
    }, paginate)), items = _usePagination[0], paginationProps = _usePagination[1];
    var paginationStep = paginationProps.step;
    var Container2 = paginate ? StyledContainer4 : import_react84.Fragment;
    var containterProps = paginate ? _extends74({}, theme.dataTable.container, {
      fill
    }) : void 0;
    var OverflowContainer = paginate ? Box : import_react84.Fragment;
    var overflowContainerProps = paginate ? {
      overflow: {
        horizontal: "auto"
      }
    } : void 0;
    var paginatedDataTableProps = paginate && (fill === true || fill === "horizontal") ? {
      style: {
        minWidth: "100%"
      }
    } : void 0;
    var placeholderContent = placeholder;
    if (placeholder && typeof placeholder === "string") {
      placeholderContent = /* @__PURE__ */ import_react84.default.createElement(Box, {
        background: {
          color: "background-front",
          opacity: "strong"
        },
        align: "center",
        justify: "center",
        fill: "vertical"
      }, /* @__PURE__ */ import_react84.default.createElement(Text, null, placeholder));
    }
    var bodyContent = groups ? /* @__PURE__ */ import_react84.default.createElement(GroupedBody, {
      ref: bodyRef,
      cellProps: cellProps.body,
      columns,
      disabled,
      groupBy: typeof groupBy === "string" ? {
        property: groupBy
      } : groupBy,
      groups,
      groupState,
      pinnedOffset,
      primaryProperty,
      onMore: onUpdate ? function() {
        if (adjustedData.length === limit) {
          var opts = {
            expanded: Object.keys(groupState).filter(function(k) {
              return groupState[k].expanded;
            }),
            count: limit + paginationStep
          };
          if (sort != null && sort.property)
            opts.sort = sort;
          if (showProp)
            opts.show = showProp;
          onUpdate(opts);
          setLimit(function(prev) {
            return prev + paginationStep;
          });
        }
      } : onMore,
      onSelect: onSelect ? function(nextSelected, row) {
        setSelected(nextSelected);
        if (onSelect)
          onSelect(nextSelected, row);
      } : void 0,
      onToggle: onToggleGroup,
      onUpdate,
      replace,
      rowProps,
      selected,
      size,
      step: paginationStep,
      verticalAlign: typeof verticalAlign2 === "string" ? verticalAlign2 : verticalAlign2 == null ? void 0 : verticalAlign2.body
    }) : /* @__PURE__ */ import_react84.default.createElement(Body, {
      ref: bodyRef,
      cellProps: cellProps.body,
      columns,
      data: !paginate ? adjustedData : items,
      disabled,
      onMore: onUpdate ? function() {
        if (adjustedData.length === limit) {
          var opts = {
            count: limit + paginationStep
          };
          if (sort != null && sort.property)
            opts.sort = sort;
          if (showProp)
            opts.show = showProp;
          onUpdate(opts);
          setLimit(function(prev) {
            return prev + paginationStep;
          });
        }
      } : onMore,
      replace,
      onClickRow,
      onSelect: onSelect ? function(nextSelected, row) {
        setSelected(nextSelected);
        if (onSelect)
          onSelect(nextSelected, row);
      } : void 0,
      pinnedCellProps: cellProps.pinned,
      pinnedOffset,
      primaryProperty,
      rowProps,
      selected,
      show: !paginate ? showProp : void 0,
      size,
      step: paginationStep,
      rowDetails,
      rowExpand,
      setRowExpand,
      verticalAlign: typeof verticalAlign2 === "string" ? verticalAlign2 : verticalAlign2 == null ? void 0 : verticalAlign2.body
    });
    return /* @__PURE__ */ import_react84.default.createElement(Container2, containterProps, /* @__PURE__ */ import_react84.default.createElement(OverflowContainer, overflowContainerProps, /* @__PURE__ */ import_react84.default.createElement(StyledDataTable, _extends74({
      fillProp: !paginate ? fill : void 0
    }, paginatedDataTableProps, rest), /* @__PURE__ */ import_react84.default.createElement(Header2, {
      ref: headerRef,
      cellProps: cellProps.header,
      columns,
      data: adjustedData,
      disabled,
      fill,
      filtering,
      filters,
      groupBy,
      groups,
      groupState,
      pin: pin === true || pin === "header",
      pinnedOffset,
      selected,
      size,
      sort,
      widths,
      onFiltering,
      onFilter,
      onResize: resizeable ? onResize : void 0,
      onSelect: onSelect ? function(nextSelected) {
        setSelected(nextSelected);
        if (onSelect)
          onSelect(nextSelected);
      } : void 0,
      onSort: sortable || sortProp || onSortProp ? onSort : void 0,
      onToggle: onToggleGroups,
      onWidths: onHeaderWidths,
      primaryProperty,
      scrollOffset,
      rowDetails,
      verticalAlign: typeof verticalAlign2 === "string" ? verticalAlign2 : verticalAlign2 == null ? void 0 : verticalAlign2.header
    }), placeholder && (!items || items.length === 0) ? /* @__PURE__ */ import_react84.default.createElement(PlaceholderBody, {
      ref: bodyRef,
      columns,
      onSelect
    }, placeholderContent) : bodyContent, showFooter && /* @__PURE__ */ import_react84.default.createElement(Footer3, {
      ref: footerRef,
      cellProps: cellProps.footer,
      columns,
      fill,
      footerValues,
      groups,
      onSelect,
      pin: pin === true || pin === "footer",
      pinnedOffset,
      primaryProperty,
      scrollOffset,
      selected,
      size,
      verticalAlign: typeof verticalAlign2 === "string" ? verticalAlign2 : verticalAlign2 == null ? void 0 : verticalAlign2.footer
    }), placeholder && items && items.length > 0 && /* @__PURE__ */ import_react84.default.createElement(StyledPlaceholder2, {
      top: headerHeight,
      bottom: footerHeight
    }, placeholderContent))), paginate && adjustedData.length > paginationStep && items && items.length ? /* @__PURE__ */ import_react84.default.createElement(Pagination, _extends74({
      alignSelf: "end"
    }, paginationProps)) : null);
  };
  DataTable.propTypes = DataTablePropTypes;

  // node_modules/grommet/es6/components/Tab/Tab.js
  var import_react86 = __toESM(require_react());
  var import_styled_components59 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/Tabs/TabsContext.js
  var import_react85 = __toESM(require_react());
  var TabsContext = /* @__PURE__ */ import_react85.default.createContext({});

  // node_modules/grommet/es6/components/Tab/StyledTab.js
  var import_styled_components58 = __toESM(require_styled_components_browser_cjs());
  var tabHoverStyle = (0, import_styled_components58.css)(["&:hover{", " ", " ", ";}&:focus{z-index:1;}"], function(props) {
    return props.theme.tab.hover.background && (0, import_styled_components58.css)(["background:", ";"], normalizeColor(props.theme.tab.hover.background, props.theme));
  }, function(props) {
    return props.theme.tab.hover.color && (0, import_styled_components58.css)(["color:", ";"], normalizeColor(props.theme.tab.hover.color, props.theme));
  }, function(props) {
    return props.theme.tab.hover.extend;
  });
  var StyledTab = import_styled_components58.default.div.withConfig({
    displayName: "StyledTab",
    componentId: "sc-1nnwnsb-0"
  })(["white-space:nowrap;", " ", " ", " ", ""], genericStyles, function(props) {
    return !props.plain && !props.disabled && props.theme.tab.hover && tabHoverStyle;
  }, function(props) {
    return props.disabled && props.theme.tab.disabled;
  }, function(props) {
    return props.theme.tab.extend;
  });
  StyledTab.defaultProps = {};
  Object.setPrototypeOf(StyledTab.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/Tab/propTypes.js
  var import_prop_types38 = __toESM(require_prop_types());
  var PropType38 = {};
  if (true) {
    PropType38 = {
      disabled: import_prop_types38.default.bool,
      icon: import_prop_types38.default.element,
      plain: import_prop_types38.default.bool,
      reverse: import_prop_types38.default.bool,
      title: import_prop_types38.default.node
    };
  }
  var TabPropTypes = PropType38;

  // node_modules/grommet/es6/components/Tab/Tab.js
  var _excluded54 = ["active", "disabled", "children", "icon", "plain", "title", "onBlur", "onFocus", "onMouseOver", "onMouseOut", "reverse", "onClick"];
  function _extends75() {
    _extends75 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends75.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose49(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Tab2 = /* @__PURE__ */ (0, import_react86.forwardRef)(function(_ref, ref) {
    var activeProp = _ref.active, disabled = _ref.disabled, children = _ref.children, icon = _ref.icon, plain = _ref.plain, title = _ref.title, _onBlur = _ref.onBlur, _onFocus = _ref.onFocus, onMouseOver = _ref.onMouseOver, onMouseOut = _ref.onMouseOut, reverse = _ref.reverse, onClick = _ref.onClick, rest = _objectWithoutPropertiesLoose49(_ref, _excluded54);
    var _useContext = (0, import_react86.useContext)(TabsContext), active = _useContext.active, activeIndex = _useContext.activeIndex, index = _useContext.index, tabsContextRef = _useContext.ref, onActivate = _useContext.onActivate, setActiveContent = _useContext.setActiveContent, setActiveTitle = _useContext.setActiveTitle, setFocusIndex = _useContext.setFocusIndex;
    var theme = (0, import_react86.useContext)(import_styled_components59.ThemeContext) || defaultProps2.theme;
    var _useState = (0, import_react86.useState)(void 0), over = _useState[0], setOver = _useState[1];
    var normalizedTitle = title;
    var tabStyles = {};
    var tabRef = useForwardedRef(ref);
    useLayoutEffect(function() {
      if (tabRef.current && tabsContextRef) {
        tabsContextRef.current = tabRef.current;
      }
    });
    (0, import_react86.useEffect)(function() {
      if (active) {
        setActiveContent(children);
        var activeTitle = typeof title === "string" ? title : activeIndex + 1;
        setActiveTitle(activeTitle);
      }
    }, [active, activeIndex, children, setActiveContent, setActiveTitle, title]);
    var onMouseOverTab = function onMouseOverTab2(event) {
      setOver(true);
      if (onMouseOver) {
        onMouseOver(event);
      }
    };
    var onMouseOutTab = function onMouseOutTab2(event) {
      setOver(void 0);
      if (onMouseOut) {
        onMouseOut(event);
      }
    };
    if (!plain) {
      if (typeof title !== "string") {
        normalizedTitle = title;
      } else if (active) {
        normalizedTitle = /* @__PURE__ */ import_react86.default.createElement(Text, theme.tab.active, title);
      } else if (disabled && theme.tab.disabled) {
        normalizedTitle = /* @__PURE__ */ import_react86.default.createElement(Text, theme.tab.disabled, title);
      } else {
        normalizedTitle = /* @__PURE__ */ import_react86.default.createElement(Text, {
          color: over ? theme.tab.hover.color : theme.tab.color
        }, title);
      }
    }
    var onClickTab = function onClickTab2(event) {
      if (event) {
        event.preventDefault();
      }
      onActivate();
      if (onClick) {
        onClick(event);
      }
    };
    if (active && disabled) {
      console.warn(
        // eslint-disable-next-line max-len
        "Warning: Tab props 'active' and 'disabled' have both been set to TRUE on the same Tab resulting in an interesting Tab state. Is this your intent?"
      );
    }
    if (!plain) {
      if (typeof title !== "string") {
        normalizedTitle = title;
      } else if (active) {
        normalizedTitle = /* @__PURE__ */ import_react86.default.createElement(Text, theme.tab.active, title);
      } else if (disabled && theme.tab.disabled) {
        normalizedTitle = /* @__PURE__ */ import_react86.default.createElement(Text, theme.tab.disabled, title);
      } else {
        normalizedTitle = /* @__PURE__ */ import_react86.default.createElement(Text, {
          color: over ? theme.tab.hover.color : theme.tab.color
        }, title);
      }
      if (theme.tab.border) {
        var borderColor = theme.tab.border.color || theme.global.control.border.color;
        if (active) {
          borderColor = theme.tab.border.active.color || borderColor;
        } else if (disabled && theme.tab.border.disabled) {
          borderColor = theme.tab.border.disabled.color || borderColor;
        } else if (over) {
          borderColor = theme.tab.border.hover.color || borderColor;
        }
        borderColor = normalizeColor(borderColor, theme);
        tabStyles.border = {
          side: theme.tab.border.side,
          size: theme.tab.border.size,
          color: borderColor
        };
      }
      tabStyles.background = active ? theme.tab.active.background || theme.tab.background : theme.tab.background;
      tabStyles.pad = theme.tab.pad;
      tabStyles.margin = theme.tab.margin;
    }
    var renderIcon = function renderIcon2(iconProp) {
      if (active) {
        return /* @__PURE__ */ import_react86.default.cloneElement(iconProp, _extends75({}, theme.tab.active));
      }
      if (disabled) {
        return /* @__PURE__ */ import_react86.default.cloneElement(iconProp, _extends75({}, theme.tab.disabled));
      }
      return /* @__PURE__ */ import_react86.default.cloneElement(iconProp, {
        color: over ? theme.tab.hover.color : theme.tab.color
      });
    };
    var normalizedIcon;
    if (icon) {
      normalizedIcon = renderIcon(icon);
    }
    var first = reverse ? normalizedTitle : normalizedIcon;
    var second = reverse ? normalizedIcon : normalizedTitle;
    var withIconStyles;
    if (first && second) {
      withIconStyles = {
        direction: "row",
        align: "center",
        justify: "center",
        gap: "small"
      };
    }
    return /* @__PURE__ */ import_react86.default.createElement(Button2, _extends75({
      ref: tabRef,
      plain: true,
      role: "tab",
      "aria-selected": active,
      "aria-expanded": active,
      disabled
    }, rest, {
      onClick: onClickTab,
      onMouseOver: onMouseOverTab,
      onMouseOut: onMouseOutTab,
      onFocus: function onFocus() {
        if (_onFocus)
          _onFocus();
        setFocusIndex(index);
      },
      onBlur: function onBlur() {
        if (_onBlur)
          _onBlur();
        setFocusIndex(-1);
      }
    }), /* @__PURE__ */ import_react86.default.createElement(StyledTab, _extends75({
      as: Box,
      disabled,
      plain
    }, withIconStyles, tabStyles), first, second));
  });
  Tab2.displayName = "Tab";
  Tab2.defaultProps = {};
  Object.setPrototypeOf(Tab2.defaultProps, defaultProps2);
  Tab2.propTypes = TabPropTypes;

  // node_modules/grommet/es6/components/Tabs/Tabs.js
  var import_react87 = __toESM(require_react());
  var import_Previous2 = __toESM(require_Previous());
  var import_Next2 = __toESM(require_Next());
  var import_styled_components61 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/Tabs/StyledTabs.js
  var import_styled_components60 = __toESM(require_styled_components_browser_cjs());
  var _FLEX_MAP2;
  var StyledTabsHeader = import_styled_components60.default.div.withConfig({
    displayName: "StyledTabs__StyledTabsHeader",
    componentId: "sc-a4fwxl-0"
  })(["", ";"], function(props) {
    return props.theme.tabs.header.extend;
  });
  StyledTabsHeader.defaultProps = {};
  Object.setPrototypeOf(StyledTabsHeader.defaultProps, defaultProps2);
  var FLEX_MAP2 = (_FLEX_MAP2 = {}, _FLEX_MAP2[true] = "1 1", _FLEX_MAP2[false] = "0 0", _FLEX_MAP2.grow = "1 0", _FLEX_MAP2.shrink = "0 1", _FLEX_MAP2);
  var flexStyle2 = (0, import_styled_components60.css)(["flex:", ";"], function(props) {
    return "" + FLEX_MAP2[props.flex] + (props.flex !== true ? " auto" : "");
  });
  var StyledTabPanel = import_styled_components60.default.div.withConfig({
    displayName: "StyledTabs__StyledTabPanel",
    componentId: "sc-a4fwxl-1"
  })(["min-height:0;", " ", ";"], function(props) {
    return props.flex && flexStyle2;
  }, function(props) {
    return props.theme.tabs.panel.extend;
  });
  StyledTabPanel.defaultProps = {};
  Object.setPrototypeOf(StyledTabPanel.defaultProps, defaultProps2);
  var StyledTabs = import_styled_components60.default.div.withConfig({
    displayName: "StyledTabs",
    componentId: "sc-a4fwxl-2"
  })(["", " ", ";"], genericStyles, function(props) {
    return props.theme.tabs.extend;
  });
  StyledTabs.defaultProps = {};
  Object.setPrototypeOf(StyledTabs.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/Tabs/propTypes.js
  var import_prop_types39 = __toESM(require_prop_types());
  function _extends76() {
    _extends76 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends76.apply(this, arguments);
  }
  var PropType39 = {};
  if (true) {
    PropType39 = _extends76({}, genericProps, {
      activeIndex: import_prop_types39.default.number,
      alignControls: import_prop_types39.default.oneOf(["start", "center", "end", "stretch"]),
      children: import_prop_types39.default.node.isRequired,
      flex: import_prop_types39.default.oneOfType([import_prop_types39.default.oneOf(["grow", "shrink"]), import_prop_types39.default.bool]),
      justify: import_prop_types39.default.oneOf(["start", "center", "end"]),
      messages: import_prop_types39.default.shape({
        tabContents: import_prop_types39.default.string
      }),
      onActive: import_prop_types39.default.func
    });
  }
  var TabsPropTypes = PropType39;

  // node_modules/grommet/es6/components/Tabs/Tabs.js
  var _excluded55 = ["alignControls", "children", "flex", "justify", "messages", "responsive"];
  function _extends77() {
    _extends77 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends77.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose50(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Tabs = /* @__PURE__ */ (0, import_react87.forwardRef)(function(_ref, ref) {
    var _theme$tabs$header;
    var alignControls = _ref.alignControls, children = _ref.children, flex = _ref.flex, _ref$justify = _ref.justify, justify = _ref$justify === void 0 ? "center" : _ref$justify, messages = _ref.messages, _ref$responsive = _ref.responsive, responsive = _ref$responsive === void 0 ? true : _ref$responsive, rest = _objectWithoutPropertiesLoose50(_ref, _excluded55);
    var theme = (0, import_react87.useContext)(import_styled_components61.ThemeContext) || defaultProps2.theme;
    var _useContext = (0, import_react87.useContext)(MessageContext), format4 = _useContext.format;
    var propsActiveIndex = rest.activeIndex, onActive = rest.onActive;
    var _useState = (0, import_react87.useState)(rest.activeIndex || 0), activeIndex = _useState[0], setActiveIndex = _useState[1];
    var _useState2 = (0, import_react87.useState)(), activeContent = _useState2[0], setActiveContent = _useState2[1];
    var _useState3 = (0, import_react87.useState)(), activeTitle = _useState3[0], setActiveTitle = _useState3[1];
    var _useState4 = (0, import_react87.useState)(), disableLeftArrow = _useState4[0], setDisableLeftArrow = _useState4[1];
    var _useState5 = (0, import_react87.useState)(), disableRightArrow = _useState5[0], setDisableRightArrow = _useState5[1];
    var _useState6 = (0, import_react87.useState)(), overflow = _useState6[0], setOverflow = _useState6[1];
    var _useState7 = (0, import_react87.useState)(-1), focusIndex = _useState7[0], setFocusIndex = _useState7[1];
    var headerRef = (0, import_react87.useRef)();
    var size = (0, import_react87.useContext)(ResponsiveContext);
    var sendAnalytics = useAnalytics();
    if (activeIndex !== propsActiveIndex && propsActiveIndex !== void 0) {
      setActiveIndex(propsActiveIndex);
    }
    var isSafari = typeof window !== "undefined" ? /^((?!chrome|android).)*safari/i.test(window.navigator.userAgent) : true;
    delete rest.activeIndex;
    delete rest.onActive;
    var tabRefs = (0, import_react87.useMemo)(function() {
      return import_react87.default.Children.map(children, function() {
        return /* @__PURE__ */ import_react87.default.createRef();
      });
    }, [children]);
    var isVisible2 = (0, import_react87.useCallback)(function(index) {
      if (tabRefs[index].current) {
        var _headerRef$current;
        var tabRect = tabRefs[index].current.getBoundingClientRect();
        var headerRect = (_headerRef$current = headerRef.current) == null ? void 0 : _headerRef$current.getBoundingClientRect();
        if (tabRect && headerRect) {
          return tabRect.left >= headerRect.left - 1 && tabRect.right <= headerRect.right + 1;
        }
      }
      return void 0;
    }, [headerRef, tabRefs]);
    var updateArrowState = (0, import_react87.useCallback)(function() {
      setDisableLeftArrow(isVisible2(0));
      setDisableRightArrow(isVisible2(tabRefs.length - 1));
    }, [tabRefs, isVisible2]);
    var scrollTo = (0, import_react87.useCallback)(function(index, keyboard) {
      var tabRect = tabRefs[index].current.getBoundingClientRect();
      var headerRect = headerRef.current.getBoundingClientRect();
      var amountHidden = 0;
      if (tabRect.left >= headerRect.left && tabRect.left <= headerRect.right) {
        amountHidden = tabRect.width - (headerRect.right - tabRect.left);
      } else if (tabRect.right >= headerRect.left && tabRect.right <= headerRect.right) {
        amountHidden = tabRect.width - (tabRect.right - headerRect.left);
        amountHidden = 0 - amountHidden;
      } else if (tabRect.left >= headerRect.right) {
        amountHidden = tabRect.right - headerRect.right;
      } else if (tabRect.right <= headerRect.left) {
        amountHidden = headerRect.left - tabRect.left;
        amountHidden = 0 - amountHidden;
      }
      if (keyboard) {
        if (amountHidden < 0)
          amountHidden -= 2;
        if (amountHidden > 0)
          amountHidden += 2;
      }
      if (isSafari) {
        headerRef.current.scrollBy({
          left: amountHidden
        });
      } else {
        headerRef.current.scrollBy({
          left: amountHidden,
          behavior: "smooth"
        });
      }
      if (isSafari) {
        updateArrowState();
      } else {
        var checkVisible = setInterval(function() {
          if (tabRefs[index].current && isVisible2(index)) {
            updateArrowState();
            clearInterval(checkVisible);
          }
        }, 50);
        setTimeout(function() {
          updateArrowState();
          clearInterval(checkVisible);
        }, 1e3);
      }
    }, [tabRefs, headerRef, isVisible2, updateArrowState, isSafari]);
    var moveByArrowKey = function moveByArrowKey2(direction) {
      var previous = direction === "previous";
      var index = direction === "previous" ? 0 : tabRefs.length - 1;
      var scrolledToIndex;
      var moveBy = theme.tabs.step[size] - 1 || 0;
      while (scrolledToIndex === void 0 && (previous && index < tabRefs.length - 1 || !previous && index > 0)) {
        if (!isVisible2(index) && (previous && isVisible2(index + 1) || !previous && isVisible2(index - 1))) {
          if (previous) {
            if (index - moveBy >= 0) {
              scrollTo(index - moveBy, false);
              scrolledToIndex = index - moveBy;
            } else {
              scrollTo(0, false);
              scrolledToIndex = 0;
            }
          } else if (index + moveBy < tabRefs.length) {
            scrollTo(index + moveBy, false);
            scrolledToIndex = index + moveBy;
          } else {
            scrollTo(tabRefs.length - 1, false);
            scrolledToIndex = tabRefs.length - 1;
          }
        }
        index = previous ? index + 1 : index - 1;
      }
    };
    (0, import_react87.useEffect)(function() {
      if (overflow && tabRefs && tabRefs[activeIndex].current && !isVisible2(activeIndex))
        scrollTo(activeIndex, true);
    }, [overflow, activeIndex, tabRefs, isVisible2, scrollTo]);
    (0, import_react87.useEffect)(function() {
      if (overflow && focusIndex !== -1 && !isVisible2(focusIndex))
        scrollTo(focusIndex, true);
      else if (overflow && focusIndex !== -1) {
        var tabRect = tabRefs[focusIndex].current.getBoundingClientRect();
        var headerRect = headerRef.current.getBoundingClientRect();
        var amountHidden = 0;
        if (tabRect.left >= headerRect.left && tabRect.right <= headerRect.right && tabRect.right + 2 >= headerRect.right)
          amountHidden = 2;
        else if (tabRect.right <= headerRect.right && tabRect.left >= headerRect.left && tabRect.left - 2 <= headerRect.left)
          amountHidden = -2;
        headerRef.current.scrollBy({
          left: amountHidden
        });
      }
    }, [overflow, tabRefs, focusIndex, isVisible2, scrollTo]);
    useLayoutEffect(function() {
      var onResize = function onResize2() {
        if (headerRef.current.scrollWidth > headerRef.current.offsetWidth) {
          setOverflow(true);
        } else
          setOverflow(false);
        updateArrowState();
      };
      onResize();
      window.addEventListener("resize", onResize);
      return function() {
        return window.removeEventListener("resize", onResize);
      };
    }, [tabRefs, disableLeftArrow, disableRightArrow, activeIndex, headerRef, overflow, updateArrowState]);
    var getTabsContext = (0, import_react87.useCallback)(function(index) {
      var activateTab = function activateTab2(nextIndex) {
        sendAnalytics({
          type: "activateTab",
          element: tabRefs[nextIndex].current
        });
        if (propsActiveIndex === void 0) {
          setActiveIndex(nextIndex);
        }
        if (onActive) {
          onActive(nextIndex);
        }
      };
      return {
        activeIndex,
        active: activeIndex === index,
        index,
        ref: tabRefs[index],
        onActivate: function onActivate() {
          return activateTab(index);
        },
        setActiveContent,
        setActiveTitle,
        setFocusIndex
      };
    }, [activeIndex, onActive, propsActiveIndex, sendAnalytics, tabRefs]);
    var tabs = import_react87.default.Children.map(children, function(child, index) {
      return /* @__PURE__ */ import_react87.default.createElement(TabsContext.Provider, {
        value: getTabsContext(index)
      }, child ? (
        // cloneElement is needed for backward compatibility with custom
        // styled components that rely on props.active. We should reassess
        // if it is still necessary in our next major release.
        /* @__PURE__ */ import_react87.default.cloneElement(child, {
          active: activeIndex === index
        })
      ) : child);
    });
    var tabsHeaderStyles = {};
    if (theme.tabs.header && theme.tabs.header.border) {
      var borderColor = theme.tabs.header.border.color || theme.global.control.border.color;
      borderColor = normalizeColor(borderColor, theme);
      tabsHeaderStyles.border = {
        side: theme.tabs.header.border.side,
        size: theme.tabs.header.border.size,
        style: theme.tabs.header.border.style,
        color: borderColor
      };
    }
    var tabContentTitle = (activeTitle || "") + " " + format4({
      id: "tabs.tabContents",
      messages
    });
    return /* @__PURE__ */ import_react87.default.createElement(StyledTabs, _extends77({
      ref,
      as: Box,
      flex,
      responsive
    }, rest, {
      background: theme.tabs.background
    }), /* @__PURE__ */ import_react87.default.createElement(Box, _extends77({
      alignSelf: alignControls || ((_theme$tabs$header = theme.tabs.header) == null ? void 0 : _theme$tabs$header.alignSelf),
      role: "tablist",
      flex: false,
      direction: overflow ? "row" : "column"
    }, tabsHeaderStyles), overflow && /* @__PURE__ */ import_react87.default.createElement(Button2, {
      a11yTitle: "Previous Tab",
      disabled: disableLeftArrow,
      tabIndex: -1,
      onClick: function onClick() {
        return moveByArrowKey("previous");
      }
    }, /* @__PURE__ */ import_react87.default.createElement(Box, {
      pad: {
        vertical: "xsmall",
        horizontal: "small"
      }
    }, /* @__PURE__ */ import_react87.default.createElement(import_Previous2.Previous, {
      color: disableLeftArrow ? theme.button.disabled.color : theme.global.colors.text
    }))), /* @__PURE__ */ import_react87.default.createElement(StyledTabsHeader, {
      ref: headerRef,
      as: Box,
      direction: "row",
      justify: overflow ? "start" : justify,
      flex: !!overflow,
      wrap: false,
      overflow: overflow ? "hidden" : "visible",
      background: theme.tabs.header.background,
      gap: theme.tabs.gap,
      pad: overflow ? "2px" : void 0,
      margin: overflow ? "-2px" : void 0
    }, tabs), overflow && /* @__PURE__ */ import_react87.default.createElement(Button2, {
      a11yTitle: "Next Tab",
      disabled: disableRightArrow,
      tabIndex: -1,
      onClick: function onClick() {
        return moveByArrowKey("next");
      }
    }, /* @__PURE__ */ import_react87.default.createElement(Box, {
      pad: {
        vertical: "xsmall",
        horizontal: "small"
      }
    }, /* @__PURE__ */ import_react87.default.createElement(import_Next2.Next, {
      color: disableRightArrow ? theme.button.disabled.color : theme.global.colors.text
    })))), /* @__PURE__ */ import_react87.default.createElement(StyledTabPanel, {
      flex,
      "aria-label": tabContentTitle,
      role: "tabpanel"
    }, activeContent));
  });
  Tabs.displayName = "Tabs";
  Tabs.propTypes = TabsPropTypes;

  // node_modules/grommet/es6/components/Grommet/Grommet.js
  var import_react88 = __toESM(require_react());
  var import_styled_components63 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/Grommet/StyledGrommet.js
  var import_styled_components62 = __toESM(require_styled_components_browser_cjs());
  var fullStyle = function fullStyle2(full) {
    if (full === "min")
      return (0, import_styled_components62.css)(["min-height:100vh;"]);
    return (0, import_styled_components62.css)(["width:100vw;height:100vh;overflow:auto;"]);
  };
  var StyledGrommet = import_styled_components62.default.div.withConfig({
    displayName: "StyledGrommet",
    componentId: "sc-19lkkz7-0"
  })(["", " ", " ", " ", " ", ""], function(props) {
    return !props.plain && baseStyle;
  }, function(props) {
    return props.full && fullStyle(props.full);
  }, function(props) {
    return props.theme.global.font.face;
  }, function(props) {
    return props.theme.grommet.extend;
  }, function(props) {
    return props.cssVars && Object.keys(props.theme.global.colors).filter(function(k) {
      return typeof props.theme.global.colors[k] === "string";
    }).map(function(k) {
      return "--" + k + ": " + props.theme.global.colors[k] + ";";
    }).join("\n");
  });
  StyledGrommet.defaultProps = {};
  Object.setPrototypeOf(StyledGrommet.defaultProps, defaultProps2);

  // node_modules/grommet/es6/components/Grommet/propTypes.js
  var import_prop_types40 = __toESM(require_prop_types());
  var PropType40 = {};
  if (true) {
    PropType40 = {
      background: backgroundDoc,
      dir: import_prop_types40.default.oneOf(["rtl"]),
      full: import_prop_types40.default.oneOfType([import_prop_types40.default.bool, import_prop_types40.default.oneOf(["min"])]),
      options: import_prop_types40.default.shape({
        layer: import_prop_types40.default.shape({
          singleId: import_prop_types40.default.bool
        })
      }),
      plain: import_prop_types40.default.bool,
      cssVars: import_prop_types40.default.bool,
      theme: import_prop_types40.default.object,
      themeMode: import_prop_types40.default.oneOf(["dark", "light", "auto"]),
      userAgent: import_prop_types40.default.string,
      containerTarget: import_prop_types40.default.object,
      messages: import_prop_types40.default.shape({
        format: import_prop_types40.default.func,
        messages: import_prop_types40.default.shape({
          fileInput: import_prop_types40.default.shape({
            browse: import_prop_types40.default.string,
            dropPrompt: import_prop_types40.default.string,
            dropPromptMultiple: import_prop_types40.default.string,
            files: import_prop_types40.default.string,
            remove: import_prop_types40.default.string,
            removeAll: import_prop_types40.default.string
          }),
          form: import_prop_types40.default.shape({
            invalid: import_prop_types40.default.string,
            required: import_prop_types40.default.string
          }),
          menu: import_prop_types40.default.shape({
            openMenu: import_prop_types40.default.string,
            closeMenu: import_prop_types40.default.string
          }),
          rangeSelector: import_prop_types40.default.shape({
            lower: import_prop_types40.default.string,
            upper: import_prop_types40.default.string
          }),
          select: import_prop_types40.default.shape({
            multiple: import_prop_types40.default.string
          }),
          skipLinks: import_prop_types40.default.shape({
            skipTo: import_prop_types40.default.string
          }),
          tabs: import_prop_types40.default.shape({
            tabContents: import_prop_types40.default.string
          }),
          textInput: import_prop_types40.default.shape({
            enterSelect: import_prop_types40.default.string,
            suggestionsCount: import_prop_types40.default.string,
            suggestionsExist: import_prop_types40.default.string,
            suggestionIsOpen: import_prop_types40.default.string
          }),
          video: import_prop_types40.default.shape({
            closeMenu: import_prop_types40.default.string,
            fullScreen: import_prop_types40.default.string,
            progressMeter: import_prop_types40.default.string,
            scrubber: import_prop_types40.default.string,
            openMenu: import_prop_types40.default.string,
            pauseButton: import_prop_types40.default.string,
            playButton: import_prop_types40.default.string,
            volumeDown: import_prop_types40.default.string,
            volumeUp: import_prop_types40.default.string
          })
        }),
        onAnalytics: import_prop_types40.default.func
      })
    };
  }
  var GrommetPropTypes = PropType40;

  // node_modules/grommet/es6/components/Grommet/Grommet.js
  var _excluded56 = ["children", "full", "containerTarget", "theme", "options", "messages", "onAnalytics"];
  function _extends78() {
    _extends78 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends78.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose51(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var FullGlobalStyle = (0, import_styled_components63.createGlobalStyle)(["body{margin:0;}"]);
  var deviceResponsive = function deviceResponsive2(userAgent, theme) {
    if (userAgent) {
      if (/(tablet|ipad|playbook|silk)|(android(?!.*mobile))/i.test(userAgent)) {
        return getDeviceBreakpoint("tablet", theme);
      }
      if (/Mobile|iPhone|Android/.test(userAgent)) {
        return getDeviceBreakpoint("phone", theme);
      }
      return getDeviceBreakpoint("computer", theme);
    }
    return void 0;
  };
  var defaultOptions2 = {};
  var Grommet = /* @__PURE__ */ (0, import_react88.forwardRef)(function(props, ref) {
    var children = props.children, full = props.full, _props$containerTarge = props.containerTarget, containerTarget = _props$containerTarge === void 0 ? typeof document === "object" ? document.body : void 0 : _props$containerTarge, themeProp = props.theme, _props$options = props.options, options2 = _props$options === void 0 ? defaultOptions2 : _props$options, messagesProp = props.messages, onAnalytics = props.onAnalytics, rest = _objectWithoutPropertiesLoose51(props, _excluded56);
    var background = props.background, dir = props.dir, themeMode = props.themeMode, userAgent = props.userAgent;
    var _useState = (0, import_react88.useState)(), stateResponsive = _useState[0], setResponsive = _useState[1];
    var _useState2 = (0, import_react88.useState)([]), roots = _useState2[0], setRoots = _useState2[1];
    var theme = (0, import_react88.useMemo)(function() {
      var nextTheme = deepMerge(base, themeProp || {});
      if (themeProp && themeProp.menu && themeProp.menu.drop && themeProp.menu.drop.align) {
        delete nextTheme.menu.drop.align;
        nextTheme.menu.drop.align = themeProp.menu.drop.align;
      }
      var themeBackground = nextTheme.global.colors.background;
      nextTheme.dark = (themeMode || nextTheme.defaultMode) === "dark";
      if (themeMode === "auto" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches) {
        nextTheme.dark = true;
      }
      var color = normalizeColor(background || themeBackground, nextTheme);
      nextTheme.dark = backgroundIsDark(color, nextTheme);
      nextTheme.baseBackground = background || themeBackground;
      nextTheme.background = nextTheme.baseBackground;
      if (dir) {
        nextTheme.dir = dir;
      }
      return nextTheme;
    }, [background, dir, themeMode, themeProp]);
    var messages = (0, import_react88.useMemo)(function() {
      var nextMessages = deepMerge(default_default, (messagesProp == null ? void 0 : messagesProp.messages) || {});
      return {
        messages: nextMessages,
        format: function format4(opts) {
          var message = (messagesProp == null ? void 0 : messagesProp.format) && messagesProp.format(opts);
          return typeof message !== "undefined" ? message : _format(opts, nextMessages);
        }
      };
    }, [messagesProp]);
    (0, import_react88.useEffect)(function() {
      var onResize = function onResize2() {
        setResponsive(getBreakpoint(document.body.clientWidth, theme));
      };
      window.addEventListener("resize", onResize);
      onResize();
      return function() {
        window.removeEventListener("resize", onResize);
      };
    }, [theme]);
    var responsive = stateResponsive || deviceResponsive(userAgent, theme) || theme.global.deviceBreakpoints.tablet;
    var grommetRef = useForwardedRef(ref);
    (0, import_react88.useEffect)(function() {
      if (grommetRef.current)
        setRoots([grommetRef.current]);
    }, [grommetRef]);
    return /* @__PURE__ */ import_react88.default.createElement(import_styled_components27.ThemeContext.Provider, {
      value: theme
    }, /* @__PURE__ */ import_react88.default.createElement(ResponsiveContext.Provider, {
      value: responsive
    }, /* @__PURE__ */ import_react88.default.createElement(RootsContext.Provider, {
      value: roots
    }, /* @__PURE__ */ import_react88.default.createElement(ContainerTargetContext.Provider, {
      value: containerTarget
    }, /* @__PURE__ */ import_react88.default.createElement(OptionsContext.Provider, {
      value: options2
    }, /* @__PURE__ */ import_react88.default.createElement(MessageContext.Provider, {
      value: messages
    }, /* @__PURE__ */ import_react88.default.createElement(AnalyticsProvider, {
      onAnalytics
    }, /* @__PURE__ */ import_react88.default.createElement(StyledGrommet, _extends78({
      full
    }, rest, {
      ref: grommetRef
    }), children), full && /* @__PURE__ */ import_react88.default.createElement(FullGlobalStyle, null))))))));
  });
  Grommet.displayName = "Grommet";
  Grommet.propTypes = GrommetPropTypes;

  // node_modules/grommet/es6/components/Page/Page.js
  var import_react90 = __toESM(require_react());
  var import_styled_components64 = __toESM(require_styled_components_browser_cjs());

  // node_modules/grommet/es6/components/Page/PageContext.js
  var import_react89 = __toESM(require_react());
  var PageContext = /* @__PURE__ */ (0, import_react89.createContext)({});

  // node_modules/grommet/es6/components/Page/propTypes.js
  var import_prop_types41 = __toESM(require_prop_types());
  var PropType41 = {};
  if (true) {
    PropType41 = {
      kind: import_prop_types41.default.string
    };
  }
  var PagePropTypes = PropType41;

  // node_modules/grommet/es6/components/Page/Page.js
  var _excluded57 = ["kind"];
  function _extends79() {
    _extends79 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends79.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose52(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Page = function Page2(_ref) {
    var kind = _ref.kind, rest = _objectWithoutPropertiesLoose52(_ref, _excluded57);
    var size = (0, import_react90.useContext)(ResponsiveContext);
    var theme = (0, import_react90.useContext)(import_styled_components64.ThemeContext);
    var contentValue = (0, import_react90.useMemo)(function() {
      var _theme$page$kind, _theme$page$kind2;
      return _extends79({
        alignSelf: (_theme$page$kind = theme.page[kind]) == null ? void 0 : _theme$page$kind.alignSelf,
        width: (_theme$page$kind2 = theme.page[kind]) == null ? void 0 : _theme$page$kind2.width
      }, theme.page[kind][size]);
    }, [theme, size, kind]);
    return /* @__PURE__ */ import_react90.default.createElement(PageContext.Provider, {
      value: contentValue
    }, /* @__PURE__ */ import_react90.default.createElement(Box, _extends79({
      fill: "horizontal"
    }, rest)));
  };
  Page.displayName = "Page";
  Page.propTypes = PagePropTypes;
  Page.defaultProps = {
    kind: "wide"
  };

  // node_modules/grommet/es6/components/PageContent/PageContent.js
  var import_react91 = __toESM(require_react());

  // node_modules/grommet/es6/components/PageContent/propTypes.js
  var import_prop_types42 = __toESM(require_prop_types());
  var PropType42 = {};
  if (true) {
    PropType42 = {
      background: import_prop_types42.default.oneOfType([import_prop_types42.default.string, import_prop_types42.default.shape({
        color: colorPropType,
        dark: import_prop_types42.default.oneOfType([import_prop_types42.default.bool, import_prop_types42.default.string]),
        image: import_prop_types42.default.string,
        position: import_prop_types42.default.string,
        opacity: import_prop_types42.default.oneOfType([import_prop_types42.default.string, import_prop_types42.default.bool, import_prop_types42.default.number, import_prop_types42.default.oneOf(["weak", "medium", "strong"])]),
        repeat: import_prop_types42.default.oneOfType([import_prop_types42.default.oneOf(["no-repeat", "repeat"]), import_prop_types42.default.string]),
        size: import_prop_types42.default.oneOfType([import_prop_types42.default.oneOf(["cover", "contain"]), import_prop_types42.default.string]),
        light: import_prop_types42.default.string,
        fill: import_prop_types42.default.oneOf(["horizontal"])
      })])
    };
  }
  var PageContentPropTypes = PropType42;

  // node_modules/grommet/es6/components/PageContent/PageContent.js
  var _excluded58 = ["children", "background"];
  function _objectDestructuringEmpty3(obj) {
    if (obj == null)
      throw new TypeError("Cannot destructure " + obj);
  }
  function _extends80() {
    _extends80 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends80.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose53(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var PageContent = function PageContent2(_ref) {
    var children = _ref.children, background = _ref.background, rest = _objectWithoutPropertiesLoose53(_ref, _excluded58);
    var _useContext = (0, import_react91.useContext)(PageContext), pageContext = _extends80({}, (_objectDestructuringEmpty3(_useContext), _useContext));
    if (background != null && background.fill) {
      return /* @__PURE__ */ import_react91.default.createElement(Box, {
        background
      }, /* @__PURE__ */ import_react91.default.createElement(Box, _extends80({
        fill: "horizontal"
      }, pageContext, rest), children));
    }
    return /* @__PURE__ */ import_react91.default.createElement(Box, _extends80({
      fill: "horizontal",
      background
    }, pageContext, rest), children);
  };
  PageContent.displayName = "PageContent";
  PageContent.propTypes = PageContentPropTypes;

  // app/javascript/components/themes/AppContainer.jsx
  var import_react92 = __toESM(require_react());
  var appContainer = {
    gap: "large",
    width: {
      min: "medium"
    }
  };
  var AppContainer = ({ ...rest }) => /* @__PURE__ */ import_react92.default.createElement(
    Box,
    {
      gap: appContainer.gap,
      height: { min: "100%" },
      width: appContainer.width,
      flex: false,
      ...rest
    }
  );

  // app/javascript/components/themes/ContentArea.jsx
  var import_react102 = __toESM(require_react());
  var import_prop_types43 = __toESM(require_prop_types());

  // node_modules/grommet-icons/es6/utils.js
  var import_react93 = __toESM(require_react());
  var import_styled_components65 = __toESM(require_styled_components_browser_cjs());
  var parseMetricToNum3 = function parseMetricToNum4(string) {
    if (string === void 0) {
      string = "";
    }
    return parseFloat(string.match(/\d+(\.\d+)?/), 10);
  };
  function useScaleProps(props) {
    var _theme$icon;
    var theme = (0, import_react93.useContext)(import_styled_components65.ThemeContext);
    var size = props.size;
    var result = {};
    if (theme != null && (_theme$icon = theme.icon) != null && _theme$icon.disableScaleDown) {
      var dimension = parseMetricToNum3(theme.icon.size[size] || size);
      if (dimension < 24)
        result.vectorEffect = "non-scaling-stroke";
    }
    return result;
  }
  var calculatePad = function calculatePad2(value, iconDimension) {
    return (value - iconDimension) / 2 + "px";
  };
  function iconPad(props) {
    var _theme$icon2, _theme$icon2$size, _theme$text, _theme$text$height, _theme$text2, _theme$text2$width;
    var height = props.height, _props$size = props.size, size = _props$size === void 0 ? "medium" : _props$size, width = props.width;
    var theme = (0, import_react93.useContext)(import_styled_components65.ThemeContext);
    var iconDimension = parseMetricToNum3(((_theme$icon2 = theme.icon) == null ? void 0 : (_theme$icon2$size = _theme$icon2.size) == null ? void 0 : _theme$icon2$size[size]) || size);
    var style = "";
    if (height && theme != null && (_theme$text = theme.text) != null && (_theme$text$height = _theme$text[height]) != null && _theme$text$height.height) {
      var lineHeight = parseMetricToNum3(theme.text[height].height);
      if (lineHeight > iconDimension) {
        var pad = calculatePad(lineHeight, iconDimension);
        style += "padding-top: " + pad + "; padding-bottom: " + pad + ";";
      }
    }
    if (width && theme != null && (_theme$text2 = theme.text) != null && (_theme$text2$width = _theme$text2[width]) != null && _theme$text2$width.height) {
      var desiredWidth = parseMetricToNum3(theme.text[width].height);
      if (desiredWidth > iconDimension) {
        var _pad = calculatePad(desiredWidth, iconDimension);
        style += "padding-left: " + _pad + "; padding-right: " + _pad + ";";
      }
    }
    return style;
  }

  // node_modules/grommet-icons/es6/themes/base.js
  var base2 = {
    global: {
      colors: {
        icon: "#666666"
      }
    },
    icon: {
      size: {
        small: "12px",
        medium: "24px",
        large: "48px",
        xlarge: "96px"
      }
    }
  };

  // node_modules/grommet-icons/es6/default-props.js
  var defaultProps3 = {
    theme: base2
  };

  // node_modules/grommet-icons/es6/StyledIcon.js
  var import_react94 = __toESM(require_react());
  var import_styled_components66 = __toESM(require_styled_components_browser_cjs());
  var import_grommet_styles = __toESM(require_grommet_styles());
  var _excluded59 = ["a11yTitle", "color", "size", "theme"];
  function _extends81() {
    _extends81 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends81.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose54(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var colorCss = (0, import_styled_components66.css)(["", " ", ' g{fill:inherit;stroke:inherit;}*:not([stroke]){&[fill="none"]{stroke-width:0;}}*[stroke*="#"],*[STROKE*="#"]{stroke:inherit;fill:none;}*[fill-rule],*[FILL-RULE],*[fill*="#"],*[FILL*="#"]{fill:inherit;stroke:none;}'], function(props) {
    return (0, import_grommet_styles.colorStyle)("fill", props.color || props.theme.global.colors.icon, props.theme);
  }, function(props) {
    return (0, import_grommet_styles.colorStyle)("stroke", props.color || props.theme.global.colors.icon, props.theme);
  });
  var IconInner = /* @__PURE__ */ (0, import_react94.forwardRef)(function(_ref, ref) {
    var a11yTitle = _ref.a11yTitle, color = _ref.color, size = _ref.size, theme = _ref.theme, rest = _objectWithoutPropertiesLoose54(_ref, _excluded59);
    return /* @__PURE__ */ import_react94.default.createElement("svg", _extends81({
      ref,
      "aria-label": a11yTitle
    }, rest));
  });
  IconInner.displayName = "Icon";
  var StyledIcon2 = (0, import_styled_components66.default)(IconInner).withConfig({
    // don't let height attribute leak to DOM
    // https://styled-components.com/docs/api#shouldforwardprop
    shouldForwardProp: function shouldForwardProp4(prop) {
      return !["height", "width"].includes(prop);
    }
  }).withConfig({
    displayName: "StyledIcon",
    componentId: "sc-ofa7kd-0"
  })(["display:inline-block;flex:0 0 auto;", " ", " ", " ", ""], function(_ref2) {
    var _ref2$size = _ref2.size, size = _ref2$size === void 0 ? "medium" : _ref2$size, theme = _ref2.theme, viewBox = _ref2.viewBox;
    var _split = (viewBox || "0 0 24 24").split(" "), w = _split[2], h = _split[3];
    var scale = w / h;
    var dimension = parseMetricToNum3(theme.icon.size[size] || size);
    if (w < h) {
      return "\n      width: " + dimension + "px;\n      height: " + dimension / scale + "px;\n    ";
    }
    if (h < w) {
      return "\n      width: " + dimension * scale + "px;\n      height: " + dimension + "px;\n    ";
    }
    return "\n      width: " + dimension + "px;\n      height: " + dimension + "px;\n    ";
  }, function(_ref3) {
    var color = _ref3.color;
    return color !== "plain" && colorCss;
  }, function(props) {
    return (props.height || props.width) && iconPad(props);
  }, function(_ref4) {
    var theme = _ref4.theme;
    return theme && theme.icon.extend;
  });
  StyledIcon2.defaultProps = {};
  Object.setPrototypeOf(StyledIcon2.defaultProps, defaultProps3);

  // node_modules/grommet-icons/es6/icons/Close.js
  var import_react95 = __toESM(require_react());
  function _extends82() {
    _extends82 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends82.apply(this, arguments);
  }
  var Close = /* @__PURE__ */ (0, import_react95.forwardRef)(function(props, ref) {
    var scaleProps = useScaleProps(props);
    return /* @__PURE__ */ import_react95.default.createElement(StyledIcon2, _extends82({
      ref,
      viewBox: "0 0 24 24",
      a11yTitle: "Close"
    }, props), /* @__PURE__ */ import_react95.default.createElement("path", _extends82({
      fill: "none",
      stroke: "#000",
      strokeWidth: "2",
      d: "m3 3 18 18M3 21 21 3"
    }, scaleProps)));
  });
  Close.displayName = "Close";

  // node_modules/grommet-icons/es6/icons/Edit.js
  var import_react96 = __toESM(require_react());
  function _extends83() {
    _extends83 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends83.apply(this, arguments);
  }
  var Edit = /* @__PURE__ */ (0, import_react96.forwardRef)(function(props, ref) {
    return /* @__PURE__ */ import_react96.default.createElement(StyledIcon2, _extends83({
      ref,
      viewBox: "0 0 24 24",
      a11yTitle: "Edit"
    }, props), /* @__PURE__ */ import_react96.default.createElement("path", {
      fill: "none",
      stroke: "#000",
      strokeWidth: "2",
      d: "m14 4 6 6-6-6zm8.294 1.294c.39.39.387 1.025-.008 1.42L9 20l-7 2 2-7L17.286 1.714a1 1 0 0 1 1.42-.008l3.588 3.588zM3 19l2 2m2-4 8-8"
    }));
  });
  Edit.displayName = "Edit";

  // node_modules/grommet-icons/es6/icons/FormClose.js
  var import_react97 = __toESM(require_react());
  function _extends84() {
    _extends84 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends84.apply(this, arguments);
  }
  var FormClose3 = /* @__PURE__ */ (0, import_react97.forwardRef)(function(props, ref) {
    return /* @__PURE__ */ import_react97.default.createElement(StyledIcon2, _extends84({
      ref,
      viewBox: "0 0 24 24",
      a11yTitle: "FormClose"
    }, props), /* @__PURE__ */ import_react97.default.createElement("path", {
      fill: "none",
      stroke: "#000",
      strokeWidth: "2",
      d: "m7 7 10 10M7 17 17 7"
    }));
  });
  FormClose3.displayName = "FormClose";

  // node_modules/grommet-icons/es6/icons/Hpe.js
  var import_react98 = __toESM(require_react());
  function _extends85() {
    _extends85 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends85.apply(this, arguments);
  }
  var Hpe = /* @__PURE__ */ (0, import_react98.forwardRef)(function(props, ref) {
    return /* @__PURE__ */ import_react98.default.createElement(StyledIcon2, _extends85({
      ref,
      viewBox: "0 0 48 24",
      a11yTitle: "Hpe"
    }, props), /* @__PURE__ */ import_react98.default.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M2 6h44v12H2V6zm3 3h38v6H5V9z",
      fill: "#00C781"
    }));
  });
  Hpe.displayName = "Hpe";

  // node_modules/grommet-icons/es6/icons/Search.js
  var import_react99 = __toESM(require_react());
  function _extends86() {
    _extends86 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends86.apply(this, arguments);
  }
  var Search2 = /* @__PURE__ */ (0, import_react99.forwardRef)(function(props, ref) {
    var scaleProps = useScaleProps(props);
    return /* @__PURE__ */ import_react99.default.createElement(StyledIcon2, _extends86({
      ref,
      viewBox: "0 0 24 24",
      a11yTitle: "Search"
    }, props), /* @__PURE__ */ import_react99.default.createElement("path", _extends86({
      fill: "none",
      stroke: "#000",
      strokeWidth: "2",
      d: "m15 15 7 7-7-7zm-5.5 2a7.5 7.5 0 1 0 0-15 7.5 7.5 0 0 0 0 15z"
    }, scaleProps)));
  });
  Search2.displayName = "Search";

  // node_modules/grommet-icons/es6/icons/User.js
  var import_react100 = __toESM(require_react());
  function _extends87() {
    _extends87 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends87.apply(this, arguments);
  }
  var User = /* @__PURE__ */ (0, import_react100.forwardRef)(function(props, ref) {
    return /* @__PURE__ */ import_react100.default.createElement(StyledIcon2, _extends87({
      ref,
      viewBox: "0 0 24 24",
      a11yTitle: "User"
    }, props), /* @__PURE__ */ import_react100.default.createElement("path", {
      fill: "none",
      stroke: "#000",
      strokeWidth: "2",
      d: "M8 24v-5m8 5v-5M3 24v-5c0-4.97 4.03-8 9-8s9 3.03 9 8v5m-9-13a5 5 0 1 0 0-10 5 5 0 0 0 0 10z"
    }));
  });
  User.displayName = "User";

  // node_modules/grommet-theme-hpe/dist/es6/themes/hpe.js
  var import_react101 = __toESM(require_react());
  var import_styled_components67 = __toESM(require_styled_components_browser_cjs());
  var import_Ascending = __toESM(require_Ascending());
  var import_Blank2 = __toESM(require_Blank());
  var import_CircleAlert = __toESM(require_CircleAlert());
  var import_Descending = __toESM(require_Descending());
  var import_FormDown2 = __toESM(require_FormDown());
  var import_FormNext2 = __toESM(require_FormNext());
  var import_FormPrevious2 = __toESM(require_FormPrevious());
  var import_FormUp3 = __toESM(require_FormUp());
  var import_Unsorted = __toESM(require_Unsorted());
  var import_Hpe = __toESM(require_Hpe());

  // node_modules/grommet-theme-hpe/dist/es6/themes/backgrounds.js
  var backgrounds = {
    "datawave-green-1": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/AdobeStock-57301038_800_0_72_RGB+19849.jpg)",
    "datawave-green-2": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/AdobeStock_222468625_800_0_72_RGB+19870.jpg)",
    "datawave-multi-1": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/AdobeStock-257301038_800_0_72_RGB+19842.jpg)",
    "datawave-multi-2": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/HPE_data_satin_01_800_0_72_RGB+20062.jpg)",
    "datawave-multi-3": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/HPE_data_satin_02_800_0_72_RGB+20061.jpg)",
    "datawave-multi-4": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/HPE_data_slice_01_800_0_72_RGB+20107.jpg)",
    "datawave-multi-5": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/HPE_data_slice_02_800_0_72_RGB+20106.jpg)",
    "datawave-multi-6": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/HPE_data_slice_03_800_0_72_RGB+20105.jpg)",
    "datawave-white-1": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/GettyImages-1135685131_800_0_72_RGB+19858.jpg)",
    "datawave-white-2": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/GettyImages-1278457196_800_0_72_RGB+19857.jpg)",
    "datawave-white-3": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/GettyImages-1304863046_800_0_72_RGB+19856.jpg)",
    "datawave-white-4": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/GettyImages-978721396_800_0_72_RGB+19859.jpg)",
    "light-shadow-1": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/GettyImages-1135685107_800_0_72_RGB+19853.jpg)",
    "light-shadow-2": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/GettyImages-1135685108_800_0_72_RGB+19852.jpg)",
    "light-shadow-3": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/GettyImages-1135685118_800_0_72_RGB+19854.jpg)",
    "light-shadow-4": "url(https://d3hq6blov2iije.cloudfront.net/images/textures/GettyImages-1190757657_800_0_72_RGB+19855.jpg)",
    "orange-yellow": "linear-gradient(\n      45deg,\n      hsl(22deg 100% 50%) 0%,\n      hsl(34deg 100% 50%) 50%,\n      hsl(46deg 100% 50%) 100%\n    );",
    "purple-blue": "linear-gradient(\n      45deg,\n      hsl(281deg 100% 63%) 1%,\n      hsl(227deg 83% 58%) 50%,\n      hsl(174deg 69% 53%) 99%\n    );",
    "purple-blue-yellow": "linear-gradient(\n      225deg,\n      hsl(263deg 82% 55%) 0%,\n      hsl(196deg 72% 53%) 25%,\n      hsl(171deg 80% 63%) 50%,\n      hsl(138deg 93% 68%) 75%,\n      hsl(47deg 99% 50%) 100%\n    );",
    "purple-magenta-yellow": "linear-gradient(\n      45deg,\n      hsl(274deg 100% 50%) 0%,\n      hsl(340deg 100% 50%) 50%,\n      hsl(46deg 100% 50%) 100%\n  );"
  };

  // node_modules/grommet-theme-hpe/dist/es6/themes/colors.js
  var colors2 = {
    /* deprecated accent and neutral colors */
    "accent-1": void 0,
    "accent-2": void 0,
    "accent-3": void 0,
    "accent-4": void 0,
    "neutral-1": void 0,
    "neutral-2": void 0,
    "neutral-3": void 0,
    "neutral-4": void 0,
    "neutral-5": void 0,
    "status-error": void 0,
    brand: "green!",
    background: {
      dark: "#1C1C1C",
      light: "#FFFFFF"
    },
    "background-back": {
      dark: "#1C1C1C",
      light: "#F7F7F7"
    },
    "background-front": {
      dark: "#222222",
      light: "#FFFFFF"
    },
    "background-contrast": {
      dark: "#FFFFFF0F",
      // 6%
      light: "#0000000A"
    },
    icon: "text",
    text: {
      dark: "#FFFFFFE6",
      // 90%
      light: "#444444"
    },
    "text-strong": {
      dark: "#FFFFFFF5",
      // 96%
      light: "#000000"
    },
    "text-weak": {
      dark: "#FFFFFF80",
      // 50%
      light: "#757575"
    },
    "text-xweak": {
      dark: "#FFFFFF33",
      // 20%
      light: "#BBBBBB"
    },
    border: {
      dark: "#FFFFFF5C",
      // 36%
      light: "#0000005C"
      // 36%
    },
    "border-strong": {
      dark: "#FFFFFFB8",
      // 72%
      light: "#000000B8"
      // 72%
    },
    "border-weak": {
      dark: "#FFFFFF1F",
      // 12%
      light: "#0000001F"
      // 12%
    },
    control: "green",
    "active-background": "background-contrast",
    "active-text": "text",
    "disabled-text": "text-weak",
    // deprecated, use text-weak instead
    "selected-background": "green",
    "selected-text": "text-strong",
    "status-critical": {
      dark: "#D04F4E",
      light: "#FC5A5A"
    },
    "status-warning": {
      dark: "#9B6310",
      light: "#FFBC44"
    },
    "status-ok": {
      dark: "#008567",
      light: "#17EBA0"
    },
    "status-unknown": {
      dark: "#555555",
      light: "#CCCCCC"
    },
    "status-disabled": "#CCCCCC",
    // deprecated, does not support light and dark. use text-weak instead
    blue: {
      dark: "#00567A",
      light: "#00C8FF"
    },
    "blue!": "#00739D",
    green: {
      dark: "#008567",
      light: "#17EBA0"
    },
    "green!": "#01A982",
    teal: {
      dark: "#117B82",
      light: "#82FFF2"
    },
    "teal!": "#00E8CF",
    purple: {
      dark: "#6633BC",
      light: "#F740FF"
    },
    "purple!": "#7630EA",
    red: {
      dark: "#A2423D",
      light: "#FC6161"
    },
    "red!": "#C54E4B",
    orange: {
      dark: "#9B6310",
      light: "#FFBC44"
    },
    "orange!": "#FF8300",
    yellow: {
      dark: "#8D741C",
      light: "#FFEB59"
    },
    "yellow!": "#FEC901",
    "validation-critical": {
      light: "#FC61613D",
      dark: "#CC1F1A4D"
      // 30%
    },
    "validation-ok": {
      light: "#17EBA03D",
      dark: "#17D0A64D"
    },
    "validation-warning": {
      light: "#FFBC443D",
      dark: "#D891284D"
    },
    "graph-0": "orange!",
    "graph-1": "blue!",
    "graph-2": "purple!",
    "graph-3": "yellow!",
    "graph-4": "teal!",
    focus: "teal!",
    placeholder: "text-weak",
    "text-primary-button": "#FFFFFF",
    "background-cta-alternate": "#F2F2F2"
  };

  // node_modules/grommet-theme-hpe/dist/es6/themes/hpe.js
  var _templateObject;
  var _templateObject2;
  function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }
    strings.raw = raw;
    return strings;
  }
  var baseSpacing = 24;
  var isObject3 = function isObject4(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  };
  var deepFreeze3 = function deepFreeze4(obj) {
    Object.keys(obj).forEach(function(key) {
      return key && isObject3(obj[key]) && Object.freeze(obj[key]);
    });
    return Object.freeze(obj);
  };
  var hpe = deepFreeze3({
    defaultMode: "light",
    global: {
      backgrounds,
      breakpoints: {
        xsmall: {
          value: baseSpacing * 24,
          // 576
          borderSize: {
            xsmall: "1px",
            small: "2px",
            medium: baseSpacing / 6 + "px",
            // 4
            large: baseSpacing / 4 + "px",
            // 6
            xlarge: baseSpacing / 2 + "px"
            // 12
          },
          edgeSize: {
            none: "0px",
            hair: "1px",
            // for Chart
            xxsmall: "2px",
            xsmall: baseSpacing / 8 + "px",
            // 3
            small: baseSpacing / 4 + "px",
            // 6
            medium: baseSpacing / 2 + "px",
            // 12
            large: baseSpacing + "px",
            // 24
            xlarge: baseSpacing * 2 + "px"
            // 48
          },
          size: {
            xxsmall: baseSpacing + "px",
            // 24
            xsmall: baseSpacing * 2 + "px",
            // 48
            small: baseSpacing * 4 + "px",
            // 96
            medium: baseSpacing * 8 + "px",
            // 192
            large: baseSpacing * 16 + "px",
            // 384
            xlarge: baseSpacing * 32 + "px",
            // 768
            full: "100%"
          }
        },
        small: {
          value: baseSpacing * 32
          // 768
        },
        medium: {
          value: baseSpacing * 45
          // 1080
        },
        large: {
          value: baseSpacing * 60
          // 1440
        },
        xlarge: {}
        // anything larger than 1440,
      },
      colors: colors2,
      control: {
        border: {
          radius: "6px"
        }
      },
      input: {
        font: {
          height: "inherit",
          weight: 500
        },
        padding: {
          horizontal: "11px",
          // equivalent to 'small' when combined with 1px border
          vertical: "5px"
          // equivalent to 'xsmall' when combined with 1px border
        },
        extend: "\n        &::-webkit-input-placeholder {\n          font-weight: 400;\n        }\n      \n        &::-moz-placeholder {\n          font-weight: 400;\n        }\n      \n        &:-ms-input-placeholder {\n          font-weight: 400;\n        }\n      "
      },
      font: {
        family: "'Metric', Arial, sans-serif",
        face: `
        @font-face {
          font-family: "Metric";
          src: url("https://d3hq6blov2iije.cloudfront.net/fonts/HPEXS-Metric-Fonts/MetricHPEXS-Regular.woff2") format('woff2'),
               url("https://d3hq6blov2iije.cloudfront.net/fonts/HPEXS-Metric-Fonts/MetricHPEXS-Regular.woff") format('woff');
        }
        @font-face {
          font-family: "Metric";
          src: url("https://d3hq6blov2iije.cloudfront.net/fonts/HPEXS-Metric-Fonts/MetricHPEXS-Bold.woff2") format('woff2'),
               url("https://d3hq6blov2iije.cloudfront.net/fonts/HPEXS-Metric-Fonts/MetricHPEXS-Bold.woff") format('woff');
          font-weight: 700;
        }
        @font-face {
          font-family: "Metric";
          src: url("https://d3hq6blov2iije.cloudfront.net/fonts/HPEXS-Metric-Fonts/MetricHPEXSSemibold-Regular.woff2") format('woff2'),
               url("https://d3hq6blov2iije.cloudfront.net/fonts/HPEXS-Metric-Fonts/MetricHPEXSSemibold-Regular.woff") format('woff');
          font-weight: 600;
        }
        @font-face {
          font-family: "Metric";
          src: url("https://d3hq6blov2iije.cloudfront.net/fonts/HPEXS-Metric-Fonts/MetricHPEXSMedium-Regular.woff2") format('woff2'),
               url("https://d3hq6blov2iije.cloudfront.net/fonts/HPEXS-Metric-Fonts/MetricHPEXSMedium-Regular.woff") format('woff');
          font-weight: 500;
        }
        @font-face {
          font-family: "Metric";
          src: url("https://d3hq6blov2iije.cloudfront.net/fonts/HPEXS-Metric-Fonts/MetricHPEXSLight-Regular.woff2") format('woff2'),
               url("https://d3hq6blov2iije.cloudfront.net/fonts/HPEXS-Metric-Fonts/MetricHPEXSLight-Regular.woff") format('woff');
          font-weight: 100;
        }`
      },
      focus: {
        border: void 0
      },
      active: {
        background: "active-background",
        color: "active-text"
      },
      drop: {
        background: "background-front",
        border: {
          radius: "4px"
        },
        margin: "xsmall",
        intelligentMargin: true,
        shadowSize: "medium",
        /* HPE Global Header/Footer Service a.k.a. HPE Common HFWS sets the header
         * at a z-index of 101. This adjustment brings Drop in alignment with Layer
         * which needs an elevated z-index to sit atop the Global header. */
        zIndex: "110"
      },
      elevation: {
        // Elevation values were derived from this Figma file.
        // https://www.figma.com/file/eZYR3dtWdb9U90QvJ7p3T9/HPE-Color-Styles?node-id=405%3A25
        // Naming in Figma file is strong/default/weak vs. Grommet t-shirt sizing.
        // As defined here, default is currently mapping to medium.
        light: {
          small: "0px 2px 4px #0000001F;",
          medium: "0px 6px 12px #0000001F;",
          large: "0px 12px 24px #0000003D;"
        },
        dark: {
          small: "0px 2px 4px #0000003D;",
          medium: "0px 6px 12px #0000005C;",
          large: "0px 12px 24px #0000007A;"
        }
      },
      hover: {
        background: "active-background",
        color: "active-text"
      },
      selected: {
        background: "selected-background",
        color: "selected-text"
      }
    },
    accordion: {
      panel: {
        border: {
          side: "horizontal",
          color: "border"
        }
      },
      heading: {
        margin: {
          vertical: "medium",
          horizontal: "xsmall"
        }
      },
      hover: {
        background: "background-contrast",
        heading: {
          color: void 0
        }
      },
      border: void 0,
      icons: {
        color: "text"
      }
    },
    anchor: {
      color: "text",
      textDecoration: "underline",
      fontWeight: 500,
      gap: "xsmall",
      hover: {
        textDecoration: "underline"
      }
    },
    avatar: {
      size: {
        large: baseSpacing * 4 + "px"
        // 96px
      },
      text: {
        size: {
          large: "xxlarge"
          // 36px
        }
      }
    },
    button: {
      "cta-primary": {
        background: {
          color: "brand"
        },
        border: {
          radius: "100px"
        },
        color: "text-primary-button",
        font: {
          weight: "bold"
        },
        icon: /* @__PURE__ */ import_react101.default.createElement(import_Hpe.Hpe, null),
        reverse: true
      },
      "cta-alternate": {
        background: "background-cta-alternate",
        border: {
          radius: "100px"
        },
        color: "text-strong",
        font: {
          weight: "bold"
        },
        icon: /* @__PURE__ */ import_react101.default.createElement(import_Hpe.Hpe, {
          color: "brand"
        }),
        reverse: true
      },
      "default": {
        color: "text-strong",
        border: void 0,
        font: {
          weight: 700
        }
      },
      gap: "xsmall",
      primary: {
        background: {
          color: "brand"
        },
        border: void 0,
        color: "text-primary-button",
        font: {
          weight: 700
        },
        // for primary button with color, use text-strong
        // instead of text-primary-button which is hard-coded
        // to "white" specifically for HPE green.
        extend: function extend3(_ref) {
          var colorValue = _ref.colorValue, primary = _ref.primary, theme = _ref.theme;
          return colorValue && primary ? "\n        color: " + theme.global.colors["text-strong"][theme.dark ? "dark" : "light"] + ";\n      " : "";
        }
      },
      secondary: {
        border: {
          color: "brand",
          width: "2px"
        },
        color: "text-strong",
        font: {
          weight: 700
        }
      },
      toolbar: {
        border: {
          color: "border",
          width: "1px"
        },
        color: "text-strong",
        font: {
          weight: 700
        }
      },
      option: {
        color: "text",
        border: {
          radius: "0px"
        },
        font: {
          weight: 500
        }
      },
      active: {
        background: {
          color: "background-contrast"
        },
        color: "text-strong",
        secondary: {
          border: {
            color: "transparent"
          }
        },
        option: {
          background: {
            color: "active-background"
          }
        }
      },
      selected: {
        option: {
          background: "selected-background",
          color: "selected-text"
        }
      },
      disabled: {
        background: {
          color: "transparent"
        },
        color: "text-xweak",
        "cta-primary": {
          border: {
            color: "border-weak",
            width: "2px"
          }
        },
        "cta-alternate": {
          border: {
            color: "border-weak",
            width: "2px"
          }
        },
        primary: {
          border: {
            color: "border-weak",
            width: "2px"
          }
        },
        secondary: {
          border: {
            color: "border-weak"
          }
        },
        opacity: 1
      },
      hover: {
        "cta-primary": {
          extend: function extend4(_ref2) {
            var active = _ref2.active, colorValue = _ref2.colorValue, theme = _ref2.theme;
            var color;
            if (!colorValue && !active) {
              if (theme.dark) {
                color = "rgba(0, 0, 0, 0.2)";
              } else
                color = "rgba(0, 0, 0, 0.2)";
            }
            var style = "inset 0 0 100px 100px " + color;
            return "-moz-box-shadow: " + style + ";\n            -webkit-box-shadow: " + style + ";\n            box-shadow: " + style + ";";
          }
        },
        "cta-alternate": {
          extend: function extend5(_ref3) {
            var active = _ref3.active, colorValue = _ref3.colorValue, theme = _ref3.theme;
            var color;
            if (!colorValue && !active) {
              if (theme.dark) {
                color = "rgba(0, 0, 0, 0.2)";
              } else
                color = "rgba(0, 0, 0, 0.2)";
            }
            var style = "inset 0 0 100px 100px " + color;
            return "-moz-box-shadow: " + style + ";\n            -webkit-box-shadow: " + style + ";\n            box-shadow: " + style + ";";
          }
        },
        "default": {
          background: {
            color: "background-contrast"
          },
          color: void 0
        },
        secondary: {
          border: {
            width: "3px"
          }
        },
        option: {
          background: "active-background",
          color: "active-text"
        },
        toolbar: {
          background: {
            color: "background-contrast"
          },
          color: void 0
        },
        primary: {
          extend: function extend6(_ref4) {
            var active = _ref4.active, colorValue = _ref4.colorValue, theme = _ref4.theme;
            var color;
            if (!colorValue && !active) {
              if (theme.dark) {
                color = "rgba(0, 0, 0, 0.2)";
              } else
                color = "rgba(0, 0, 0, 0.2)";
            }
            var style = "inset 0 0 100px 100px " + color;
            return "-moz-box-shadow: " + style + ";\n            -webkit-box-shadow: " + style + ";\n            box-shadow: " + style + ";";
          }
        }
      },
      color: "text-strong",
      border: {
        radius: "6px"
      },
      padding: {
        vertical: "4px",
        horizontal: "22px"
      },
      size: {
        small: {
          border: {
            radius: "6px"
          },
          pad: {
            vertical: "4px",
            horizontal: "8px"
          },
          "cta-primary": {
            pad: {
              vertical: "3px",
              horizontal: "12px"
            }
          },
          "cta-alternate": {
            pad: {
              vertical: "3px",
              horizontal: "12px"
            }
          }
        },
        medium: {
          border: {
            radius: "6px"
          },
          pad: {
            vertical: "6px",
            horizontal: "12px"
          },
          "cta-primary": {
            pad: {
              vertical: "6px",
              horizontal: "16px"
            }
          },
          "cta-alternate": {
            pad: {
              vertical: "6px",
              horizontal: "16px"
            }
          }
        },
        large: {
          border: {
            radius: "8px"
          },
          pad: {
            vertical: "8px",
            horizontal: "16px"
          },
          "cta-primary": {
            pad: {
              vertical: "8px",
              horizontal: "20px"
            }
          },
          "cta-alternate": {
            pad: {
              vertical: "8px",
              horizontal: "20px"
            }
          }
        },
        xlarge: {
          border: {
            radius: "10px"
          },
          pad: {
            vertical: "10px",
            horizontal: "20px"
          },
          "cta-primary": {
            pad: {
              vertical: "10px",
              horizontal: "28px"
            }
          },
          "cta-alternate": {
            pad: {
              vertical: "10px",
              horizontal: "28px"
            }
          }
        }
      },
      // aligning with brand central which follows slightly different interval between t-shirt sizes
      extend: function extend7(_ref5) {
        var sizeProp = _ref5.sizeProp;
        var fontSize = "19px";
        var lineHeight = "24px";
        if (sizeProp === "small") {
          fontSize = "16px";
          lineHeight = "22px";
        } else if (sizeProp === "large") {
          fontSize = "20px";
          lineHeight = "26px";
        } else if (sizeProp === "xlarge") {
          fontSize = "22px";
          lineHeight = "28px";
        }
        return "\n      font-size: " + fontSize + ";\n      line-height: " + lineHeight + "\n      ";
      }
    },
    calendar: {
      icons: {
        next: import_FormNext2.FormNext,
        previous: import_FormPrevious2.FormPrevious
      },
      small: {
        fontSize: "13.6px",
        lineHeight: 1.375,
        daySize: "27.43px"
      },
      medium: {
        fontSize: "18px",
        lineHeight: 1.45,
        daySize: "54.86px"
      },
      large: {
        fontSize: "31.2px",
        lineHeight: 1.11,
        daySize: "109.71px"
      }
    },
    card: {
      container: {
        background: "background-front",
        elevation: "medium",
        extend: "transition: all 0.3s ease-in-out;"
      },
      body: {
        pad: "medium"
      },
      footer: {
        pad: {
          horizontal: "medium",
          vertical: "small"
        }
      },
      header: {
        pad: "medium"
      },
      hover: {
        container: {
          elevation: "large"
        }
      }
    },
    checkBox: {
      hover: {
        border: {
          color: "border-strong"
        },
        background: {
          color: "background-contrast"
        },
        // HPE Design System guidance states that pad="none" should be applied on CheckBox
        // when its used outside of a FormField. We will apply this hover treatment in
        // those instances.
        extend: function extend8(_ref6) {
          var disabled = _ref6.disabled, pad = _ref6.pad, theme = _ref6.theme;
          return "\n      " + (!disabled && pad === "none" && "border: 2px solid " + theme.global.colors["border-strong"][theme.dark ? "dark" : "light"] + ";") + "\n    ";
        }
      },
      color: "background",
      border: {
        color: "border",
        width: "1px"
      },
      check: {
        radius: "4px",
        extend: function extend9(_ref7) {
          var theme = _ref7.theme, checked = _ref7.checked, indeterminate = _ref7.indeterminate;
          return "\n      background-color: " + (checked || indeterminate ? theme.global.colors.green[theme.dark ? "dark" : "light"] : theme.global.colors.background[theme.dark ? "dark" : "light"]) + ";\n      " + ((checked || indeterminate) && "border: none;") + "\n        ";
        }
      },
      icon: {
        extend: function extend10(_ref8) {
          var theme = _ref8.theme;
          return "stroke-width: 2px;\n      stroke: " + theme.global.colors["text-strong"][theme.dark ? "dark" : "light"];
        }
      },
      gap: "small",
      label: {
        align: "start"
      },
      pad: {
        vertical: "xsmall",
        horizontal: "small"
      },
      toggle: {
        background: "background",
        color: "background",
        knob: {
          extend: function extend11(_ref9) {
            var theme = _ref9.theme;
            return "\n           box-shadow: " + theme.global.elevation[theme.dark ? "dark" : "light"].small + ";\n           border: 1px solid " + theme.global.colors.border[theme.dark ? "dark" : "light"] + "\n        ";
          }
        },
        extend: function extend12(_ref10) {
          var checked = _ref10.checked, theme = _ref10.theme;
          return "\n        " + (checked && "background-color: " + theme.global.colors.green[theme.dark ? "dark" : "light"] + ";") + "\n      ";
        }
      },
      // HPE Design System guidance states that pad="none" should be applied on CheckBox
      // when its used outside of a FormField. We will apply this hover treatment in
      // those instances.
      extend: function extend13(_ref11) {
        var disabled = _ref11.disabled, pad = _ref11.pad;
        return "\n    " + (!disabled && pad === "none" && ":hover {\n      background-color: unset;\n    }") + "\n    font-weight: 500;\n    width: auto;\n  };\n  ";
      }
    },
    checkBoxGroup: {
      container: {
        gap: "none",
        margin: {
          vertical: "xsmall"
        }
      }
    },
    dataTable: {
      body: {
        extend: function extend14(_ref12) {
          var theme = _ref12.theme;
          return "\n        /* Margin and padding allow room for focus on table body */\n        margin: " + theme.global.edgeSize.xxsmall + " 0px;\n        padding: 0px " + theme.global.edgeSize.xxsmall + ";\n      ";
        }
      },
      header: {
        border: {
          side: "bottom"
        },
        color: "text-strong",
        extend: function extend15(_ref13) {
          var column = _ref13.column, sort = _ref13.sort, sortable = _ref13.sortable, theme = _ref13.theme;
          return "\n          " + (sort && sort.property === column && "\n            background: " + theme.global.colors["background-contrast"][theme.dark ? "dark" : "light"] + "\n          ") + ";\n          " + (sortable && sort && sort.property !== column && "\n              svg {\n                opacity: 0;\n              }\n              :hover {\n                svg {\n                  opacity: 1;\n                }\n              }\n            ") + ";\n        ";
        },
        font: {
          weight: "bold"
        },
        gap: "none",
        hover: {
          background: {
            color: "background-contrast"
          }
        },
        pad: {
          horizontal: "small",
          vertical: "xsmall"
        }
      },
      icons: {
        ascending: import_Ascending.Ascending,
        descending: import_Descending.Descending,
        sortable: import_Unsorted.Unsorted
      },
      /* Add FireFox work around until it adds support for backdrop-filter
      https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter
      */
      pinned: {
        header: {
          background: {
            opacity: 0.95
          },
          extend: "backdrop-filter: blur(8px);"
        },
        body: {
          background: {
            opacity: 0.95
          },
          extend: "backdrop-filter: blur(8px);"
        },
        footer: {
          background: {
            opacity: 0.95
          },
          extend: "backdrop-filter: blur(8px);"
        }
      },
      resize: {
        hover: {
          border: {
            color: "border-strong",
            size: "small"
          }
        }
      }
    },
    dateInput: {
      container: {
        round: "xsmall"
      },
      icon: {
        size: "small"
      }
    },
    fileInput: {
      border: {
        size: "xsmall"
      },
      button: {
        border: {
          radius: "24px"
        },
        pad: {
          vertical: "6px",
          horizontal: "12px"
        },
        color: "text-strong",
        font: {
          weight: "bold"
        },
        hover: {
          background: "background-contrast"
        }
      },
      dragOver: {
        background: "background-contrast",
        border: "none"
      },
      hover: {
        border: {
          color: "border"
        }
      },
      message: {
        color: "placeholder"
      },
      pad: {
        horizontal: "xsmall"
      },
      extend: "border-radius: 4px;"
    },
    formField: {
      content: {
        margin: {
          vertical: "xsmall"
        },
        pad: void 0
      },
      border: {
        error: {
          color: "border-strong"
        },
        color: "border",
        side: "all"
      },
      disabled: {
        background: {
          color: void 0
        },
        border: {
          color: "border-weak"
        },
        label: {
          color: "text-xweak"
        }
      },
      error: {
        background: {
          color: "validation-critical"
        },
        container: {
          gap: "xsmall"
        },
        icon: /* @__PURE__ */ import_react101.default.createElement(import_CircleAlert.CircleAlert, {
          size: "small",
          style: {
            marginTop: "4px"
          }
        }),
        size: "xsmall",
        color: "text",
        margin: {
          bottom: "xsmall",
          top: "none",
          horizontal: "none"
        }
      },
      focus: {
        border: {
          color: "border-strong"
        }
      },
      help: {
        size: "xsmall",
        color: "text",
        margin: "none"
      },
      info: {
        size: "xsmall",
        color: "text",
        margin: {
          bottom: "xsmall",
          top: "none",
          horizontal: "none"
        }
      },
      label: {
        size: "xsmall",
        color: "text",
        margin: {
          bottom: "none",
          top: "xsmall",
          horizontal: "none"
        },
        requiredIndicator: true,
        weight: 500
      },
      margin: {
        bottom: "none"
      },
      round: "6px",
      survey: {
        label: {
          margin: {
            bottom: "none"
          }
        }
      }
    },
    heading: {
      color: "text-strong",
      level: {
        1: {
          small: {
            size: "36px",
            height: "42px",
            maxWidth: "854px"
          },
          medium: {
            size: "53px",
            height: "59px",
            maxWidth: "1277px"
          },
          large: {
            size: "88px",
            height: "94px",
            maxWidth: "2122px"
          },
          xlarge: {
            size: "124px",
            height: "130px",
            maxWidth: "2966px"
          }
        },
        2: {
          small: {
            size: "31px",
            height: "37px",
            maxWidth: "749px"
          },
          medium: {
            size: "44px",
            height: "50px",
            maxWidth: "1066px"
          },
          large: {
            size: "58px",
            height: "64px",
            maxWidth: "1382px"
          },
          xlarge: {
            size: "71px",
            height: "77px",
            maxWidth: "1699px"
          }
        },
        3: {
          small: {
            size: "27px",
            height: "33px",
            maxWidth: "643px"
          },
          medium: {
            size: "36px",
            height: "42px",
            maxWidth: "854px"
          },
          large: {
            size: "44px",
            height: "50px",
            maxWidth: "1066px"
          },
          xlarge: {
            size: "53px",
            height: "59px",
            maxWidth: "1277px"
          }
        },
        4: {
          small: {
            size: "22px",
            height: "28px",
            maxWidth: "538px"
          },
          medium: {
            size: "27px",
            height: "33px",
            maxWidth: "643px"
          },
          large: {
            size: "31px",
            height: "37px",
            maxWidth: "749px"
          },
          xlarge: {
            size: "36px",
            height: "42px",
            maxWidth: "854px"
          }
        },
        5: {
          small: {
            size: "16px",
            height: "22px",
            maxWidth: "379px"
          },
          medium: {
            size: "16px",
            height: "22px",
            maxWidth: "379px"
          },
          large: {
            size: "16px",
            height: "22px",
            maxWidth: "379px"
          },
          xlarge: {
            size: "16px",
            height: "22px",
            maxWidth: "379px"
          }
        },
        6: {
          small: {
            size: "14px",
            height: "20px",
            maxWidth: "326px"
          },
          medium: {
            size: "14px",
            height: "20px",
            maxWidth: "326px"
          },
          large: {
            size: "14px",
            height: "20px",
            maxWidth: "326px"
          },
          xlarge: {
            size: "14px",
            height: "20px",
            maxWidth: "326px"
          }
        }
      },
      weight: 700
    },
    icon: {
      size: {
        xxlarge: "166px"
      }
    },
    layer: {
      background: "background",
      border: {
        radius: "small",
        intelligentRounding: true
      },
      container: {
        elevation: "large"
      },
      overlay: {
        background: "#00000080"
      },
      /* HPE Global Header/Footer Service a.k.a. HPE Common HFWS sets the header
       * at a z-index of 101. This adjustment allows for Layer modals and side-drawers
       * to sit atop the Global header. */
      zIndex: "110"
    },
    list: {
      item: {
        border: void 0
      }
    },
    maskedInput: {
      container: {
        extend: function extend16(_ref14) {
          var theme = _ref14.theme;
          return "\n        svg {\n          fill: " + theme.global.colors["text-strong"][theme.dark ? "dark" : "light"] + ";\n          stroke: " + theme.global.colors["text-strong"][theme.dark ? "dark" : "light"] + ";\n        }\n      ";
        }
      }
    },
    menu: {
      drop: {
        align: {
          top: "bottom",
          left: "left"
        }
      },
      group: {
        container: {
          pad: "none"
        },
        separator: {
          color: "border",
          pad: "none"
        }
      },
      icons: {
        color: "text-strong"
      }
    },
    notification: {
      actions: {
        color: {
          light: "text",
          dark: "text-strong"
        }
      },
      direction: "row",
      container: {
        round: "xsmall"
      },
      global: {
        container: {
          round: "none"
        }
      },
      message: {
        color: {
          dark: "text-strong"
        }
      },
      critical: {
        background: "validation-critical",
        global: {
          background: "validation-critical"
        },
        toast: {
          background: "background-front"
        }
      },
      warning: {
        background: "validation-warning",
        global: {
          background: "validation-warning"
        },
        toast: {
          background: "background-front"
        }
      },
      normal: {
        background: "validation-ok",
        global: {
          background: "validation-ok"
        },
        toast: {
          background: "background-front"
        }
      },
      unknown: {
        background: "background-contrast",
        global: {
          background: "background-contrast"
        },
        toast: {
          background: "background-front"
        }
      },
      info: {
        background: "background-contrast",
        global: {
          background: "background-contrast"
        },
        toast: {
          background: "background-front"
        }
      },
      undefined: {
        background: "background-contrast",
        global: {
          background: "background-contrast"
        },
        toast: {
          background: "background-front"
        }
      },
      toast: {
        direction: "column"
      }
    },
    page: {
      wide: {
        width: {
          min: "336px",
          // 336 + 24 (margin) + 24 (margin) = 384 (e.g. 'medium')
          max: "xxlarge"
        },
        xsmall: {
          pad: {
            horizontal: "large"
          }
        },
        xlarge: {
          pad: {
            horizontal: "large"
          }
        }
      },
      narrow: {
        width: {
          min: "336px",
          // 336 + 24 (margin) + 24 (margin) = 384 (e.g. 'medium')
          max: "large"
        },
        xsmall: {
          pad: {
            horizontal: "large"
          }
        },
        xlarge: {
          pad: {
            horizontal: "large"
          }
        }
      },
      full: {
        width: {
          min: "336px",
          // 336 + 24 (margin) + 24 (margin) = 384 (e.g. 'medium')
          max: "100%"
        },
        xsmall: {
          pad: {
            horizontal: "large"
          }
        },
        xlarge: {
          pad: {
            horizontal: "large"
          }
        }
      }
    },
    pageHeader: {
      actions: {
        pad: {
          vertical: "xxsmall"
        }
        // aligns button height with heading font-size instead of line-height
      },
      subtitle: {
        size: "large"
      },
      title: {
        size: "small"
      },
      xsmall: {
        areas: [["parent", "parent"], ["title", "actions"], ["subtitle", "actions"]],
        columns: [["small", "flex"], "auto"],
        rows: ["auto", "auto", "auto"],
        gap: {
          row: "xsmall",
          column: "medium"
        }
      },
      xlarge: {
        areas: [["parent", "parent"], ["title", "actions"], ["subtitle", "actions"]],
        columns: [["medium", "large"], "auto"],
        rows: ["auto", "auto", "auto"],
        gap: {
          row: "xsmall",
          column: "large"
        }
      }
    },
    pagination: {
      button: {
        font: {
          weight: 700
        },
        active: {
          font: {
            weight: 700
          }
        },
        disabled: {
          color: "text-xweak"
        }
      }
    },
    paragraph: {
      small: {
        size: "16px",
        height: "22px",
        maxWidth: "379px"
      },
      medium: {
        size: "18px",
        height: "24px",
        maxWidth: "432px"
      },
      large: {
        size: "22px",
        height: "28px",
        maxWidth: "538px"
      },
      xlarge: {
        size: "27px",
        height: "33px",
        maxWidth: "643px"
      },
      xxlarge: {
        size: "36px",
        height: "42px",
        maxWidth: "854px"
      }
    },
    radioButton: {
      border: {
        color: "border",
        width: "xsmall"
      },
      check: {
        color: "selected-background",
        background: {
          color: "background-front"
        }
      },
      color: "selected-background",
      container: {
        extend: function extend17(_ref15) {
          var theme = _ref15.theme;
          return "\n      font-weight: 500;\n      width: auto;\n      padding: " + theme.global.edgeSize.xxsmall + " " + theme.global.edgeSize.xsmall + ";\n    ";
        }
      },
      extend: function extend18(_ref16) {
        var theme = _ref16.theme;
        return "\n      padding: " + theme.global.edgeSize.xxsmall + " " + theme.global.edgeSize.xsmall + ";\n    ";
      },
      gap: "xsmall",
      hover: {
        background: {
          color: "background-contrast"
        },
        border: {
          color: void 0
        }
      },
      icons: {
        circle: function circle() {
          return /* @__PURE__ */ import_react101.default.createElement(import_Blank2.Blank, {
            color: "selected-background"
          }, /* @__PURE__ */ import_react101.default.createElement("circle", {
            cx: "12",
            cy: "12",
            r: "8"
          }));
        }
      }
    },
    radioButtonGroup: {
      container: {
        gap: "none",
        margin: {
          vertical: "xsmall"
        }
      }
    },
    rangeInput: {
      thumb: {
        color: "green"
      },
      track: {
        lower: {
          color: "green"
        },
        upper: {
          color: "border"
        }
      }
    },
    select: {
      control: {
        extend: function extend19(_ref17) {
          var disabled = _ref17.disabled;
          return (0, import_styled_components67.css)(_templateObject || (_templateObject = _taggedTemplateLiteralLoose(["\n        ", "\n      "])), disabled && "\n        opacity: 0.3;\n        input {\n          cursor: default;\n        }");
        }
      },
      icons: {
        color: "text",
        down: import_FormDown2.FormDown,
        up: import_FormUp3.FormUp
      },
      options: void 0
    },
    spinner: {
      container: {
        pad: "none",
        color: "green",
        border: [{
          color: "border-weak",
          side: "all",
          size: "medium"
        }, {
          color: "border-weak",
          side: "right",
          size: "medium"
        }, {
          color: "border-weak",
          side: "top",
          size: "medium"
        }, {
          color: "border-weak",
          side: "left",
          size: "medium"
        }]
      }
    },
    starRating: {
      color: "purple!"
    },
    tab: {
      color: "text-strong",
      active: {
        background: "background-contrast",
        color: "text-strong"
      },
      hover: {
        background: "background-contrast",
        color: "text-strong"
      },
      border: {
        side: "bottom",
        color: "transparent",
        size: "6px",
        active: {
          color: "text-strong"
        },
        disabled: {
          color: void 0
        },
        hover: {
          color: void 0
        }
      },
      disabled: {
        color: "text-xweak"
      },
      pad: {
        // top and bottom pad need to be defined individually, specifying
        // "vertical" only applies to top
        bottom: "small",
        top: "small",
        horizontal: "medium"
      },
      margin: {
        // bring the overall tabs border behind invidual tab borders
        vertical: "-2px",
        horizontal: "none"
      },
      extend: function extend20(_ref18) {
        var theme = _ref18.theme;
        return (0, import_styled_components67.css)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteralLoose(["\n      border-top-left-radius: ", "; // should use radius property of border\n      border-top-right-radius: ", "; // should use radius property of border\n      font-weight: bold;\n    "])), theme.global.control.border.radius, theme.global.control.border.radius);
      }
    },
    tabs: {
      header: {
        border: {
          side: "bottom",
          size: "small",
          color: "border"
        }
      },
      step: {
        xsmall: 1,
        xlarge: 3
      }
    },
    table: {
      header: {
        extend: "\n        > div { \n          height: 100%;\n          justify-content: center;\n        }\n        // align onSelect checkbox to center of header cell\n        label { \n          justify-content: center;\n        }\n      ",
        // space for focus indicator on sortable columns
        pad: {
          left: "none",
          vertical: "none",
          right: "xxsmall"
        }
      },
      body: {
        extend: function extend21(_ref19) {
          var theme = _ref19.theme;
          return "\n          :hover {\n            button {\n              background: " + theme.global.colors["background-contrast"][theme.dark ? "dark" : "light"] + "\n            }\n          }\n        ";
        }
      },
      row: {
        hover: {
          background: "background-contrast"
        }
      },
      footer: {
        extend: "\n        font-weight: bold;\n      "
      }
    },
    text: {
      xsmall: {
        size: "14px",
        height: "20px",
        maxWidth: "326px"
      },
      small: {
        size: "16px",
        height: "22px",
        maxWidth: "379px"
      },
      medium: {
        size: "18px",
        height: "24px",
        maxWidth: "432px"
      },
      large: {
        size: "22px",
        height: "28px",
        maxWidth: "538px"
      },
      xlarge: {
        size: "27px",
        height: "33px",
        maxWidth: "643px"
      },
      xxlarge: {
        size: "36px",
        height: "42px",
        maxWidth: "854px"
      }
    },
    textInput: {
      container: {
        extend: function extend22(_ref20) {
          var theme = _ref20.theme;
          return "\n        svg {\n          fill: " + theme.global.colors["text-strong"][theme.dark ? "dark" : "light"] + ";\n          stroke: " + theme.global.colors["text-strong"][theme.dark ? "dark" : "light"] + ";\n        }\n      ";
        }
      }
    },
    tip: {
      content: {
        background: "background",
        border: {
          color: "border-weak"
        },
        margin: "xxsmall",
        elevation: "small",
        pad: {
          vertical: "none",
          horizontal: "small"
        },
        round: "xsmall"
      }
    },
    thumbsRating: {
      like: {
        color: "purple!"
      },
      dislike: {
        color: "purple!"
      }
    },
    // Theme-Designer only parameters
    name: "HPE 1",
    rounding: 4,
    scale: 1.1,
    spacing: 24
  });

  // app/javascript/components/themes/aries.js
  var import_utils62 = __toESM(require_utils3());
  var import_Info = __toESM(require_Info());
  var aries = (0, import_utils62.deepMerge)(hpe, {
    defaultMode: "dark",
    // To be stripped out once theme changes are made in grommet-theme-hpe.
    // keeping file for use as playground for future theme adjusments that need
    // to be quickly tested
    buttonGroup: {
      // any Box props
      gap: "small"
    },
    feedback: {
      closeButton: {
        a11yTitle: `You are in a dialog containing a form to submit feedback.
        To close this layer, press Enter.`
      },
      container: {
        pad: "medium"
      },
      header: {
        align: "start",
        direction: "row",
        justify: "between",
        gap: "xsmall"
      },
      heading: {
        size: "small",
        level: 2,
        margin: {
          vertical: "none"
        }
      },
      footer: {
        pad: {
          top: "medium"
        },
        direction: "row",
        justify: "end",
        gap: "xsmall"
      },
      success: {
        color: "text-strong",
        weight: "bold",
        alignSelf: "end"
      }
    },
    // this is producing a console warning because it's not a supported status
    // proposing that notification should be more flexible to allow other statuses
    notification: {
      learn: {
        icon: import_Info.Info,
        background: {
          color: "status-warning",
          opacity: "weak"
        },
        color: "text",
        // global: {},
        toast: {
          background: "background-front"
        }
      }
    }
  });
  var { colors: colors3 } = aries.global;

  // app/javascript/components/themes/ContentArea.jsx
  var ContentArea = ({
    background = "background-front",
    border,
    children,
    icon,
    pad = "small",
    round: round2 = "xxsmall",
    title,
    ...rest
  }) => /* @__PURE__ */ import_react102.default.createElement(import_styled_components27.ThemeContext.Extend, { value: aries }, /* @__PURE__ */ import_react102.default.createElement(
    Box,
    {
      background,
      border: border === true ? { color: "border-strong", style: "dashed" } : border,
      flex: false,
      pad,
      round: round2,
      ...rest
    },
    icon ? /* @__PURE__ */ import_react102.default.createElement(Box, { align: "center", gap: "small", direction: "row" }, /* @__PURE__ */ import_react102.default.createElement(Hpe, { color: "brand" }), /* @__PURE__ */ import_react102.default.createElement(Text, { color: "text-strong", size: "small", weight: "bold" }, title)) : /* @__PURE__ */ import_react102.default.createElement(Text, { color: "text-strong", size: "small", weight: "bold" }, title),
    children
  ));
  ContentArea.propTypes = {
    background: import_prop_types43.default.oneOfType([import_prop_types43.default.string, import_prop_types43.default.object]),
    border: import_prop_types43.default.oneOfType([import_prop_types43.default.bool, import_prop_types43.default.object]),
    children: import_prop_types43.default.node,
    icon: import_prop_types43.default.bool,
    pad: import_prop_types43.default.oneOfType([
      import_prop_types43.default.string,
      import_prop_types43.default.shape({
        horizontal: import_prop_types43.default.string,
        vertical: import_prop_types43.default.string,
        top: import_prop_types43.default.string,
        right: import_prop_types43.default.string,
        bottom: import_prop_types43.default.string,
        left: import_prop_types43.default.string
      })
    ]),
    round: import_prop_types43.default.oneOfType([import_prop_types43.default.string, import_prop_types43.default.object]),
    title: import_prop_types43.default.oneOfType([import_prop_types43.default.string, import_prop_types43.default.node])
  };

  // app/javascript/components/general/Header.jsx
  var import_react104 = __toESM(require_react());
  var import_prop_types45 = __toESM(require_prop_types());

  // app/javascript/components/module/UserManagement.jsx
  var import_react103 = __toESM(require_react());
  var import_prop_types44 = __toESM(require_prop_types());
  var options = ["Name", "Email Address", "Employee Number", "All Users"];
  var LayerForm = (props) => {
    const [user_detail, setUserDetail] = (0, import_react103.useState)([]);
    const [role_list, setrole_list] = (0, import_react103.useState)([]);
    const [role_selected, setrole_selected] = (0, import_react103.useState)([]);
    const [loading, setLoading] = (0, import_react103.useState)(false);
    const [showForm, setshowForm] = (0, import_react103.useState)(false);
    const [form_errors, setform_errors] = (0, import_react103.useState)("");
    const [user_id, setuser_id] = (0, import_react103.useState)("");
    const [value, setValue3] = (0, import_react103.useState)("Name");
    (0, import_react103.useEffect)(() => {
      fetchData();
    }, []);
    const fetchData = () => {
      let csrf = document.querySelector("meta[name='csrf-token']").getAttribute("content");
      const post_set = {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-CSRF-Token": csrf }
      };
      setLoading(true);
      fetch("api/get_role_list", post_set).then((response) => response.json()).then((data) => {
        setrole_list(data);
        setLoading(false);
      }).catch((error2) => {
        console.log(error2);
        setLoading(false);
      });
    };
    const onSubmit_update = ({ value: value2, touched }) => {
      setform_errors("");
      let csrf = document.querySelector("meta[name='csrf-token']").getAttribute("content");
      const post_set = {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-CSRF-Token": csrf },
        body: JSON.stringify(value2)
      };
      setLoading(true);
      fetch("api/update_user", post_set).then((response) => response.json()).then((data) => {
        fetch_userData();
        setshowForm(false);
        setLoading(false);
      }).catch((error2) => {
        console.log(error2);
        setLoading(false);
      });
    };
    const onSubmit = ({ value: value2, touched }) => {
      setUserDetail([]);
      if (value2.search_text && value2.search_text.length >= 3 || value2.search_type == "All Users") {
        setform_errors("");
        let csrf = document.querySelector("meta[name='csrf-token']").getAttribute("content");
        const post_set = {
          method: "POST",
          headers: { "Content-Type": "application/json", "X-CSRF-Token": csrf },
          body: JSON.stringify(value2)
        };
        fetch_userData = () => {
          setLoading(true);
          fetch("api/search_user", post_set).then((response) => response.json()).then((data) => {
            setUserDetail(data);
            setshowForm(false);
            setLoading(false);
          }).catch((error2) => {
            console.log(error2);
            setLoading(false);
          });
        };
        fetch_userData();
      } else if (value2.search_text && value2.search_text.length < 3) {
        setform_errors("Please provide some more inputs");
      } else {
        setform_errors("Please provide some inputs");
      }
    };
    const size = (0, import_react103.useContext)(ResponsiveContext);
    const edit_user = (user_id2, roleids) => {
      setuser_id(user_id2);
      setrole_selected(roleids);
      setshowForm(true);
    };
    return /* @__PURE__ */ import_react103.default.createElement(Box, { gap: "medium" }, /* @__PURE__ */ import_react103.default.createElement(Button2, { alignSelf: "end", icon: /* @__PURE__ */ import_react103.default.createElement(Close, null), onClick: () => props.setOpen(false) }), /* @__PURE__ */ import_react103.default.createElement(Header, { alignSelf: "center", pad: { horizontal: "xxsmall" } }, /* @__PURE__ */ import_react103.default.createElement(Box, null, /* @__PURE__ */ import_react103.default.createElement(Heading, { level: 4, margin: "none", id: "layer-title" }, "Search User"))), /* @__PURE__ */ import_react103.default.createElement("div", { direction: "row" }, /* @__PURE__ */ import_react103.default.createElement(Form, { validate: "blur", method: "post", onSubmit: ({ value: value2, touched }) => onSubmit({ value: value2, touched }) }, /* @__PURE__ */ import_react103.default.createElement("div", { direction: "row", style: { marginTop: "10px" } }, /* @__PURE__ */ import_react103.default.createElement("div", { className: "col-md-9" }, /* @__PURE__ */ import_react103.default.createElement(FormField, { htmlFor: "search_text" }, /* @__PURE__ */ import_react103.default.createElement(Select, { id: "search_type", name: "search_type", options, value, onChange: ({ option }) => setValue3(option) }), /* @__PURE__ */ import_react103.default.createElement(TextInput, { id: "search_text", name: "search_text" }))), /* @__PURE__ */ import_react103.default.createElement("div", { className: "col-md-3" }, /* @__PURE__ */ import_react103.default.createElement(Box, { direction: "row", gap: "small", margin: "medium", className: "" }, /* @__PURE__ */ import_react103.default.createElement(Button2, { label: "Search", icon: /* @__PURE__ */ import_react103.default.createElement(Search2, { style: { width: 18 } }), secondary: true, type: "submit" }))), form_errors && /* @__PURE__ */ import_react103.default.createElement("div", { className: "col-md-12" }, /* @__PURE__ */ import_react103.default.createElement(Box, { direction: "row", align: "center", gap: "medium", margin: "medium", className: "mt-3 pt-3" }, /* @__PURE__ */ import_react103.default.createElement("span", { style: { margin: "auto", color: "#F00" } }, form_errors)))))), showForm == true && /* @__PURE__ */ import_react103.default.createElement("div", { direction: "row" }, /* @__PURE__ */ import_react103.default.createElement(Form, { validate: "blur", method: "post", onSubmit: ({ value: value2, touched }) => onSubmit_update({ value: value2, touched }) }, /* @__PURE__ */ import_react103.default.createElement(TextInput, { id: "user_id", type: "hidden", name: "user_id", value: user_id }), /* @__PURE__ */ import_react103.default.createElement("div", { direction: "row", style: { marginTop: "10px" } }, /* @__PURE__ */ import_react103.default.createElement(Box, { direction: "row", gap: "small", margin: "medium", className: "" }, /* @__PURE__ */ import_react103.default.createElement(FormField, { name: "user_role", fill: true, htmlFor: "user_roles", label: "User Role" }, /* @__PURE__ */ import_react103.default.createElement(CheckBoxGroup, { options: role_list, value: role_selected, name: "user_roles", id: "user_roles", onChange: ({ value: value2, option }) => {
      setrole_selected(value2);
    }, valueKey: "role_id", labelKey: "name" }))), /* @__PURE__ */ import_react103.default.createElement(Box, { direction: "row", gap: "small", margin: "medium", className: "" }, /* @__PURE__ */ import_react103.default.createElement(Button2, { label: "Update", secondary: true, type: "submit" }), /* @__PURE__ */ import_react103.default.createElement(Button2, { label: "Exit", onClick: () => setshowForm(false), secondary: true }))))), user_detail.length > 0 && /* @__PURE__ */ import_react103.default.createElement("table", { className: "table table-bordered table-sm" }, /* @__PURE__ */ import_react103.default.createElement("thead", null, /* @__PURE__ */ import_react103.default.createElement("tr", null, /* @__PURE__ */ import_react103.default.createElement("td", null, /* @__PURE__ */ import_react103.default.createElement("b", null, "Name")), /* @__PURE__ */ import_react103.default.createElement("td", null, /* @__PURE__ */ import_react103.default.createElement("b", null, "Email ")), /* @__PURE__ */ import_react103.default.createElement("td", null, /* @__PURE__ */ import_react103.default.createElement("b", null, "Emp No")), /* @__PURE__ */ import_react103.default.createElement("td", null, /* @__PURE__ */ import_react103.default.createElement("b", null, "Roles")), /* @__PURE__ */ import_react103.default.createElement("td", null, /* @__PURE__ */ import_react103.default.createElement("b", null, "Action")))), /* @__PURE__ */ import_react103.default.createElement("tbody", null, user_detail.map((sd) => {
      let roleids = sd.roles.map(function(rl) {
        return rl["id"];
      });
      return sd.id > 0 && /* @__PURE__ */ import_react103.default.createElement("tr", { key: "tr" + sd.id }, /* @__PURE__ */ import_react103.default.createElement("td", { id: "c" + sd.id, key: "c" + sd.id }, " ", sd.full_name), /* @__PURE__ */ import_react103.default.createElement("td", { id: "b" + sd.id, key: "b" + sd.id }, sd.email), /* @__PURE__ */ import_react103.default.createElement("td", { id: "a" + sd.id, key: "a" + sd.id }, " ", sd.emp_id), /* @__PURE__ */ import_react103.default.createElement("td", { id: "d" + sd.id, key: "d" + sd.id }, /* @__PURE__ */ import_react103.default.createElement("ul", { key: "ul" + sd.id, className: "list-group" }, sd.roles.map((rl) => /* @__PURE__ */ import_react103.default.createElement("li", { className: "list-group-item", id: "rl" + rl.id, key: "rl" + rl.id }, rl.name)))), /* @__PURE__ */ import_react103.default.createElement("td", { key: "e" + sd.id }, /* @__PURE__ */ import_react103.default.createElement(Button2, { key: "btn" + sd.id, icon: /* @__PURE__ */ import_react103.default.createElement(Edit, { style: { width: 18 } }), onClick: () => edit_user(sd.id, roleids), secondary: true })));
    }), user_detail.map((sd) => sd.id == 0 && /* @__PURE__ */ import_react103.default.createElement("tr", { key: "tr" + sd.id }, /* @__PURE__ */ import_react103.default.createElement("td", { className: "text-center", colspan: "5", key: "td" + sd.id }, " No records "))))));
  };
  LayerForm.propTypes = {
    setOpen: import_prop_types44.default.func.isRequired
  };
  var UserManagement = (props) => {
    const [open, setOpen] = (0, import_react103.useState)(false);
    const size = (0, import_react103.useContext)(ResponsiveContext);
    const onOpen = () => setOpen(true);
    const onClose = () => setOpen(void 0);
    const user2 = props.user;
    return /* @__PURE__ */ import_react103.default.createElement(import_react103.default.Fragment, null, /* @__PURE__ */ import_react103.default.createElement(Button2, { label: "User Management", onClick: onOpen, secondary: true }), open && /* @__PURE__ */ import_react103.default.createElement(Layer, { position: "right", full: !["xsmall", "small"].includes(size) ? "vertical" : true, onEsc: onClose }, /* @__PURE__ */ import_react103.default.createElement(Box, { fill: "vertical", overflow: "auto", width: !["xsmall", "small"].includes(size) ? "large" : void 0, pad: "medium" }, /* @__PURE__ */ import_react103.default.createElement(LayerForm, { user: user2, setOpen: (value) => setOpen(value) }))));
  };
  var UserManagement_default = UserManagement;

  // app/javascript/components/general/Header.jsx
  var PassParam = (props) => {
    const user2 = props.user;
    var roleids = [];
    if (user2) {
      roles = user2.roles;
      if (roles) {
        roleids = roles.map(function(rl) {
          return rl["id"];
        });
      }
    }
    const [open, setOpen] = (0, import_react104.useState)();
    const onOpen = () => {
      setOpen(true);
    };
    const onClose = () => {
      setOpen(false);
    };
    const DropContent = ({ onClose: onClose2 }) => /* @__PURE__ */ import_react104.default.createElement(Box, { pad: "medium", gap: "medium", width: "medium" }, /* @__PURE__ */ import_react104.default.createElement(Box, { direction: "row", justify: "between", align: "center" }, /* @__PURE__ */ import_react104.default.createElement(Heading, { level: 5, margin: "none" }, user2.full_name), /* @__PURE__ */ import_react104.default.createElement(Button2, { icon: /* @__PURE__ */ import_react104.default.createElement(FormClose3, null), onClick: onClose2 })), /* @__PURE__ */ import_react104.default.createElement(Box, { direction: "row", justify: "between", align: "center" }, /* @__PURE__ */ import_react104.default.createElement(Text, null, user2.email)), (roleids.includes(1) || roleids.includes(3)) && /* @__PURE__ */ import_react104.default.createElement(UserManagement_default, { user: user2 }));
    DropContent.propTypes = {
      onClose: import_prop_types45.default.func
    };
    return /* @__PURE__ */ import_react104.default.createElement(
      DropButton,
      {
        icon: /* @__PURE__ */ import_react104.default.createElement(User, null),
        open,
        onOpen,
        onClose,
        dropContent: /* @__PURE__ */ import_react104.default.createElement(DropContent, { onClose }),
        dropProps: { align: { top: "bottom", right: "right" } }
      }
    );
  };
  var HeaderExample = (props) => {
    const user2 = props.user;
    return /* @__PURE__ */ import_react104.default.createElement("div", { className: "hpehf-header" }, /* @__PURE__ */ import_react104.default.createElement(Header, { fill: "horizontal" }, /* @__PURE__ */ import_react104.default.createElement("a", { href: "/" }, /* @__PURE__ */ import_react104.default.createElement(Button2, null, /* @__PURE__ */ import_react104.default.createElement(
      Box,
      {
        direction: "row",
        align: "start",
        gap: "medium",
        pad: { vertical: "small" },
        responsive: false
      },
      /* @__PURE__ */ import_react104.default.createElement(Hpe, { color: "brand" }),
      /* @__PURE__ */ import_react104.default.createElement(Box, { direction: "row", gap: "small", wrap: true }, /* @__PURE__ */ import_react104.default.createElement(Text, { color: "text-strong", weight: "bold" }), /* @__PURE__ */ import_react104.default.createElement("img", { src: "rocket-logo.png", style: { width: "120px", marginTop: "-5px" }, alt: props.app_name }))
    ))), /* @__PURE__ */ import_react104.default.createElement(PassParam, { user: user2 })));
  };
  var Header_default = HeaderExample;

  // app/javascript/components/general/Footer.jsx
  var import_react105 = __toESM(require_react());
  var footer_margin = { margintop: 100 };
  var FooterExample = (props) => {
    const user2 = props.user;
    const size = (0, import_react105.useContext)(ResponsiveContext);
    return /* @__PURE__ */ import_react105.default.createElement(
      Footer,
      {
        background: "background-front",
        direction: !["xsmall", "small"].includes(size) ? "row" : "column",
        align: !["xsmall", "small"].includes(size) ? "center" : void 0,
        pad: { horizontal: "medium", vertical: "small" },
        fill: "horizontal",
        style: footer_margin
      },
      /* @__PURE__ */ import_react105.default.createElement(
        Box,
        {
          direction: !["xsmall", "small"].includes(size) ? "row" : "column",
          align: !["xsmall", "small"].includes(size) ? "center" : void 0,
          gap: "xsmall"
        },
        /* @__PURE__ */ import_react105.default.createElement(Text, { size: "small" }, "\xA9 2023 Hewlett Packard Enterprise Development LP")
      ),
      /* @__PURE__ */ import_react105.default.createElement(
        Box,
        {
          direction: "row",
          align: !["xsmall", "small"].includes(size) ? "center" : void 0,
          gap: "xsmall",
          wrap: true
        }
      )
    );
  };
  var Footer_default = FooterExample;

  // app/javascript/components/Home.jsx
  var import_react168 = __toESM(require_react());
  var import_jquery = __toESM(require_jquery());

  // app/javascript/components/module/RulesList.jsx
  var import_react167 = __toESM(require_react());

  // app/javascript/components/module/EditRule.jsx
  var import_react165 = __toESM(require_react());
  var import_prop_types68 = __toESM(require_prop_types());

  // app/javascript/components/module/QueryBuilder.jsx
  var import_react164 = __toESM(require_react());

  // node_modules/@babel/runtime/helpers/esm/classCallCheck.js
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  // node_modules/@babel/runtime/helpers/esm/typeof.js
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }

  // node_modules/@babel/runtime/helpers/esm/toPrimitive.js
  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }

  // node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }

  // node_modules/@babel/runtime/helpers/esm/createClass.js
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  // node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }

  // node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }

  // node_modules/@babel/runtime/helpers/esm/inherits.js
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass)
      _setPrototypeOf(subClass, superClass);
  }

  // node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
  function _possibleConstructorReturn(self2, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self2);
  }

  // node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }

  // node_modules/@react-awesome-query-builder/ui/esm/components/QueryContainer.js
  var import_react116 = __toESM(require_react());

  // node_modules/@react-awesome-query-builder/core/modules/export/index.js
  var export_exports2 = {};
  __export(export_exports2, {
    _mongodbFormat: () => _mongodbFormat,
    _spelFormat: () => _spelFormat,
    _sqlFormat: () => _sqlFormat,
    elasticSearchFormat: () => elasticSearchFormat,
    jsonLogicFormat: () => jsonLogicFormat,
    mongodbFormat: () => mongodbFormat,
    queryBuilderFormat: () => queryBuilderFormat,
    queryString: () => queryString,
    spelFormat: () => spelFormat,
    sqlFormat: () => sqlFormat
  });

  // node_modules/@react-awesome-query-builder/core/modules/utils/stuff.js
  var import_immutable = __toESM(require_immutable());
  var defaultValue3 = (value, _default) => {
    return typeof value === "undefined" ? _default : value;
  };
  var deepEqual = function(v1, v2) {
    if (v1 === v2) {
      return true;
    } else if (import_immutable.Map.isMap(v1)) {
      return v1.equals(v2);
    } else {
      return JSON.stringify(v1) == JSON.stringify(v2);
    }
  };
  var shallowEqual = (a, b, deep = false) => {
    if (a === b) {
      return true;
    } else if (Array.isArray(a))
      return shallowEqualArrays(a, b, deep);
    else if (import_immutable.Map.isMap(a))
      return a.equals(b);
    else if (typeof a == "object")
      return shallowEqualObjects(a, b, deep);
    else
      return a === b;
  };
  function shallowEqualArrays(arrA, arrB, deep = false) {
    if (arrA === arrB) {
      return true;
    }
    if (!arrA || !arrB) {
      return false;
    }
    var len = arrA.length;
    if (arrB.length !== len) {
      return false;
    }
    for (var i = 0; i < len; i++) {
      var isEqual = deep ? shallowEqual(arrA[i], arrB[i], deep) : arrA[i] === arrB[i];
      if (!isEqual) {
        return false;
      }
    }
    return true;
  }
  function shallowEqualObjects(objA, objB, deep = false) {
    if (objA === objB) {
      return true;
    }
    if (!objA || !objB) {
      return false;
    }
    var aKeys = Object.keys(objA);
    var bKeys = Object.keys(objB);
    var len = aKeys.length;
    if (bKeys.length !== len) {
      return false;
    }
    for (var i = 0; i < len; i++) {
      var key = aKeys[i];
      var isEqual = deep ? shallowEqual(objA[key], objB[key], deep) : objA[key] === objB[key];
      if (!isEqual) {
        return false;
      }
    }
    return true;
  }
  var isImmutable = (v) => {
    return typeof v === "object" && v !== null && typeof v.toJS === "function";
  };
  function toImmutableList(v) {
    return isImmutable(v) ? v : new import_immutable.default.List(v);
  }
  function applyToJS(v) {
    return isImmutable(v) ? v.toJS() : v;
  }
  var escapeRegExp3 = (string) => {
    return string.replace(/[.*+?^${}()|[\]\\/]/g, "\\$&");
  };
  var isJsonLogic = (logic) => typeof logic === "object" && logic !== null && !Array.isArray(logic) && Object.keys(logic).length === 1;
  function sleep(delay) {
    return new Promise((resolve) => {
      setTimeout(resolve, delay);
    });
  }
  function mergeArraysSmart(arr1, arr2) {
    if (!arr1)
      arr1 = [];
    if (!arr2)
      arr2 = [];
    return arr2.map((op) => [op, arr1.indexOf(op)]).map(([op, ind], i, orig) => {
      if (ind == -1) {
        const next = orig.slice(i + 1);
        const prev = orig.slice(0, i);
        const after = prev.reverse().find(([_cop, ci]) => ci != -1);
        const before = next.find(([_cop, ci]) => ci != -1);
        if (before)
          return [op, "before", before[0]];
        else if (after)
          return [op, "after", after[0]];
        else
          return [op, "append", null];
      } else {
        return null;
      }
    }).filter((x) => x !== null).reduce((acc, [newOp, rel, relOp]) => {
      const ind = acc.indexOf(relOp);
      if (acc.indexOf(newOp) == -1) {
        if (ind > -1) {
          acc.splice(ind + (rel == "after" ? 1 : 0), 0, newOp);
        } else {
          acc.splice(rel == "append" ? Infinity : 0, 0, newOp);
        }
      }
      return acc;
    }, arr1.slice());
  }
  var isDev = () => typeof process !== "undefined" && process.env && true;
  var getLogger = (devMode = false) => {
    const verbose = devMode != void 0 ? devMode : isDev();
    return verbose ? console : {
      error: () => {
      },
      log: () => {
      },
      warn: () => {
      },
      debug: () => {
      },
      info: () => {
      }
    };
  };
  var getFirstDefined = (arr = []) => {
    let ret;
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i];
      if (v !== void 0) {
        ret = v;
        break;
      }
    }
    return ret;
  };
  var logger = getLogger();

  // node_modules/@react-awesome-query-builder/core/modules/utils/configUtils.js
  var configUtils_exports = {};
  __export(configUtils_exports, {
    extendConfig: () => extendConfig,
    getFieldConfig: () => getFieldConfig,
    getFieldRawConfig: () => getFieldRawConfig,
    getFieldWidgetConfig: () => getFieldWidgetConfig,
    getFuncArgConfig: () => getFuncArgConfig,
    getFuncConfig: () => getFuncConfig,
    getOperatorConfig: () => getOperatorConfig,
    normalizeField: () => normalizeField
  });
  var import_merge = __toESM(require_merge());

  // node_modules/@react-awesome-query-builder/core/modules/utils/uuid.js
  var query_builder_seed = 0;
  var uuid_default = () => {
    const timePart = ((/* @__PURE__ */ new Date()).getTime().toString(16) + "FF").substr(0, 11);
    const s = "ssssssss-xxxx-4xxx-yxxx-x".replace(/[xys]/g, (c) => {
      const r = c === "s" ? Math.floor(Math.random() * 16) : query_builder_seed++ & 15;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
    return s + timePart;
  };

  // node_modules/@react-awesome-query-builder/core/modules/utils/configUtils.js
  var import_mergeWith = __toESM(require_mergeWith());

  // node_modules/@react-awesome-query-builder/core/modules/config/default.js
  var settings = {
    formatField: (field, parts2, label2, fieldDefinition, config2, isForDisplay) => {
      if (isForDisplay)
        return label2;
      else
        return field;
    },
    valueSourcesInfo: {
      value: {}
    },
    fieldSeparator: ".",
    fieldSeparatorDisplay: ".",
    canReorder: true,
    canRegroup: true,
    canDeleteLocked: false,
    canLeaveEmptyGroup: true,
    shouldCreateEmptyGroup: false,
    canShortMongoQuery: true,
    removeEmptyGroupsOnLoad: true,
    removeIncompleteRulesOnLoad: true,
    removeInvalidMultiSelectValuesOnLoad: true,
    setOpOnChangeField: ["keep", "default"],
    // 'default' (default if present), 'keep' (keep prev from last field), 'first', 'none'
    groupOperators: ["some", "all", "none"],
    defaultGroupConjunction: "AND",
    // localization
    locale: {
      moment: "en"
    },
    valueLabel: "Value",
    valuePlaceholder: "Value",
    fieldLabel: "Field",
    operatorLabel: "Operator",
    funcLabel: "Function",
    fieldPlaceholder: "Select field",
    funcPlaceholder: "Select function",
    operatorPlaceholder: "Select operator",
    lockLabel: "Lock",
    lockedLabel: "Locked",
    deleteLabel: null,
    addGroupLabel: "Add group",
    addCaseLabel: "Add condition",
    addDefaultCaseLabel: "Add default condition",
    defaultCaseLabel: "Default:",
    addRuleLabel: "Add rule",
    addSubRuleLabel: "Add sub rule",
    delGroupLabel: "",
    notLabel: "Not",
    valueSourcesPopupTitle: "Select value source",
    removeRuleConfirmOptions: null,
    removeGroupConfirmOptions: null
  };

  // node_modules/@react-awesome-query-builder/core/modules/utils/configUtils.js
  var import_moment = __toESM(require_moment());

  // node_modules/@react-awesome-query-builder/core/modules/utils/ruleUtils.js
  var ruleUtils_exports = {};
  __export(ruleUtils_exports, {
    filterValueSourcesForField: () => filterValueSourcesForField,
    formatFieldName: () => formatFieldName,
    getFieldPartsConfigs: () => getFieldPartsConfigs,
    getFieldPath: () => getFieldPath,
    getFieldPathLabels: () => getFieldPathLabels,
    getFirstField: () => getFirstField,
    getFirstOperator: () => getFirstOperator,
    getFuncPathLabels: () => getFuncPathLabels,
    getNewValueForFieldOp: () => getNewValueForFieldOp,
    getOperatorsForField: () => getOperatorsForField,
    getValueLabel: () => getValueLabel,
    getValueSourcesForFieldOp: () => getValueSourcesForFieldOp,
    getWidgetForFieldOp: () => getWidgetForFieldOp,
    getWidgetsForFieldOp: () => getWidgetsForFieldOp
  });
  var import_immutable5 = __toESM(require_immutable());

  // node_modules/@react-awesome-query-builder/core/modules/utils/listValues.js
  var listValues_exports = {};
  __export(listValues_exports, {
    getItemInListValues: () => getItemInListValues,
    getTitleInListValues: () => getTitleInListValues,
    getValueInListValues: () => getValueInListValues,
    listValuesToArray: () => listValuesToArray,
    mapListValues: () => mapListValues
  });
  var isObject5 = (v) => typeof v == "object" && v !== null;
  var listValue = (v, title) => isObject5(v) ? v : { value: v, title: title !== void 0 ? title : v };
  var listValuesToArray = (listValuesObj) => {
    if (!isObject5(listValuesObj))
      return listValuesObj;
    if (Array.isArray(listValuesObj))
      return listValuesObj.map((v) => listValue(v));
    let listValuesArr = [];
    for (let v in listValuesObj) {
      const title = listValuesObj[v];
      listValuesArr.push(listValue(v, title));
    }
    return listValuesArr;
  };
  var getItemInListValues = (listValues, value) => {
    if (Array.isArray(listValues)) {
      const values = listValues.map((v) => listValue(v));
      return values.find((v) => v.value === value) || values.find((v) => `${v.value}` === value);
    } else {
      return listValues[value] !== void 0 ? listValue(value, listValues[value]) : void 0;
    }
  };
  var getTitleInListValues = (listValues, value) => {
    if (listValues == void 0)
      return value;
    const it = getItemInListValues(listValues, value);
    return it !== void 0 ? it.title : value;
  };
  var getValueInListValues = (listValues, value) => {
    if (listValues == void 0)
      return value;
    const it = getItemInListValues(listValues, value);
    return it !== void 0 ? it.value : value;
  };
  var mapListValues = (listValues, mapFn) => {
    let ret = [];
    if (Array.isArray(listValues)) {
      for (let v of listValues) {
        const lv = mapFn(listValue(v));
        if (lv != null)
          ret.push(lv);
      }
    } else {
      for (let value in listValues) {
        const lv = mapFn(listValue(value, listValues[value]));
        if (lv != null)
          ret.push(lv);
      }
    }
    return ret;
  };

  // node_modules/@react-awesome-query-builder/core/modules/utils/defaultUtils.js
  var defaultUtils_exports = {};
  __export(defaultUtils_exports, {
    createListFromArray: () => createListFromArray,
    defaultConjunction: () => defaultConjunction,
    defaultField: () => defaultField,
    defaultGroupConjunction: () => defaultGroupConjunction,
    defaultGroupProperties: () => defaultGroupProperties,
    defaultItemProperties: () => defaultItemProperties,
    defaultOperator: () => defaultOperator,
    defaultOperatorOptions: () => defaultOperatorOptions,
    defaultRoot: () => defaultRoot,
    defaultRule: () => defaultRule,
    defaultRuleProperties: () => defaultRuleProperties,
    emptyProperies: () => emptyProperies
  });
  var import_immutable2 = __toESM(require_immutable());
  var defaultField = (config2, canGetFirst = true, parentRuleGroupPath = null) => {
    return typeof config2.settings.defaultField === "function" ? config2.settings.defaultField(parentRuleGroupPath) : config2.settings.defaultField || (canGetFirst ? getFirstField(config2, parentRuleGroupPath) : null);
  };
  var defaultOperator = (config2, field, canGetFirst = true) => {
    let fieldConfig = getFieldConfig(config2, field);
    let fieldOperators = fieldConfig && fieldConfig.operators || [];
    let fieldDefaultOperator = fieldConfig && fieldConfig.defaultOperator;
    if (!fieldOperators.includes(fieldDefaultOperator))
      fieldDefaultOperator = null;
    if (!fieldDefaultOperator && canGetFirst)
      fieldDefaultOperator = getFirstOperator(config2, field);
    let op = typeof config2.settings.defaultOperator === "function" ? config2.settings.defaultOperator(field, fieldConfig) : fieldDefaultOperator;
    return op;
  };
  var defaultOperatorOptions = (config2, operator, field) => {
    let operatorConfig = operator ? getOperatorConfig(config2, operator, field) : null;
    if (!operatorConfig)
      return null;
    return operatorConfig.options ? new import_immutable2.default.Map(
      operatorConfig.options && operatorConfig.options.defaults || {}
    ) : null;
  };
  var defaultRuleProperties = (config2, parentRuleGroupPath = null, item = null) => {
    let field = null, operator = null;
    const { setDefaultFieldAndOp, showErrorMessage } = config2.settings;
    if (item) {
      field = item?.properties?.field;
      operator = item?.properties?.operator;
    } else if (setDefaultFieldAndOp) {
      field = defaultField(config2, true, parentRuleGroupPath);
      operator = defaultOperator(config2, field);
    }
    let current = new import_immutable2.default.Map({
      field,
      operator,
      value: new import_immutable2.default.List(),
      valueSrc: new import_immutable2.default.List(),
      //used for complex operators like proximity
      operatorOptions: defaultOperatorOptions(config2, operator, field)
    });
    if (showErrorMessage) {
      current = current.set("valueError", new import_immutable2.default.List());
    }
    if (field && operator) {
      let { newValue, newValueSrc, newValueType, newValueError } = getNewValueForFieldOp(
        config2,
        config2,
        current,
        field,
        operator,
        "operator",
        false
      );
      current = current.set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType);
      if (showErrorMessage) {
        current = current.set("valueError", newValueError);
      }
    }
    return current;
  };
  var defaultGroupConjunction = (config2, fieldConfig = null) => {
    fieldConfig = getFieldConfig(config2, fieldConfig);
    const conjs = fieldConfig && fieldConfig.conjunctions || Object.keys(config2.conjunctions);
    if (conjs.length == 1)
      return conjs[0];
    return config2.settings.defaultGroupConjunction || config2.settings.defaultConjunction || conjs[0];
  };
  var defaultConjunction = (config2) => config2.settings.defaultConjunction || Object.keys(config2.conjunctions)[0];
  var defaultGroupProperties = (config2, fieldConfig = null) => new import_immutable2.default.Map({
    conjunction: defaultGroupConjunction(config2, fieldConfig),
    not: false
  });
  var defaultItemProperties = (config2, item) => {
    return item && item.type == "group" ? defaultGroupProperties(config2, item?.properties?.field) : defaultRuleProperties(config2, null, item);
  };
  var defaultRule = (id, config2) => ({
    [id]: new import_immutable2.default.Map({
      type: "rule",
      id,
      properties: defaultRuleProperties(config2)
    })
  });
  var defaultRoot = (config2) => {
    return new import_immutable2.default.Map({
      type: "group",
      id: uuid_default(),
      children1: new import_immutable2.default.OrderedMap({ ...defaultRule(uuid_default(), config2) }),
      properties: defaultGroupProperties(config2)
    });
  };
  var createListFromArray = (ids) => {
    return new import_immutable2.default.List(ids);
  };
  var emptyProperies = () => new import_immutable2.default.Map();

  // node_modules/@react-awesome-query-builder/core/modules/utils/treeUtils.js
  var treeUtils_exports = {};
  __export(treeUtils_exports, {
    expandTreePath: () => expandTreePath,
    expandTreeSubpath: () => expandTreeSubpath,
    fixEmptyGroupsInTree: () => fixEmptyGroupsInTree,
    fixPathsInTree: () => fixPathsInTree,
    getFlatTree: () => getFlatTree,
    getItemByPath: () => getItemByPath,
    getLightTree: () => getLightTree,
    getSwitchValues: () => getSwitchValues,
    getTotalReordableNodesCountInTree: () => getTotalReordableNodesCountInTree,
    getTotalRulesCountInTree: () => getTotalRulesCountInTree,
    getTreeBadFields: () => getTreeBadFields,
    hasChildren: () => hasChildren,
    isEmptyTree: () => isEmptyTree,
    removeIsLockedInTree: () => removeIsLockedInTree,
    removePathsInTree: () => removePathsInTree
  });
  var import_immutable3 = __toESM(require_immutable());
  var expandTreePath = (path, ...suffix) => path.interpose("children1").withMutations((list) => {
    list.skip(1);
    list.push.apply(list, suffix);
    return list;
  });
  var expandTreeSubpath = (path, ...suffix) => path.interpose("children1").withMutations((list) => {
    list.push.apply(list, suffix);
    return list;
  });
  var getItemByPath = (tree2, path) => {
    let children = new import_immutable3.default.OrderedMap({ [tree2.get("id")]: tree2 });
    let res = tree2;
    path.forEach((id) => {
      res = children.get(id);
      children = res.get("children1");
    });
    return res;
  };
  var removePathsInTree = (tree2) => {
    let newTree = tree2;
    function _processNode(item, path) {
      const itemPath = path.push(item.get("id"));
      if (item.get("path")) {
        newTree = newTree.removeIn(expandTreePath(itemPath, "path"));
      }
      const children = item.get("children1");
      if (children) {
        children.map((child, _childId) => {
          _processNode(child, itemPath);
        });
      }
    }
    _processNode(tree2, new import_immutable3.default.List());
    return newTree;
  };
  var removeIsLockedInTree = (tree2) => {
    let newTree = tree2;
    function _processNode(item, path, isParentLocked = false) {
      const itemPath = path.push(item.get("id"));
      const isLocked = item.getIn(["properties", "isLocked"]);
      if (isParentLocked && isLocked) {
        newTree = newTree.deleteIn(expandTreePath(itemPath, "properties", "isLocked"));
      }
      const children = item.get("children1");
      if (children) {
        children.map((child, _childId) => {
          _processNode(child, itemPath, isLocked || isParentLocked);
        });
      }
    }
    _processNode(tree2, new import_immutable3.default.List());
    return newTree;
  };
  var fixPathsInTree = (tree2) => {
    let newTree = tree2;
    function _processNode(item, path, lev, nodeId) {
      if (!item)
        return;
      const currPath = item.get("path");
      const currId = item.get("id");
      const itemId = currId || nodeId;
      const itemPath = path.push(itemId);
      if (!currPath || !currPath.equals(itemPath)) {
        newTree = newTree.setIn(expandTreePath(itemPath, "path"), itemPath);
      }
      if (!currId) {
        newTree = newTree.setIn(expandTreePath(itemPath, "id"), itemId);
      }
      const children = item.get("children1");
      if (children) {
        if (children.constructor.name == "Map") {
          newTree = newTree.setIn(
            expandTreePath(itemPath, "children1"),
            new import_immutable3.default.OrderedMap(children)
          );
        }
        children.map((child, childId) => {
          _processNode(child, itemPath, lev + 1, childId);
        });
      }
    }
    _processNode(tree2, new import_immutable3.default.List(), 0);
    return newTree;
  };
  var fixEmptyGroupsInTree = (tree2) => {
    let newTree = tree2;
    function _processNode(item, path, lev, nodeId) {
      if (!item)
        return false;
      const itemId = item.get("id") || nodeId;
      const itemPath = path.push(itemId);
      const children = item.get("children1");
      if (children) {
        const allChildrenGone = children.map((child, childId) => {
          return _processNode(child, itemPath, lev + 1, childId);
        }).reduce((curr, v) => curr && v, true);
        if ((children.size == 0 || allChildrenGone) && lev > 0) {
          newTree = newTree.deleteIn(expandTreePath(itemPath));
          return true;
        }
      }
      return false;
    }
    _processNode(tree2, new import_immutable3.default.List(), 0);
    return newTree;
  };
  var getFlatTree = (tree2) => {
    let flat = [];
    let items = {};
    let realHeight = 0;
    function _flatizeTree(item, path, insideCollapsed, insideLocked, insideRuleGroup, lev, info, parentType, caseId) {
      const type = item.get("type");
      const collapsed = item.get("collapsed");
      const id = item.get("id");
      const children = item.get("children1");
      const isLocked = item.getIn(["properties", "isLocked"]);
      const childrenIds = children ? children.map((_child, childId) => childId) : null;
      const isRuleGroup = type == "rule_group";
      const isLeaf = !insideRuleGroup && (!children || isRuleGroup);
      const itemsBefore = flat.length;
      const top2 = realHeight;
      flat.push(id);
      if (!insideCollapsed)
        realHeight += 1;
      info.height = (info.height || 0) + 1;
      items[id] = {
        type,
        parent: path.length ? path[path.length - 1] : null,
        parentType,
        caseId: type == "case_group" ? id : caseId,
        isDefaultCase: type == "case_group" && !children,
        path: path.concat(id),
        lev,
        leaf: !children,
        index: itemsBefore,
        id,
        children: childrenIds,
        leafsCount: 0,
        _top: itemsBefore,
        //_height: (itemsAfter - itemsBefore),
        top: insideCollapsed ? null : top2,
        //height: height,
        //bottom: (insideCollapsed ? null : top) + height,
        collapsed,
        node: item,
        isLocked: isLocked || insideLocked
      };
      if (children) {
        let subinfo = {};
        children.map((child, _childId) => {
          _flatizeTree(
            child,
            path.concat(id),
            insideCollapsed || collapsed,
            insideLocked || isLocked,
            insideRuleGroup || isRuleGroup,
            lev + 1,
            subinfo,
            type,
            type == "case_group" ? id : caseId
          );
        });
        if (!collapsed) {
          info.height = (info.height || 0) + (subinfo.height || 0);
        }
      }
      if (caseId && isLeaf) {
        items[caseId].leafsCount++;
      }
      const itemsAfter = flat.length;
      const _bottom = realHeight;
      const height = info.height;
      Object.assign(items[id], {
        _height: itemsAfter - itemsBefore,
        height,
        bottom: (insideCollapsed ? null : top2) + height
      });
    }
    _flatizeTree(tree2, [], false, false, false, 0, {}, null, null);
    for (let i = 0; i < flat.length; i++) {
      const prevId = i > 0 ? flat[i - 1] : null;
      const nextId = i < flat.length - 1 ? flat[i + 1] : null;
      let item = items[flat[i]];
      item.prev = prevId;
      item.next = nextId;
    }
    return { flat, items };
  };
  var getTotalReordableNodesCountInTree = (tree2) => {
    if (!tree2)
      return -1;
    let cnt = 0;
    function _processNode(item, path, lev) {
      let id, children, type;
      if (typeof item.get === "function") {
        id = item.get("id");
        children = item.get("children1");
        type = item.get("type");
      } else {
        id = item.id;
        children = item.children1;
        type = item.type;
      }
      const isRuleGroup = type == "rule_group";
      cnt++;
      if (children && !isRuleGroup) {
        children.map((child, _childId) => {
          _processNode(child, path.concat(id), lev + 1);
        });
      }
    }
    _processNode(tree2, [], 0);
    return cnt - 1;
  };
  var getTotalRulesCountInTree = (tree2) => {
    if (!tree2)
      return -1;
    let cnt = 0;
    function _processNode(item, path, lev) {
      let id, children, type;
      if (typeof item.get === "function") {
        id = item.get("id");
        children = item.get("children1");
        type = item.get("type");
      } else {
        id = item.id;
        children = item.children1;
        type = item.type;
      }
      if (type == "rule" || type == "rule_group") {
        cnt++;
      } else if (children) {
        children.map((child, _childId) => {
          _processNode(child, path.concat(id), lev + 1);
        });
      }
    }
    _processNode(tree2, [], 0);
    return cnt;
  };
  var getTreeBadFields = (tree2) => {
    let badFields = [];
    function _processNode(item, path, lev) {
      const id = item.get("id");
      const children = item.get("children1");
      const valueError = item.getIn(["properties", "valueError"]);
      const field = item.getIn(["properties", "field"]);
      if (valueError && valueError.size > 0 && valueError.filter((v) => v != null).size > 0) {
        badFields.push(field);
      }
      if (children) {
        children.map((child, _childId) => {
          _processNode(child, path.concat(id), lev + 1);
        });
      }
    }
    if (tree2)
      _processNode(tree2, [], 0);
    return Array.from(new Set(badFields));
  };
  var getLightTree = (tree2, children1AsArray = false) => {
    let newTree = tree2;
    function _processNode(item, itemId) {
      if (item.path)
        delete item.path;
      if (!children1AsArray && itemId)
        delete item.id;
      let properties = item.properties;
      if (properties) {
        if (properties.operatorOptions == null)
          delete properties.operatorOptions;
      }
      const children = item.children1;
      if (children) {
        for (let id in children) {
          _processNode(children[id], id);
        }
        if (children1AsArray) {
          item.children1 = Object.values(children);
        }
      }
    }
    _processNode(tree2, null);
    return newTree;
  };
  var getSwitchValues = (tree2) => {
    let vals = [];
    const children = tree2.get("children1");
    if (children) {
      children.map((child) => {
        const value = child.getIn(["properties", "value"]);
        let caseValue;
        if (value && value.size == 1) {
          caseValue = value.get(0);
          if (Array.isArray(caseValue) && caseValue.length == 0) {
            caseValue = null;
          }
        } else {
          caseValue = null;
        }
        vals = [...vals, caseValue];
      });
    }
    return vals;
  };
  var isEmptyTree = (tree2) => !tree2.get("children1") || tree2.get("children1").size == 0;
  var hasChildren = (tree2, path) => tree2.getIn(expandTreePath(path, "children1")).size > 0;

  // node_modules/@react-awesome-query-builder/core/modules/utils/validation.js
  var import_omit = __toESM(require_omit());
  var import_immutable4 = __toESM(require_immutable());
  var typeOf = (v) => {
    if (typeof v == "object" && v !== null && Array.isArray(v))
      return "array";
    else
      return typeof v;
  };
  var isTypeOf = (v, type) => {
    if (typeOf(v) == type)
      return true;
    if (type == "number" && !isNaN(v))
      return true;
    return false;
  };
  var validateAndFixTree = (newTree, _oldTree, newConfig, oldConfig) => {
    let tree2 = validateTree(newTree, _oldTree, newConfig, oldConfig);
    tree2 = fixPathsInTree(tree2);
    return tree2;
  };
  var validateTree = (tree2, _oldTree, config2, oldConfig, removeEmptyGroups, removeIncompleteRules) => {
    if (removeEmptyGroups === void 0) {
      removeEmptyGroups = config2.settings.removeEmptyGroupsOnLoad;
    }
    if (removeIncompleteRules === void 0) {
      removeIncompleteRules = config2.settings.removeIncompleteRulesOnLoad;
    }
    const c = {
      config: config2,
      oldConfig,
      removeEmptyGroups,
      removeIncompleteRules
    };
    return validateItem(tree2, [], null, {}, c);
  };
  function validateItem(item, path, itemId, meta, c) {
    const type = item.get("type");
    const children = item.get("children1");
    if ((type === "group" || type === "rule_group" || type == "case_group" || type == "switch_group") && children && children.size) {
      return validateGroup(item, path, itemId, meta, c);
    } else if (type === "rule") {
      return validateRule(item, path, itemId, meta, c);
    } else {
      return item;
    }
  }
  function validateGroup(item, path, itemId, meta, c) {
    const { removeEmptyGroups } = c;
    let id = item.get("id");
    let children = item.get("children1");
    const oldChildren = children;
    if (!id && itemId) {
      id = itemId;
      item = item.set("id", id);
      meta.sanitized = true;
    }
    let submeta = {};
    children = children.map((currentChild, childId) => validateItem(currentChild, path.concat(id), childId, submeta, c));
    if (removeEmptyGroups)
      children = children.filter((currentChild) => currentChild != void 0);
    let sanitized = submeta.sanitized || oldChildren.size != children.size;
    if (!children.size && removeEmptyGroups && path.length) {
      sanitized = true;
      item = void 0;
    }
    if (sanitized)
      meta.sanitized = true;
    if (sanitized && item)
      item = item.set("children1", children);
    return item;
  }
  function validateRule(item, path, itemId, meta, c) {
    const { removeIncompleteRules, config: config2, oldConfig } = c;
    const { showErrorMessage } = config2.settings;
    let id = item.get("id");
    let properties = item.get("properties");
    let field = properties.get("field") || null;
    let operator = properties.get("operator") || null;
    let operatorOptions = properties.get("operatorOptions");
    let valueSrc = properties.get("valueSrc");
    let value = properties.get("value");
    let valueError = properties.get("valueError");
    const oldSerialized = {
      field,
      operator,
      operatorOptions: operatorOptions ? operatorOptions.toJS() : {},
      valueSrc: valueSrc ? valueSrc.toJS() : null,
      value: value ? value.toJS() : null,
      valueError: valueError ? valueError.toJS() : null
    };
    let _wasValid = field && operator && value && !value.includes(void 0);
    if (!id && itemId) {
      id = itemId;
      item = item.set("id", id);
      meta.sanitized = true;
    }
    const fieldDefinition = field ? getFieldConfig(config2, field) : null;
    if (field && !fieldDefinition) {
      logger.warn(`No config for field ${field}`);
      field = null;
    }
    if (field == null) {
      properties = ["operator", "operatorOptions", "valueSrc", "value"].reduce((map, key) => map.delete(key), properties);
      operator = null;
    }
    if (operator == "range_between" || operator == "range_not_between") {
      operator = operator == "range_between" ? "between" : "not_between";
      console.info(`Fixed operator ${properties.get("operator")} to ${operator}`);
      properties = properties.set("operator", operator);
    }
    const operatorDefinition = operator ? getOperatorConfig(config2, operator, field) : null;
    if (operator && !operatorDefinition) {
      console.warn(`No config for operator ${operator}`);
      operator = null;
    }
    const availOps = field ? getOperatorsForField(config2, field) : [];
    if (!availOps) {
      console.warn(`Type of field ${field} is not supported`);
      operator = null;
    } else if (operator && availOps.indexOf(operator) == -1) {
      if (operator == "is_empty" || operator == "is_not_empty") {
        operator = operator == "is_empty" ? "is_null" : "is_not_null";
        console.info(`Fixed operator ${properties.get("operator")} to ${operator} for ${field}`);
        properties = properties.set("operator", operator);
      } else {
        console.warn(`Operator ${operator} is not supported for field ${field}`);
        operator = null;
      }
    }
    if (operator == null) {
      properties = properties.delete("operatorOptions");
      properties = properties.delete("valueSrc");
      properties = properties.delete("value");
    }
    operatorOptions = properties.get("operatorOptions");
    let _operatorCardinality = operator ? defaultValue3(operatorDefinition.cardinality, 1) : null;
    if (!operator || operatorOptions && !operatorDefinition.options) {
      operatorOptions = null;
      properties = properties.delete("operatorOptions");
    } else if (operator && !operatorOptions && operatorDefinition.options) {
      operatorOptions = defaultOperatorOptions(config2, operator, field);
      properties = properties.set("operatorOptions", operatorOptions);
    }
    valueSrc = properties.get("valueSrc");
    value = properties.get("value");
    const canFix = !showErrorMessage;
    const isEndValue = true;
    let { newValue, newValueSrc, newValueError } = getNewValueForFieldOp(config2, oldConfig, properties, field, operator, null, canFix, isEndValue);
    value = newValue;
    valueSrc = newValueSrc;
    valueError = newValueError;
    properties = properties.set("value", value);
    properties = properties.set("valueSrc", valueSrc);
    if (showErrorMessage) {
      properties = properties.set("valueError", valueError);
    }
    const newSerialized = {
      field,
      operator,
      operatorOptions: operatorOptions ? operatorOptions.toJS() : {},
      valueSrc: valueSrc ? valueSrc.toJS() : null,
      value: value ? value.toJS() : null,
      valueError: valueError ? valueError.toJS() : null
    };
    const sanitized = !deepEqual(oldSerialized, newSerialized);
    const isComplete = field && operator && value && !value.includes(void 0);
    if (sanitized)
      meta.sanitized = true;
    if (!isComplete && removeIncompleteRules)
      item = void 0;
    else if (sanitized)
      item = item.set("properties", properties);
    return item;
  }
  var validateValue = (config2, leftField, field, operator, value, valueType, valueSrc, asyncListValues, canFix = false, isEndValue = false, isRawValue = true) => {
    let validError = null;
    let fixedValue = value;
    if (value != null) {
      if (valueSrc == "field") {
        [validError, fixedValue] = validateFieldValue(leftField, field, value, valueSrc, valueType, asyncListValues, config2, operator, isEndValue, canFix);
      } else if (valueSrc == "func") {
        [validError, fixedValue] = validateFuncValue(leftField, field, value, valueSrc, valueType, asyncListValues, config2, operator, isEndValue, canFix);
      } else if (valueSrc == "value" || !valueSrc) {
        [validError, fixedValue] = validateNormalValue(leftField, field, value, valueSrc, valueType, asyncListValues, config2, operator, isEndValue, canFix);
      }
      if (!validError) {
        const fieldConfig = getFieldConfig(config2, field);
        const w = getWidgetForFieldOp(config2, field, operator, valueSrc);
        const operatorDefinition = operator ? getOperatorConfig(config2, operator, field) : null;
        const fieldWidgetDefinition = (0, import_omit.default)(getFieldWidgetConfig(config2, field, operator, w, valueSrc), ["factory"]);
        const rightFieldDefinition = valueSrc == "field" ? getFieldConfig(config2, value) : null;
        const fieldSettings = fieldWidgetDefinition;
        const fn2 = fieldWidgetDefinition.validateValue;
        if (typeof fn2 == "function") {
          const args = [
            fixedValue,
            fieldSettings,
            operator,
            operatorDefinition
          ];
          if (valueSrc == "field")
            args.push(rightFieldDefinition);
          const validResult = fn2(...args);
          if (typeof validResult == "boolean") {
            if (validResult == false)
              validError = "Invalid value";
          } else {
            validError = validResult;
          }
        }
      }
    }
    if (isRawValue && validError) {
      console.warn("[RAQB validate]", `Field ${field}: ${validError}`);
    }
    return [validError, fixedValue];
  };
  var validateValueInList = (value, listValues, canFix, isEndValue, removeInvalidMultiSelectValuesOnLoad) => {
    const values = import_immutable4.List.isList(value) ? value.toJS() : value instanceof Array ? [...value] : void 0;
    if (values) {
      const [goodValues, badValues] = values.reduce(([goodVals, badVals], val) => {
        const vv = getItemInListValues(listValues, val);
        if (vv == void 0) {
          return [goodVals, [...badVals, val]];
        } else {
          return [[...goodVals, vv.value], badVals];
        }
      }, [[], []]);
      const plural = badValues.length > 1;
      const err = badValues.length ? `${plural ? "Values" : "Value"} ${badValues.join(", ")} ${plural ? "are" : "is"} not in list of values` : null;
      if (removeInvalidMultiSelectValuesOnLoad !== void 0) {
        canFix = removeInvalidMultiSelectValuesOnLoad;
      } else {
        canFix = canFix || isEndValue;
      }
      return [err, canFix ? goodValues : value];
    } else {
      const vv = getItemInListValues(listValues, value);
      if (vv == void 0) {
        return [`Value ${value} is not in list of values`, value];
      } else {
        value = vv.value;
      }
      return [null, value];
    }
  };
  var validateNormalValue = (leftField, field, value, valueSrc, valueType, asyncListValues, config2, operator = null, isEndValue = false, canFix = false) => {
    if (field) {
      const fieldConfig = getFieldConfig(config2, field);
      const w = getWidgetForFieldOp(config2, field, operator, valueSrc);
      const wConfig = config2.widgets[w];
      const wType = wConfig.type;
      const jsType = wConfig.jsType;
      const fieldSettings = fieldConfig.fieldSettings;
      if (valueType && valueType != wType)
        return [`Value should have type ${wType}, but got value of type ${valueType}`, value];
      if (jsType && !isTypeOf(value, jsType) && !fieldSettings.listValues) {
        return [`Value should have JS type ${jsType}, but got value of type ${typeof value}`, value];
      }
      if (fieldSettings) {
        const listValues = asyncListValues || fieldSettings.listValues;
        if (listValues && !fieldSettings.allowCustomValues) {
          return validateValueInList(value, listValues, canFix, isEndValue, config2.settings.removeInvalidMultiSelectValuesOnLoad);
        }
        if (fieldSettings.min != null && value < fieldSettings.min) {
          return [`Value ${value} < min ${fieldSettings.min}`, canFix ? fieldSettings.min : value];
        }
        if (fieldSettings.max != null && value > fieldSettings.max) {
          return [`Value ${value} > max ${fieldSettings.max}`, canFix ? fieldSettings.max : value];
        }
      }
    }
    return [null, value];
  };
  var validateFieldValue = (leftField, field, value, _valueSrc, valueType, asyncListValues, config2, operator = null, isEndValue = false, canFix = false) => {
    const { fieldSeparator } = config2.settings;
    const isFuncArg = typeof field == "object" && field?._isFuncArg;
    const leftFieldStr = Array.isArray(leftField) ? leftField.join(fieldSeparator) : leftField;
    const rightFieldStr = Array.isArray(value) ? value.join(fieldSeparator) : value;
    const rightFieldDefinition = getFieldConfig(config2, value);
    if (!rightFieldDefinition)
      return [`Unknown field ${value}`, value];
    if (rightFieldStr == leftFieldStr && !isFuncArg)
      return [`Can't compare field ${leftField} with itself`, value];
    if (valueType && valueType != rightFieldDefinition.type)
      return [`Field ${value} is of type ${rightFieldDefinition.type}, but expected ${valueType}`, value];
    return [null, value];
  };
  var validateFuncValue = (leftField, field, value, _valueSrc, valueType, asyncListValues, config2, operator = null, isEndValue = false, canFix = false) => {
    let fixedValue = value;
    if (value) {
      const funcKey = value.get("func");
      if (funcKey) {
        const funcConfig = getFuncConfig(config2, funcKey);
        if (funcConfig) {
          if (valueType && funcConfig.returnType != valueType)
            return [`Function ${funcKey} should return value of type ${funcConfig.returnType}, but got ${valueType}`, value];
          for (const argKey in funcConfig.args) {
            const argConfig = funcConfig.args[argKey];
            const args = fixedValue.get("args");
            const argVal = args ? args.get(argKey) : void 0;
            const fieldDef = getFieldConfig(config2, argConfig);
            const argValue = argVal ? argVal.get("value") : void 0;
            const argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
            if (argValue !== void 0) {
              const [argValidError, fixedArgVal] = validateValue(
                config2,
                leftField,
                fieldDef,
                operator,
                argValue,
                argConfig.type,
                argValueSrc,
                asyncListValues,
                canFix,
                isEndValue,
                false
              );
              if (argValidError !== null) {
                if (canFix) {
                  fixedValue = fixedValue.deleteIn(["args", argKey]);
                  if (argConfig.defaultValue !== void 0) {
                    fixedValue = fixedValue.setIn(["args", argKey, "value"], argConfig.defaultValue);
                    fixedValue = fixedValue.setIn(["args", argKey, "valueSrc"], "value");
                  }
                } else {
                  return [`Invalid value of arg ${argKey} for func ${funcKey}: ${argValidError}`, value];
                }
              } else if (fixedArgVal !== argValue) {
                fixedValue = fixedValue.setIn(["args", argKey, "value"], fixedArgVal);
              }
            } else if (isEndValue && argConfig.defaultValue === void 0 && !canFix) {
              return [`Value of arg ${argKey} for func ${funcKey} is required`, value];
            }
          }
        } else
          return [`Unknown function ${funcKey}`, value];
      }
    }
    return [null, fixedValue];
  };

  // node_modules/@react-awesome-query-builder/core/modules/utils/ruleUtils.js
  var import_last = __toESM(require_last());
  var selectTypes = [
    "select",
    "multiselect",
    "treeselect",
    "treemultiselect"
  ];
  var getNewValueForFieldOp = function(config2, oldConfig = null, current, newField, newOperator, changedProp = null, canFix = true, isEndValue = false) {
    if (!oldConfig)
      oldConfig = config2;
    const currentField = current.get("field");
    const currentOperator = current.get("operator");
    const currentValue = current.get("value");
    const currentValueSrc = current.get("valueSrc", new import_immutable5.default.List());
    const currentValueType = current.get("valueType", new import_immutable5.default.List());
    const currentAsyncListValues = current.get("asyncListValues");
    const { convertableWidgets, clearValueOnChangeField, clearValueOnChangeOp, showErrorMessage } = config2.settings;
    const newOperatorConfig = getOperatorConfig(config2, newOperator, newField);
    const operatorCardinality = newOperator ? defaultValue3(newOperatorConfig.cardinality, 1) : null;
    const currentFieldConfig = getFieldConfig(oldConfig, currentField);
    const newFieldConfig = getFieldConfig(config2, newField);
    let canReuseValue = currentField && currentOperator && newOperator && currentValue != void 0 && (!changedProp || changedProp == "field" && !clearValueOnChangeField || changedProp == "operator" && !clearValueOnChangeOp) && (currentFieldConfig && newFieldConfig && currentFieldConfig.type == newFieldConfig.type);
    if (canReuseValue && selectTypes.includes(currentFieldConfig.type) && changedProp == "field") {
      canReuseValue = false;
    }
    for (let i = 0; i < operatorCardinality; i++) {
      const vs = currentValueSrc.get(i) || null;
      const currentWidget = getWidgetForFieldOp(oldConfig, currentField, currentOperator, vs);
      const newWidget = getWidgetForFieldOp(config2, newField, newOperator, vs);
      const currentValueWidget = vs == "value" ? currentWidget : getWidgetForFieldOp(oldConfig, currentField, currentOperator, "value");
      const newValueWidget = vs == "value" ? newWidget : getWidgetForFieldOp(config2, newField, newOperator, "value");
      const canReuseWidget = newValueWidget == currentValueWidget || (convertableWidgets[currentValueWidget] || []).includes(newValueWidget);
      if (!canReuseWidget)
        canReuseValue = false;
    }
    if (currentOperator != newOperator && [currentOperator, newOperator].includes("proximity"))
      canReuseValue = false;
    const firstWidgetConfig = getFieldWidgetConfig(config2, newField, newOperator, null, currentValueSrc.first());
    const valueSources = getValueSourcesForFieldOp(config2, newField, newOperator);
    let valueFixes = {};
    let valueErrors = Array.from({ length: operatorCardinality }, () => null);
    if (canReuseValue) {
      for (let i = 0; i < operatorCardinality; i++) {
        const v = currentValue.get(i);
        const vType = currentValueType.get(i) || null;
        const vSrc = currentValueSrc.get(i) || null;
        let isValidSrc = valueSources.find((v2) => v2 == vSrc) != null;
        if (!isValidSrc && i > 0 && vSrc == null)
          isValidSrc = true;
        const asyncListValues = currentAsyncListValues;
        const [validateError, fixedValue] = validateValue(
          config2,
          newField,
          newField,
          newOperator,
          v,
          vType,
          vSrc,
          asyncListValues,
          canFix,
          isEndValue
        );
        const isValid = !validateError;
        const fixValue = fixedValue !== v;
        const dropValue = !isValidSrc || !isValid && (changedProp == "field" || !showErrorMessage && !fixValue);
        const showValueError = !!validateError && showErrorMessage && !dropValue && !fixValue;
        if (showValueError) {
          valueErrors[i] = validateError;
        }
        if (fixValue) {
          valueFixes[i] = fixedValue;
        }
        if (dropValue) {
          canReuseValue = false;
          break;
        }
      }
    }
    let newValue = null, newValueSrc = null, newValueType = null, newValueError = null;
    newValue = new import_immutable5.default.List(Array.from({ length: operatorCardinality }, (_ignore, i) => {
      let v = void 0;
      if (canReuseValue) {
        if (i < currentValue.size) {
          v = currentValue.get(i);
          if (valueFixes[i] !== void 0) {
            v = valueFixes[i];
          }
        }
      } else if (operatorCardinality == 1) {
        v = getFirstDefined([
          newFieldConfig?.defaultValue,
          newFieldConfig?.fieldSettings?.defaultValue,
          firstWidgetConfig?.defaultValue
        ]);
      }
      return v;
    }));
    newValueSrc = new import_immutable5.default.List(Array.from({ length: operatorCardinality }, (_ignore, i) => {
      let vs = null;
      if (canReuseValue) {
        if (i < currentValueSrc.size)
          vs = currentValueSrc.get(i);
      } else if (valueSources.length == 1) {
        vs = valueSources[0];
      } else if (valueSources.length > 1) {
        vs = valueSources[0];
      }
      return vs;
    }));
    if (showErrorMessage) {
      if (newOperatorConfig && newOperatorConfig.validateValues && newValueSrc.toJS().filter((vs) => vs == "value" || vs == null).length == operatorCardinality) {
        const jsValues = firstWidgetConfig && firstWidgetConfig.toJS ? newValue.toJS().map((v) => firstWidgetConfig.toJS(v, firstWidgetConfig)) : newValue.toJS();
        const rangeValidateError = newOperatorConfig.validateValues(jsValues);
        if (showErrorMessage) {
          valueErrors.push(rangeValidateError);
        }
      }
      newValueError = new import_immutable5.default.List(valueErrors);
    }
    newValueType = new import_immutable5.default.List(Array.from({ length: operatorCardinality }, (_ignore, i) => {
      let vt = null;
      if (canReuseValue) {
        if (i < currentValueType.size)
          vt = currentValueType.get(i);
      } else if (operatorCardinality == 1 && firstWidgetConfig && firstWidgetConfig.type !== void 0) {
        vt = firstWidgetConfig.type;
      } else if (operatorCardinality == 1 && newFieldConfig && newFieldConfig.type !== void 0) {
        vt = newFieldConfig.type == "!group" ? "number" : newFieldConfig.type;
      }
      return vt;
    }));
    return { canReuseValue, newValue, newValueSrc, newValueType, newValueError, operatorCardinality };
  };
  var getFirstField = (config2, parentRuleGroupPath = null) => {
    const fieldSeparator = config2.settings.fieldSeparator;
    const parentPathArr = typeof parentRuleGroupPath == "string" ? parentRuleGroupPath.split(fieldSeparator) : parentRuleGroupPath;
    const parentField = parentRuleGroupPath ? getFieldRawConfig(config2, parentRuleGroupPath) : config2;
    let firstField = parentField, key = null, keysPath = [];
    do {
      const subfields = firstField === config2 ? config2.fields : firstField.subfields;
      if (!subfields || !Object.keys(subfields).length) {
        firstField = key = null;
        break;
      }
      key = Object.keys(subfields)[0];
      keysPath.push(key);
      firstField = subfields[key];
    } while (firstField.type == "!struct" || firstField.type == "!group");
    return (parentPathArr || []).concat(keysPath).join(fieldSeparator);
  };
  var getOperatorsForField = (config2, field) => {
    const fieldConfig = getFieldConfig(config2, field);
    const fieldOps = fieldConfig ? fieldConfig.operators : [];
    return fieldOps;
  };
  var getFirstOperator = (config2, field) => {
    const fieldOps = getOperatorsForField(config2, field);
    return fieldOps ? fieldOps[0] : null;
  };
  var getFieldPath = (field, config2, onlyKeys = false) => {
    if (!field)
      return null;
    const fieldSeparator = config2.settings.fieldSeparator;
    const parts2 = Array.isArray(field) ? field : field.split(fieldSeparator);
    if (onlyKeys)
      return parts2;
    else
      return parts2.map((_curr, ind, arr) => arr.slice(0, ind + 1)).map((parts3) => parts3.join(fieldSeparator));
  };
  var getFuncPathLabels = (field, config2, parentField = null) => {
    return getFieldPathLabels(field, config2, parentField, "funcs", "subfields");
  };
  var getFieldPathLabels = (field, config2, parentField = null, fieldsKey = "fields", subfieldsKey = "subfields") => {
    if (!field)
      return null;
    const fieldSeparator = config2.settings.fieldSeparator;
    const parts2 = Array.isArray(field) ? field : field.split(fieldSeparator);
    const parentParts = parentField ? Array.isArray(parentField) ? parentField : parentField.split(fieldSeparator) : [];
    return parts2.slice(parentParts.length).map((_curr, ind, arr) => arr.slice(0, ind + 1)).map((parts3) => [...parentParts, ...parts3].join(fieldSeparator)).map((part) => {
      const cnf = getFieldRawConfig(config2, part, fieldsKey, subfieldsKey);
      return cnf && cnf.label || cnf && (0, import_last.default)(part.split(fieldSeparator));
    }).filter((label) => label != null);
  };
  var getFieldPartsConfigs = (field, config2, parentField = null) => {
    if (!field)
      return null;
    const parentFieldDef = parentField && getFieldRawConfig(config2, parentField) || null;
    const fieldSeparator = config2.settings.fieldSeparator;
    const parts2 = Array.isArray(field) ? field : field.split(fieldSeparator);
    const parentParts = parentField ? Array.isArray(parentField) ? parentField : parentField.split(fieldSeparator) : [];
    return parts2.slice(parentParts.length).map((_curr, ind, arr) => arr.slice(0, ind + 1)).map((parts3) => ({
      part: [...parentParts, ...parts3].join(fieldSeparator),
      key: parts3[parts3.length - 1]
    })).map(({ part, key }) => {
      const cnf = getFieldRawConfig(config2, part);
      return { key, cnf };
    }).map(({ key, cnf }, ind, arr) => {
      const parentCnf = ind > 0 ? arr[ind - 1].cnf : parentFieldDef;
      return [key, cnf, parentCnf];
    });
  };
  var getValueLabel = (config2, field, operator, delta, valueSrc = null, isSpecialRange = false) => {
    const isFuncArg = field && typeof field == "object" && !!field.func && !!field.arg;
    const { showLabels } = config2.settings;
    const fieldConfig = getFieldConfig(config2, field);
    const fieldWidgetConfig = getFieldWidgetConfig(config2, field, operator, null, valueSrc) || {};
    const mergedOpConfig = getOperatorConfig(config2, operator, field) || {};
    const cardinality = isSpecialRange ? 1 : mergedOpConfig.cardinality;
    let ret = null;
    if (cardinality > 1) {
      const valueLabels = fieldWidgetConfig.valueLabels || mergedOpConfig.valueLabels;
      if (valueLabels)
        ret = valueLabels[delta];
      if (ret && typeof ret != "object") {
        ret = { label: ret, placeholder: ret };
      }
      if (!ret) {
        ret = {
          label: config2.settings.valueLabel + " " + (delta + 1),
          placeholder: config2.settings.valuePlaceholder + " " + (delta + 1)
        };
      }
    } else {
      let label = fieldWidgetConfig.valueLabel;
      let placeholder = fieldWidgetConfig.valuePlaceholder;
      if (isFuncArg) {
        if (!label)
          label = fieldConfig.label || field.arg;
        if (!placeholder && !showLabels)
          placeholder = fieldConfig.label || field.arg;
      }
      ret = {
        label: label || config2.settings.valueLabel,
        placeholder: placeholder || config2.settings.valuePlaceholder
      };
    }
    return ret;
  };
  function _getWidgetsAndSrcsForFieldOp(config2, field, operator = null, valueSrc = null) {
    let widgets3 = [];
    let valueSrcs = [];
    if (!field)
      return { widgets: widgets3, valueSrcs };
    const isFuncArg = typeof field == "object" && (!!field.func && !!field.arg || field._isFuncArg);
    const fieldConfig = getFieldConfig(config2, field);
    const opConfig = operator ? config2.operators[operator] : null;
    if (fieldConfig && fieldConfig.widgets) {
      for (const widget in fieldConfig.widgets) {
        const widgetConfig = fieldConfig.widgets[widget];
        const widgetValueSrc = config2.widgets[widget].valueSrc || "value";
        let canAdd = true;
        if (widget == "field") {
          canAdd = canAdd && filterValueSourcesForField(config2, ["field"], fieldConfig).length > 0;
        }
        if (widget == "func") {
          canAdd = canAdd && filterValueSourcesForField(config2, ["func"], fieldConfig).length > 0;
        }
        if (valueSrc == "value" && !widgetConfig.operators && !isFuncArg && field != "!case_value")
          canAdd = false;
        if (widgetConfig.operators && operator)
          canAdd = canAdd && widgetConfig.operators.indexOf(operator) != -1;
        if (valueSrc && valueSrc != widgetValueSrc && valueSrc != "const")
          canAdd = false;
        if (opConfig && opConfig.cardinality == 0 && widgetValueSrc != "value")
          canAdd = false;
        if (canAdd) {
          widgets3.push(widget);
          let canAddValueSrc = fieldConfig.valueSources && fieldConfig.valueSources.indexOf(widgetValueSrc) != -1;
          if (opConfig && opConfig.valueSources && opConfig.valueSources.indexOf(widgetValueSrc) == -1)
            canAddValueSrc = false;
          if (canAddValueSrc && !valueSrcs.find((v) => v == widgetValueSrc))
            valueSrcs.push(widgetValueSrc);
        }
      }
    }
    const widgetWeight = (w) => {
      let wg = 0;
      if (fieldConfig.preferWidgets) {
        if (fieldConfig.preferWidgets.includes(w))
          wg += 10 - fieldConfig.preferWidgets.indexOf(w);
      } else if (w == fieldConfig.mainWidget) {
        wg += 100;
      }
      if (w == "field") {
        wg -= 1;
      }
      if (w == "func") {
        wg -= 2;
      }
      return wg;
    };
    widgets3.sort((w1, w2) => widgetWeight(w2) - widgetWeight(w1));
    return { widgets: widgets3, valueSrcs };
  }
  var getWidgetsForFieldOp = (config2, field, operator, valueSrc = null) => {
    const { widgets: widgets3 } = _getWidgetsAndSrcsForFieldOp(config2, field, operator, valueSrc);
    return widgets3;
  };
  var filterValueSourcesForField = (config2, valueSrcs, fieldDefinition) => {
    if (!fieldDefinition)
      return valueSrcs;
    return valueSrcs.filter((vs) => {
      let canAdd = true;
      if (vs == "field") {
        if (config2._fieldsCntByType) {
          const minCnt = fieldDefinition._isFuncArg ? 0 : 1;
          canAdd = canAdd && config2._fieldsCntByType[fieldDefinition.type] > minCnt;
        }
      }
      if (vs == "func") {
        if (config2._funcsCntByType)
          canAdd = canAdd && !!config2._funcsCntByType[fieldDefinition.type];
        if (fieldDefinition.funcs)
          canAdd = canAdd && fieldDefinition.funcs.length > 0;
      }
      return canAdd;
    });
  };
  var getValueSourcesForFieldOp = (config2, field, operator, fieldDefinition = null, leftFieldForFunc = null) => {
    const { valueSrcs } = _getWidgetsAndSrcsForFieldOp(config2, field, operator, null);
    const filteredValueSrcs = filterValueSourcesForField(config2, valueSrcs, fieldDefinition);
    return filteredValueSrcs;
  };
  var getWidgetForFieldOp = (config2, field, operator, valueSrc = null) => {
    const { widgets: widgets3 } = _getWidgetsAndSrcsForFieldOp(config2, field, operator, valueSrc);
    let widget = null;
    if (widgets3.length)
      widget = widgets3[0];
    return widget;
  };
  var formatFieldName = (field, config2, meta, parentField = null) => {
    if (!field)
      return;
    const fieldDef = getFieldConfig(config2, field) || {};
    const { fieldSeparator } = config2.settings;
    const fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);
    let fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field;
    if (fieldDef.tableName) {
      const fieldPartsCopy = [...fieldParts];
      fieldPartsCopy[0] = fieldDef.tableName;
      fieldName = fieldPartsCopy.join(fieldSeparator);
    }
    if (fieldDef.fieldName) {
      fieldName = fieldDef.fieldName;
    }
    if (parentField) {
      const parentFieldDef = getFieldConfig(config2, parentField) || {};
      let parentFieldName = parentField;
      if (parentFieldDef.fieldName) {
        parentFieldName = parentFieldDef.fieldName;
      }
      if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {
        fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);
      } else {
        meta.errors.push(`Can't cut group ${parentFieldName} from field ${fieldName}`);
      }
    }
    return fieldName;
  };

  // node_modules/@react-awesome-query-builder/core/modules/utils/configUtils.js
  var import_clone = __toESM(require_clone());
  var extendConfig = (config2, configId) => {
    if (config2.__configId) {
      return config2;
    }
    config2 = { ...config2 };
    config2.settings = (0, import_merge.default)({}, settings, config2.settings);
    config2._fieldsCntByType = {};
    config2._funcsCntByType = {};
    config2.types = (0, import_clone.default)(config2.types);
    _extendTypesConfig(config2.types, config2);
    config2.fields = (0, import_clone.default)(config2.fields);
    config2.__fieldNames = {};
    _extendFieldsConfig(config2.fields, config2);
    config2.funcs = (0, import_clone.default)(config2.funcs);
    _extendFuncArgsConfig(config2.funcs, config2);
    import_moment.default.locale(config2.settings.locale.moment);
    Object.defineProperty(config2, "__configId", {
      enumerable: false,
      writable: false,
      value: configId || uuid_default()
    });
    return config2;
  };
  function _extendTypesConfig(typesConfig, config2) {
    for (let type in typesConfig) {
      let typeConfig = typesConfig[type];
      _extendTypeConfig(type, typeConfig, config2);
    }
  }
  function _extendTypeConfig(type, typeConfig, config2) {
    let operators3 = null, defaultOperator2 = null;
    typeConfig.mainWidget = typeConfig.mainWidget || Object.keys(typeConfig.widgets).filter((w) => w != "field" && w != "func")[0];
    for (let widget in typeConfig.widgets) {
      let typeWidgetConfig = typeConfig.widgets[widget];
      if (typeWidgetConfig.operators) {
        let typeWidgetOperators = typeWidgetConfig.operators;
        if (typeConfig.excludeOperators) {
          typeWidgetOperators = typeWidgetOperators.filter((op) => !typeConfig.excludeOperators.includes(op));
        }
        operators3 = mergeArraysSmart(operators3, typeWidgetOperators);
      }
      if (typeWidgetConfig.defaultOperator)
        defaultOperator2 = typeWidgetConfig.defaultOperator;
      if (widget == typeConfig.mainWidget) {
        typeWidgetConfig = (0, import_merge.default)({}, { widgetProps: typeConfig.mainWidgetProps || {} }, typeWidgetConfig);
      }
      typeConfig.widgets[widget] = typeWidgetConfig;
    }
    if (!typeConfig.valueSources)
      typeConfig.valueSources = Object.keys(config2.settings.valueSourcesInfo);
    for (let valueSrc of typeConfig.valueSources) {
      if (valueSrc != "value" && !typeConfig.widgets[valueSrc]) {
        typeConfig.widgets[valueSrc] = {};
      }
    }
    if (!typeConfig.operators && operators3)
      typeConfig.operators = Array.from(new Set(operators3));
    if (!typeConfig.defaultOperator && defaultOperator2)
      typeConfig.defaultOperator = defaultOperator2;
  }
  function _extendFieldsConfig(subconfig, config2, path = []) {
    for (let field in subconfig) {
      _extendFieldConfig(subconfig[field], config2, [...path, field]);
      if (subconfig[field].subfields) {
        _extendFieldsConfig(subconfig[field].subfields, config2, [...path, field]);
      }
    }
  }
  function _extendFuncArgsConfig(subconfig, config2) {
    if (!subconfig)
      return;
    for (let funcKey in subconfig) {
      const funcDef = subconfig[funcKey];
      if (funcDef.returnType) {
        if (!config2._funcsCntByType[funcDef.returnType])
          config2._funcsCntByType[funcDef.returnType] = 0;
        config2._funcsCntByType[funcDef.returnType]++;
      }
      for (let argKey in funcDef.args) {
        _extendFieldConfig(funcDef.args[argKey], config2, null, true);
      }
      if (funcDef.args) {
        const argKeys = Object.keys(funcDef.args);
        let tmpIsOptional = true;
        for (const argKey of argKeys.reverse()) {
          const argDef = funcDef.args[argKey];
          if (!tmpIsOptional && argDef.isOptional) {
            delete argDef.isOptional;
          }
          if (!argDef.isOptional)
            tmpIsOptional = false;
        }
      }
      if (funcDef.subfields) {
        _extendFuncArgsConfig(funcDef.subfields, config2);
      }
    }
  }
  function _extendFieldConfig(fieldConfig, config2, path = null, isFuncArg = false) {
    let operators3 = null, defaultOperator2 = null;
    const typeConfig = config2.types[fieldConfig.type];
    const excludeOperatorsForField = fieldConfig.excludeOperators || [];
    if (fieldConfig.type != "!struct" && fieldConfig.type != "!group") {
      const keysToPutInFieldSettings = ["listValues", "allowCustomValues", "validateValue"];
      if (!fieldConfig.fieldSettings)
        fieldConfig.fieldSettings = {};
      for (const k of keysToPutInFieldSettings) {
        if (fieldConfig[k]) {
          fieldConfig.fieldSettings[k] = fieldConfig[k];
          delete fieldConfig[k];
        }
      }
      if (fieldConfig.fieldSettings.listValues) {
        if (config2.settings.normalizeListValues) {
          fieldConfig.fieldSettings.listValues = config2.settings.normalizeListValues(
            fieldConfig.fieldSettings.listValues,
            fieldConfig.type,
            fieldConfig.fieldSettings
          );
        }
      }
      if (!typeConfig) {
        fieldConfig.disabled = true;
        return;
      }
      if (!isFuncArg) {
        if (!config2._fieldsCntByType[fieldConfig.type])
          config2._fieldsCntByType[fieldConfig.type] = 0;
        config2._fieldsCntByType[fieldConfig.type]++;
      }
      if (!fieldConfig.widgets)
        fieldConfig.widgets = {};
      if (isFuncArg)
        fieldConfig._isFuncArg = true;
      fieldConfig.mainWidget = fieldConfig.mainWidget || typeConfig.mainWidget;
      fieldConfig.valueSources = fieldConfig.valueSources || typeConfig.valueSources;
      const excludeOperatorsForType = typeConfig.excludeOperators || [];
      for (let widget in typeConfig.widgets) {
        let fieldWidgetConfig = fieldConfig.widgets[widget] || {};
        const typeWidgetConfig = typeConfig.widgets[widget] || {};
        if (!isFuncArg) {
          const excludeOperators = [...excludeOperatorsForField, ...excludeOperatorsForType];
          const shouldIncludeOperators = fieldConfig.preferWidgets && (widget == "field" || fieldConfig.preferWidgets.includes(widget)) || excludeOperators.length > 0;
          if (fieldWidgetConfig.operators) {
            const addOperators = fieldWidgetConfig.operators.filter((o) => !excludeOperators.includes(o));
            operators3 = [...operators3 || [], ...addOperators];
          } else if (shouldIncludeOperators && typeWidgetConfig.operators) {
            const addOperators = typeWidgetConfig.operators.filter((o) => !excludeOperators.includes(o));
            operators3 = [...operators3 || [], ...addOperators];
          }
          if (fieldWidgetConfig.defaultOperator)
            defaultOperator2 = fieldWidgetConfig.defaultOperator;
        }
        if (widget == fieldConfig.mainWidget) {
          fieldWidgetConfig = (0, import_merge.default)({}, { widgetProps: fieldConfig.mainWidgetProps || {} }, fieldWidgetConfig);
        }
        fieldConfig.widgets[widget] = fieldWidgetConfig;
      }
      if (!isFuncArg) {
        if (!fieldConfig.operators && operators3)
          fieldConfig.operators = Array.from(new Set(operators3));
        if (!fieldConfig.defaultOperator && defaultOperator2)
          fieldConfig.defaultOperator = defaultOperator2;
      }
    }
    const computedFieldName = computeFieldName(config2, path);
    if (computedFieldName) {
      fieldConfig.fieldName = computedFieldName;
    }
    if (path && fieldConfig.fieldName) {
      config2.__fieldNames[fieldConfig.fieldName] = path;
    }
  }
  var getFieldRawConfig = (config2, field, fieldsKey = "fields", subfieldsKey = "subfields") => {
    if (!field)
      return null;
    if (field == "!case_value") {
      return {
        type: "case_value",
        mainWidget: "case_value",
        widgets: {
          "case_value": config2.widgets["case_value"]
        }
      };
    }
    const fieldSeparator = config2.settings.fieldSeparator;
    const parts2 = Array.isArray(field) ? field : field.split(fieldSeparator);
    const targetFields = config2[fieldsKey];
    if (!targetFields)
      return null;
    let fields = targetFields;
    let fieldConfig = null;
    let path = [];
    for (let i = 0; i < parts2.length; i++) {
      const part = parts2[i];
      path.push(part);
      const pathKey = path.join(fieldSeparator);
      fieldConfig = fields[pathKey];
      if (i < parts2.length - 1) {
        if (fieldConfig && fieldConfig[subfieldsKey]) {
          fields = fieldConfig[subfieldsKey];
          path = [];
        } else {
          fieldConfig = null;
        }
      }
    }
    return fieldConfig;
  };
  var computeFieldName = (config2, path) => {
    if (!path)
      return null;
    const fieldSeparator = config2.settings.fieldSeparator;
    let l = [...path], r = [], f, fConfig;
    while ((f = l.pop()) !== void 0 && l.length > 0) {
      r.unshift(f);
      fConfig = getFieldRawConfig(config2, l);
      if (fConfig.fieldName) {
        return [fConfig.fieldName, ...r].join(fieldSeparator);
      }
    }
    return null;
  };
  var normalizeField = (config2, field) => {
    const fieldSeparator = config2.settings.fieldSeparator;
    const fieldStr = Array.isArray(field) ? field.join(fieldSeparator) : field;
    if (config2.__fieldNames[fieldStr]) {
      return config2.__fieldNames[fieldStr].join(fieldSeparator);
    }
    return fieldStr;
  };
  var getFuncConfig = (config2, func) => {
    if (!func)
      return null;
    const funcConfig = getFieldRawConfig(config2, func, "funcs", "subfields");
    if (!funcConfig)
      return null;
    return funcConfig;
  };
  var getFuncArgConfig = (config2, funcKey, argKey) => {
    const funcConfig = getFuncConfig(config2, funcKey);
    if (!funcConfig)
      return null;
    const argConfig = funcConfig.args && funcConfig.args[argKey] || null;
    if (!argConfig)
      return null;
    const typeConfig = config2.types[argConfig.type] || {};
    let ret = (0, import_mergeWith.default)({}, typeConfig, argConfig || {}, (objValue, srcValue, _key, _object, _source, _stack) => {
      if (Array.isArray(objValue)) {
        return srcValue;
      }
    });
    return ret;
  };
  var getFieldConfig = (config2, field) => {
    if (!field)
      return null;
    if (typeof field == "object" && !field.func && !!field.type)
      return field;
    if (typeof field == "object" && field.func && field.arg)
      return getFuncArgConfig(config2, field.func, field.arg);
    const fieldConfig = getFieldRawConfig(config2, field);
    if (!fieldConfig)
      return null;
    const typeConfig = config2.types[fieldConfig.type] || {};
    let ret = (0, import_mergeWith.default)({}, typeConfig, fieldConfig || {}, (objValue, srcValue, _key, _object, _source, _stack) => {
      if (Array.isArray(objValue)) {
        return srcValue;
      }
    });
    return ret;
  };
  var getOperatorConfig = (config2, operator, field = null) => {
    if (!operator)
      return null;
    const opConfig = config2.operators[operator];
    if (field) {
      const fieldConfig = getFieldConfig(config2, field);
      const widget = getWidgetForFieldOp(config2, field, operator);
      const widgetConfig = config2.widgets[widget] || {};
      const fieldWidgetConfig = (fieldConfig && fieldConfig.widgets ? fieldConfig.widgets[widget] : {}) || {};
      const widgetOpProps = (widgetConfig.opProps || {})[operator];
      const fieldWidgetOpProps = (fieldWidgetConfig.opProps || {})[operator];
      const mergedOpConfig = (0, import_merge.default)({}, opConfig, widgetOpProps, fieldWidgetOpProps);
      return mergedOpConfig;
    } else {
      return opConfig;
    }
  };
  var getFieldWidgetConfig = (config2, field, operator, widget = null, valueSrc = null) => {
    if (!field)
      return null;
    if (!(operator || widget) && valueSrc != "const" && field != "!case_value")
      return null;
    const fieldConfig = getFieldConfig(config2, field);
    if (!widget)
      widget = getWidgetForFieldOp(config2, field, operator, valueSrc);
    const widgetConfig = config2.widgets[widget] || {};
    const fieldWidgetConfig = (fieldConfig && fieldConfig.widgets ? fieldConfig.widgets[widget] : {}) || {};
    const fieldWidgetProps = fieldWidgetConfig.widgetProps || {};
    const valueFieldSettings = (valueSrc == "value" || !valueSrc) && fieldConfig && fieldConfig.fieldSettings || {};
    const mergedConfig = (0, import_merge.default)({}, widgetConfig, fieldWidgetProps, valueFieldSettings);
    return mergedConfig;
  };

  // node_modules/@react-awesome-query-builder/core/modules/utils/funcUtils.js
  var funcUtils_exports = {};
  __export(funcUtils_exports, {
    completeFuncValue: () => completeFuncValue,
    completeValue: () => completeValue,
    setArgValue: () => setArgValue,
    setArgValueSrc: () => setArgValueSrc,
    setFunc: () => setFunc
  });
  var import_immutable6 = __toESM(require_immutable());
  var isObject6 = (v) => typeof v == "object" && v !== null && !Array.isArray(v);
  var completeValue = (value, valueSrc, config2) => {
    if (valueSrc == "func")
      return completeFuncValue(value, config2);
    else
      return value;
  };
  var completeFuncValue = (value, config2) => {
    const _checkFuncValue = (value2) => {
      if (!value2)
        return void 0;
      const funcKey = value2.get("func");
      const funcConfig = funcKey && getFuncConfig(config2, funcKey);
      if (!funcConfig)
        return void 0;
      let complValue = value2;
      let tmpHasOptional = false;
      for (const argKey in funcConfig.args) {
        const argConfig = funcConfig.args[argKey];
        const { valueSources, isOptional, defaultValue: defaultValue6 } = argConfig;
        const filteredValueSources = filterValueSourcesForField(config2, valueSources, argConfig);
        const args = complValue.get("args");
        const argDefaultValueSrc = filteredValueSources.length == 1 ? filteredValueSources[0] : void 0;
        const argVal = args ? args.get(argKey) : void 0;
        const argValue = argVal ? argVal.get("value") : void 0;
        const argValueSrc = (argVal ? argVal.get("valueSrc") : void 0) || argDefaultValueSrc;
        if (argValue !== void 0) {
          const completeArgValue = completeValue(argValue, argValueSrc, config2);
          if (completeArgValue === void 0) {
            return void 0;
          } else if (completeArgValue !== argValue) {
            complValue = complValue.setIn(["args", argKey, "value"], completeArgValue);
          }
          if (tmpHasOptional) {
            return void 0;
          }
        } else if (defaultValue6 !== void 0 && !isObject6(defaultValue6)) {
          complValue = complValue.setIn(["args", argKey, "value"], getDefaultArgValue(argConfig));
          complValue = complValue.setIn(["args", argKey, "valueSrc"], "value");
        } else if (isOptional) {
          tmpHasOptional = true;
        } else {
          return void 0;
        }
      }
      return complValue;
    };
    return _checkFuncValue(value);
  };
  var setFunc = (value, funcKey, config2) => {
    const fieldSeparator = config2.settings.fieldSeparator;
    value = value || new import_immutable6.default.Map();
    if (Array.isArray(funcKey)) {
      funcKey = funcKey.join(fieldSeparator);
    }
    value = value.set("func", funcKey);
    value = value.set("args", new import_immutable6.default.Map());
    const funcConfig = funcKey && getFuncConfig(config2, funcKey);
    if (funcConfig) {
      for (const argKey in funcConfig.args) {
        const argConfig = funcConfig.args[argKey];
        const { valueSources, defaultValue: defaultValue6 } = argConfig;
        const filteredValueSources = filterValueSourcesForField(config2, valueSources, argConfig);
        const firstValueSrc = filteredValueSources.length ? filteredValueSources[0] : void 0;
        const defaultValueSrc = defaultValue6 ? isObject6(defaultValue6) && !!defaultValue6.func ? "func" : "value" : void 0;
        const argDefaultValueSrc = defaultValueSrc || firstValueSrc;
        if (defaultValue6 !== void 0) {
          value = value.setIn(["args", argKey, "value"], getDefaultArgValue(argConfig));
        }
        if (argDefaultValueSrc) {
          value = value.setIn(["args", argKey, "valueSrc"], argDefaultValueSrc);
        }
      }
    }
    return value;
  };
  var getDefaultArgValue = ({ defaultValue: value }) => {
    if (isObject6(value) && !import_immutable6.default.Map.isMap(value) && value.func) {
      return import_immutable6.default.fromJS(value, function(k, v) {
        return import_immutable6.default.Iterable.isIndexed(v) ? v.toList() : v.toOrderedMap();
      });
    }
    return value;
  };
  var setArgValue = (value, argKey, argVal, argConfig, config2) => {
    if (value && value.get("func")) {
      value = value.setIn(["args", argKey, "value"], argVal);
      const { valueSources } = argConfig;
      const filteredValueSources = filterValueSourcesForField(config2, valueSources, argConfig);
      const argDefaultValueSrc = filteredValueSources.length == 1 ? filteredValueSources[0] : void 0;
      if (argDefaultValueSrc) {
        value = value.setIn(["args", argKey, "valueSrc"], argDefaultValueSrc);
      }
    }
    return value;
  };
  var setArgValueSrc = (value, argKey, argValSrc, _argConfig, _config) => {
    if (value && value.get("func")) {
      value = value.setIn(["args", argKey], new import_immutable6.default.Map({ valueSrc: argValSrc }));
    }
    return value;
  };

  // node_modules/@react-awesome-query-builder/core/modules/export/queryBuilder.js
  var import_immutable7 = __toESM(require_immutable());
  var queryBuilderFormat = (item, config2) => {
    let meta = {
      usedFields: []
    };
    const res = formatItem(item, config2, meta);
    if (!res)
      return void 0;
    return {
      ...res,
      ...meta
    };
  };
  var formatItem = (item, config2, meta) => {
    if (!item)
      return void 0;
    const type = item.get("type");
    const children = item.get("children1");
    if ((type === "group" || type === "rule_group") && children && children.size) {
      return formatGroup(item, config2, meta);
    } else if (type === "rule") {
      return formatRule(item, config2, meta);
    }
    return void 0;
  };
  var formatGroup = (item, config2, meta) => {
    const properties = item.get("properties") || new import_immutable7.Map();
    const children = item.get("children1");
    const id = item.get("id");
    const list = children.map((currentChild) => formatItem(currentChild, config2, meta)).filter((currentChild) => typeof currentChild !== "undefined");
    if (!list.size)
      return void 0;
    let conjunction = properties.get("conjunction");
    if (!conjunction)
      conjunction = defaultConjunction(config2);
    const not = properties.get("not");
    const resultQuery = {
      id,
      rules: list.toList(),
      condition: conjunction.toUpperCase(),
      not
    };
    return resultQuery;
  };
  var formatRule = (item, config2, meta) => {
    const properties = item.get("properties") || new import_immutable7.Map();
    const id = item.get("id");
    const operator = properties.get("operator");
    const options2 = properties.get("operatorOptions");
    let field = properties.get("field");
    let value = properties.get("value");
    let valueSrc = properties.get("valueSrc");
    let valueType = properties.get("valueType");
    const hasUndefinedValues = value.filter((v) => v === void 0).size > 0;
    if (field == null || operator == null || hasUndefinedValues)
      return void 0;
    const fieldDefinition = getFieldConfig(config2, field) || {};
    const operatorDefinition = getOperatorConfig(config2, operator, field) || {};
    const fieldType = fieldDefinition.type || "undefined";
    const cardinality = defaultValue3(operatorDefinition.cardinality, 1);
    const typeConfig = config2.types[fieldDefinition.type] || {};
    const fieldName = formatFieldName(field, config2, meta);
    if (value.size < cardinality)
      return void 0;
    if (meta.usedFields.indexOf(field) == -1)
      meta.usedFields.push(field);
    value = value.toArray();
    valueSrc = valueSrc.toArray();
    valueType = valueType.toArray();
    let values = [];
    for (let i = 0; i < value.length; i++) {
      const val = {
        type: valueType[i],
        value: value[i]
      };
      values.push(val);
      if (valueSrc[i] == "field") {
        const secondField = value[i];
        if (meta.usedFields.indexOf(secondField) == -1)
          meta.usedFields.push(secondField);
      }
    }
    let operatorOptions = options2 ? options2.toJS() : null;
    if (operatorOptions && !Object.keys(operatorOptions).length)
      operatorOptions = null;
    let ruleQuery = {
      id,
      fieldName,
      type: fieldType,
      input: typeConfig.mainWidget,
      operator
    };
    if (operatorOptions)
      ruleQuery.operatorOptions = operatorOptions;
    ruleQuery.values = values;
    return ruleQuery;
  };

  // node_modules/@react-awesome-query-builder/core/modules/export/jsonLogic.js
  var import_immutable8 = __toESM(require_immutable());
  var import_omit2 = __toESM(require_omit());
  var import_pick = __toESM(require_pick());
  var jsonLogicFormat = (item, config2) => {
    let meta = {
      usedFields: [],
      errors: []
    };
    const logic = formatItem2(item, config2, meta, true);
    const { errors, usedFields } = meta;
    const { fieldSeparator } = config2.settings;
    let data = {};
    for (let ff of usedFields) {
      const def = getFieldConfig(config2, ff) || {};
      const parts2 = ff.split(fieldSeparator);
      let tmp = data;
      for (let i = 0; i < parts2.length; i++) {
        const p = parts2[i];
        const pdef = getFieldConfig(config2, parts2.slice(0, i + 1)) || {};
        if (i != parts2.length - 1) {
          if (pdef.type == "!group" && pdef.mode != "struct") {
            if (!tmp[p])
              tmp[p] = [{}];
            tmp = tmp[p][0];
          } else {
            if (!tmp[p])
              tmp[p] = {};
            tmp = tmp[p];
          }
        } else {
          if (!tmp[p])
            tmp[p] = null;
        }
      }
    }
    return {
      errors,
      logic,
      data
    };
  };
  var formatItem2 = (item, config2, meta, isRoot, parentField = null) => {
    if (!item)
      return void 0;
    const type = item.get("type");
    const properties = item.get("properties") || new import_immutable8.Map();
    const isLocked = properties.get("isLocked");
    const { lockedOp } = config2.settings.jsonLogic;
    let ret;
    if (type === "group" || type === "rule_group") {
      ret = formatGroup2(item, config2, meta, isRoot, parentField);
    } else if (type === "rule") {
      ret = formatRule2(item, config2, meta, parentField);
    }
    if (isLocked && ret && lockedOp) {
      ret = { [lockedOp]: ret };
    }
    return ret;
  };
  var formatGroup2 = (item, config2, meta, isRoot, parentField = null) => {
    const type = item.get("type");
    const properties = item.get("properties") || new import_immutable8.Map();
    const mode = properties.get("mode");
    const children = item.get("children1") || new import_immutable8.List();
    const field = properties.get("field");
    let conjunction = properties.get("conjunction");
    if (!conjunction)
      conjunction = defaultConjunction(config2);
    const conjunctionDefinition = config2.conjunctions[conjunction];
    const conj = conjunctionDefinition.jsonLogicConj || conjunction.toLowerCase();
    const not = properties.get("not");
    if (conj != "and" && conj != "or") {
      meta.errors.push(`Conjunction ${conj} is not supported`);
      return void 0;
    }
    const isRuleGroup = type === "rule_group" && !isRoot;
    const groupField = isRuleGroup && mode != "struct" ? field : parentField;
    const groupOperator = properties.get("operator");
    const groupOperatorDefinition = groupOperator && getOperatorConfig(config2, groupOperator, field) || null;
    const formattedValue = formatItemValue(config2, properties, meta, groupOperator, parentField);
    const isGroup0 = isRuleGroup && (!groupOperator || groupOperatorDefinition.cardinality == 0);
    const list = children.map((currentChild) => formatItem2(currentChild, config2, meta, false, groupField)).filter((currentChild) => typeof currentChild !== "undefined");
    if (isRuleGroup && mode != "struct" && !isGroup0) {
      if (formattedValue == void 0)
        return void 0;
    } else {
      if (!list.size)
        return void 0;
    }
    let resultQuery = {};
    if (list.size == 1 && !isRoot)
      resultQuery = list.first();
    else
      resultQuery[conj] = list.toList().toJS();
    if (not) {
      resultQuery = { "!": resultQuery };
    }
    if (isRuleGroup && mode != "struct") {
      const formattedField = formatField(meta, config2, field, parentField);
      if (isGroup0) {
        const op = groupOperator || "some";
        resultQuery = {
          [op]: [
            formattedField,
            resultQuery
          ]
        };
      } else {
        const filter3 = !list.size ? formattedField : {
          "filter": [
            formattedField,
            resultQuery
          ]
        };
        const count = {
          "reduce": [
            filter3,
            { "+": [1, { var: "accumulator" }] },
            0
          ]
        };
        resultQuery = formatLogic(config2, properties, count, formattedValue, groupOperator);
      }
    }
    return resultQuery;
  };
  var formatRule2 = (item, config2, meta, parentField = null) => {
    const properties = item.get("properties") || new import_immutable8.Map();
    const field = properties.get("field");
    let operator = properties.get("operator");
    let operatorOptions = properties.get("operatorOptions");
    operatorOptions = operatorOptions ? operatorOptions.toJS() : null;
    if (operatorOptions && !Object.keys(operatorOptions).length)
      operatorOptions = null;
    if (field == null || operator == null)
      return void 0;
    const fieldDefinition = getFieldConfig(config2, field) || {};
    let operatorDefinition = getOperatorConfig(config2, operator, field) || {};
    let reversedOp = operatorDefinition.reversedOp;
    let revOperatorDefinition = getOperatorConfig(config2, reversedOp, field) || {};
    let isRev = false;
    if (!operatorDefinition.jsonLogic && !revOperatorDefinition.jsonLogic) {
      meta.errors.push(`Operator ${operator} is not supported`);
      return void 0;
    }
    if (!operatorDefinition.jsonLogic && revOperatorDefinition.jsonLogic) {
      isRev = true;
      [operator, reversedOp] = [reversedOp, operator];
      [operatorDefinition, revOperatorDefinition] = [revOperatorDefinition, operatorDefinition];
    }
    const formattedValue = formatItemValue(config2, properties, meta, operator, parentField);
    if (formattedValue === void 0)
      return void 0;
    const formattedField = formatField(meta, config2, field, parentField);
    return formatLogic(config2, properties, formattedField, formattedValue, operator, operatorOptions, fieldDefinition, isRev);
  };
  var formatItemValue = (config2, properties, meta, operator, parentField) => {
    const field = properties.get("field");
    const iValueSrc = properties.get("valueSrc");
    const iValueType = properties.get("valueType");
    const fieldDefinition = getFieldConfig(config2, field) || {};
    const operatorDefinition = getOperatorConfig(config2, operator, field) || {};
    const cardinality = defaultValue3(operatorDefinition.cardinality, 1);
    const iValue = properties.get("value");
    const asyncListValues = properties.get("asyncListValues");
    if (iValue == void 0)
      return void 0;
    let valueSrcs = [];
    let valueTypes = [];
    let oldUsedFields = meta.usedFields;
    const fvalue = iValue.map((currentValue, ind) => {
      const valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
      const valueType = iValueType ? iValueType.get(ind) : null;
      const cValue = completeValue(currentValue, valueSrc, config2);
      const widget = getWidgetForFieldOp(config2, field, operator, valueSrc);
      const fieldWidgetDef = (0, import_omit2.default)(getFieldWidgetConfig(config2, field, operator, widget, valueSrc), ["factory"]);
      const fv = formatValue(
        meta,
        config2,
        cValue,
        valueSrc,
        valueType,
        fieldWidgetDef,
        fieldDefinition,
        operator,
        operatorDefinition,
        parentField,
        asyncListValues
      );
      if (fv !== void 0) {
        valueSrcs.push(valueSrc);
        valueTypes.push(valueType);
      }
      return fv;
    });
    const hasUndefinedValues = fvalue.filter((v) => v === void 0).size > 0;
    if (fvalue.size < cardinality || hasUndefinedValues) {
      meta.usedFields = oldUsedFields;
      return void 0;
    }
    return cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;
  };
  var formatValue = (meta, config2, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, parentField = null, asyncListValues) => {
    if (currentValue === void 0)
      return void 0;
    let ret;
    if (valueSrc == "field") {
      ret = formatField(meta, config2, currentValue, parentField);
    } else if (valueSrc == "func") {
      ret = formatFunc(meta, config2, currentValue, parentField);
    } else if (typeof fieldWidgetDef.jsonLogic === "function") {
      const fn2 = fieldWidgetDef.jsonLogic;
      const args = [
        currentValue,
        {
          ...(0, import_pick.default)(fieldDef, ["fieldSettings", "listValues"]),
          asyncListValues
        },
        //useful options: valueFormat for date/time
        (0, import_omit2.default)(fieldWidgetDef, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue"])
      ];
      if (operator) {
        args.push(operator);
        args.push(operatorDef);
      }
      ret = fn2(...args);
    } else {
      ret = currentValue;
    }
    return ret;
  };
  var formatFunc = (meta, config2, currentValue, parentField = null) => {
    const funcKey = currentValue.get("func");
    const args = currentValue.get("args");
    const funcConfig = getFuncConfig(config2, funcKey);
    if (!funcConfig.jsonLogic) {
      meta.errors.push(`Func ${funcKey} is not supported`);
      return void 0;
    }
    let formattedArgs = {};
    for (const argKey in funcConfig.args) {
      const argConfig = funcConfig.args[argKey];
      const fieldDef = getFieldConfig(config2, argConfig);
      const argVal = args ? args.get(argKey) : void 0;
      const argValue = argVal ? argVal.get("value") : void 0;
      const argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
      const formattedArgVal = formatValue(
        meta,
        config2,
        argValue,
        argValueSrc,
        argConfig.type,
        fieldDef,
        argConfig,
        null,
        null,
        parentField
      );
      if (argValue != void 0 && formattedArgVal === void 0) {
        meta.errors.push(`Can't format value of arg ${argKey} for func ${funcKey}`);
        return void 0;
      }
      if (formattedArgVal !== void 0) {
        formattedArgs[argKey] = formattedArgVal;
      }
    }
    const formattedArgsArr = Object.values(formattedArgs);
    let ret;
    if (typeof funcConfig.jsonLogic === "function") {
      const fn2 = funcConfig.jsonLogic;
      const args2 = [
        formattedArgs
      ];
      ret = fn2(...args2);
    } else {
      const funcName = funcConfig.jsonLogic || funcKey;
      const isMethod = !!funcConfig.jsonLogicIsMethod;
      if (isMethod) {
        const [obj, ...params] = formattedArgsArr;
        if (params.length) {
          ret = { "method": [obj, funcName, params] };
        } else {
          ret = { "method": [obj, funcName] };
        }
      } else {
        ret = { [funcName]: formattedArgsArr };
      }
    }
    return ret;
  };
  var formatField = (meta, config2, field, parentField = null) => {
    const { fieldSeparator, jsonLogic } = config2.settings;
    let ret;
    if (field) {
      if (Array.isArray(field))
        field = field.join(fieldSeparator);
      const fieldDef = getFieldConfig(config2, field) || {};
      let fieldName = field;
      if (fieldDef.fieldName) {
        fieldName = fieldDef.fieldName;
      }
      if (parentField) {
        const parentFieldDef = getFieldConfig(config2, parentField) || {};
        let parentFieldName = parentField;
        if (parentFieldDef.fieldName) {
          parentFieldName = parentFieldDef.fieldName;
        }
        if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {
          fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);
        } else {
          meta.errors.push(`Can't cut group ${parentFieldName} from field ${fieldName}`);
        }
      }
      let varName = fieldDef.jsonLogicVar || (fieldDef.type == "!group" ? jsonLogic.groupVarKey : "var");
      ret = { [varName]: fieldName };
      if (meta.usedFields.indexOf(field) == -1)
        meta.usedFields.push(field);
    }
    return ret;
  };
  var buildFnToFormatOp = (operator, operatorDefinition, formattedField, formattedValue) => {
    let formatteOp = operator;
    const cardinality = defaultValue3(operatorDefinition.cardinality, 1);
    const isReverseArgs = defaultValue3(operatorDefinition._jsonLogicIsRevArgs, false);
    if (typeof operatorDefinition.jsonLogic == "string")
      formatteOp = operatorDefinition.jsonLogic;
    const rangeOps = ["<", "<=", ">", ">="];
    const eqOps = ["==", "!="];
    const fn2 = (field, op, val, opDef, opOpts) => {
      if (cardinality == 0 && eqOps.includes(formatteOp))
        return { [formatteOp]: [formattedField, null] };
      else if (cardinality == 0)
        return { [formatteOp]: formattedField };
      else if (cardinality == 1 && isReverseArgs)
        return { [formatteOp]: [formattedValue, formattedField] };
      else if (cardinality == 1)
        return { [formatteOp]: [formattedField, formattedValue] };
      else if (cardinality == 2 && rangeOps.includes(formatteOp))
        return { [formatteOp]: [formattedValue[0], formattedField, formattedValue[1]] };
      else
        return { [formatteOp]: [formattedField, ...formattedValue] };
    };
    return fn2;
  };
  var formatLogic = (config2, properties, formattedField, formattedValue, operator, operatorOptions = null, fieldDefinition = null, isRev = false) => {
    const field = properties.get("field");
    const operatorDefinition = getOperatorConfig(config2, operator, field) || {};
    let fn2 = typeof operatorDefinition.jsonLogic == "function" ? operatorDefinition.jsonLogic : buildFnToFormatOp(operator, operatorDefinition, formattedField, formattedValue);
    const args = [
      formattedField,
      operator,
      formattedValue,
      (0, import_omit2.default)(operatorDefinition, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"]),
      operatorOptions,
      fieldDefinition
    ];
    let ruleQuery = fn2(...args);
    if (isRev) {
      ruleQuery = { "!": ruleQuery };
    }
    return ruleQuery;
  };

  // node_modules/@react-awesome-query-builder/core/modules/export/mongoDb.js
  var import_omit3 = __toESM(require_omit());
  var import_pick2 = __toESM(require_pick());
  var import_immutable9 = __toESM(require_immutable());
  var isObject7 = (v) => typeof v == "object" && v !== null && !Array.isArray(v);
  var mongodbFormat = (tree2, config2) => {
    return _mongodbFormat(tree2, config2, false);
  };
  var _mongodbFormat = (tree2, config2, returnErrors = true) => {
    let meta = {
      errors: []
    };
    const res = formatItem3([], tree2, config2, meta);
    if (returnErrors) {
      return [res, meta.errors];
    } else {
      if (meta.errors.length)
        console.warn("Errors while exporting to MongoDb:", meta.errors);
      return res;
    }
  };
  var formatItem3 = (parents, item, config2, meta, _not = false, _canWrapExpr = true, _fieldName = void 0, _value = void 0) => {
    if (!item)
      return void 0;
    const type = item.get("type");
    if (type === "group" || type === "rule_group") {
      return formatGroup3(parents, item, config2, meta, _not, _canWrapExpr, _fieldName, _value);
    } else if (type === "rule") {
      return formatRule3(parents, item, config2, meta, _not, _canWrapExpr, _fieldName, _value);
    }
    return void 0;
  };
  var formatGroup3 = (parents, item, config2, meta, _not = false, _canWrapExpr = true, _fieldName = void 0, _value = void 0) => {
    const type = item.get("type");
    const properties = item.get("properties") || new import_immutable9.Map();
    const children = item.get("children1") || new import_immutable9.List();
    const { canShortMongoQuery } = config2.settings;
    const hasParentRuleGroup = parents.filter((it) => it.get("type") == "rule_group").length > 0;
    const parentPath = parents.filter((it) => it.get("type") == "rule_group").map((it) => it.get("properties").get("field")).slice(-1).pop();
    const realParentPath = hasParentRuleGroup && parentPath;
    const groupField = type === "rule_group" ? properties.get("field") : null;
    const groupFieldName = formatFieldName2(groupField, config2, meta, realParentPath);
    const groupFieldDef = getFieldConfig(config2, groupField) || {};
    const mode = groupFieldDef.mode;
    const canHaveEmptyChildren = groupField && mode == "array";
    const not = _not ? !properties.get("not") : properties.get("not");
    const list = children.map(
      (currentChild) => formatItem3(
        [...parents, item],
        currentChild,
        config2,
        meta,
        not,
        true,
        mode == "array" ? (f) => `$$el.${f}` : void 0
      )
    ).filter((currentChild) => typeof currentChild !== "undefined");
    if (!canHaveEmptyChildren && !list.size)
      return void 0;
    let conjunction = properties.get("conjunction");
    if (!conjunction)
      conjunction = defaultConjunction(config2);
    let conjunctionDefinition = config2.conjunctions[conjunction];
    const reversedConj = conjunctionDefinition.reversedConj;
    if (not && reversedConj) {
      conjunction = reversedConj;
      conjunctionDefinition = config2.conjunctions[conjunction];
    }
    const mongoConj = conjunctionDefinition.mongoConj;
    let resultQuery;
    if (list.size == 1) {
      resultQuery = list.first();
    } else if (list.size > 1) {
      const rules = list.toList().toJS();
      const canShort = canShortMongoQuery && mongoConj == "$and";
      if (canShort) {
        resultQuery = rules.reduce((acc, rule3) => {
          if (!acc)
            return void 0;
          for (let k in rule3) {
            if (k[0] == "$") {
              acc = void 0;
              break;
            }
            if (acc[k] == void 0) {
              acc[k] = rule3[k];
            } else {
              let prev = acc[k], next = rule3[k];
              if (!isObject7(prev)) {
                prev = { "$eq": prev };
              }
              if (!isObject7(next)) {
                next = { "$eq": next };
              }
              const prevOp = Object.keys(prev)[0], nextOp = Object.keys(next)[0];
              if (prevOp == nextOp) {
                acc = void 0;
                break;
              }
              acc[k] = Object.assign({}, prev, next);
            }
          }
          return acc;
        }, {});
      }
      if (!resultQuery)
        resultQuery = { [mongoConj]: rules };
    }
    if (groupField) {
      if (mode == "array") {
        const totalQuery = {
          "$size": groupFieldName
        };
        const filterQuery = resultQuery ? {
          "$size": {
            "$filter": {
              input: "$" + groupFieldName,
              as: "el",
              cond: resultQuery
            }
          }
        } : totalQuery;
        resultQuery = formatItem3(
          parents,
          item.set("type", "rule"),
          config2,
          meta,
          false,
          false,
          (_f) => filterQuery,
          totalQuery
        );
        resultQuery = { "$expr": resultQuery };
      } else {
        resultQuery = { [groupFieldName]: { "$elemMatch": resultQuery } };
      }
    }
    return resultQuery;
  };
  var formatRule3 = (parents, item, config2, meta, _not = false, _canWrapExpr = true, _fieldName = void 0, _value = void 0) => {
    const properties = item.get("properties") || new import_immutable9.Map();
    const hasParentRuleGroup = parents.filter((it) => it.get("type") == "rule_group").length > 0;
    const parentPath = parents.filter((it) => it.get("type") == "rule_group").map((it) => it.get("properties").get("field")).slice(-1).pop();
    const realParentPath = hasParentRuleGroup && parentPath;
    let operator = properties.get("operator");
    const operatorOptions = properties.get("operatorOptions");
    const field = properties.get("field");
    const iValue = properties.get("value");
    const iValueSrc = properties.get("valueSrc");
    const iValueType = properties.get("valueType");
    const asyncListValues = properties.get("asyncListValues");
    if (field == null || operator == null || iValue === void 0)
      return void 0;
    const fieldDef = getFieldConfig(config2, field) || {};
    let operatorDefinition = getOperatorConfig(config2, operator, field) || {};
    let reversedOp = operatorDefinition.reversedOp;
    let revOperatorDefinition = getOperatorConfig(config2, reversedOp, field) || {};
    const cardinality = defaultValue3(operatorDefinition.cardinality, 1);
    let not = _not;
    if (not && reversedOp) {
      [operator, reversedOp] = [reversedOp, operator];
      [operatorDefinition, revOperatorDefinition] = [revOperatorDefinition, operatorDefinition];
      not = false;
    }
    const fieldName = formatFieldName2(field, config2, meta, realParentPath);
    let valueSrcs = [];
    let valueTypes = [];
    let useExpr = false;
    const fvalue = iValue.map((currentValue, ind) => {
      const valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
      const valueType = iValueType ? iValueType.get(ind) : null;
      const cValue = completeValue(currentValue, valueSrc, config2);
      const widget = getWidgetForFieldOp(config2, field, operator, valueSrc);
      const fieldWidgetDef = (0, import_omit3.default)(getFieldWidgetConfig(config2, field, operator, widget, valueSrc), ["factory"]);
      const [fv, fvUseExpr] = formatValue2(
        meta,
        config2,
        cValue,
        valueSrc,
        valueType,
        fieldWidgetDef,
        fieldDef,
        realParentPath,
        operator,
        operatorDefinition,
        asyncListValues
      );
      if (fv !== void 0) {
        useExpr = useExpr || fvUseExpr;
        valueSrcs.push(valueSrc);
        valueTypes.push(valueType);
      }
      return fv;
    });
    if (_fieldName)
      useExpr = true;
    const wrapExpr = useExpr && _canWrapExpr;
    const hasUndefinedValues = fvalue.filter((v) => v === void 0).size > 0;
    if (fvalue.size < cardinality || hasUndefinedValues)
      return void 0;
    const formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;
    const fn2 = operatorDefinition.mongoFormatOp;
    if (!fn2) {
      meta.errors.push(`Operator ${operator} is not supported`);
      return void 0;
    }
    const args = [
      _fieldName ? _fieldName(fieldName) : fieldName,
      operator,
      _value !== void 0 && formattedValue == null ? _value : formattedValue,
      useExpr,
      valueSrcs.length > 1 ? valueSrcs : valueSrcs[0],
      valueTypes.length > 1 ? valueTypes : valueTypes[0],
      (0, import_omit3.default)(operatorDefinition, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"]),
      operatorOptions,
      fieldDef
    ];
    let ruleQuery = fn2(...args);
    if (wrapExpr) {
      ruleQuery = { "$expr": ruleQuery };
    }
    if (not) {
      ruleQuery = { "$not": ruleQuery };
    }
    return ruleQuery;
  };
  var formatValue2 = (meta, config2, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, parentPath, operator, operatorDef, asyncListValues) => {
    if (currentValue === void 0)
      return [void 0, false];
    let ret;
    let useExpr = false;
    if (valueSrc == "field") {
      [ret, useExpr] = formatRightField(meta, config2, currentValue, parentPath);
    } else if (valueSrc == "func") {
      [ret, useExpr] = formatFunc2(meta, config2, currentValue, parentPath);
    } else {
      if (typeof fieldWidgetDef.mongoFormatValue === "function") {
        const fn2 = fieldWidgetDef.mongoFormatValue;
        const args = [
          currentValue,
          {
            ...(0, import_pick2.default)(fieldDef, ["fieldSettings", "listValues"]),
            asyncListValues
          },
          //useful options: valueFormat for date/time
          (0, import_omit3.default)(fieldWidgetDef, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue"])
        ];
        if (operator) {
          args.push(operator);
          args.push(operatorDef);
        }
        ret = fn2(...args);
      } else {
        ret = currentValue;
      }
    }
    return [ret, useExpr];
  };
  var formatFieldName2 = (field, config2, meta, parentPath) => {
    if (!field)
      return;
    const fieldDef = getFieldConfig(config2, field) || {};
    const { fieldSeparator } = config2.settings;
    const fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);
    let fieldName = Array.isArray(field) ? field.join(fieldSeparator) : field;
    if (fieldDef.fieldName) {
      fieldName = fieldDef.fieldName;
    }
    if (parentPath) {
      const parentFieldDef = getFieldConfig(config2, parentPath) || {};
      let parentFieldName = parentPath;
      if (parentFieldDef.fieldName) {
        parentFieldName = parentFieldDef.fieldName;
      }
      if (fieldName.indexOf(parentFieldName + ".") == 0) {
        fieldName = fieldName.slice((parentFieldName + ".").length);
      } else {
        meta.errors.push(`Can't cut group ${parentFieldName} from field ${fieldName}`);
      }
    }
    return fieldName;
  };
  var formatRightField = (meta, config2, rightField, parentPath) => {
    const { fieldSeparator } = config2.settings;
    let ret;
    const useExpr = true;
    if (rightField) {
      const rightFieldDefinition = getFieldConfig(config2, rightField) || {};
      const fieldParts = Array.isArray(rightField) ? rightField : rightField.split(fieldSeparator);
      const _fieldKeys = getFieldPath(rightField, config2);
      const fieldPartsLabels = getFieldPathLabels(rightField, config2);
      const fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;
      const formatFieldFn = config2.settings.formatField;
      const rightFieldName = formatFieldName2(rightField, config2, meta, parentPath);
      const formattedField = formatFieldFn(rightFieldName, fieldParts, fieldFullLabel, rightFieldDefinition, config2, false);
      ret = "$" + formattedField;
    }
    return [ret, useExpr];
  };
  var formatFunc2 = (meta, config2, currentValue, parentPath) => {
    const useExpr = true;
    let ret;
    const funcKey = currentValue.get("func");
    const args = currentValue.get("args");
    const funcConfig = getFuncConfig(config2, funcKey);
    const funcName = funcConfig.mongoFunc || funcKey;
    const mongoArgsAsObject = funcConfig.mongoArgsAsObject;
    let formattedArgs = {};
    let argsCnt = 0;
    let lastArg = void 0;
    for (const argKey in funcConfig.args) {
      const argConfig = funcConfig.args[argKey];
      const fieldDef = getFieldConfig(config2, argConfig);
      const argVal = args ? args.get(argKey) : void 0;
      const argValue = argVal ? argVal.get("value") : void 0;
      const argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
      const argAsyncListValues = argVal ? argVal.get("asyncListValues") : void 0;
      const widget = getWidgetForFieldOp(config2, fieldDef, null, argValueSrc);
      const fieldWidgetDef = (0, import_omit3.default)(getFieldWidgetConfig(config2, fieldDef, null, widget, argValueSrc), ["factory"]);
      const [formattedArgVal, _argUseExpr] = formatValue2(
        meta,
        config2,
        argValue,
        argValueSrc,
        argConfig.type,
        fieldWidgetDef,
        fieldDef,
        parentPath,
        null,
        null,
        argAsyncListValues
      );
      if (argValue != void 0 && formattedArgVal === void 0) {
        meta.errors.push(`Can't format value of arg ${argKey} for func ${funcKey}`);
        return [void 0, false];
      }
      argsCnt++;
      if (formattedArgVal !== void 0) {
        formattedArgs[argKey] = formattedArgVal;
        lastArg = formattedArgVal;
      }
    }
    if (typeof funcConfig.mongoFormatFunc === "function") {
      const fn2 = funcConfig.mongoFormatFunc;
      const args2 = [
        formattedArgs
      ];
      ret = fn2(...args2);
    } else if (funcConfig.mongoFormatFunc === null) {
      meta.errors.push(`Functon ${funcName} is not supported`);
      return [void 0, false];
    } else {
      if (mongoArgsAsObject)
        ret = { [funcName]: formattedArgs };
      else if (argsCnt == 1 && lastArg !== void 0)
        ret = { [funcName]: lastArg };
      else
        ret = { [funcName]: Object.values(formattedArgs) };
    }
    return [ret, useExpr];
  };

  // node_modules/@react-awesome-query-builder/core/modules/export/sql.js
  var import_omit4 = __toESM(require_omit());
  var import_pick3 = __toESM(require_pick());
  var import_immutable10 = __toESM(require_immutable());

  // node_modules/@react-awesome-query-builder/core/modules/utils/export.js
  var export_exports = {};
  __export(export_exports, {
    SqlString: () => SqlString,
    mongoEmptyValue: () => mongoEmptyValue,
    spelEscape: () => spelEscape,
    spelFixList: () => spelFixList,
    spelFormatConcat: () => spelFormatConcat,
    spelImportConcat: () => spelImportConcat,
    sqlEmptyValue: () => sqlEmptyValue,
    stringifyForDisplay: () => stringifyForDisplay
  });
  var import_sqlstring = __toESM(require_sqlstring());
  var SqlString = import_sqlstring.default;
  SqlString.trim = (val) => {
    if (val.charAt(0) == "'")
      return val.substring(1, val.length - 1);
    else
      return val;
  };
  SqlString.escapeLike = (val, any_start = true, any_end = true) => {
    let res = SqlString.escape(val);
    res = SqlString.trim(res);
    res = res.replace(/[%_]/g, "\\$&");
    res = (any_start ? "%" : "") + res + (any_end ? "%" : "");
    res = "'" + res + "'";
    return res;
  };
  var sqlEmptyValue = (fieldDef) => {
    let v = "''";
    const type = fieldDef?.type;
    if (type == "date") {
      v = "'0000-00-00'";
    } else if (type == "datetime") {
      v = "'0000-00-00 00:00'";
    } else if (type == "time") {
      v = "'00:00'";
    } else if (type == "number") {
      v = "0";
    }
    return v;
  };
  var mongoEmptyValue = (fieldDef) => {
    let v = "";
    const type = fieldDef?.type;
    if (type == "number") {
      v = 0;
    }
    return v;
  };
  var spelEscapeString = (val) => {
    return "'" + val.replace(/'/g, "''") + "'";
  };
  var spelInlineList = (vals, toArray = false) => {
    let javaType;
    let jt;
    const numberJavaTypes = ["int", "float"];
    vals.map((v) => {
      if (v !== void 0 && v !== null) {
        if (typeof v === "string") {
          jt = "String";
        } else if (typeof v === "number") {
          jt = Number.isInteger(v) ? "int" : "float";
        } else
          throw new Error(`spelEscape: Can't use value ${v} in array`);
        if (!javaType) {
          javaType = jt;
        } else if (javaType != jt) {
          if (numberJavaTypes.includes(javaType) && numberJavaTypes.includes(jt)) {
            javaType = "float";
          } else
            throw new Error(`spelEscape: Can't use different types in array: found ${javaType} and ${jt}`);
        }
      }
    });
    if (!javaType) {
      javaType = "String";
    }
    let escapedVals;
    if (javaType == "float") {
      escapedVals = vals.map((v) => spelEscape(v, true));
    } else {
      escapedVals = vals.map((v) => spelEscape(v));
    }
    let res;
    if (toArray) {
      res = `new ${javaType}[]{${escapedVals.join(", ")}}`;
    } else {
      res = `{${escapedVals.join(", ")}}`;
    }
    return res;
  };
  var spelFixList = (val) => {
    return `${val}.?[true]`;
  };
  var spelEscape = (val, numberToFloat = false, arrayToArray = false) => {
    if (val === void 0 || val === null) {
      return "null";
    }
    switch (typeof val) {
      case "boolean":
        return val ? "true" : "false";
      case "number":
        if (!Number.isFinite(val) || isNaN(val))
          return void 0;
        return val + (!Number.isInteger(val) || numberToFloat ? "f" : "");
      case "object":
        if (Array.isArray(val)) {
          return spelInlineList(val, arrayToArray);
        } else {
          throw new Error("spelEscape: Object is not supported");
        }
      default:
        return spelEscapeString(val);
    }
  };
  var spelFormatConcat = (parts2) => {
    if (parts2 && Array.isArray(parts2) && parts2.length) {
      return parts2.map((part) => {
        if (part.type == "const") {
          return spelEscape(part.value);
        } else if (part.type == "property") {
          return "" + part.value;
        } else if (part.type == "variable") {
          return "#" + part.value;
        }
        return void 0;
      }).filter((r) => r != void 0).join(" + ");
    } else {
      return "null";
    }
  };
  var spelImportConcat = (val) => {
    if (val == void 0)
      return [void 0, []];
    let errors = [];
    const parts2 = val.valueType == "case_value" ? val.value : [val];
    const res = parts2.map((child) => {
      if (child.valueSrc == "value") {
        if (child.value === null) {
          return void 0;
        } else {
          return {
            type: "const",
            value: child.value
          };
        }
      } else if (child.valueSrc == "field") {
        return {
          type: child.isVariable ? "variable" : "property",
          value: child.value
        };
      } else {
        errors.push(`Unsupported valueSrc ${child.valueSrc} in concatenation`);
      }
    }).filter((v) => v != void 0);
    return [res, errors];
  };
  var stringifyForDisplay = (v) => v == null ? "NULL" : v.toString();

  // node_modules/@react-awesome-query-builder/core/modules/export/sql.js
  var sqlFormat = (tree2, config2) => {
    return _sqlFormat(tree2, config2, false);
  };
  var _sqlFormat = (tree2, config2, returnErrors = true) => {
    let meta = {
      errors: []
    };
    const res = formatItem4(tree2, config2, meta);
    if (returnErrors) {
      return [res, meta.errors];
    } else {
      if (meta.errors.length)
        console.warn("Errors while exporting to SQL:", meta.errors);
      return res;
    }
  };
  var formatItem4 = (item, config2, meta) => {
    if (!item)
      return void 0;
    const type = item.get("type");
    const children = item.get("children1");
    if (type === "group" || type === "rule_group") {
      return formatGroup4(item, config2, meta);
    } else if (type === "rule") {
      return formatRule4(item, config2, meta);
    }
    return void 0;
  };
  var formatGroup4 = (item, config2, meta) => {
    const type = item.get("type");
    const properties = item.get("properties") || new import_immutable10.Map();
    const children = item.get("children1") || new import_immutable10.List();
    const isRuleGroup = type === "rule_group";
    const groupField = isRuleGroup ? properties.get("field") : null;
    const groupFieldDef = getFieldConfig(config2, groupField) || {};
    const mode = groupFieldDef.mode;
    if (mode == "array") {
      meta.errors.push(`Aggregation is not supported for ${groupField}`);
    }
    const not = properties.get("not");
    const canHaveEmptyChildren = false;
    const list = children.map((currentChild) => formatItem4(currentChild, config2, meta)).filter((currentChild) => typeof currentChild !== "undefined");
    if (!canHaveEmptyChildren && !list.size)
      return void 0;
    let conjunction = properties.get("conjunction");
    if (!conjunction)
      conjunction = defaultConjunction(config2);
    const conjunctionDefinition = config2.conjunctions[conjunction];
    return conjunctionDefinition.sqlFormatConj(list, conjunction, not);
  };
  var buildFnToFormatOp2 = (operator, operatorDefinition) => {
    const sqlOp = operatorDefinition.sqlOp || operator;
    const cardinality = defaultValue3(operatorDefinition.cardinality, 1);
    let fn2;
    if (cardinality == 0) {
      fn2 = (field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) => {
        return `${field} ${sqlOp}`;
      };
    } else if (cardinality == 1) {
      fn2 = (field, op, value, valueSrc, valueType, opDef, operatorOptions, fieldDef) => {
        return `${field} ${sqlOp} ${value}`;
      };
    } else if (cardinality == 2) {
      fn2 = (field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) => {
        const valFrom = values.first();
        const valTo = values.get(1);
        return `${field} ${sqlOp} ${valFrom} AND ${valTo}`;
      };
    }
    return fn2;
  };
  var formatRule4 = (item, config2, meta) => {
    const properties = item.get("properties") || new import_immutable10.Map();
    const field = properties.get("field");
    let operator = properties.get("operator");
    const operatorOptions = properties.get("operatorOptions");
    const iValueSrc = properties.get("valueSrc");
    const iValueType = properties.get("valueType");
    const iValue = properties.get("value");
    const asyncListValues = properties.get("asyncListValues");
    if (field == null || operator == null)
      return void 0;
    const fieldDefinition = getFieldConfig(config2, field) || {};
    let opDef = getOperatorConfig(config2, operator, field) || {};
    let reversedOp = opDef.reversedOp;
    let revOpDef = getOperatorConfig(config2, reversedOp, field) || {};
    const cardinality = defaultValue3(opDef.cardinality, 1);
    let isRev = false;
    const canFormatOp = opDef.sqlOp || opDef.sqlFormatOp;
    const canFormatRevOp = revOpDef.sqlOp || revOpDef.sqlFormatOp;
    if (!canFormatOp && !canFormatRevOp) {
      meta.errors.push(`Operator ${operator} is not supported`);
      return void 0;
    }
    if (!canFormatRevOp && canFormatRevOp) {
      isRev = true;
      [operator, reversedOp] = [reversedOp, operator];
      [opDef, revOpDef] = [revOpDef, opDef];
    }
    let valueSrcs = [];
    let valueTypes = [];
    const fvalue = iValue.map((currentValue, ind) => {
      const valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
      const valueType = iValueType ? iValueType.get(ind) : null;
      const cValue = completeValue(currentValue, valueSrc, config2);
      const widget = getWidgetForFieldOp(config2, field, operator, valueSrc);
      const fieldWidgetDefinition = (0, import_omit4.default)(getFieldWidgetConfig(config2, field, operator, widget, valueSrc), ["factory"]);
      let fv = formatValue3(
        meta,
        config2,
        cValue,
        valueSrc,
        valueType,
        fieldWidgetDefinition,
        fieldDefinition,
        operator,
        opDef,
        asyncListValues
      );
      if (fv !== void 0) {
        valueSrcs.push(valueSrc);
        valueTypes.push(valueType);
      }
      return fv;
    });
    const hasUndefinedValues = fvalue.filter((v) => v === void 0).size > 0;
    if (hasUndefinedValues || fvalue.size < cardinality)
      return void 0;
    const formattedValue = cardinality == 1 ? fvalue.first() : fvalue;
    const fn2 = opDef.sqlFormatOp || buildFnToFormatOp2(operator, opDef);
    if (!fn2) {
      meta.errors.push(`Operator ${operator} is not supported`);
      return void 0;
    }
    const formattedField = formatField2(meta, config2, field);
    const args = [
      formattedField,
      operator,
      formattedValue,
      valueSrcs.length > 1 ? valueSrcs : valueSrcs[0],
      valueTypes.length > 1 ? valueTypes : valueTypes[0],
      (0, import_omit4.default)(opDef, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"]),
      operatorOptions,
      fieldDefinition
    ];
    let ret;
    ret = fn2(...args);
    if (isRev) {
      ret = config2.settings.sqlFormatReverse(ret);
    }
    if (ret === void 0) {
      meta.errors.push(`Operator ${operator} is not supported for value source ${valueSrcs.join(", ")}`);
      return void 0;
    }
    return ret;
  };
  var formatValue3 = (meta, config2, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, asyncListValues) => {
    if (currentValue === void 0)
      return void 0;
    let ret;
    if (valueSrc == "field") {
      ret = formatField2(meta, config2, currentValue);
    } else if (valueSrc == "func") {
      ret = formatFunc3(meta, config2, currentValue);
    } else {
      if (typeof fieldWidgetDef.sqlFormatValue === "function") {
        const fn2 = fieldWidgetDef.sqlFormatValue;
        const args = [
          currentValue,
          {
            ...(0, import_pick3.default)(fieldDef, ["fieldSettings", "listValues"]),
            asyncListValues
          },
          //useful options: valueFormat for date/time
          (0, import_omit4.default)(fieldWidgetDef, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue"])
        ];
        if (operator) {
          args.push(operator);
          args.push(operatorDef);
        }
        if (valueSrc == "field") {
          const valFieldDefinition = getFieldConfig(config2, currentValue) || {};
          args.push(valFieldDefinition);
        }
        ret = fn2(...args);
      } else {
        if (Array.isArray(currentValue)) {
          ret = currentValue.map((v) => SqlString.escape(v));
        } else {
          ret = SqlString.escape(currentValue);
        }
      }
    }
    return ret;
  };
  var formatField2 = (meta, config2, field) => {
    if (!field)
      return;
    const { fieldSeparator } = config2.settings;
    const fieldDefinition = getFieldConfig(config2, field) || {};
    const fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);
    const _fieldKeys = getFieldPath(field, config2);
    const fieldPartsLabels = getFieldPathLabels(field, config2);
    const fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;
    const formatFieldFn = config2.settings.formatField;
    const fieldName = formatFieldName(field, config2, meta);
    const formattedField = formatFieldFn(fieldName, fieldParts, fieldFullLabel, fieldDefinition, config2);
    return formattedField;
  };
  var formatFunc3 = (meta, config2, currentValue) => {
    const funcKey = currentValue.get("func");
    const args = currentValue.get("args");
    const funcConfig = getFuncConfig(config2, funcKey);
    const funcName = funcConfig.sqlFunc || funcKey;
    let formattedArgs = {};
    for (const argKey in funcConfig.args) {
      const argConfig = funcConfig.args[argKey];
      const fieldDef = getFieldConfig(config2, argConfig);
      const argVal = args ? args.get(argKey) : void 0;
      const argValue = argVal ? argVal.get("value") : void 0;
      const argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
      const argAsyncListValues = argVal ? argVal.get("asyncListValues") : void 0;
      const formattedArgVal = formatValue3(
        meta,
        config2,
        argValue,
        argValueSrc,
        argConfig.type,
        fieldDef,
        argConfig,
        null,
        null,
        argAsyncListValues
      );
      if (argValue != void 0 && formattedArgVal === void 0) {
        meta.errors.push(`Can't format value of arg ${argKey} for func ${funcKey}`);
        return void 0;
      }
      if (formattedArgVal !== void 0) {
        formattedArgs[argKey] = formattedArgVal;
      }
    }
    let ret;
    if (typeof funcConfig.sqlFormatFunc === "function") {
      const fn2 = funcConfig.sqlFormatFunc;
      const args2 = [
        formattedArgs
      ];
      ret = fn2(...args2);
    } else {
      const argsStr = Object.entries(formattedArgs).map(([k, v]) => v).join(", ");
      ret = `${funcName}(${argsStr})`;
    }
    return ret;
  };

  // node_modules/@react-awesome-query-builder/core/modules/export/spel.js
  var import_omit5 = __toESM(require_omit());
  var import_pick4 = __toESM(require_pick());
  var import_immutable11 = __toESM(require_immutable());
  var spelFormat = (tree2, config2) => {
    return _spelFormat(tree2, config2, false);
  };
  var _spelFormat = (tree2, config2, returnErrors = true) => {
    let meta = {
      errors: []
    };
    const res = formatItem5(tree2, config2, meta, null);
    if (returnErrors) {
      return [res, meta.errors];
    } else {
      if (meta.errors.length)
        console.warn("Errors while exporting to SpEL:", meta.errors);
      return res;
    }
  };
  var formatItem5 = (item, config2, meta, parentField = null) => {
    if (!item)
      return void 0;
    const type = item.get("type");
    if (type === "group" || type === "rule_group") {
      return formatGroup5(item, config2, meta, parentField);
    } else if (type === "rule") {
      return formatRule5(item, config2, meta, parentField);
    } else if (type == "switch_group") {
      return formatSwitch(item, config2, meta, parentField);
    } else if (type == "case_group") {
      return formatCase(item, config2, meta, parentField);
    }
    return void 0;
  };
  var formatCase = (item, config2, meta, parentField = null) => {
    const type = item.get("type");
    if (type != "case_group") {
      meta.errors.push(`Unexpected child of type ${type} inside switch`);
      return void 0;
    }
    const properties = item.get("properties") || new import_immutable11.Map();
    const [formattedValue, valueSrc, valueType] = formatItemValue2(
      config2,
      properties,
      meta,
      null,
      parentField,
      "!case_value"
    );
    const cond = formatGroup5(item, config2, meta, parentField);
    return [cond, formattedValue];
  };
  var formatSwitch = (item, config2, meta, parentField = null) => {
    const properties = item.get("properties") || new import_immutable11.Map();
    const children = item.get("children1");
    if (!children)
      return void 0;
    const cases = children.map((currentChild) => formatCase(currentChild, config2, meta, null)).filter((currentChild) => typeof currentChild !== "undefined").toArray();
    if (!cases.length)
      return void 0;
    if (cases.length == 1 && !cases[0][0]) {
      return cases[0][1];
    }
    let filteredCases = [];
    for (let i = 0; i < cases.length; i++) {
      if (i != cases.length - 1 && !cases[i][0]) {
        meta.errors.push(`No condition for case ${i}`);
      } else {
        filteredCases.push(cases[i]);
        if (i == cases.length - 1 && cases[i][0]) {
          filteredCases.push([void 0, null]);
        }
      }
    }
    let left2 = "", right2 = "";
    for (let i = 0; i < filteredCases.length; i++) {
      let [cond, value] = filteredCases[i];
      if (value == void 0)
        value = "null";
      if (cond == void 0)
        cond = "true";
      if (i != filteredCases.length - 1) {
        left2 += `(${cond} ? ${value} : `;
        right2 += ")";
      } else {
        left2 += `${value}`;
      }
    }
    return left2 + right2;
  };
  var formatGroup5 = (item, config2, meta, parentField = null) => {
    const type = item.get("type");
    const properties = item.get("properties") || new import_immutable11.Map();
    const mode = properties.get("mode");
    const children = item.get("children1") || new import_immutable11.List();
    const field = properties.get("field");
    let conjunction = properties.get("conjunction");
    if (!conjunction)
      conjunction = defaultConjunction(config2);
    const conjunctionDefinition = config2.conjunctions[conjunction];
    const not = properties.get("not");
    const isRuleGroup = type === "rule_group";
    const isRuleGroupArray = isRuleGroup && mode != "struct";
    const groupField = isRuleGroupArray ? field : parentField;
    const groupFieldDef = getFieldConfig(config2, groupField) || {};
    const isSpelArray = groupFieldDef.isSpelArray;
    let groupOperator = properties.get("operator");
    if (!groupOperator && (!mode || mode == "some")) {
      groupOperator = "some";
    }
    const realGroupOperator = checkOp(config2, groupOperator, field);
    const isGroupOpRev = realGroupOperator != groupOperator;
    const realGroupOperatorDefinition = groupOperator && getOperatorConfig(config2, realGroupOperator, field) || null;
    const isGroup0 = isRuleGroup && (!realGroupOperator || realGroupOperatorDefinition.cardinality == 0);
    const [formattedValue, valueSrc, valueType] = formatItemValue2(
      config2,
      properties,
      meta,
      realGroupOperator,
      parentField,
      null
    );
    const list = children.map((currentChild) => formatItem5(currentChild, config2, meta, groupField)).filter((currentChild) => typeof currentChild !== "undefined");
    if (isRuleGroupArray && !isGroup0) {
      if (formattedValue == void 0)
        return void 0;
    } else {
      if (!list.size)
        return void 0;
    }
    const omitBrackets = isRuleGroup;
    const filter3 = list.size ? conjunctionDefinition.spelFormatConj(list, conjunction, not, omitBrackets) : null;
    let ret;
    if (isRuleGroupArray) {
      const formattedField = formatField3(meta, config2, field, parentField);
      const getSize3 = isSpelArray ? ".length" : ".size()";
      const fullSize = `${formattedField}${getSize3}`;
      const filteredSize = filter3 ? `${formattedField}.?[${filter3}]${getSize3}` : fullSize;
      const groupValue = isGroup0 ? fullSize : formattedValue;
      ret = formatExpression(
        meta,
        config2,
        properties,
        filteredSize,
        groupValue,
        realGroupOperator,
        valueSrc,
        valueType,
        isGroupOpRev
      );
    } else {
      ret = filter3;
    }
    return ret;
  };
  var buildFnToFormatOp3 = (operator, operatorDefinition) => {
    const spelOp = operatorDefinition.spelOp;
    if (!spelOp)
      return void 0;
    const objectIsFirstArg = spelOp[0] == "$";
    const isMethod = spelOp[0] == "." || objectIsFirstArg;
    const isFunction = spelOp.substring(spelOp.length - 2) == "()";
    const sop = isMethod ? spelOp.slice(1) : isFunction ? spelOp.substring(0, spelOp.length - 2) : spelOp;
    let fn2;
    const cardinality = defaultValue3(operatorDefinition.cardinality, 1);
    if (cardinality == 0) {
      fn2 = (field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) => {
        if (isMethod)
          return `${field}.${sop}()`;
        else
          return `${field} ${sop}`;
      };
    } else if (cardinality == 1) {
      fn2 = (field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) => {
        if (objectIsFirstArg)
          return `${values}.${sop}(${field})`;
        else if (isFunction)
          return `${sop}(${field}, ${values})`;
        else if (isMethod)
          return `${field}.${sop}(${values})`;
        else
          return `${field} ${sop} ${values}`;
      };
    }
    return fn2;
  };
  var formatExpression = (meta, config2, properties, formattedField, formattedValue, operator, valueSrc, valueType, isRev = false) => {
    const field = properties.get("field");
    const opDef = getOperatorConfig(config2, operator, field) || {};
    const fieldDef = getFieldConfig(config2, field) || {};
    const operatorOptions = properties.get("operatorOptions");
    const fn2 = opDef.spelFormatOp || buildFnToFormatOp3(operator, opDef);
    if (!fn2) {
      meta.errors.push(`Operator ${operator} is not supported`);
      return void 0;
    }
    const args = [
      formattedField,
      operator,
      formattedValue,
      valueSrc,
      valueType,
      (0, import_omit5.default)(opDef, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"]),
      operatorOptions,
      fieldDef
    ];
    let ret;
    ret = fn2(...args);
    if (isRev) {
      ret = config2.settings.spelFormatReverse(ret);
    }
    if (ret === void 0) {
      meta.errors.push(`Operator ${operator} is not supported for value source ${valueSrc}`);
    }
    return ret;
  };
  var checkOp = (config2, operator, field) => {
    if (!operator)
      return void 0;
    let opDef = getOperatorConfig(config2, operator, field) || {};
    let reversedOp = opDef.reversedOp;
    let revOpDef = getOperatorConfig(config2, reversedOp, field) || {};
    let isRev = false;
    const canFormatOp = opDef.spelOp || opDef.spelFormatOp;
    const canFormatRevOp = revOpDef.spelOp || revOpDef.spelFormatOp;
    if (!canFormatOp && !canFormatRevOp) {
      return void 0;
    }
    if (!canFormatOp && canFormatRevOp) {
      isRev = true;
      [operator, reversedOp] = [reversedOp, operator];
      [opDef, revOpDef] = [revOpDef, opDef];
    }
    return operator;
  };
  var formatRule5 = (item, config2, meta, parentField = null) => {
    const properties = item.get("properties") || new import_immutable11.Map();
    const field = properties.get("field");
    let operator = properties.get("operator");
    if (field == null || operator == null)
      return void 0;
    const realOp = checkOp(config2, operator, field);
    if (!realOp) {
      meta.errors.push(`Operator ${operator} is not supported`);
      return void 0;
    }
    const isRev = realOp != operator;
    const [formattedValue, valueSrc, valueType] = formatItemValue2(
      config2,
      properties,
      meta,
      realOp,
      parentField,
      null
    );
    if (formattedValue === void 0)
      return void 0;
    const formattedField = formatField3(meta, config2, field, parentField);
    let res = formatExpression(
      meta,
      config2,
      properties,
      formattedField,
      formattedValue,
      realOp,
      valueSrc,
      valueType,
      isRev
    );
    return res;
  };
  var formatItemValue2 = (config2, properties, meta, operator, parentField, expectedValueType = null) => {
    let field = properties.get("field");
    const iValueSrc = properties.get("valueSrc");
    const iValueType = properties.get("valueType");
    if (expectedValueType == "!case_value" || iValueType && iValueType.get(0) == "case_value") {
      field = "!case_value";
    }
    const fieldDef = getFieldConfig(config2, field) || {};
    const operatorDefinition = getOperatorConfig(config2, operator, field) || {};
    const cardinality = defaultValue3(operatorDefinition.cardinality, 1);
    const iValue = properties.get("value");
    const asyncListValues = properties.get("asyncListValues");
    let valueSrcs = [];
    let valueTypes = [];
    let formattedValue;
    if (iValue != void 0) {
      const fvalue = iValue.map((currentValue, ind) => {
        const valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
        const valueType = iValueType ? iValueType.get(ind) : null;
        const cValue = completeValue(currentValue, valueSrc, config2);
        const widget = getWidgetForFieldOp(config2, field, operator, valueSrc);
        const fieldWidgetDef = (0, import_omit5.default)(getFieldWidgetConfig(config2, field, operator, widget, valueSrc), ["factory"]);
        const fv = formatValue4(
          meta,
          config2,
          cValue,
          valueSrc,
          valueType,
          fieldWidgetDef,
          fieldDef,
          operator,
          operatorDefinition,
          parentField,
          asyncListValues
        );
        if (fv !== void 0) {
          valueSrcs.push(valueSrc);
          valueTypes.push(valueType);
        }
        return fv;
      });
      const hasUndefinedValues = fvalue.filter((v) => v === void 0).size > 0;
      if (!(fvalue.size < cardinality || hasUndefinedValues)) {
        formattedValue = cardinality > 1 ? fvalue.toArray() : cardinality == 1 ? fvalue.first() : null;
      }
    }
    return [
      formattedValue,
      valueSrcs.length > 1 ? valueSrcs : valueSrcs[0],
      valueTypes.length > 1 ? valueTypes : valueTypes[0]
    ];
  };
  var formatValue4 = (meta, config2, currentValue, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, operatorDef, parentField = null, asyncListValues) => {
    if (currentValue === void 0)
      return void 0;
    let ret;
    if (valueSrc == "field") {
      ret = formatField3(meta, config2, currentValue, parentField);
    } else if (valueSrc == "func") {
      ret = formatFunc4(meta, config2, currentValue, parentField);
    } else {
      if (typeof fieldWidgetDef.spelFormatValue === "function") {
        const fn2 = fieldWidgetDef.spelFormatValue;
        const args = [
          currentValue,
          {
            ...(0, import_pick4.default)(fieldDef, ["fieldSettings", "listValues"]),
            asyncListValues
          },
          //useful options: valueFormat for date/time
          (0, import_omit5.default)(fieldWidgetDef, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue"])
        ];
        if (operator) {
          args.push(operator);
          args.push(operatorDef);
        }
        if (valueSrc == "field") {
          const valFieldDefinition = getFieldConfig(config2, currentValue) || {};
          args.push(valFieldDefinition);
        }
        ret = fn2(...args);
      } else {
        ret = spelEscape(currentValue);
      }
    }
    return ret;
  };
  var formatField3 = (meta, config2, field, parentField = null) => {
    if (!field)
      return;
    const { fieldSeparator } = config2.settings;
    const fieldDefinition = getFieldConfig(config2, field) || {};
    const fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);
    const _fieldKeys = getFieldPath(field, config2, parentField);
    const fieldPartsConfigs = getFieldPartsConfigs(field, config2, parentField);
    const formatFieldFn = config2.settings.formatSpelField;
    let fieldName = formatFieldName(field, config2, meta);
    if (parentField) {
      const parentFieldDef = getFieldConfig(config2, parentField) || {};
      let parentFieldName = parentField;
      if (parentFieldDef.fieldName) {
        parentFieldName = parentFieldDef.fieldName;
      }
      if (fieldName.indexOf(parentFieldName + fieldSeparator) == 0) {
        fieldName = fieldName.slice((parentFieldName + fieldSeparator).length);
      } else {
        meta.errors.push(`Can't cut group ${parentFieldName} from field ${fieldName}`);
      }
    }
    const fieldPartsMeta = fieldPartsConfigs.map(([key, cnf, parentCnf]) => {
      let parent;
      if (parentCnf) {
        if (parentCnf.type == "!struct" || parentCnf.type == "!group" && parentCnf.mode == "struct")
          parent = cnf.isSpelMap ? "map" : "class";
        else if (parentCnf.type == "!group")
          parent = cnf.isSpelItemMap ? "[map]" : "[class]";
        else
          parent = "class";
      }
      const isSpelVariable = cnf?.isSpelVariable;
      return {
        key,
        parent,
        isSpelVariable
      };
    });
    const formattedField = formatFieldFn(fieldName, parentField, fieldParts, fieldPartsMeta, fieldDefinition, config2);
    return formattedField;
  };
  var formatFunc4 = (meta, config2, currentValue, parentField = null) => {
    const funcKey = currentValue.get("func");
    const args = currentValue.get("args");
    const funcConfig = getFuncConfig(config2, funcKey);
    const funcName = funcConfig.spelFunc || funcKey;
    let formattedArgs = {};
    for (const argKey in funcConfig.args) {
      const argConfig = funcConfig.args[argKey];
      const fieldDef = getFieldConfig(config2, argConfig);
      const argVal = args ? args.get(argKey) : void 0;
      const argValue = argVal ? argVal.get("value") : void 0;
      const argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
      const argAsyncListValues = argVal ? argVal.get("asyncListValues") : void 0;
      const formattedArgVal = formatValue4(
        meta,
        config2,
        argValue,
        argValueSrc,
        argConfig.type,
        fieldDef,
        argConfig,
        null,
        null,
        parentField,
        argAsyncListValues
      );
      if (argValue != void 0 && formattedArgVal === void 0) {
        meta.errors.push(`Can't format value of arg ${argKey} for func ${funcKey}`);
        return void 0;
      }
      if (formattedArgVal !== void 0) {
        formattedArgs[argKey] = formattedArgVal;
      }
    }
    let ret;
    if (typeof funcConfig.spelFormatFunc === "function") {
      const fn2 = funcConfig.spelFormatFunc;
      const args2 = [
        formattedArgs
      ];
      ret = fn2(...args2);
    } else {
      const args2 = Object.entries(formattedArgs).map(([k, v]) => v);
      if (funcName[0] == "." && args2.length) {
        const [obj, ...params] = args2;
        ret = `${obj}${funcName}(${params.join(", ")})`;
      } else {
        ret = `${funcName}(${args2.join(", ")})`;
      }
    }
    return ret;
  };

  // node_modules/@react-awesome-query-builder/core/modules/export/queryString.js
  var import_omit6 = __toESM(require_omit());
  var import_pick5 = __toESM(require_pick());
  var import_immutable12 = __toESM(require_immutable());
  var queryString = (item, config2, isForDisplay = false) => {
    let meta = {
      errors: []
    };
    const res = formatItem6(item, config2, meta, isForDisplay, null);
    if (meta.errors.length)
      console.warn("Errors while exporting to string:", meta.errors);
    return res;
  };
  var formatItem6 = (item, config2, meta, isForDisplay = false, parentField = null) => {
    if (!item)
      return void 0;
    const type = item.get("type");
    const children = item.get("children1");
    if (type === "group" || type === "rule_group") {
      return formatGroup6(item, config2, meta, isForDisplay, parentField);
    } else if (type === "rule") {
      return formatRule6(item, config2, meta, isForDisplay, parentField);
    }
    return void 0;
  };
  var formatGroup6 = (item, config2, meta, isForDisplay = false, parentField = null) => {
    const type = item.get("type");
    const properties = item.get("properties") || new import_immutable12.Map();
    const mode = properties.get("mode");
    const children = item.get("children1") || new import_immutable12.List();
    const isRuleGroup = type === "rule_group";
    const groupField = isRuleGroup && mode == "array" ? properties.get("field") : null;
    const canHaveEmptyChildren = isRuleGroup && mode == "array";
    const not = properties.get("not");
    const list = children.map((currentChild) => formatItem6(currentChild, config2, meta, isForDisplay, groupField)).filter((currentChild) => typeof currentChild !== "undefined");
    if (!canHaveEmptyChildren && !list.size)
      return void 0;
    let conjunction = properties.get("conjunction");
    if (!conjunction)
      conjunction = defaultConjunction(config2);
    const conjunctionDefinition = config2.conjunctions[conjunction];
    const conjStr = list.size ? conjunctionDefinition.formatConj(list, conjunction, not, isForDisplay) : null;
    let ret;
    if (groupField) {
      const aggrArgs = formatRule6(item, config2, meta, isForDisplay, parentField, true);
      if (aggrArgs) {
        const isRev = aggrArgs.pop();
        const args = [
          conjStr,
          ...aggrArgs
        ];
        ret = config2.settings.formatAggr(...args);
        if (isRev) {
          ret = config2.settings.formatReverse(ret, null, null, null, null, isForDisplay);
        }
      }
    } else {
      ret = conjStr;
    }
    return ret;
  };
  var formatItemValue3 = (config2, properties, meta, _operator, isForDisplay, parentField) => {
    const field = properties.get("field");
    const iValueSrc = properties.get("valueSrc");
    const iValueType = properties.get("valueType");
    const fieldDef = getFieldConfig(config2, field) || {};
    const operator = _operator || properties.get("operator");
    const operatorDef = getOperatorConfig(config2, operator, field) || {};
    const cardinality = defaultValue3(operatorDef.cardinality, 1);
    const iValue = properties.get("value");
    const asyncListValues = properties.get("asyncListValues");
    let valueSrcs = [];
    let valueTypes = [];
    let formattedValue;
    if (iValue != void 0) {
      const fvalue = iValue.map((currentValue, ind) => {
        const valueSrc = iValueSrc ? iValueSrc.get(ind) : null;
        const valueType = iValueType ? iValueType.get(ind) : null;
        const cValue = completeValue(currentValue, valueSrc, config2);
        const widget = getWidgetForFieldOp(config2, field, operator, valueSrc);
        const fieldWidgetDef = (0, import_omit6.default)(getFieldWidgetConfig(config2, field, operator, widget, valueSrc), ["factory"]);
        let fv = formatValue5(
          config2,
          meta,
          cValue,
          valueSrc,
          valueType,
          fieldWidgetDef,
          fieldDef,
          operator,
          operatorDef,
          isForDisplay,
          parentField,
          asyncListValues
        );
        if (fv !== void 0) {
          valueSrcs.push(valueSrc);
          valueTypes.push(valueType);
        }
        return fv;
      });
      const hasUndefinedValues = fvalue.filter((v) => v === void 0).size > 0;
      if (!(hasUndefinedValues || fvalue.size < cardinality)) {
        formattedValue = cardinality == 1 ? fvalue.first() : fvalue;
      }
    }
    return [
      formattedValue,
      valueSrcs.length > 1 ? valueSrcs : valueSrcs[0],
      valueTypes.length > 1 ? valueTypes : valueTypes[0]
    ];
  };
  var buildFnToFormatOp4 = (operator, operatorDefinition) => {
    const fop = operatorDefinition.labelForFormat || operator;
    const cardinality = defaultValue3(operatorDefinition.cardinality, 1);
    let fn2;
    if (cardinality == 0) {
      fn2 = (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        return `${field} ${fop}`;
      };
    } else if (cardinality == 1) {
      fn2 = (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        return `${field} ${fop} ${values}`;
      };
    } else if (cardinality == 2) {
      fn2 = (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        const valFrom = values.first();
        const valTo = values.get(1);
        return `${field} ${fop} ${valFrom} AND ${valTo}`;
      };
    }
    return fn2;
  };
  var formatRule6 = (item, config2, meta, isForDisplay = false, parentField = null, returnArgs = false) => {
    const properties = item.get("properties") || new import_immutable12.Map();
    const field = properties.get("field");
    let operator = properties.get("operator");
    let operatorOptions = properties.get("operatorOptions");
    if (field == null || operator == null)
      return void 0;
    const fieldDef = getFieldConfig(config2, field) || {};
    let operatorDef = getOperatorConfig(config2, operator, field) || {};
    let reversedOp = operatorDef.reversedOp;
    let revOperatorDef = getOperatorConfig(config2, reversedOp, field) || {};
    let isRev = false;
    let fn2 = operatorDef.formatOp;
    if (!fn2 && reversedOp) {
      fn2 = revOperatorDef.formatOp;
      if (fn2) {
        isRev = true;
        [operator, reversedOp] = [reversedOp, operator];
        [operatorDef, revOperatorDef] = [revOperatorDef, operatorDef];
      }
    }
    if (!fn2)
      fn2 = buildFnToFormatOp4(operator, operatorDef);
    if (!fn2)
      return void 0;
    const formattedField = formatField4(config2, meta, field, isForDisplay, parentField);
    const [formattedValue, valueSrc, valueType] = formatItemValue3(
      config2,
      properties,
      meta,
      operator,
      isForDisplay,
      parentField
    );
    if (formattedValue === void 0)
      return void 0;
    const args = [
      formattedField,
      operator,
      formattedValue,
      valueSrc,
      valueType,
      (0, import_omit6.default)(operatorDef, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic", "spelFormatOp"]),
      operatorOptions,
      isForDisplay,
      fieldDef,
      isRev
    ];
    if (returnArgs) {
      return args;
    } else {
      let ret = fn2(...args);
      if (isRev) {
        ret = config2.settings.formatReverse(ret, operator, reversedOp, operatorDef, revOperatorDef, isForDisplay);
      }
      return ret;
    }
  };
  var formatValue5 = (config2, meta, value, valueSrc, valueType, fieldWidgetDef, fieldDef, operator, opDef, isForDisplay, parentField = null, asyncListValues) => {
    if (value === void 0)
      return void 0;
    let ret;
    if (valueSrc == "field") {
      ret = formatField4(config2, meta, value, isForDisplay, parentField);
    } else if (valueSrc == "func") {
      ret = formatFunc5(config2, meta, value, isForDisplay, parentField);
    } else {
      if (typeof fieldWidgetDef.formatValue === "function") {
        const fn2 = fieldWidgetDef.formatValue;
        const args = [
          value,
          {
            ...(0, import_pick5.default)(fieldDef, ["fieldSettings", "listValues"]),
            asyncListValues
          },
          //useful options: valueFormat for date/time
          (0, import_omit6.default)(fieldWidgetDef, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic", "elasticSearchFormatValue", "spelFormatValue"]),
          isForDisplay
        ];
        if (operator) {
          args.push(operator);
          args.push(opDef);
        }
        if (valueSrc == "field") {
          const valFieldDefinition = getFieldConfig(config2, value) || {};
          args.push(valFieldDefinition);
        }
        ret = fn2(...args);
      } else {
        ret = value;
      }
    }
    return ret;
  };
  var formatField4 = (config2, meta, field, isForDisplay, parentField = null, cutParentField = true) => {
    const { fieldSeparator, fieldSeparatorDisplay } = config2.settings;
    let ret = null;
    if (field) {
      const fieldDefinition = getFieldConfig(config2, field) || {};
      const fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);
      const _fieldKeys = getFieldPath(field, config2);
      const fieldPartsLabels = getFieldPathLabels(field, config2, cutParentField ? parentField : null);
      const fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparatorDisplay) : null;
      const fieldLabel2 = fieldDefinition.label2 || fieldFullLabel;
      const formatFieldFn = config2.settings.formatField;
      const fieldName = formatFieldName(field, config2, meta, cutParentField ? parentField : null);
      ret = formatFieldFn(fieldName, fieldParts, fieldLabel2, fieldDefinition, config2, isForDisplay);
    }
    return ret;
  };
  var formatFunc5 = (config2, meta, funcValue, isForDisplay, parentField = null) => {
    const funcKey = funcValue.get("func");
    const args = funcValue.get("args");
    const funcConfig = getFuncConfig(config2, funcKey);
    const funcName = isForDisplay && funcConfig.label || funcKey;
    let formattedArgs = {};
    let formattedArgsWithNames = {};
    for (const argKey in funcConfig.args) {
      const argConfig = funcConfig.args[argKey];
      const fieldDef = getFieldConfig(config2, argConfig);
      const argVal = args ? args.get(argKey) : void 0;
      const argValue = argVal ? argVal.get("value") : void 0;
      const argValueSrc = argVal ? argVal.get("valueSrc") : void 0;
      const argAsyncListValues = argVal ? argVal.get("asyncListValues") : void 0;
      const formattedArgVal = formatValue5(
        config2,
        meta,
        argValue,
        argValueSrc,
        argConfig.type,
        fieldDef,
        argConfig,
        null,
        null,
        isForDisplay,
        parentField,
        argAsyncListValues
      );
      const argName = isForDisplay && argConfig.label || argKey;
      if (formattedArgVal !== void 0) {
        formattedArgs[argKey] = formattedArgVal;
        formattedArgsWithNames[argName] = formattedArgVal;
      }
    }
    let ret = null;
    if (typeof funcConfig.formatFunc === "function") {
      const fn2 = funcConfig.formatFunc;
      const args2 = [
        formattedArgs,
        isForDisplay
      ];
      ret = fn2(...args2);
    } else {
      const argsStr = Object.entries(formattedArgsWithNames).map(([k, v]) => isForDisplay ? `${k}: ${v}` : `${v}`).join(", ");
      ret = `${funcName}(${argsStr})`;
    }
    return ret;
  };

  // node_modules/@react-awesome-query-builder/core/modules/export/elasticSearch.js
  function buildEsGeoPoint(geoPointString) {
    if (geoPointString == null) {
      return null;
    }
    const coordsNumberArray = geoPointString.split(",").map(Number);
    return {
      top_left: {
        lat: coordsNumberArray[0],
        lon: coordsNumberArray[1]
      },
      bottom_right: {
        lat: coordsNumberArray[2],
        lon: coordsNumberArray[3]
      }
    };
  }
  function buildEsRangeParameters(value, operator) {
    if (value.length > 1) {
      return {
        gte: "".concat(value[0]),
        lte: "".concat(value[1])
      };
    }
    const dateTime = value[0];
    switch (operator) {
      case "on_date":
      case "not_on_date":
      case "equal":
      case "select_equals":
      case "not_equal":
        return {
          gte: "".concat(dateTime, "||/d"),
          lte: "".concat(dateTime, "||+1d")
        };
      case "less_or_equal":
        return {
          lte: "".concat(dateTime)
        };
      case "greater_or_equal":
        return {
          gte: "".concat(dateTime)
        };
      case "less":
        return {
          lt: "".concat(dateTime)
        };
      case "greater":
        return {
          gt: "".concat(dateTime)
        };
      default:
        return void 0;
    }
  }
  function buildEsWildcardParameters(value) {
    return {
      value: "*" + value + "*"
    };
  }
  function determineOccurrence(combinator, not) {
    switch (combinator) {
      case "AND":
        return not ? "must_not" : "must";
      case "OR":
        return not ? "should_not" : "should";
      case "NOT":
        return not ? "must" : "must_not";
      default:
        return void 0;
    }
  }
  function buildRegexpParameters(value) {
    return {
      value
    };
  }
  function determineField(fieldName, config2) {
    return fieldName;
  }
  function buildParameters(queryType, value, operator, fieldName, config2) {
    const textField = determineField(fieldName, config2);
    switch (queryType) {
      case "filter":
        return {
          script: config2.operators[operator].elasticSearchScript(fieldName, value)
        };
      case "exists":
        return { field: fieldName };
      case "match":
        return { [textField]: value[0] };
      case "term":
        return { [fieldName]: value[0] };
      case "geo_bounding_box":
        return { [fieldName]: buildEsGeoPoint(value[0]) };
      case "range":
        return { [fieldName]: buildEsRangeParameters(value, operator) };
      case "wildcard":
        return { [fieldName]: buildEsWildcardParameters(value[0]) };
      case "regexp":
        return { [fieldName]: buildRegexpParameters(value[0]) };
      default:
        return void 0;
    }
  }
  function buildEsRule(fieldName, value, operator, config2, valueSrc) {
    if (!fieldName || !operator || value == void 0)
      return void 0;
    let op = operator;
    let opConfig = config2.operators[op];
    if (!opConfig)
      return void 0;
    let { elasticSearchQueryType: elasticSearchQueryType2 } = opConfig;
    let not = false;
    if (!elasticSearchQueryType2 && opConfig.reversedOp) {
      not = true;
      op = opConfig.reversedOp;
      opConfig = config2.operators[op];
      ({ elasticSearchQueryType: elasticSearchQueryType2 } = opConfig);
    }
    const widget = getWidgetForFieldOp(config2, fieldName, op, valueSrc);
    const widgetConfig = config2.widgets[widget];
    if (!widgetConfig)
      return void 0;
    const { elasticSearchFormatValue: elasticSearchFormatValue2 } = widgetConfig;
    let queryType;
    if (typeof elasticSearchQueryType2 === "function") {
      queryType = elasticSearchQueryType2(widget);
    } else {
      queryType = elasticSearchQueryType2;
    }
    if (!queryType) {
      return void 0;
    }
    let parameters;
    if (typeof elasticSearchFormatValue2 === "function") {
      parameters = elasticSearchFormatValue2(queryType, value, op, fieldName, config2);
    } else {
      parameters = buildParameters(queryType, value, op, fieldName, config2);
    }
    if (not) {
      return {
        bool: {
          must_not: {
            [queryType]: { ...parameters }
          }
        }
      };
    } else {
      return {
        [queryType]: { ...parameters }
      };
    }
  }
  function buildEsGroup(children, conjunction, not, recursiveFxn, config2) {
    if (!children || !children.size)
      return void 0;
    const childrenArray = children.valueSeq().toArray();
    const occurrence = determineOccurrence(conjunction, not);
    const result = childrenArray.map((c) => recursiveFxn(c, config2)).filter((v) => v !== void 0);
    if (!result.length)
      return void 0;
    const resultFlat = result.flat(Infinity);
    return {
      bool: {
        [occurrence]: resultFlat
      }
    };
  }
  function elasticSearchFormat(tree2, config2) {
    if (!tree2)
      return void 0;
    const type = tree2.get("type");
    const properties = tree2.get("properties") || /* @__PURE__ */ new Map();
    if (type === "rule" && properties.get("field")) {
      const operator = properties.get("operator");
      const field = properties.get("field");
      const value = properties.get("value").toJS();
      const _valueType = properties.get("valueType")?.get(0);
      const valueSrc = properties.get("valueSrc")?.get(0);
      if (valueSrc === "func") {
        return;
      }
      if (value && Array.isArray(value[0])) {
        return value[0].map(
          (val) => buildEsRule(field, [val], operator, config2, valueSrc)
        );
      } else {
        return buildEsRule(field, value, operator, config2, valueSrc);
      }
    }
    if (type === "group" || type === "rule_group") {
      const not = properties.get("not");
      let conjunction = properties.get("conjunction");
      if (!conjunction)
        conjunction = defaultConjunction(config2);
      const children = tree2.get("children1");
      return buildEsGroup(children, conjunction, not, elasticSearchFormat, config2);
    }
  }

  // node_modules/@react-awesome-query-builder/core/modules/import/index.js
  var import_exports = {};
  __export(import_exports, {
    _loadFromJsonLogic: () => _loadFromJsonLogic,
    _loadFromSpel: () => _loadFromSpel,
    checkTree: () => checkTree,
    getTree: () => getTree,
    isImmutableTree: () => isImmutableTree,
    isJsonLogic: () => isJsonLogic,
    isTree: () => isTree,
    isValidTree: () => isValidTree,
    loadFromJsonLogic: () => loadFromJsonLogic,
    loadFromSpel: () => loadFromSpel,
    loadTree: () => loadTree
  });

  // node_modules/@react-awesome-query-builder/core/modules/import/tree.js
  var import_immutable13 = __toESM(require_immutable());
  var getTree = (immutableTree, light = true, children1AsArray = true) => {
    if (!immutableTree)
      return void 0;
    let tree2 = immutableTree;
    tree2 = tree2.toJS();
    if (light)
      tree2 = getLightTree(tree2, children1AsArray);
    return tree2;
  };
  var loadTree = (serTree) => {
    if (isImmutableTree(serTree)) {
      return serTree;
    } else if (isTree(serTree)) {
      return jsTreeToImmutable(serTree);
    } else if (typeof serTree == "string" && serTree.startsWith('["~#iM"')) {
      throw "You are trying to load query in obsolete serialization format (Immutable string) which is not supported in versions starting from 2.1.17";
    } else if (typeof serTree == "string") {
      return jsTreeToImmutable(JSON.parse(serTree));
    } else
      throw "Can't load tree!";
  };
  var checkTree = (tree2, config2) => {
    if (!tree2)
      return void 0;
    const extendedConfig = extendConfig(config2);
    return validateTree(tree2, null, extendedConfig, extendedConfig);
  };
  var isValidTree = (tree2) => {
    return getTreeBadFields(tree2).length == 0;
  };
  var isImmutableTree = (tree2) => {
    return import_immutable13.Map.isMap(tree2);
  };
  var isTree = (tree2) => {
    return typeof tree2 == "object" && (tree2.type == "group" || tree2.type == "switch_group");
  };
  function jsTreeToImmutable(tree2) {
    return (0, import_immutable13.fromJS)(tree2, function(key, value) {
      let outValue;
      if (key == "properties") {
        outValue = value.toOrderedMap();
        for (let i = 0; i < 2; i++) {
          if (outValue.get("value")?.get(i) === null) {
            outValue = outValue.setIn(["value", i], void 0);
          }
        }
      } else if (key == "value" && value.get(0) && value.get(0).toJS !== void 0) {
        const valueJs = value.get(0).toJS();
        if (valueJs.func) {
          outValue = value.toOrderedMap();
        } else {
          outValue = import_immutable13.default.List.of(valueJs);
        }
      } else if (key == "asyncListValues") {
        outValue = value.toJS();
      } else if (key == "children1" && import_immutable13.default.Iterable.isIndexed(value)) {
        outValue = new import_immutable13.default.OrderedMap(value.map((child) => [child.get("id"), child]));
      } else {
        outValue = import_immutable13.default.Iterable.isIndexed(value) ? value.toList() : value.toOrderedMap();
      }
      return outValue;
    });
  }

  // node_modules/@react-awesome-query-builder/core/modules/import/jsonLogic.js
  var import_moment2 = __toESM(require_moment());
  var arrayUniq = (arr) => Array.from(new Set(arr));
  var loadFromJsonLogic = (logicTree, config2) => {
    return _loadFromJsonLogic(logicTree, config2, false);
  };
  var _loadFromJsonLogic = (logicTree, config2, returnErrors = true) => {
    let meta = {
      errors: []
    };
    const extendedConfig = extendConfig(config2);
    const conv = buildConv(extendedConfig);
    let jsTree = logicTree ? convertFromLogic(logicTree, conv, extendedConfig, "rule", meta) : void 0;
    if (jsTree && jsTree.type != "group") {
      jsTree = wrapInDefaultConj(jsTree, extendedConfig);
    }
    const immTree = jsTree ? loadTree(jsTree) : void 0;
    if (returnErrors) {
      return [immTree, meta.errors];
    } else {
      if (meta.errors.length)
        console.warn("Errors while importing from JsonLogic:", meta.errors);
      return immTree;
    }
  };
  var buildConv = (config2) => {
    let operators3 = {};
    for (let opKey in config2.operators) {
      const opConfig = config2.operators[opKey];
      if (typeof opConfig.jsonLogic == "string") {
        const opk = (opConfig._jsonLogicIsRevArgs ? "#" : "") + opConfig.jsonLogic + "/" + defaultValue3(opConfig.cardinality, 1);
        if (!operators3[opk])
          operators3[opk] = [];
        operators3[opk].push(opKey);
      } else if (typeof opConfig.jsonLogic2 == "string") {
        const opk = opConfig.jsonLogic2 + "/" + defaultValue3(opConfig.cardinality, 1);
        if (!operators3[opk])
          operators3[opk] = [];
        operators3[opk].push(opKey);
      }
    }
    let conjunctions3 = {};
    for (let conjKey in config2.conjunctions) {
      const conjunctionDefinition = config2.conjunctions[conjKey];
      const ck = conjunctionDefinition.jsonLogicConj || conjKey.toLowerCase();
      conjunctions3[ck] = conjKey;
    }
    let funcs = {};
    for (let funcKey in config2.funcs) {
      const funcConfig = config2.funcs[funcKey];
      let fk;
      if (funcConfig.jsonLogicIsMethod) {
        fk = "#" + funcConfig.jsonLogic;
      } else if (typeof funcConfig.jsonLogic == "string") {
        fk = funcConfig.jsonLogic;
      }
      if (fk) {
        if (!funcs[fk])
          funcs[fk] = [];
        funcs[fk].push(funcKey);
      }
    }
    const { groupVarKey, altVarKey } = config2.settings.jsonLogic;
    return {
      operators: operators3,
      conjunctions: conjunctions3,
      funcs,
      varKeys: ["var", groupVarKey, altVarKey]
    };
  };
  var convertFromLogic = (logic, conv, config2, expectedType, meta, not = false, fieldConfig, widget, parentField = null, _isLockedLogic = false) => {
    let op, vals;
    if (isJsonLogic(logic)) {
      op = Object.keys(logic)[0];
      vals = logic[op];
      if (!Array.isArray(vals))
        vals = [vals];
    }
    let ret;
    let beforeErrorsCnt = meta.errors.length;
    const { lockedOp } = config2.settings.jsonLogic;
    const isEmptyOp = op == "!" && (vals.length == 1 && vals[0] && isJsonLogic(vals[0]) && conv.varKeys.includes(Object.keys(vals[0])[0]));
    const isRev = op == "!" && !isEmptyOp;
    const isLocked = lockedOp && op == lockedOp;
    if (isLocked) {
      ret = convertFromLogic(vals[0], conv, config2, expectedType, meta, not, fieldConfig, widget, parentField, true);
    } else if (isRev) {
      ret = convertFromLogic(vals[0], conv, config2, expectedType, meta, !not, fieldConfig, widget, parentField);
    } else if (expectedType == "val") {
      ret = convertField(op, vals, conv, config2, not, meta, parentField) || convertFunc(op, vals, conv, config2, not, fieldConfig, meta, parentField) || convertVal(logic, fieldConfig, widget, config2, meta);
    } else if (expectedType == "rule") {
      ret = convertConj(op, vals, conv, config2, not, meta, parentField, false) || convertOp(op, vals, conv, config2, not, meta, parentField);
    }
    let afterErrorsCnt = meta.errors.length;
    if (op != "!" && ret === void 0 && afterErrorsCnt == beforeErrorsCnt) {
      meta.errors.push(`Can't parse logic ${JSON.stringify(logic)}`);
    }
    if (isLocked) {
      ret.properties.isLocked = true;
    }
    return ret;
  };
  var convertVal = (val, fieldConfig, widget, config2, meta) => {
    if (val === void 0)
      return void 0;
    const widgetConfig = config2.widgets[widget || fieldConfig.mainWidget];
    if (!widgetConfig) {
      meta.errors.push(`No widget for type ${fieldConfig.type}`);
      return void 0;
    }
    if (isJsonLogic(val)) {
      meta.errors.push(`Unexpected logic in value: ${JSON.stringify(val)}`);
      return void 0;
    }
    if (fieldConfig && fieldConfig.type == "time" && typeof val == "number") {
      const [h, m, s] = [Math.floor(val / 60 / 60) % 24, Math.floor(val / 60) % 60, val % 60];
      const valueFormat = widgetConfig.valueFormat;
      if (valueFormat) {
        const dateVal = new Date(val);
        dateVal.setMilliseconds(0);
        dateVal.setHours(h);
        dateVal.setMinutes(m);
        dateVal.setSeconds(s);
        val = (0, import_moment2.default)(dateVal).format(valueFormat);
      } else {
        val = `${h}:${m}:${s}`;
      }
    }
    if (fieldConfig && ["date", "datetime"].includes(fieldConfig.type) && val && !(val instanceof Date)) {
      try {
        const dateVal = new Date(val);
        if (dateVal instanceof Date && dateVal.toISOString() === val) {
          val = dateVal;
        }
      } catch (e) {
        meta.errors.push(`Can't convert value ${val} as Date`);
        val = void 0;
      }
    }
    if (val instanceof Date && fieldConfig) {
      const valueFormat = widgetConfig.valueFormat;
      if (valueFormat) {
        val = (0, import_moment2.default)(val).format(valueFormat);
      }
    }
    let asyncListValues;
    if (val && fieldConfig.fieldSettings && fieldConfig.fieldSettings.asyncFetch) {
      const vals = Array.isArray(val) ? val : [val];
      asyncListValues = vals;
    }
    return {
      valueSrc: "value",
      value: val,
      valueType: widgetConfig.type,
      asyncListValues
    };
  };
  var convertField = (op, vals, conv, config2, not, meta, parentField = null) => {
    const { fieldSeparator } = config2.settings;
    if (conv.varKeys.includes(op) && typeof vals[0] == "string") {
      let field = vals[0];
      if (parentField)
        field = [parentField, field].join(fieldSeparator);
      field = normalizeField(config2, field);
      const fieldConfig = getFieldConfig(config2, field);
      if (!fieldConfig) {
        meta.errors.push(`No config for field ${field}`);
        return void 0;
      }
      return {
        valueSrc: "field",
        value: field,
        valueType: fieldConfig.type
      };
    }
    return void 0;
  };
  var convertFunc = (op, vals, conv, config2, not, fieldConfig, meta, parentField = null) => {
    if (!op)
      return void 0;
    let func, argsArr, funcKey;
    const jsonLogicIsMethod = op == "method";
    if (jsonLogicIsMethod) {
      let obj, opts;
      [obj, func, ...opts] = vals;
      argsArr = [obj, ...opts];
    } else {
      func = op;
      argsArr = vals;
    }
    const fk = (jsonLogicIsMethod ? "#" : "") + func;
    const funcKeys = (conv.funcs[fk] || []).filter(
      (k) => fieldConfig ? config2.funcs[k].returnType == fieldConfig.type : true
    );
    if (funcKeys.length) {
      funcKey = funcKeys[0];
    } else {
      const v = { [op]: vals };
      for (const [f, fc] of Object.entries(config2.funcs || {})) {
        if (fc.jsonLogicImport && fc.returnType == fieldConfig.type) {
          let parsed;
          try {
            parsed = fc.jsonLogicImport(v);
          } catch (_e) {
          }
          if (parsed) {
            funcKey = f;
            argsArr = parsed;
          }
        }
      }
    }
    if (!funcKey)
      return void 0;
    if (funcKey) {
      const funcConfig = config2.funcs[funcKey];
      const argKeys = Object.keys(funcConfig.args || {});
      let args = argsArr.reduce((acc, val, ind) => {
        const argKey = argKeys[ind];
        const argConfig = funcConfig.args[argKey];
        let argVal = convertFromLogic(val, conv, config2, "val", meta, false, argConfig, null, parentField);
        if (argVal === void 0) {
          argVal = argConfig.defaultValue;
          if (argVal === void 0) {
            meta.errors.push(`No value for arg ${argKey} of func ${funcKey}`);
            return void 0;
          }
        }
        return { ...acc, [argKey]: argVal };
      }, {});
      return {
        valueSrc: "func",
        value: {
          func: funcKey,
          args
        },
        valueType: funcConfig.returnType
      };
    }
    return void 0;
  };
  var convertConj = (op, vals, conv, config2, not, meta, parentField = null, isRuleGroup = false) => {
    const conjKey = conv.conjunctions[op];
    const { fieldSeparator } = config2.settings;
    const parentFieldConfig = parentField ? getFieldConfig(config2, parentField) : null;
    const isParentGroup = parentFieldConfig?.type == "!group";
    if (conjKey) {
      let type = "group";
      const children = vals.map((v) => convertFromLogic(v, conv, config2, "rule", meta, false, null, null, parentField)).filter((r) => r !== void 0).reduce((acc, r) => ({ ...acc, [r.id]: r }), {});
      const complexFields = Object.values(children).map((v) => v?.properties?.field).filter((f) => f && f.includes(fieldSeparator));
      const complexFieldsGroupAncestors = Object.fromEntries(
        arrayUniq(complexFields).map((f) => {
          const parts2 = f.split(fieldSeparator);
          const ancs = Object.fromEntries(
            parts2.slice(0, -1).map((f2, i, parts3) => [...parts3.slice(0, i), f2]).map((fp) => [fp.join(fieldSeparator), getFieldConfig(config2, fp)]).filter(([_f, fc]) => fc.type == "!group")
          );
          return [f, Object.keys(ancs)];
        })
      );
      const childrenInRuleGroup = Object.values(children).map((v) => v?.properties?.field).map((f) => complexFieldsGroupAncestors[f]).filter((ancs) => ancs && ancs.length);
      const usedRuleGroups = arrayUniq(Object.values(complexFieldsGroupAncestors).flat());
      const usedTopRuleGroups = topLevelFieldsFilter(usedRuleGroups);
      let properties = {
        conjunction: conjKey,
        not
      };
      const id = uuid_default();
      let children1 = {};
      let groupToId = {};
      Object.entries(children).map(([k, v]) => {
        if (v.type == "group" || v.type == "rule_group") {
          children1[k] = v;
        } else {
          const field = v?.properties?.field;
          const groupAncestors = complexFieldsGroupAncestors[field];
          const groupField = groupAncestors?.at(-1);
          if (!groupField) {
            children1[k] = v;
          } else {
            let ch = children1;
            let parentFieldParts = parentField ? parentField.split(fieldSeparator) : [];
            const isInParent = shallowEqual(parentFieldParts, groupField.split(fieldSeparator).slice(0, parentFieldParts.length));
            if (!isInParent)
              parentFieldParts = [];
            const traverseGroupFields = groupField.split(fieldSeparator).slice(parentFieldParts.length).map((f, i, parts2) => [...parentFieldParts, ...parts2.slice(0, i), f].join(fieldSeparator)).map((f) => normalizeField(config2, f)).map((f) => ({ f, fc: getFieldConfig(config2, f) || {} })).filter(({ fc }) => fc.type != "!struct");
            traverseGroupFields.map(({ f: gf, fc: gfc }, i) => {
              let groupId = groupToId[gf];
              if (!groupId) {
                groupId = uuid_default();
                groupToId[gf] = groupId;
                ch[groupId] = {
                  type: "rule_group",
                  id: groupId,
                  children1: {},
                  properties: {
                    conjunction: conjKey,
                    not: false,
                    field: gf,
                    mode: gfc.mode
                  }
                };
              }
              ch = ch[groupId].children1;
            });
            ch[k] = v;
          }
        }
      });
      return {
        type,
        id,
        children1,
        properties
      };
    }
    return void 0;
  };
  var topLevelFieldsFilter = (fields) => {
    let arr = [...fields].sort((a, b) => a.length - b.length);
    for (let i = 0; i < arr.length; i++) {
      for (let j = i + 1; j < arr.length; j++) {
        if (arr[j].indexOf(arr[i]) == 0) {
          arr.splice(j, 1);
          j--;
        }
      }
    }
    return arr;
  };
  var wrapInDefaultConjRuleGroup = (rule3, parentField, parentFieldConfig, config2, conj) => {
    if (!rule3)
      return void 0;
    return {
      type: "rule_group",
      id: uuid_default(),
      children1: { [rule3.id]: rule3 },
      properties: {
        conjunction: conj || defaultGroupConjunction(config2, parentFieldConfig),
        not: false,
        field: parentField
      }
    };
  };
  var wrapInDefaultConj = (rule3, config2, not = false) => {
    return {
      type: "group",
      id: uuid_default(),
      children1: { [rule3.id]: rule3 },
      properties: {
        conjunction: defaultConjunction(config2),
        not
      }
    };
  };
  var parseRule = (op, arity, vals, parentField, conv, config2, meta) => {
    let errors = [];
    let res = _parseRule(op, arity, vals, parentField, conv, config2, errors, false) || _parseRule(op, arity, vals, parentField, conv, config2, errors, true);
    if (!res) {
      meta.errors.push(errors.join("; ") || `Unknown op ${op}/${arity}`);
      return void 0;
    }
    return res;
  };
  var _parseRule = (op, arity, vals, parentField, conv, config2, errors, isRevArgs) => {
    const isAllOrSomeInForMultiselect = (op == "all" || op == "some") && isJsonLogic(vals[1]) && Object.keys(vals[1])[0] == "in";
    const isGroup0 = !isAllOrSomeInForMultiselect && config2.settings.groupOperators.includes(op);
    const eqOps = ["==", "!="];
    let cardinality = isGroup0 ? 0 : arity - 1;
    if (isGroup0)
      cardinality = 0;
    else if (eqOps.includes(op) && cardinality == 1 && vals[1] === null)
      cardinality = 0;
    const opk = op + "/" + cardinality;
    const { fieldSeparator } = config2.settings;
    let opKeys = conv.operators[(isRevArgs ? "#" : "") + opk];
    if (!opKeys)
      return;
    let jlField, args = [];
    const rangeOps = ["<", "<=", ">", ">="];
    if (rangeOps.includes(op) && arity == 3) {
      jlField = vals[1];
      args = [vals[0], vals[2]];
    } else if (isRevArgs) {
      jlField = vals[1];
      args = [vals[0]];
    } else {
      [jlField, ...args] = vals;
    }
    if (!isJsonLogic(jlField)) {
      errors.push(`Incorrect operands for ${op}: ${JSON.stringify(vals)}`);
      return;
    }
    let k = Object.keys(jlField)[0];
    let v = Object.values(jlField)[0];
    let field, having, isGroup;
    if (conv.varKeys.includes(k) && typeof v == "string") {
      field = v;
    }
    if (isGroup0) {
      isGroup = true;
      having = args[0];
      args = [];
    }
    if (k == "reduce" && Array.isArray(v) && v.length == 3) {
      let [filter3, acc, init] = v;
      if (isJsonLogic(filter3) && init == 0 && isJsonLogic(acc) && Array.isArray(acc["+"]) && acc["+"][0] == 1 && isJsonLogic(acc["+"][1]) && acc["+"][1]["var"] == "accumulator") {
        k = Object.keys(filter3)[0];
        v = Object.values(filter3)[0];
        if (k == "filter") {
          let [group3, filter4] = v;
          if (isJsonLogic(group3)) {
            k = Object.keys(group3)[0];
            v = Object.values(group3)[0];
            if (conv.varKeys.includes(k) && typeof v == "string") {
              field = v;
              having = filter4;
              isGroup = true;
            }
          }
        } else if (conv.varKeys.includes(k) && typeof v == "string") {
          field = v;
          isGroup = true;
        }
      }
    }
    if (!field) {
      errors.push(`Unknown field ${JSON.stringify(jlField)}`);
      return;
    }
    if (parentField)
      field = [parentField, field].join(fieldSeparator);
    field = normalizeField(config2, field);
    const fieldConfig = getFieldConfig(config2, field);
    if (!fieldConfig) {
      errors.push(`No config for field ${field}`);
      return;
    }
    let opKey = opKeys[0];
    if (opKeys.length > 1 && fieldConfig && fieldConfig.operators) {
      opKeys = opKeys.filter((k2) => fieldConfig.operators.includes(k2));
      if (opKeys.length == 0) {
        errors.push(`No corresponding ops for field ${field}`);
        return;
      }
      opKey = opKeys[0];
    }
    return {
      field,
      fieldConfig,
      opKey,
      args,
      having
    };
  };
  var convertOp = (op, vals, conv, config2, not, meta, parentField = null) => {
    if (!op)
      return void 0;
    const arity = vals.length;
    if ((op == "all" || op == "some") && isJsonLogic(vals[1])) {
      const op2 = Object.keys(vals[1])[0];
      if (op2 == "in") {
        vals = [
          vals[0],
          vals[1][op2][1]
        ];
        op = op + "-" + op2;
      }
    }
    const parseRes = parseRule(op, arity, vals, parentField, conv, config2, meta);
    if (!parseRes)
      return void 0;
    let { field, fieldConfig, opKey, args, having } = parseRes;
    let opConfig = config2.operators[opKey];
    const showNot = fieldConfig.showNot !== void 0 ? fieldConfig.showNot : config2.settings.showNot;
    let canRev = true;
    let conj;
    let havingVals;
    let havingNot = false;
    if (fieldConfig.type == "!group" && having) {
      conj = Object.keys(having)[0];
      havingVals = having[conj];
      if (!Array.isArray(havingVals))
        havingVals = [havingVals];
      const isEmptyOp = conj == "!" && (havingVals.length == 1 && havingVals[0] && isJsonLogic(havingVals[0]) && conv.varKeys.includes(Object.keys(havingVals[0])[0]));
      if (conj == "!" && !isEmptyOp) {
        havingNot = true;
        having = having["!"];
        conj = Object.keys(having)[0];
        havingVals = having[conj];
        if (!Array.isArray(havingVals))
          havingVals = [havingVals];
      }
    }
    if (not && canRev && opConfig.reversedOp) {
      not = false;
      opKey = opConfig.reversedOp;
      opConfig = config2.operators[opKey];
    }
    const widget = getWidgetForFieldOp(config2, field, opKey);
    const convertedArgs = args.map((v) => convertFromLogic(v, conv, config2, "val", meta, false, fieldConfig, widget, parentField));
    if (convertedArgs.filter((v) => v === void 0).length) {
      return void 0;
    }
    let res;
    if (fieldConfig.type == "!group" && having) {
      if (conv.conjunctions[conj] !== void 0) {
        res = convertConj(conj, havingVals, conv, config2, havingNot, meta, field, true);
        havingNot = false;
      } else {
        const rule3 = convertOp(conj, havingVals, conv, config2, havingNot, meta, field);
        havingNot = false;
        res = wrapInDefaultConjRuleGroup(rule3, field, fieldConfig, config2, conv.conjunctions["and"]);
      }
      if (!res)
        return void 0;
      res.type = "rule_group";
      Object.assign(res.properties, {
        field,
        mode: fieldConfig.mode,
        operator: opKey
      });
      if (fieldConfig.mode == "array") {
        Object.assign(res.properties, {
          value: convertedArgs.map((v) => v.value),
          valueSrc: convertedArgs.map((v) => v.valueSrc),
          valueType: convertedArgs.map((v) => v.valueType)
        });
      }
      if (not) {
        res = wrapInDefaultConj(res, config2, not);
      }
    } else if (fieldConfig.type == "!group" && !having) {
      res = {
        type: "rule_group",
        id: uuid_default(),
        children1: {},
        properties: {
          conjunction: defaultGroupConjunction(config2, fieldConfig),
          not,
          mode: fieldConfig.mode,
          field,
          operator: opKey
        }
      };
      if (fieldConfig.mode == "array") {
        Object.assign(res.properties, {
          value: convertedArgs.map((v) => v.value),
          valueSrc: convertedArgs.map((v) => v.valueSrc),
          valueType: convertedArgs.map((v) => v.valueType)
        });
      }
    } else {
      const asyncListValuesArr = convertedArgs.map((v) => v.asyncListValues).filter((v) => v != void 0);
      const asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : void 0;
      res = {
        type: "rule",
        id: uuid_default(),
        properties: {
          field,
          operator: opKey,
          value: convertedArgs.map((v) => v.value),
          valueSrc: convertedArgs.map((v) => v.valueSrc),
          valueType: convertedArgs.map((v) => v.valueType),
          asyncListValues
        }
      };
      if (not) {
        res = wrapInDefaultConj(res, config2, not);
      }
    }
    return res;
  };

  // node_modules/@react-awesome-query-builder/core/modules/import/spel.js
  var import_spel2js = __toESM(require_spel2js());
  var import_moment3 = __toESM(require_moment());
  var loadFromSpel = (logicTree, config2) => {
    return _loadFromSpel(logicTree, config2, true);
  };
  var _loadFromSpel = (spelStr, config2, returnErrors = true) => {
    let meta = {
      errors: []
    };
    const extendedConfig = extendConfig(config2);
    const conv = buildConv2(extendedConfig);
    let compiledExpression;
    let convertedObj;
    let jsTree = void 0;
    try {
      const compileRes = import_spel2js.SpelExpressionEvaluator.compile(spelStr);
      compiledExpression = compileRes._compiledExpression;
    } catch (e) {
      meta.errors.push(e);
    }
    if (compiledExpression) {
      logger.debug("compiledExpression:", compiledExpression);
      convertedObj = convertCompiled(compiledExpression, meta);
      logger.debug("convertedObj:", convertedObj, meta);
      jsTree = convertToTree(convertedObj, conv, extendedConfig, meta);
      if (jsTree && jsTree.type != "group" && jsTree.type != "switch_group") {
        jsTree = wrapInDefaultConj2(jsTree, extendedConfig, convertedObj["not"]);
      }
      logger.debug("jsTree:", jsTree);
    }
    const immTree = jsTree ? loadTree(jsTree) : void 0;
    if (returnErrors) {
      return [immTree, meta.errors];
    } else {
      if (meta.errors.length)
        console.warn("Errors while importing from SpEL:", meta.errors);
      return immTree;
    }
  };
  var convertCompiled = (expr, meta, parentExpr = null) => {
    const type = expr.getType();
    let children = expr.getChildren().map((child) => convertCompiled(child, meta, expr));
    if (type == "op-or" || type == "op-and") {
      children = children.reduce((acc, child) => {
        const canFlatize = child.type == type && !child.not;
        const flat = canFlatize ? child.children : [child];
        return [...acc, ...flat];
      }, []);
    }
    if (type == "op-not") {
      if (children.length != 1) {
        meta.errors.push(`Operator NOT should have 1 child, but got ${children.length}}`);
      }
      return {
        ...children[0],
        not: !(children[0].not || false)
      };
    }
    if (type == "compound") {
      children = children.filter((child) => {
        const isListFix = child.type == "selection" && child.children.length == 1 && child.children[0].type == "boolean" && child.children[0].val == true;
        return !isListFix;
      });
      const selection = children.find(
        (child) => child.type == "selection"
      );
      if (selection && selection.children.length != 1) {
        meta.errors.push(`Selection should have 1 child, but got ${selection.children.length}`);
      }
      const filter3 = selection ? selection.children[0] : null;
      const lastChild = children[children.length - 1];
      const isSize = lastChild.type == "method" && lastChild.val.methodName == "size" || lastChild.type == "!func" && lastChild.methodName == "size";
      const isLength = lastChild.type == "property" && lastChild.val == "length";
      const sourceParts = children.filter(
        (child) => child !== selection && child !== lastChild
      );
      const source = {
        type: "compound",
        children: sourceParts
      };
      if (isSize || isLength) {
        return {
          type: "!aggr",
          filter: filter3,
          source
        };
      }
      children = children.filter((child) => {
        const isThis = child.type == "variable" && child.val == "this";
        const isRoot = child.type == "variable" && child.val == "root";
        return !(isThis || isRoot);
      });
      children = children.map((child) => {
        if (child.type == "indexer" && child.children.length == 1) {
          return {
            type: "indexer",
            val: child.children[0].val,
            itype: child.children[0].type
          };
        } else {
          return child;
        }
      });
      if (lastChild.type == "method") {
        const obj = children.filter(
          (child) => child !== lastChild
        );
        return {
          type: "!func",
          obj,
          methodName: lastChild.val.methodName,
          args: lastChild.val.args
        };
      }
      if (lastChild.type == "!func") {
        const obj = children.filter(
          (child) => child !== lastChild
        );
        return {
          ...lastChild,
          obj
        };
      }
    }
    let val;
    try {
      if (expr.getRaw) {
        val = expr.getRaw();
      } else if (expr.getValue.length == 0) {
        val = expr.getValue();
      }
    } catch (e) {
      logger.error("[spel2js] Error in getValue()", e);
    }
    if (type == "ternary") {
      val = flatizeTernary(children);
    }
    if (typeof val === "object" && val !== null) {
      if (val.methodName || val.functionName) {
        val.args = val.args.map((child) => convertCompiled(child, meta, expr));
      }
    }
    if (type == "list") {
      val = val.map((item) => convertCompiled(item, meta, expr));
      if (!parentExpr && val.length == 1) {
        return val[0];
      }
    }
    if (type == "constructorref") {
      const qid = children.find((child) => child.type == "qualifiedidentifier");
      const cls = qid?.val;
      if (!cls) {
        meta.errors.push(`Can't find qualifiedidentifier in constructorref children: ${JSON.stringify(children)}`);
        return void 0;
      }
      const args = children.filter((child) => child.type != "qualifiedidentifier");
      return {
        type: "!new",
        cls,
        args
      };
    }
    if (type == "typeref") {
      const qid = children.find((child) => child.type == "qualifiedidentifier");
      const cls = qid?.val;
      if (!cls) {
        meta.errors.push(`Can't find qualifiedidentifier in typeref children: ${JSON.stringify(children)}`);
        return void 0;
      }
      const _args = children.filter((child) => child.type != "qualifiedidentifier");
      return {
        type: "!type",
        cls
      };
    }
    if (type == "function" || type == "method") {
      const { functionName, methodName, args } = val;
      return {
        type: "!func",
        methodName: functionName || methodName,
        isVar: type == "function",
        args
      };
    }
    return {
      type,
      children,
      val
    };
  };
  var flatizeTernary = (children) => {
    let flat = [];
    function _processTernaryChildren(tern) {
      let [cond, if_val, else_val] = tern;
      flat.push([cond, if_val]);
      if (else_val?.type == "ternary") {
        _processTernaryChildren(else_val.children);
      } else {
        flat.push([void 0, else_val]);
      }
    }
    _processTernaryChildren(children);
    return flat;
  };
  var buildConv2 = (config2) => {
    let operators3 = {};
    for (let opKey in config2.operators) {
      const opConfig = config2.operators[opKey];
      if (opConfig.spelOps) {
        opConfig.spelOps.forEach((spelOp) => {
          const opk = spelOp;
          if (!operators3[opk])
            operators3[opk] = [];
          operators3[opk].push(opKey);
        });
      } else if (opConfig.spelOp) {
        const opk = opConfig.spelOp;
        if (!operators3[opk])
          operators3[opk] = [];
        operators3[opk].push(opKey);
      } else {
        logger.log(`[spel] No spelOp for operator ${opKey}`);
      }
    }
    let conjunctions3 = {};
    for (let conjKey in config2.conjunctions) {
      const conjunctionDefinition = config2.conjunctions[conjKey];
      const ck = conjunctionDefinition.spelConj || conjKey.toLowerCase();
      conjunctions3[ck] = conjKey;
    }
    let funcs = {};
    for (let funcKey in config2.funcs) {
      const funcConfig = config2.funcs[funcKey];
      let fk;
      if (typeof funcConfig.spelFunc == "string") {
        fk = funcConfig.spelFunc;
      }
      if (fk) {
        if (!funcs[fk])
          funcs[fk] = [];
        funcs[fk].push(funcKey);
      }
    }
    return {
      operators: operators3,
      conjunctions: conjunctions3,
      funcs
    };
  };
  var convertPath = (parts2, meta) => {
    let isError2 = false;
    const res = parts2.map((c) => {
      if (c.type == "variable" || c.type == "property" || c.type == "indexer" && c.itype == "string") {
        return c.val;
      } else {
        isError2 = true;
        meta.errors.push(`Unexpected item in compound: ${JSON.stringify(c)}`);
      }
    });
    return !isError2 ? res : void 0;
  };
  var convertArg = (spel, conv, config2, meta, parentSpel) => {
    if (spel == void 0)
      return void 0;
    const { fieldSeparator } = config2.settings;
    const literalTypes = {
      number: "number",
      string: "text",
      boolean: "boolean",
      null: "null"
      // should not be
    };
    const groupFieldParts = parentSpel?._groupField ? [parentSpel?._groupField] : [];
    if (spel.type == "compound") {
      const parts2 = convertPath(spel.children, meta);
      if (!parts2) {
        return void 0;
      }
      const fullParts = [...groupFieldParts, ...parts2];
      const isVariable = spel.children?.[0]?.type == "variable";
      return {
        valueSrc: "field",
        //valueType: todo
        isVariable,
        value: fullParts.join(fieldSeparator)
      };
    } else if (spel.type == "variable" || spel.type == "property") {
      const fullParts = [...groupFieldParts, spel.val];
      const isVariable = spel.type == "variable";
      return {
        valueSrc: "field",
        //valueType: todo
        isVariable,
        value: fullParts.join(fieldSeparator)
      };
    } else if (literalTypes[spel.type]) {
      let value = spel.val;
      let valueType = literalTypes[spel.type];
      if (parentSpel?.isUnary) {
        value = -value;
      }
      return {
        valueSrc: "value",
        valueType,
        value
      };
    } else if (spel.type == "list") {
      const values = spel.val.map((v) => convertArg(v, conv, config2, meta, spel));
      const _itemType = values.length ? values[0]?.valueType : null;
      const value = values.map((v) => v?.value);
      const valueType = "multiselect";
      return {
        valueSrc: "value",
        valueType,
        value
      };
    } else if (spel.type == "!func") {
      const { obj, methodName, args, isVar } = spel;
      const funcToOpMap = {
        [".contains"]: "like",
        [".startsWith"]: "starts_with",
        [".endsWith"]: "ends_with",
        ["$contains"]: "select_any_in",
        [".equals"]: "multiselect_equals",
        //[".containsAll"]: "multiselect_contains",
        ["CollectionUtils.containsAny()"]: "multiselect_contains"
      };
      const convertedArgs = args.map((v) => convertArg(v, conv, config2, meta, {
        ...spel,
        _groupField: parentSpel?._groupField
      }));
      if (methodName == "contains" && obj && obj[0].type == "list") {
        const convertedObj = obj.map((v) => convertArg(v, conv, config2, meta, spel));
        if (!(convertedArgs.length == 1 && convertedArgs[0].valueSrc == "field")) {
          meta.errors.push(`Expected arg to method ${methodName} to be field but got: ${JSON.stringify(convertedArgs)}`);
          return void 0;
        }
        const field = convertedArgs[0].value;
        if (!(convertedObj.length == 1 && convertedObj[0].valueType == "multiselect")) {
          meta.errors.push(`Expected object of method ${methodName} to be inline list but got: ${JSON.stringify(convertedObj)}`);
          return void 0;
        }
        const opKey = funcToOpMap["$" + methodName];
        const list = convertedObj[0];
        return buildRule(config2, meta, field, opKey, [list], spel);
      } else if (obj && obj[0].type == "property" && funcToOpMap[obj[0].val + "." + methodName + "()"]) {
        const opKey = funcToOpMap[obj[0].val + "." + methodName + "()"];
        const field = convertedArgs[0].value;
        const args2 = convertedArgs.slice(1);
        return buildRule(config2, meta, field, opKey, args2, spel);
      } else if (funcToOpMap["." + methodName]) {
        const opKey = funcToOpMap["." + methodName];
        const parts2 = convertPath(obj, meta);
        if (parts2 && convertedArgs.length == 1) {
          const fullParts = [...groupFieldParts, ...parts2];
          const field = fullParts.join(fieldSeparator);
          return buildRule(config2, meta, field, opKey, convertedArgs, spel);
        }
      } else if (methodName == "parse" && obj && obj[0].type == "!new" && obj[0].cls.at(-1) == "SimpleDateFormat") {
        const args2 = obj[0].args.map((v) => convertArg(v, conv, config2, meta, {
          ...spel,
          _groupField: parentSpel?._groupField
        }));
        if (!(args2.length == 1 && args2[0].valueType == "text")) {
          meta.errors.push(`Expected args of ${obj[0].cls.join(".")}.${methodName} to be 1 string but got: ${JSON.stringify(args2)}`);
          return void 0;
        }
        if (!(convertedArgs.length == 1 && convertedArgs[0].valueType == "text")) {
          meta.errors.push(`Expected args of ${obj[0].cls.join(".")} to be 1 string but got: ${JSON.stringify(convertedArgs)}`);
          return void 0;
        }
        const dateFormat = args2[0].value;
        const dateString = convertedArgs[0].value;
        const valueType = dateFormat.includes(" ") ? "datetime" : "date";
        const field = null;
        const widget = valueType;
        const fieldConfig = getFieldConfig(config2, field);
        const widgetConfig = config2.widgets[widget || fieldConfig?.mainWidget];
        const valueFormat = widgetConfig.valueFormat;
        const dateVal = (0, import_moment3.default)(dateString, import_moment3.default.ISO_8601);
        const value = dateVal.isValid() ? dateVal.format(valueFormat) : void 0;
        return {
          valueSrc: "value",
          valueType,
          value
        };
      } else if (methodName == "parse" && obj && obj[0].type == "!type" && obj[0].cls.at(-1) == "LocalTime") {
        if (!(convertedArgs.length == 1 && convertedArgs[0].valueType == "text")) {
          meta.errors.push(`Expected args of ${obj[0].cls.join(".")} to be 1 string but got: ${JSON.stringify(convertedArgs)}`);
          return void 0;
        }
        const timeString = convertedArgs[0].value;
        const valueType = "time";
        const field = null;
        const widget = valueType;
        const fieldConfig = getFieldConfig(config2, field);
        const widgetConfig = config2.widgets[widget || fieldConfig?.mainWidget];
        const valueFormat = widgetConfig.valueFormat;
        const dateVal = (0, import_moment3.default)(timeString, "HH:mm:ss");
        const value = dateVal.isValid() ? dateVal.format(valueFormat) : void 0;
        return {
          valueSrc: "value",
          valueType,
          value
        };
      } else {
        meta.errors.push(`Unsupported method ${methodName}`);
      }
    } else if (spel.type == "op-plus" && parentSpel?.type == "ternary") {
      return buildCaseValueConcat(spel, conv, config2, meta);
    } else {
      meta.errors.push(`Can't convert arg of type ${spel.type}`);
    }
    return void 0;
  };
  var buildRule = (config2, meta, field, opKey, convertedArgs, spel) => {
    if (convertedArgs.filter((v) => v === void 0).length) {
      return void 0;
    }
    const fieldConfig = getFieldConfig(config2, field);
    if (!fieldConfig) {
      meta.errors.push(`No config for field ${field}`);
      return void 0;
    }
    let canRev = true;
    let needWrapReverse = false;
    if (spel?.not && canRev) {
      const opConfig = config2.operators[opKey];
      if (opConfig.reversedOp) {
        opKey = opConfig.reversedOp;
        spel.not = false;
      } else {
        needWrapReverse = true;
      }
    }
    const widget = getWidgetForFieldOp(config2, field, opKey);
    const widgetConfig = config2.widgets[widget || fieldConfig.mainWidget];
    const asyncListValuesArr = convertedArgs.map((v) => v.asyncListValues).filter((v) => v != void 0);
    const asyncListValues = asyncListValuesArr.length ? asyncListValuesArr[0] : void 0;
    let res = {
      type: "rule",
      id: uuid_default(),
      properties: {
        field,
        operator: opKey,
        value: convertedArgs.map((v) => v.value),
        valueSrc: convertedArgs.map((v) => v.valueSrc),
        valueType: convertedArgs.map((v) => {
          if (v.valueSrc == "value") {
            return widgetConfig?.type || fieldConfig?.type || v.valueType;
          }
          return v.valueType;
        }),
        asyncListValues
      }
    };
    if (needWrapReverse) {
      res = wrapInDefaultConj2(res, config2, spel?.not);
      if (spel?.not) {
        spel.not = false;
      }
    }
    return res;
  };
  var buildRuleGroup = ({ groupFilter, groupFieldValue }, opKey, convertedArgs, config2, meta) => {
    if (groupFieldValue.valueSrc != "field")
      throw `Bad groupFieldValue: ${JSON.stringify(groupFieldValue)}`;
    const groupField = groupFieldValue.value;
    let groupOpRule = buildRule(config2, meta, groupField, opKey, convertedArgs);
    if (!groupOpRule)
      return void 0;
    const fieldConfig = getFieldConfig(config2, groupField);
    const mode = fieldConfig?.mode;
    let res = {
      ...groupFilter || {},
      type: "rule_group",
      properties: {
        ...groupOpRule.properties,
        ...groupFilter?.properties || {},
        mode
      }
    };
    if (!res.id)
      res.id = uuid_default();
    return res;
  };
  var compareArgs = (left2, right2, spel, conv, config2, meta, parentSpel = null) => {
    if (left2.type == right2.type) {
      if (left2.type == "!aggr") {
        const [leftSource, rightSource] = [left2.source, right2.source].map((v) => convertArg(v, conv, config2, meta, {
          ...spel,
          _groupField: parentSpel?._groupField
        }));
        return leftSource.value == rightSource.value;
      } else {
        const [leftVal, rightVal] = [left2, right2].map((v) => convertArg(v, conv, config2, meta, {
          ...spel,
          _groupField: parentSpel?._groupField
        }));
        return leftVal.value == rightVal.value;
      }
    }
    return false;
  };
  var convertToTree = (spel, conv, config2, meta, parentSpel = null) => {
    if (!spel)
      return void 0;
    let res;
    if (spel.type.indexOf("op-") == 0) {
      let op = spel.type.slice("op-".length);
      const isUnary = (op == "minus" || op == "plus") && spel.children.length == 1;
      if (isUnary) {
        spel.isUnary = true;
        return convertToTree(spel.children[0], conv, config2, meta, spel);
      }
      let isBetweenNormal = op == "and" && spel.children.length == 2 && spel.children[0].type == "op-ge" && spel.children[1].type == "op-le";
      let isBetweenRev = op == "or" && spel.children.length == 2 && spel.children[0].type == "op-lt" && spel.children[1].type == "op-gt";
      let isBetween = isBetweenNormal || isBetweenRev;
      if (isBetween) {
        const [left2, from] = spel.children[0].children;
        const [right2, to] = spel.children[1].children;
        const isNumbers = from.type == "number" && to.type == "number";
        const isSameSource = compareArgs(left2, right2, spel, conv, config2, meta, parentSpel);
        if (isNumbers && isSameSource) {
          const _fromValue = from.val;
          const _toValue = to.val;
          const oneSpel = {
            type: "op-between",
            children: [
              left2,
              from,
              to
            ]
          };
          return convertToTree(oneSpel, conv, config2, meta, parentSpel);
        }
      }
      let opKeys = conv.operators[op];
      if (op == "eq" && spel.children[1].type == "null") {
        opKeys = ["is_null"];
      } else if (op == "ne" && spel.children[1].type == "null") {
        opKeys = ["is_not_null"];
      } else if (op == "le" && spel.children[1].type == "string" && spel.children[1].val == "") {
        opKeys = ["is_empty"];
      } else if (op == "gt" && spel.children[1].type == "string" && spel.children[1].val == "") {
        opKeys = ["is_not_empty"];
      } else if (op == "between") {
        opKeys = ["between"];
      }
      const convertChildren = () => spel.children.map(
        (child) => convertToTree(child, conv, config2, meta, {
          ...spel,
          _groupField: parentSpel?._groupField
        })
      );
      if (op == "and" || op == "or") {
        const children1 = {};
        const vals = convertChildren();
        vals.forEach((v) => {
          if (v) {
            const id = uuid_default();
            v.id = id;
            if (v.type != void 0) {
              children1[id] = v;
            } else {
              meta.errors.push(`Bad item in AND/OR: ${JSON.stringify(v)}`);
            }
          }
        });
        res = {
          type: "group",
          id: uuid_default(),
          children1,
          properties: {
            conjunction: conv.conjunctions[op],
            not: spel.not
          }
        };
      } else if (opKeys) {
        const vals = convertChildren();
        const fieldObj = vals[0];
        let convertedArgs = vals.slice(1);
        const groupField = fieldObj?.groupFieldValue?.value;
        const opArg = convertedArgs?.[0];
        let opKey = opKeys[0];
        if (opKeys.length > 1) {
          logger.warn(`[spel] Spel operator ${op} can be mapped to ${opKeys}`);
          const field = fieldObj?.value;
          const widgets3 = opKeys.map((op2) => ({ op: op2, widget: getWidgetForFieldOp(config2, field, op2) }));
          if (op == "eq" || op == "ne") {
            const ws = widgets3.find(({ op: op2, widget }) => widget && widget != "field");
            if (ws) {
              opKey = ws.op;
            }
          }
        }
        if (fieldObj?.groupFieldValue) {
          if (opArg && opArg.groupFieldValue && opArg.groupFieldValue.valueSrc == "field" && opArg.groupFieldValue.value == groupField) {
            opKey = "all";
            convertedArgs = [];
          } else if (opKey == "equal" && opArg.valueSrc == "value" && opArg.valueType == "number" && opArg.value == 0) {
            opKey = "none";
            convertedArgs = [];
          } else if (opKey == "greater" && opArg.valueSrc == "value" && opArg.valueType == "number" && opArg.value == 0) {
            opKey = "some";
            convertedArgs = [];
          }
        }
        let canRev = true;
        let needWrapReverse = false;
        if (spel.not && canRev) {
          const opConfig = config2.operators[opKey];
          if (opConfig.reversedOp) {
            opKey = opConfig.reversedOp;
            spel.not = false;
          } else {
            needWrapReverse = true;
          }
        }
        if (!fieldObj) {
        } else if (fieldObj.groupFieldValue) {
          if (fieldObj.groupFieldValue.valueSrc != "field") {
            meta.errors.push(`Expected group field ${JSON.stringify(fieldObj)}`);
          }
          res = buildRuleGroup(fieldObj, opKey, convertedArgs, config2, meta);
        } else {
          if (fieldObj.valueSrc != "field") {
            meta.errors.push(`Expected field ${JSON.stringify(fieldObj)}`);
          }
          const field = fieldObj.value;
          res = buildRule(config2, meta, field, opKey, convertedArgs);
        }
        if (needWrapReverse) {
          if (res.type !== "group") {
            res = wrapInDefaultConj2(res, config2, spel.not);
          } else {
            res.properties.not = !res.properties.not;
          }
        }
      } else {
        if (!parentSpel) {
          res = buildSimpleSwitch(spel, conv, config2, meta);
        }
        if (!res) {
          meta.errors.push(`Can't convert op ${op}`);
        }
      }
    } else if (spel.type == "!aggr") {
      const groupFieldValue = convertToTree(spel.source, conv, config2, meta, {
        ...spel,
        _groupField: parentSpel?._groupField
      });
      let groupFilter = convertToTree(spel.filter, conv, config2, meta, {
        ...spel,
        _groupField: groupFieldValue?.value
      });
      if (groupFilter?.type == "rule") {
        groupFilter = wrapInDefaultConj2(groupFilter, config2, spel.filter.not);
      }
      res = {
        groupFilter,
        groupFieldValue
      };
      if (!parentSpel) {
        res = void 0;
        meta.errors.push("Unexpected !aggr in root");
      }
    } else if (spel.type == "ternary") {
      const children1 = {};
      spel.val.forEach((v) => {
        const [cond, val] = v;
        const caseI = buildCase(cond, val, conv, config2, meta, spel);
        if (caseI) {
          children1[caseI.id] = caseI;
        }
      });
      res = {
        type: "switch_group",
        id: uuid_default(),
        children1,
        properties: {}
      };
    } else {
      res = convertArg(spel, conv, config2, meta, parentSpel);
      if (res && !res.type && !parentSpel) {
        const sw = buildSimpleSwitch(spel, conv, config2, meta);
        if (sw) {
          res = sw;
        } else {
          res = void 0;
          meta.errors.push(`Can't convert rule of type ${spel.type}, it looks like var/literal`);
        }
      } else {
      }
    }
    return res;
  };
  var buildSimpleSwitch = (val, conv, config2, meta) => {
    let children1 = {};
    const cond = null;
    const caseI = buildCase(cond, val, conv, config2, meta);
    if (caseI) {
      children1[caseI.id] = caseI;
    }
    let res = {
      type: "switch_group",
      id: uuid_default(),
      children1,
      properties: {}
    };
    return res;
  };
  var buildCase = (cond, val, conv, config2, meta, spel = null) => {
    const valProperties = buildCaseValProperties(config2, meta, conv, val, spel);
    let caseI;
    if (cond) {
      caseI = convertToTree(cond, conv, config2, meta, spel);
      if (caseI && caseI.type) {
        if (caseI.type != "group") {
          caseI = wrapInDefaultConj2(caseI, config2);
        }
        caseI.type = "case_group";
      } else {
        meta.errors.push(`Unexpected case: ${JSON.stringify(caseI)}`);
        caseI = void 0;
      }
    } else {
      caseI = {
        id: uuid_default(),
        type: "case_group",
        properties: {}
      };
    }
    if (caseI) {
      caseI.properties = {
        ...caseI.properties,
        ...valProperties
      };
    }
    return caseI;
  };
  var buildCaseValueConcat = (spel, conv, config2, meta) => {
    let flat = [];
    function _processConcatChildren(children) {
      children.map((child) => {
        if (child.type == "op-plus") {
          _processConcatChildren(child.children);
        } else {
          const convertedChild = convertArg(child, conv, config2, meta, spel);
          if (convertedChild) {
            flat.push(convertedChild);
          } else {
            meta.errors.push(`Can't convert ${child.type} in concatenation`);
          }
        }
      });
    }
    _processConcatChildren(spel.children);
    return {
      valueSrc: "value",
      valueType: "case_value",
      value: flat
    };
  };
  var buildCaseValProperties = (config2, meta, conv, val, spel = null) => {
    let valProperties = {};
    let convVal;
    if (val?.type == "op-plus") {
      convVal = buildCaseValueConcat(val, conv, config2, meta);
    } else {
      convVal = convertArg(val, conv, config2, meta, spel);
    }
    const widgetDef = config2.widgets["case_value"];
    const importCaseValue = widgetDef?.spelImportValue;
    if (importCaseValue) {
      const [normVal, normErrors] = importCaseValue(convVal);
      normErrors.map((e) => meta.errors.push(e));
      if (normVal) {
        valProperties = {
          value: [normVal],
          valueSrc: ["value"],
          valueType: ["case_value"]
        };
      }
    } else {
      meta.errors.push("No fucntion to import case value");
    }
    return valProperties;
  };
  var wrapInDefaultConj2 = (rule3, config2, not = false) => {
    return {
      type: "group",
      id: uuid_default(),
      children1: { [rule3.id]: rule3 },
      properties: {
        conjunction: defaultConjunction(config2),
        not: not || false
      }
    };
  };

  // node_modules/@react-awesome-query-builder/core/modules/utils/index.js
  var utils_exports = {};
  __export(utils_exports, {
    Autocomplete: () => autocomplete_exports,
    ConfigUtils: () => configUtils_exports,
    DefaultUtils: () => defaultUtils_exports,
    ExportUtils: () => export_exports,
    FuncUtils: () => funcUtils_exports,
    ListUtils: () => listValues_exports,
    RuleUtils: () => ruleUtils_exports,
    TreeUtils: () => treeUtils_exports,
    clone: () => import_clone2.default,
    getSwitchValues: () => getSwitchValues,
    moment: () => import_moment4.default,
    uuid: () => uuid_default,
    validateAndFixTree: () => validateAndFixTree,
    validateTree: () => validateTree
  });
  var import_clone2 = __toESM(require_clone());
  var import_moment4 = __toESM(require_moment());

  // node_modules/@react-awesome-query-builder/core/modules/utils/autocomplete.js
  var autocomplete_exports = {};
  __export(autocomplete_exports, {
    getListValue: () => getListValue,
    listValueToOption: () => listValueToOption,
    mergeListValues: () => mergeListValues,
    simulateAsyncFetch: () => simulateAsyncFetch
  });
  var simulateAsyncFetch = (all, cPageSize = 0, delay = 1e3) => async (search, offset2, meta) => {
    const pageSize = meta.pageSize != void 0 ? meta.pageSize : cPageSize;
    const filtered = listValuesToArray(all).filter(({ title }) => search == null ? true : title.toUpperCase().indexOf(search.toUpperCase()) != -1);
    const pages = pageSize ? Math.ceil(filtered.length / pageSize) : 0;
    const currentOffset = offset2 || 0;
    const currentPage = pageSize ? Math.ceil(currentOffset / pageSize) : null;
    const values = pageSize ? filtered.slice(currentOffset, currentOffset + pageSize) : filtered;
    const newOffset = pageSize ? currentOffset + values.length : null;
    const hasMore = pageSize ? newOffset < filtered.length : false;
    console.debug("simulateAsyncFetch", {
      search,
      offset: offset2,
      values,
      hasMore,
      filtered
    });
    await sleep(delay);
    return {
      values,
      hasMore
    };
  };
  var mergeListValues = (values, newValues, toStart = false) => {
    if (!newValues)
      return values;
    const old = values || [];
    const newFiltered = newValues.filter((v) => old.find((av) => av.value == v.value) == void 0);
    const merged = toStart ? [...newFiltered, ...old] : [...old, ...newFiltered];
    return merged;
  };
  var listValueToOption = (lv) => {
    if (lv == null)
      return null;
    const { title, value, disabled, groupTitle, renderTitle } = lv;
    let option = { title, value };
    if (disabled)
      option.disabled = disabled;
    if (groupTitle)
      option.groupTitle = groupTitle;
    if (renderTitle)
      option.renderTitle = renderTitle;
    return option;
  };
  var getListValue = (selectedValue, listValues) => mapListValues(listValues, (lv) => lv.value === selectedValue ? lv : null).filter((v) => v !== null).shift();

  // node_modules/@react-awesome-query-builder/core/modules/config/funcs.js
  var import_moment5 = __toESM(require_moment());

  // node_modules/@react-awesome-query-builder/core/modules/config/index.js
  var import_moment6 = __toESM(require_moment());
  var conjunctions = {
    AND: {
      label: "And",
      mongoConj: "$and",
      jsonLogicConj: "and",
      sqlConj: "AND",
      spelConj: "and",
      spelConjs: ["and", "&&"],
      reversedConj: "OR",
      formatConj: (children, conj, not, isForDisplay) => {
        return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" " + (isForDisplay ? "AND" : "&&") + " ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
      },
      sqlFormatConj: (children, conj, not) => {
        return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" AND ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
      },
      spelFormatConj: (children, conj, not, omitBrackets) => {
        if (not)
          omitBrackets = false;
        return children.size > 1 ? (not ? "!" : "") + (omitBrackets ? "" : "(") + children.join(" && ") + (omitBrackets ? "" : ")") : (not ? "!(" : "") + children.first() + (not ? ")" : "");
      }
    },
    OR: {
      label: "Or",
      mongoConj: "$or",
      jsonLogicConj: "or",
      sqlConj: "OR",
      spelConj: "or",
      spelConjs: ["or", "||"],
      reversedConj: "AND",
      formatConj: (children, conj, not, isForDisplay) => {
        return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" " + (isForDisplay ? "OR" : "||") + " ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
      },
      sqlFormatConj: (children, conj, not) => {
        return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" OR ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
      },
      spelFormatConj: (children, conj, not, omitBrackets) => {
        if (not)
          omitBrackets = false;
        return children.size > 1 ? (not ? "!" : "") + (omitBrackets ? "" : "(") + children.join(" || ") + (omitBrackets ? "" : ")") : (not ? "!(" : "") + children.first() + (not ? ")" : "");
      }
    }
  };
  var mongoFormatOp1 = (mop, mc, not, field, _op, value, useExpr, valueSrc, valueType, opDef, operatorOptions, fieldDef) => {
    const $field = typeof field == "string" && !field.startsWith("$") ? "$" + field : field;
    const mv = mc(value, fieldDef);
    if (mv === void 0)
      return void 0;
    if (not) {
      if (!useExpr && (!mop || mop == "$eq"))
        return { [field]: { "$ne": mv } };
      return !useExpr ? { [field]: { "$not": { [mop]: mv } } } : { "$not": { [mop]: [$field, mv] } };
    } else {
      if (!useExpr && (!mop || mop == "$eq"))
        return { [field]: mv };
      return !useExpr ? { [field]: { [mop]: mv } } : { [mop]: [$field, mv] };
    }
  };
  var mongoFormatOp2 = (mops, not, field, _op, values, useExpr, valueSrcs, valueTypes, opDef, operatorOptions, fieldDef) => {
    const $field = typeof field == "string" && !field.startsWith("$") ? "$" + field : field;
    if (not) {
      return !useExpr ? { [field]: { "$not": { [mops[0]]: values[0], [mops[1]]: values[1] } } } : {
        "$not": { "$and": [
          { [mops[0]]: [$field, values[0]] },
          { [mops[1]]: [$field, values[1]] }
        ] }
      };
    } else {
      return !useExpr ? { [field]: { [mops[0]]: values[0], [mops[1]]: values[1] } } : { "$and": [
        { [mops[0]]: [$field, values[0]] },
        { [mops[1]]: [$field, values[1]] }
      ] };
    }
  };
  var operators = {
    equal: {
      label: "==",
      labelForFormat: "==",
      sqlOp: "=",
      spelOp: "==",
      spelOps: ["==", "eq"],
      reversedOp: "not_equal",
      formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
        const opStr = isForDisplay ? "=" : opDef.label;
        if (valueTypes == "boolean" && isForDisplay)
          return value == "No" ? `NOT ${field}` : `${field}`;
        else
          return `${field} ${opStr} ${value}`;
      },
      mongoFormatOp: mongoFormatOp1.bind(null, "$eq", (v) => v, false),
      jsonLogic: "==",
      elasticSearchQueryType: "term"
    },
    not_equal: {
      isNotOp: true,
      label: "!=",
      labelForFormat: "!=",
      sqlOp: "<>",
      spelOp: "!=",
      spelOps: ["!=", "ne"],
      reversedOp: "equal",
      formatOp: (field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) => {
        if (valueTypes == "boolean" && isForDisplay)
          return value == "No" ? `${field}` : `NOT ${field}`;
        else
          return `${field} ${opDef.label} ${value}`;
      },
      mongoFormatOp: mongoFormatOp1.bind(null, "$ne", (v) => v, false),
      jsonLogic: "!="
    },
    less: {
      label: "<",
      labelForFormat: "<",
      sqlOp: "<",
      spelOp: "<",
      spelOps: ["<", "lt"],
      reversedOp: "greater_or_equal",
      mongoFormatOp: mongoFormatOp1.bind(null, "$lt", (v) => v, false),
      jsonLogic: "<",
      elasticSearchQueryType: "range"
    },
    less_or_equal: {
      label: "<=",
      labelForFormat: "<=",
      sqlOp: "<=",
      spelOp: "<=",
      spelOps: ["<=", "le"],
      reversedOp: "greater",
      mongoFormatOp: mongoFormatOp1.bind(null, "$lte", (v) => v, false),
      jsonLogic: "<=",
      elasticSearchQueryType: "range"
    },
    greater: {
      label: ">",
      labelForFormat: ">",
      sqlOp: ">",
      spelOp: ">",
      spelOps: [">", "gt"],
      reversedOp: "less_or_equal",
      mongoFormatOp: mongoFormatOp1.bind(null, "$gt", (v) => v, false),
      jsonLogic: ">",
      elasticSearchQueryType: "range"
    },
    greater_or_equal: {
      label: ">=",
      labelForFormat: ">=",
      sqlOp: ">=",
      spelOp: ">=",
      spelOps: [">=", "ge"],
      reversedOp: "less",
      mongoFormatOp: mongoFormatOp1.bind(null, "$gte", (v) => v, false),
      jsonLogic: ">=",
      elasticSearchQueryType: "range"
    },
    like: {
      label: "Contains",
      labelForFormat: "Contains",
      reversedOp: "not_like",
      sqlOp: "LIKE",
      spelOp: ".contains",
      spelOps: ["matches", ".contains"],
      mongoFormatOp: mongoFormatOp1.bind(null, "$regex", (v) => typeof v == "string" ? escapeRegExp3(v) : void 0, false),
      //jsonLogic: (field, op, val) => ({ "in": [val, field] }),
      jsonLogic: "in",
      _jsonLogicIsRevArgs: true,
      valueSources: ["value"],
      elasticSearchQueryType: "regexp"
    },
    not_like: {
      isNotOp: true,
      label: "Not contains",
      reversedOp: "like",
      labelForFormat: "Not Contains",
      sqlOp: "NOT LIKE",
      mongoFormatOp: mongoFormatOp1.bind(null, "$regex", (v) => typeof v == "string" ? escapeRegExp3(v) : void 0, true),
      valueSources: ["value"]
    },
    starts_with: {
      label: "Starts with",
      labelForFormat: "Starts with",
      sqlOp: "LIKE",
      spelOp: ".startsWith",
      spelOps: ["matches", ".startsWith"],
      mongoFormatOp: mongoFormatOp1.bind(null, "$regex", (v) => typeof v == "string" ? "^" + escapeRegExp3(v) : void 0, false),
      jsonLogic: void 0,
      // not supported
      valueSources: ["value"]
    },
    ends_with: {
      label: "Ends with",
      labelForFormat: "Ends with",
      sqlOp: "LIKE",
      spelOp: ".endsWith",
      spelOps: ["matches", ".endsWith"],
      mongoFormatOp: mongoFormatOp1.bind(null, "$regex", (v) => typeof v == "string" ? escapeRegExp3(v) + "$" : void 0, false),
      jsonLogic: void 0,
      // not supported
      valueSources: ["value"]
    },
    between: {
      label: "Between",
      labelForFormat: "BETWEEN",
      sqlOp: "BETWEEN",
      cardinality: 2,
      formatOp: (field, op, values, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) => {
        let valFrom = values.first();
        let valTo = values.get(1);
        if (isForDisplay)
          return `${field} BETWEEN ${valFrom} AND ${valTo}`;
        else
          return `${field} >= ${valFrom} && ${field} <= ${valTo}`;
      },
      spelFormatOp: (field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) => {
        const valFrom = values[0];
        const valTo = values[1];
        return `${field} >= ${valFrom} && ${field} <= ${valTo}`;
      },
      mongoFormatOp: mongoFormatOp2.bind(null, ["$gte", "$lte"], false),
      valueLabels: [
        "Value from",
        "Value to"
      ],
      textSeparators: [
        null,
        "and"
      ],
      reversedOp: "not_between",
      jsonLogic: "<=",
      validateValues: (values) => {
        if (values[0] != void 0 && values[1] != void 0) {
          return values[0] <= values[1] ? null : "Invalid range";
        }
        return null;
      },
      elasticSearchQueryType: function elasticSearchQueryType(type) {
        return type === "time" ? "filter" : "range";
      }
    },
    not_between: {
      isNotOp: true,
      label: "Not between",
      labelForFormat: "NOT BETWEEN",
      sqlOp: "NOT BETWEEN",
      cardinality: 2,
      formatOp: (field, op, values, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) => {
        let valFrom = values.first();
        let valTo = values.get(1);
        if (isForDisplay)
          return `${field} NOT BETWEEN ${valFrom} AND ${valTo}`;
        else
          return `(${field} < ${valFrom} || ${field} > ${valTo})`;
      },
      spelFormatOp: (field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) => {
        const valFrom = values[0];
        const valTo = values[1];
        return `(${field} < ${valFrom} || ${field} > ${valTo})`;
      },
      mongoFormatOp: mongoFormatOp2.bind(null, ["$gte", "$lte"], true),
      valueLabels: [
        "Value from",
        "Value to"
      ],
      textSeparators: [
        null,
        "and"
      ],
      reversedOp: "between",
      validateValues: (values) => {
        if (values[0] != void 0 && values[1] != void 0) {
          return values[0] <= values[1] ? null : "Invalid range";
        }
        return null;
      }
    },
    is_empty: {
      label: "Is empty",
      labelForFormat: "IS EMPTY",
      cardinality: 0,
      reversedOp: "is_not_empty",
      formatOp: (field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        return isForDisplay ? `${field} IS EMPTY` : `!${field}`;
      },
      sqlFormatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) => {
        const empty = sqlEmptyValue(fieldDef);
        return `COALESCE(${field}, ${empty}) = ${empty}`;
      },
      spelFormatOp: (field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) => {
        return `${field} <= ''`;
      },
      mongoFormatOp: mongoFormatOp1.bind(null, "$in", (v, fieldDef) => [mongoEmptyValue(fieldDef), null], false),
      jsonLogic: "!"
    },
    is_not_empty: {
      isNotOp: true,
      label: "Is not empty",
      labelForFormat: "IS NOT EMPTY",
      cardinality: 0,
      reversedOp: "is_empty",
      formatOp: (field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        return isForDisplay ? `${field} IS NOT EMPTY` : `!!${field}`;
      },
      sqlFormatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) => {
        const empty = sqlEmptyValue(fieldDef);
        return `COALESCE(${field}, ${empty}) <> ${empty}`;
      },
      spelFormatOp: (field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) => {
        return `${field} > ''`;
      },
      mongoFormatOp: mongoFormatOp1.bind(null, "$nin", (v, fieldDef) => [mongoEmptyValue(fieldDef), null], false),
      jsonLogic: "!!",
      elasticSearchQueryType: "exists"
    },
    is_null: {
      label: "Is null",
      labelForFormat: "IS NULL",
      sqlOp: "IS NULL",
      cardinality: 0,
      reversedOp: "is_not_null",
      formatOp: (field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        return isForDisplay ? `${field} IS NULL` : `!${field}`;
      },
      spelFormatOp: (field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) => {
        return `${field} == null`;
      },
      // check if value is null OR not exists
      mongoFormatOp: mongoFormatOp1.bind(null, "$eq", (v) => null, false),
      jsonLogic: "=="
    },
    is_not_null: {
      label: "Is not null",
      labelForFormat: "IS NOT NULL",
      sqlOp: "IS NOT NULL",
      cardinality: 0,
      reversedOp: "is_null",
      formatOp: (field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        return isForDisplay ? `${field} IS NOT NULL` : `!!${field}`;
      },
      spelFormatOp: (field, op, values, valueSrc, valueTypes, opDef, operatorOptions, fieldDef) => {
        return `${field} != null`;
      },
      // check if value exists and is not null
      mongoFormatOp: mongoFormatOp1.bind(null, "$ne", (v) => null, false),
      jsonLogic: "!=",
      elasticSearchQueryType: "exists"
    },
    select_equals: {
      label: "==",
      labelForFormat: "==",
      sqlOp: "=",
      // enum/set
      formatOp: (field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        const opStr = isForDisplay ? "=" : "==";
        return `${field} ${opStr} ${value}`;
      },
      spelOp: "==",
      spelOps: ["==", "eq"],
      mongoFormatOp: mongoFormatOp1.bind(null, "$eq", (v) => v, false),
      reversedOp: "select_not_equals",
      jsonLogic: "==",
      elasticSearchQueryType: "term"
    },
    select_not_equals: {
      isNotOp: true,
      label: "!=",
      labelForFormat: "!=",
      sqlOp: "<>",
      // enum/set
      formatOp: (field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        return `${field} != ${value}`;
      },
      spelOp: "!=",
      spelOps: ["!=", "ne"],
      mongoFormatOp: mongoFormatOp1.bind(null, "$ne", (v) => v, false),
      reversedOp: "select_equals",
      jsonLogic: "!="
    },
    select_any_in: {
      label: "Any in",
      labelForFormat: "IN",
      sqlOp: "IN",
      formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        if (valueSrc == "value")
          return `${field} IN (${values.join(", ")})`;
        else
          return `${field} IN (${values})`;
      },
      sqlFormatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) => {
        if (valueSrc == "value") {
          return `${field} IN (${values.join(", ")})`;
        } else
          return void 0;
      },
      spelOp: "$contains",
      // tip: $ means first arg is object
      mongoFormatOp: mongoFormatOp1.bind(null, "$in", (v) => v, false),
      reversedOp: "select_not_any_in",
      jsonLogic: "in",
      elasticSearchQueryType: "term"
    },
    select_not_any_in: {
      isNotOp: true,
      label: "Not in",
      labelForFormat: "NOT IN",
      sqlOp: "NOT IN",
      formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        if (valueSrc == "value")
          return `${field} NOT IN (${values.join(", ")})`;
        else
          return `${field} NOT IN (${values})`;
      },
      sqlFormatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) => {
        if (valueSrc == "value") {
          return `${field} NOT IN (${values.join(", ")})`;
        } else
          return void 0;
      },
      mongoFormatOp: mongoFormatOp1.bind(null, "$nin", (v) => v, false),
      reversedOp: "select_any_in"
    },
    // it's not "contains all", but "contains any" operator
    multiselect_contains: {
      label: "Contains",
      labelForFormat: "CONTAINS",
      formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        if (valueSrc == "value")
          return `${field} CONTAINS [${values.join(", ")}]`;
        else
          return `${field} CONTAINS ${values}`;
      },
      reversedOp: "multiselect_not_contains",
      jsonLogic2: "some-in",
      jsonLogic: (field, op, vals) => ({
        "some": [field, { "in": [{ "var": "" }, vals] }]
      }),
      //spelOp: ".containsAll",
      spelOp: "CollectionUtils.containsAny()",
      elasticSearchQueryType: "term",
      mongoFormatOp: mongoFormatOp1.bind(null, "$in", (v) => v, false)
    },
    multiselect_not_contains: {
      isNotOp: true,
      label: "Not contains",
      labelForFormat: "NOT CONTAINS",
      formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        if (valueSrc == "value")
          return `${field} NOT CONTAINS [${values.join(", ")}]`;
        else
          return `${field} NOT CONTAINS ${values}`;
      },
      reversedOp: "multiselect_contains"
    },
    multiselect_equals: {
      label: "Equals",
      labelForFormat: "==",
      sqlOp: "=",
      formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        const opStr = isForDisplay ? "=" : "==";
        if (valueSrc == "value")
          return `${field} ${opStr} [${values.join(", ")}]`;
        else
          return `${field} ${opStr} ${values}`;
      },
      sqlFormatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) => {
        if (valueSrc == "value")
          return `${field} = '${values.map((v) => SqlString.trim(v)).join(",")}'`;
        else
          return void 0;
      },
      spelOp: ".equals",
      mongoFormatOp: mongoFormatOp1.bind(null, "$eq", (v) => v, false),
      reversedOp: "multiselect_not_equals",
      jsonLogic2: "all-in",
      jsonLogic: (field, op, vals) => ({
        // it's not "equals", but "includes" operator - just for example
        "all": [field, { "in": [{ "var": "" }, vals] }]
      }),
      elasticSearchQueryType: "term"
    },
    multiselect_not_equals: {
      isNotOp: true,
      label: "Not equals",
      labelForFormat: "!=",
      sqlOp: "<>",
      formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        if (valueSrc == "value")
          return `${field} != [${values.join(", ")}]`;
        else
          return `${field} != ${values}`;
      },
      sqlFormatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) => {
        if (valueSrc == "value")
          return `${field} != '${values.map((v) => SqlString.trim(v)).join(",")}'`;
        else
          return void 0;
      },
      mongoFormatOp: mongoFormatOp1.bind(null, "$ne", (v) => v, false),
      reversedOp: "multiselect_equals"
    },
    proximity: {
      label: "Proximity search",
      cardinality: 2,
      valueLabels: [
        { label: "Word 1", placeholder: "Enter first word" },
        { label: "Word 2", placeholder: "Enter second word" }
      ],
      textSeparators: [
        //'Word 1',
        //'Word 2'
      ],
      formatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) => {
        const val1 = values.first();
        const val2 = values.get(1);
        const prox = operatorOptions.get("proximity");
        return `${field} ${val1} NEAR/${prox} ${val2}`;
      },
      sqlFormatOp: (field, op, values, valueSrc, valueType, opDef, operatorOptions, fieldDef) => {
        const val1 = values.first();
        const val2 = values.get(1);
        const aVal1 = SqlString.trim(val1);
        const aVal2 = SqlString.trim(val2);
        const prox = operatorOptions.get("proximity");
        return `CONTAINS(${field}, 'NEAR((${aVal1}, ${aVal2}), ${prox})')`;
      },
      mongoFormatOp: void 0,
      // not supported
      jsonLogic: void 0,
      // not supported
      options: {
        optionLabel: "Near",
        // label on top of "near" selectbox (for config.settings.showLabels==true)
        optionTextBefore: "Near",
        // label before "near" selectbox (for config.settings.showLabels==false)
        optionPlaceholder: "Select words between",
        // placeholder for "near" selectbox
        minProximity: 2,
        maxProximity: 10,
        defaults: {
          proximity: 2
        }
      }
    },
    some: {
      label: "Some",
      labelForFormat: "SOME",
      cardinality: 0,
      jsonLogic: "some",
      spelFormatOp: (filteredSize) => `${filteredSize} > 0`,
      mongoFormatOp: mongoFormatOp1.bind(null, "$gt", (v) => 0, false)
    },
    all: {
      label: "All",
      labelForFormat: "ALL",
      cardinality: 0,
      jsonLogic: "all",
      spelFormatOp: (filteredSize, op, fullSize) => `${filteredSize} == ${fullSize}`,
      mongoFormatOp: mongoFormatOp1.bind(null, "$eq", (v) => v, false)
    },
    none: {
      label: "None",
      labelForFormat: "NONE",
      cardinality: 0,
      jsonLogic: "none",
      spelFormatOp: (filteredSize) => `${filteredSize} == 0`,
      mongoFormatOp: mongoFormatOp1.bind(null, "$eq", (v) => 0, false)
    }
  };
  var widgets = {
    text: {
      type: "text",
      jsType: "string",
      valueSrc: "value",
      valueLabel: "String",
      valuePlaceholder: "Enter string",
      formatValue: (val, fieldDef, wgtDef, isForDisplay) => {
        return isForDisplay ? stringifyForDisplay(val) : JSON.stringify(val);
      },
      spelFormatValue: (val, fieldDef, wgtDef, op, opDef) => {
        if (opDef.spelOp == "matches" && op != "regex") {
          let regex;
          if (op == "starts_with") {
            regex = `(?s)^${escapeRegExp3(val)}.*`;
          } else if (op == "ends_with") {
            regex = `(?s).*${escapeRegExp3(val)}$`;
          } else {
            regex = `(?s).*${escapeRegExp3(val)}.*`;
          }
          return spelEscape(regex);
        } else {
          return spelEscape(val);
        }
      },
      sqlFormatValue: (val, fieldDef, wgtDef, op, opDef) => {
        if (opDef.sqlOp == "LIKE" || opDef.sqlOp == "NOT LIKE") {
          return SqlString.escapeLike(val, op != "starts_with", op != "ends_with");
        } else {
          return SqlString.escape(val);
        }
      },
      toJS: (val, fieldSettings) => val,
      mongoFormatValue: (val, fieldDef, wgtDef) => val
    },
    textarea: {
      type: "text",
      jsType: "string",
      valueSrc: "value",
      valueLabel: "Text",
      valuePlaceholder: "Enter text",
      formatValue: (val, fieldDef, wgtDef, isForDisplay) => {
        return isForDisplay ? stringifyForDisplay(val) : JSON.stringify(val);
      },
      sqlFormatValue: (val, fieldDef, wgtDef, op, opDef) => {
        if (opDef.sqlOp == "LIKE" || opDef.sqlOp == "NOT LIKE") {
          return SqlString.escapeLike(val, op != "starts_with", op != "ends_with");
        } else {
          return SqlString.escape(val);
        }
      },
      spelFormatValue: (val) => spelEscape(val),
      toJS: (val, fieldSettings) => val,
      mongoFormatValue: (val, fieldDef, wgtDef) => val,
      fullWidth: true
    },
    number: {
      type: "number",
      jsType: "number",
      valueSrc: "value",
      valueLabel: "Number",
      valuePlaceholder: "Enter number",
      valueLabels: [
        { label: "Number from", placeholder: "Enter number from" },
        { label: "Number to", placeholder: "Enter number to" }
      ],
      formatValue: (val, fieldDef, wgtDef, isForDisplay) => {
        return isForDisplay ? stringifyForDisplay(val) : JSON.stringify(val);
      },
      sqlFormatValue: (val, fieldDef, wgtDef, op, opDef) => {
        return SqlString.escape(val);
      },
      spelFormatValue: (val, fieldDef, wgtDef) => {
        const isFloat = wgtDef.step && !Number.isInteger(wgtDef.step);
        return spelEscape(val, isFloat);
      },
      toJS: (val, fieldSettings) => val,
      mongoFormatValue: (val, fieldDef, wgtDef) => val
    },
    slider: {
      type: "number",
      jsType: "number",
      valueSrc: "value",
      valueLabel: "Number",
      valuePlaceholder: "Enter number or move slider",
      formatValue: (val, fieldDef, wgtDef, isForDisplay) => {
        return isForDisplay ? stringifyForDisplay(val) : JSON.stringify(val);
      },
      sqlFormatValue: (val, fieldDef, wgtDef, op, opDef) => {
        return SqlString.escape(val);
      },
      spelFormatValue: (val) => spelEscape(val),
      toJS: (val, fieldSettings) => val,
      mongoFormatValue: (val, fieldDef, wgtDef) => val
    },
    select: {
      type: "select",
      jsType: "string",
      valueSrc: "value",
      valueLabel: "Value",
      valuePlaceholder: "Select value",
      formatValue: (val, fieldDef, wgtDef, isForDisplay) => {
        let valLabel = getTitleInListValues(fieldDef.fieldSettings.listValues || fieldDef.asyncListValues, val);
        return isForDisplay ? stringifyForDisplay(valLabel) : JSON.stringify(val);
      },
      sqlFormatValue: (val, fieldDef, wgtDef, op, opDef) => {
        return SqlString.escape(val);
      },
      spelFormatValue: (val) => spelEscape(val),
      toJS: (val, fieldSettings) => val,
      mongoFormatValue: (val, fieldDef, wgtDef) => val
    },
    multiselect: {
      type: "multiselect",
      jsType: "array",
      valueSrc: "value",
      valueLabel: "Values",
      valuePlaceholder: "Select values",
      formatValue: (vals, fieldDef, wgtDef, isForDisplay) => {
        let valsLabels = vals.map((v) => getTitleInListValues(fieldDef.fieldSettings.listValues || fieldDef.asyncListValues, v));
        return isForDisplay ? valsLabels.map(stringifyForDisplay) : vals.map(JSON.stringify);
      },
      sqlFormatValue: (vals, fieldDef, wgtDef, op, opDef) => {
        return vals.map((v) => SqlString.escape(v));
      },
      spelFormatValue: (vals, fieldDef, wgtDef, op, opDef) => {
        const isCallable = opDef.spelOp && opDef.spelOp[0] == "$";
        let res = spelEscape(vals);
        if (isCallable) {
          res = spelFixList(res);
        }
        return res;
      },
      toJS: (val, fieldSettings) => val,
      mongoFormatValue: (val, fieldDef, wgtDef) => val
    },
    date: {
      type: "date",
      jsType: "string",
      valueSrc: "value",
      dateFormat: "DD.MM.YYYY",
      valueFormat: "YYYY-MM-DD",
      useKeyboard: true,
      valueLabel: "Date",
      valuePlaceholder: "Enter date",
      valueLabels: [
        { label: "Date from", placeholder: "Enter date from" },
        { label: "Date to", placeholder: "Enter date to" }
      ],
      formatValue: (val, fieldDef, wgtDef, isForDisplay) => {
        const dateVal = (0, import_moment6.default)(val, wgtDef.valueFormat);
        return isForDisplay ? dateVal.format(wgtDef.dateFormat) : JSON.stringify(val);
      },
      sqlFormatValue: (val, fieldDef, wgtDef, op, opDef) => {
        const dateVal = (0, import_moment6.default)(val, wgtDef.valueFormat);
        return SqlString.escape(dateVal.format("YYYY-MM-DD"));
      },
      spelFormatValue: (val, fieldDef, wgtDef, op, opDef) => {
        const dateVal = (0, import_moment6.default)(val, wgtDef.valueFormat);
        return `new java.text.SimpleDateFormat('yyyy-MM-dd').parse('${dateVal.format("YYYY-MM-DD")}')`;
      },
      jsonLogic: (val, fieldDef, wgtDef) => (0, import_moment6.default)(val, wgtDef.valueFormat).toDate(),
      toJS: (val, fieldSettings) => {
        const dateVal = (0, import_moment6.default)(val, fieldSettings.valueFormat);
        return dateVal.isValid() ? dateVal.toDate() : void 0;
      },
      mongoFormatValue: (val, fieldDef, wgtDef) => {
        const dateVal = (0, import_moment6.default)(val, wgtDef.valueFormat);
        return dateVal.isValid() ? dateVal.toDate() : void 0;
      }
    },
    time: {
      type: "time",
      jsType: "string",
      valueSrc: "value",
      timeFormat: "HH:mm",
      valueFormat: "HH:mm:ss",
      use12Hours: false,
      useKeyboard: true,
      valueLabel: "Time",
      valuePlaceholder: "Enter time",
      valueLabels: [
        { label: "Time from", placeholder: "Enter time from" },
        { label: "Time to", placeholder: "Enter time to" }
      ],
      formatValue: (val, fieldDef, wgtDef, isForDisplay) => {
        const dateVal = (0, import_moment6.default)(val, wgtDef.valueFormat);
        return isForDisplay ? dateVal.format(wgtDef.timeFormat) : JSON.stringify(val);
      },
      sqlFormatValue: (val, fieldDef, wgtDef, op, opDef) => {
        const dateVal = (0, import_moment6.default)(val, wgtDef.valueFormat);
        return SqlString.escape(dateVal.format("HH:mm:ss"));
      },
      spelFormatValue: (val, fieldDef, wgtDef, op, opDef) => {
        const dateVal = (0, import_moment6.default)(val, wgtDef.valueFormat);
        return `T(java.time.LocalTime).parse('${dateVal.format("HH:mm:ss")}')`;
      },
      jsonLogic: (val, fieldDef, wgtDef) => {
        const dateVal = (0, import_moment6.default)(val, wgtDef.valueFormat);
        return dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second");
      },
      toJS: (val, fieldSettings) => {
        const dateVal = (0, import_moment6.default)(val, fieldSettings.valueFormat);
        return dateVal.isValid() ? dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second") : void 0;
      },
      mongoFormatValue: (val, fieldDef, wgtDef) => {
        const dateVal = (0, import_moment6.default)(val, wgtDef.valueFormat);
        return dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second");
      },
      elasticSearchFormatValue: function elasticSearchFormatValue(queryType, value, operator, fieldName) {
        return {
          script: {
            script: {
              source: "doc[".concat(fieldName, "][0].getHour() >== params.min && doc[").concat(fieldName, "][0].getHour() <== params.max"),
              params: {
                min: value[0],
                max: value[1]
              }
            }
          }
        };
      }
    },
    datetime: {
      type: "datetime",
      jsType: "string",
      valueSrc: "value",
      timeFormat: "HH:mm",
      dateFormat: "DD.MM.YYYY",
      valueFormat: "YYYY-MM-DD HH:mm:ss",
      use12Hours: false,
      useKeyboard: true,
      valueLabel: "Datetime",
      valuePlaceholder: "Enter datetime",
      valueLabels: [
        { label: "Datetime from", placeholder: "Enter datetime from" },
        { label: "Datetime to", placeholder: "Enter datetime to" }
      ],
      formatValue: (val, fieldDef, wgtDef, isForDisplay) => {
        const dateVal = (0, import_moment6.default)(val, wgtDef.valueFormat);
        return isForDisplay ? dateVal.format(wgtDef.dateFormat + " " + wgtDef.timeFormat) : JSON.stringify(val);
      },
      sqlFormatValue: (val, fieldDef, wgtDef, op, opDef) => {
        const dateVal = (0, import_moment6.default)(val, wgtDef.valueFormat);
        return SqlString.escape(dateVal.toDate());
      },
      spelFormatValue: (val, fieldDef, wgtDef, op, opDef) => {
        const dateVal = (0, import_moment6.default)(val, wgtDef.valueFormat);
        return `new java.text.SimpleDateFormat('yyyy-MM-dd HH:mm:ss').parse('${dateVal.format("YYYY-MM-DD HH:mm:ss")}')`;
      },
      jsonLogic: (val, fieldDef, wgtDef) => (0, import_moment6.default)(val, wgtDef.valueFormat).toDate(),
      toJS: (val, fieldSettings) => {
        const dateVal = (0, import_moment6.default)(val, fieldSettings.valueFormat);
        return dateVal.isValid() ? dateVal.toDate() : void 0;
      },
      mongoFormatValue: (val, fieldDef, wgtDef) => {
        const dateVal = (0, import_moment6.default)(val, wgtDef.valueFormat);
        return dateVal.isValid() ? dateVal.toDate() : void 0;
      }
    },
    boolean: {
      type: "boolean",
      jsType: "boolean",
      valueSrc: "value",
      labelYes: "Yes",
      labelNo: "No",
      formatValue: (val, fieldDef, wgtDef, isForDisplay) => {
        return isForDisplay ? val ? "Yes" : "No" : JSON.stringify(!!val);
      },
      sqlFormatValue: (val, fieldDef, wgtDef, op, opDef) => {
        return SqlString.escape(val);
      },
      spelFormatValue: (val, fieldDef, wgtDef, op, opDef) => {
        return spelEscape(val);
      },
      defaultValue: false,
      toJS: (val, fieldSettings) => val,
      mongoFormatValue: (val, fieldDef, wgtDef) => val
    },
    field: {
      valueSrc: "field",
      formatValue: (val, fieldDef, wgtDef, isForDisplay, op, opDef, rightFieldDef) => {
        return isForDisplay ? rightFieldDef.label || val : val;
      },
      sqlFormatValue: (val, fieldDef, wgtDef, op, opDef, rightFieldDef) => {
        return val;
      },
      spelFormatValue: (val, fieldDef, wgtDef, op, opDef) => {
        return val;
      },
      valueLabel: "Field to compare",
      valuePlaceholder: "Select field to compare"
    },
    func: {
      valueSrc: "func",
      valueLabel: "Function",
      valuePlaceholder: "Select function"
    },
    case_value: {
      valueSrc: "value",
      type: "case_value",
      spelFormatValue: (val) => {
        return spelEscape(val === "" ? null : val);
      },
      spelImportValue: (val) => {
        return [val.value, []];
      }
    }
  };
  var types = {
    text: {
      defaultOperator: "equal",
      mainWidget: "text",
      widgets: {
        text: {
          operators: [
            "equal",
            "not_equal",
            "like",
            "not_like",
            "starts_with",
            "ends_with",
            "proximity",
            "is_empty",
            "is_not_empty",
            "is_null",
            "is_not_null"
          ],
          widgetProps: {},
          opProps: {}
        },
        textarea: {
          operators: [
            "equal",
            "not_equal",
            "like",
            "not_like",
            "starts_with",
            "ends_with",
            "is_empty",
            "is_not_empty",
            "is_null",
            "is_not_null"
          ],
          widgetProps: {},
          opProps: {}
        },
        field: {
          operators: [
            //unary ops (like `is_empty`) will be excluded anyway, see getWidgetsForFieldOp()
            "equal",
            "not_equal",
            "proximity"
            //can exclude if you want
          ]
        }
      }
    },
    number: {
      defaultOperator: "equal",
      mainWidget: "number",
      widgets: {
        number: {
          operators: [
            "equal",
            "not_equal",
            "less",
            "less_or_equal",
            "greater",
            "greater_or_equal",
            "between",
            "not_between",
            // "is_empty",
            // "is_not_empty",
            "is_null",
            "is_not_null"
          ]
        },
        slider: {
          operators: [
            "equal",
            "not_equal",
            "less",
            "less_or_equal",
            "greater",
            "greater_or_equal",
            // "is_empty",
            // "is_not_empty",
            "is_null",
            "is_not_null"
          ]
        }
      }
    },
    date: {
      defaultOperator: "equal",
      widgets: {
        date: {
          operators: [
            "equal",
            "not_equal",
            "less",
            "less_or_equal",
            "greater",
            "greater_or_equal",
            "between",
            "not_between",
            // "is_empty",
            // "is_not_empty",
            "is_null",
            "is_not_null"
          ]
        }
      }
    },
    time: {
      defaultOperator: "equal",
      widgets: {
        time: {
          operators: [
            "equal",
            "not_equal",
            "less",
            "less_or_equal",
            "greater",
            "greater_or_equal",
            "between",
            "not_between",
            // "is_empty",
            // "is_not_empty",
            "is_null",
            "is_not_null"
          ]
        }
      }
    },
    datetime: {
      defaultOperator: "equal",
      widgets: {
        datetime: {
          operators: [
            "equal",
            "not_equal",
            "less",
            "less_or_equal",
            "greater",
            "greater_or_equal",
            "between",
            "not_between",
            // "is_empty",
            // "is_not_empty",
            "is_null",
            "is_not_null"
          ]
        }
      }
    },
    select: {
      mainWidget: "select",
      defaultOperator: "select_equals",
      widgets: {
        select: {
          operators: [
            "select_equals",
            "select_not_equals",
            // "is_empty",
            // "is_not_empty",
            "is_null",
            "is_not_null"
          ]
        },
        multiselect: {
          operators: [
            "select_any_in",
            "select_not_any_in",
            // "is_empty",
            // "is_not_empty",
            "is_null",
            "is_not_null"
          ]
        }
      }
    },
    multiselect: {
      defaultOperator: "multiselect_equals",
      widgets: {
        multiselect: {
          operators: [
            "multiselect_contains",
            "multiselect_not_contains",
            "multiselect_equals",
            "multiselect_not_equals",
            // "is_empty",
            // "is_not_empty",
            "is_null",
            "is_not_null"
          ]
        }
      }
    },
    boolean: {
      defaultOperator: "equal",
      widgets: {
        boolean: {
          operators: [
            "equal",
            "not_equal",
            "is_null",
            "is_not_null"
          ],
          widgetProps: {
            //you can enable this if you don't use fields as value sources
            // hideOperator: true,
            // operatorInlineLabel: "is",
          }
        },
        field: {
          operators: [
            "equal",
            "not_equal"
          ]
        }
      }
    },
    "!group": {
      defaultOperator: "some",
      mainWidget: "number",
      widgets: {
        number: {
          widgetProps: {
            min: 0
          },
          operators: [
            // w/o operand
            "some",
            "all",
            "none",
            // w/ operand - count
            "equal",
            "not_equal",
            "less",
            "less_or_equal",
            "greater",
            "greater_or_equal",
            "between",
            "not_between"
          ],
          opProps: {
            equal: {
              label: "Count =="
            },
            not_equal: {
              label: "Count !="
            },
            less: {
              label: "Count <"
            },
            less_or_equal: {
              label: "Count <="
            },
            greater: {
              label: "Count >"
            },
            greater_or_equal: {
              label: "Count >="
            },
            between: {
              label: "Count between"
            },
            not_between: {
              label: "Count not between"
            }
          }
        }
      }
    },
    "case_value": {
      mainWidget: "case_value",
      widgets: {
        case_value: {}
      }
    }
  };
  var settings2 = {
    ...settings,
    convertableWidgets: {
      "number": ["slider", "rangeslider"],
      "slider": ["number", "rangeslider"],
      "rangeslider": ["number", "slider"],
      "text": ["textarea"],
      "textarea": ["text"]
    },
    formatSpelField: (field, parentField, parts2, partsExt, fieldDefinition, config2) => {
      let fieldName = partsExt.map(({ key, parent }, ind) => {
        if (ind == 0) {
          if (parent == "[map]")
            return `#this[${spelEscape(key)}]`;
          else if (parent == "[class]")
            return key;
          else
            return key;
        } else {
          if (parent == "map" || parent == "[map]")
            return `[${spelEscape(key)}]`;
          else if (parent == "class" || parent == "[class]")
            return `.${key}`;
          else
            return `.${key}`;
        }
      }).join("");
      if (fieldDefinition.isSpelVariable) {
        fieldName = "#" + fieldName;
      }
      return fieldName;
    },
    sqlFormatReverse: (q) => {
      if (q == void 0)
        return void 0;
      return "NOT(" + q + ")";
    },
    spelFormatReverse: (q) => {
      if (q == void 0)
        return void 0;
      return "!(" + q + ")";
    },
    formatReverse: (q, operator, reversedOp, operatorDefinition, revOperatorDefinition, isForDisplay) => {
      if (q == void 0)
        return void 0;
      if (isForDisplay)
        return "NOT (" + q + ")";
      else
        return "!(" + q + ")";
    },
    formatAggr: (whereStr, aggrField, operator, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay, aggrFieldDef) => {
      const { labelForFormat, cardinality } = opDef;
      if (cardinality == 0) {
        const cond = whereStr ? ` HAVE ${whereStr}` : "";
        return `${labelForFormat} OF ${aggrField}${cond}`;
      } else if (cardinality == void 0 || cardinality == 1) {
        const cond = whereStr ? ` WHERE ${whereStr}` : "";
        return `COUNT OF ${aggrField}${cond} ${labelForFormat} ${value}`;
      } else if (cardinality == 2) {
        const cond = whereStr ? ` WHERE ${whereStr}` : "";
        let valFrom = value.first();
        let valTo = value.get(1);
        return `COUNT OF ${aggrField}${cond} ${labelForFormat} ${valFrom} AND ${valTo}`;
      }
    },
    jsonLogic: {
      groupVarKey: "var",
      altVarKey: "var",
      lockedOp: "locked"
    },
    canCompareFieldWithField: (leftField, leftFieldConfig, rightField, rightFieldConfig) => {
      return true;
    },
    // enable compare fields
    valueSourcesInfo: {
      value: {
        label: "Value"
      },
      field: {
        label: "Field",
        widget: "field"
      },
      func: {
        label: "Function",
        widget: "func"
      }
    }
  };
  var config_default = {
    conjunctions,
    operators,
    widgets,
    types,
    settings: settings2
  };

  // node_modules/@react-awesome-query-builder/core/modules/stores/tree.js
  var import_immutable14 = __toESM(require_immutable());

  // node_modules/@react-awesome-query-builder/core/modules/stores/constants.js
  var ADD_GROUP = "ADD_GROUP";
  var ADD_CASE_GROUP = "ADD_CASE_GROUP";
  var REMOVE_GROUP = "REMOVE_GROUP";
  var SET_CONJUNCTION = "SET_CONJUNCTION";
  var SET_NOT = "SET_NOT";
  var ADD_RULE = "ADD_RULE";
  var REMOVE_RULE = "REMOVE_RULE";
  var SET_FIELD = "SET_FIELD";
  var SET_OPERATOR = "SET_OPERATOR";
  var SET_VALUE = "SET_VALUE";
  var SET_VALUE_SRC = "SET_VALUE_SRC";
  var SET_OPERATOR_OPTION = "SET_OPERATOR_OPTION";
  var SET_LOCK = "SET_LOCK";
  var SET_TREE = "SET_TREE";
  var MOVE_ITEM = "MOVE_ITEM";
  var PLACEMENT_AFTER = "after";
  var PLACEMENT_BEFORE = "before";
  var PLACEMENT_APPEND = "append";
  var PLACEMENT_PREPEND = "prepend";
  var SET_DRAG_PROGRESS = "SET_DRAG_PROGRESS";
  var SET_DRAG_START = "SET_DRAG_START";
  var SET_DRAG_END = "SET_DRAG_END";

  // node_modules/@react-awesome-query-builder/core/modules/stores/tree.js
  var import_omit7 = __toESM(require_omit());
  var import_mapValues = __toESM(require_mapValues());
  var addNewGroup = (state, path, type, groupUuid, properties, config2, children = null, meta = {}) => {
    const { shouldCreateEmptyGroup } = config2.settings;
    const groupPath = path.push(groupUuid);
    const canAddNewRule = !shouldCreateEmptyGroup;
    const isDefaultCase = !!meta?.isDefaultCase;
    const origState = state;
    state = addItem(state, path, type, groupUuid, defaultGroupProperties(config2).merge(properties || {}), config2, children);
    if (state !== origState) {
      if (!children && !isDefaultCase) {
        state = state.setIn(expandTreePath(groupPath, "children1"), new import_immutable14.default.OrderedMap());
        if (canAddNewRule) {
          state = addItem(state, groupPath, "rule", uuid_default(), defaultRuleProperties(config2), config2);
        }
      }
      state = fixPathsInTree(state);
    }
    return state;
  };
  var removeGroup = (state, path, config2) => {
    state = removeItem(state, path);
    const { canLeaveEmptyGroup } = config2.settings;
    const parentPath = path.slice(0, -1);
    const isEmptyParentGroup = !hasChildren(state, parentPath);
    if (isEmptyParentGroup && !canLeaveEmptyGroup) {
      state = fixEmptyGroupsInTree(state);
      if (isEmptyTree(state) && !canLeaveEmptyGroup) {
        state = addItem(state, new import_immutable14.default.List(), "rule", uuid_default(), defaultRuleProperties(config2), config2);
      }
    }
    state = fixPathsInTree(state);
    return state;
  };
  var removeRule = (state, path, config2) => {
    state = removeItem(state, path);
    const { canLeaveEmptyGroup } = config2.settings;
    const parentPath = path.pop();
    const parent = state.getIn(expandTreePath(parentPath));
    const parentField = parent.getIn(["properties", "field"]);
    const parentOperator = parent.getIn(["properties", "operator"]);
    const parentValue = parent.getIn(["properties", "value", 0]);
    const parentFieldConfig = parentField ? getFieldConfig(config2, parentField) : null;
    const parentOperatorConfig = parentOperator ? getOperatorConfig(config2, parentOperator, parentField) : null;
    const hasGroupCountRule = parentField && parentOperator && parentOperatorConfig.cardinality != 0;
    const isParentRuleGroup = parent.get("type") == "rule_group";
    const isEmptyParentGroup = !hasChildren(state, parentPath);
    const canLeaveEmpty = isParentRuleGroup ? hasGroupCountRule && parentFieldConfig.initialEmptyWhere : canLeaveEmptyGroup;
    if (isEmptyParentGroup && !canLeaveEmpty) {
      if (isParentRuleGroup) {
        state = state.deleteIn(expandTreePath(parentPath));
      }
      state = fixEmptyGroupsInTree(state);
      if (isEmptyTree(state) && !canLeaveEmptyGroup) {
        state = addItem(state, new import_immutable14.default.List(), "rule", uuid_default(), defaultRuleProperties(config2), config2);
      }
    }
    state = fixPathsInTree(state);
    return state;
  };
  var setNot = (state, path, not) => state.setIn(expandTreePath(path, "properties", "not"), not);
  var setLock = (state, path, lock) => removeIsLockedInTree(state.setIn(expandTreePath(path, "properties", "isLocked"), lock));
  var setConjunction = (state, path, conjunction) => state.setIn(expandTreePath(path, "properties", "conjunction"), conjunction);
  var _addChildren1 = (config2, item, children) => {
    if (children && Array.isArray(children)) {
      item.children1 = new import_immutable14.default.OrderedMap(
        children.reduce((map, it) => {
          const id1 = uuid_default();
          const it1 = {
            ...it,
            properties: defaultItemProperties(config2, it).merge(it.properties || {}),
            id: id1
          };
          _addChildren1(config2, it1, it1.children1);
          return {
            ...map,
            [id1]: new import_immutable14.default.Map(it1)
          };
        }, {})
      );
    }
  };
  var addItem = (state, path, type, id, properties, config2, children = null) => {
    if (type == "switch_group")
      throw new Error("Can't add switch_group programmatically");
    const { maxNumberOfCases, maxNumberOfRules, maxNesting } = config2.settings;
    const rootType = state.get("type");
    const isTernary = rootType == "switch_group";
    const targetItem = state.getIn(expandTreePath(path));
    const caseGroup = isTernary ? state.getIn(expandTreePath(path.take(2))) : null;
    const childrenPath = expandTreePath(path, "children1");
    const targetChildren = state.getIn(childrenPath);
    const hasChildren2 = !!targetChildren && targetChildren.size;
    const targetChildrenSize = hasChildren2 ? targetChildren.size : null;
    let currentNumber, maxNumber;
    if (type == "case_group") {
      currentNumber = targetChildrenSize;
      maxNumber = maxNumberOfCases;
    } else if (type == "group") {
      currentNumber = path.size;
      maxNumber = maxNesting;
    } else if (targetItem?.get("type") == "rule_group") {
    } else {
      currentNumber = isTernary ? getTotalRulesCountInTree(caseGroup) : getTotalRulesCountInTree(state);
      maxNumber = maxNumberOfRules;
    }
    const canAdd = maxNumber && currentNumber ? currentNumber < maxNumber : true;
    const item = { type, id, properties };
    _addChildren1(config2, item, children);
    const isLastDefaultCase = type == "case_group" && hasChildren2 && targetChildren.last().get("children1") == null;
    if (canAdd) {
      const newChildren = new import_immutable14.default.OrderedMap({
        [id]: new import_immutable14.default.Map(item)
      });
      if (!hasChildren2) {
        state = state.setIn(childrenPath, newChildren);
      } else if (isLastDefaultCase) {
        const last5 = targetChildren.last();
        const newChildrenWithLast = new import_immutable14.default.OrderedMap({
          [id]: new import_immutable14.default.Map(item),
          [last5.get("id")]: last5
        });
        state = state.deleteIn(expandTreePath(childrenPath, "children1", last5.get("id")));
        state = state.mergeIn(childrenPath, newChildrenWithLast);
      } else {
        state = state.mergeIn(childrenPath, newChildren);
      }
      state = fixPathsInTree(state);
    }
    return state;
  };
  var removeItem = (state, path) => {
    state = state.deleteIn(expandTreePath(path));
    state = fixPathsInTree(state);
    return state;
  };
  var moveItem = (state, fromPath, toPath, placement, config2) => {
    const from = getItemByPath(state, fromPath);
    const sourcePath = fromPath.pop();
    const source = fromPath.size > 1 ? getItemByPath(state, sourcePath) : null;
    const sourceChildren = source ? source.get("children1") : null;
    const to = getItemByPath(state, toPath);
    const targetPath = placement == PLACEMENT_APPEND || placement == PLACEMENT_PREPEND ? toPath : toPath.pop();
    const target = placement == PLACEMENT_APPEND || placement == PLACEMENT_PREPEND ? to : toPath.size > 1 ? getItemByPath(state, targetPath) : null;
    const targetChildren = target ? target.get("children1") : null;
    if (!source || !target || !from)
      return state;
    const isSameParent = source.get("id") == target.get("id");
    const isSourceInsideTarget = targetPath.size < sourcePath.size && deepEqual(targetPath.toArray(), sourcePath.toArray().slice(0, targetPath.size));
    const isTargetInsideSource = targetPath.size > sourcePath.size && deepEqual(sourcePath.toArray(), targetPath.toArray().slice(0, sourcePath.size));
    let sourceSubpathFromTarget = null;
    let targetSubpathFromSource = null;
    if (isSourceInsideTarget) {
      sourceSubpathFromTarget = import_immutable14.default.List(sourcePath.toArray().slice(targetPath.size));
    } else if (isTargetInsideSource) {
      targetSubpathFromSource = import_immutable14.default.List(targetPath.toArray().slice(sourcePath.size));
    }
    let newTargetChildren = targetChildren, newSourceChildren = sourceChildren;
    if (!isTargetInsideSource)
      newSourceChildren = newSourceChildren.delete(from.get("id"));
    if (isSameParent) {
      newTargetChildren = newSourceChildren;
    } else if (isSourceInsideTarget) {
      newTargetChildren = newTargetChildren.updateIn(expandTreeSubpath(sourceSubpathFromTarget, "children1"), (_oldChildren) => newSourceChildren);
    }
    if (placement == PLACEMENT_BEFORE || placement == PLACEMENT_AFTER) {
      newTargetChildren = import_immutable14.default.OrderedMap().withMutations((r) => {
        for (let [itemId, item] of newTargetChildren.entries()) {
          if (itemId == to.get("id") && placement == PLACEMENT_BEFORE) {
            r.set(from.get("id"), from);
          }
          r.set(itemId, item);
          if (itemId == to.get("id") && placement == PLACEMENT_AFTER) {
            r.set(from.get("id"), from);
          }
        }
      });
    } else if (placement == PLACEMENT_APPEND) {
      newTargetChildren = newTargetChildren.merge({ [from.get("id")]: from });
    } else if (placement == PLACEMENT_PREPEND) {
      newTargetChildren = import_immutable14.default.OrderedMap({ [from.get("id")]: from }).merge(newTargetChildren);
    }
    if (isTargetInsideSource) {
      newSourceChildren = newSourceChildren.updateIn(expandTreeSubpath(targetSubpathFromSource, "children1"), (_oldChildren) => newTargetChildren);
      newSourceChildren = newSourceChildren.delete(from.get("id"));
    }
    if (!isSameParent && !isSourceInsideTarget)
      state = state.updateIn(expandTreePath(sourcePath, "children1"), (_oldChildren) => newSourceChildren);
    if (!isTargetInsideSource)
      state = state.updateIn(expandTreePath(targetPath, "children1"), (_oldChildren) => newTargetChildren);
    state = fixPathsInTree(state);
    return state;
  };
  var setField = (state, path, newField, config2) => {
    if (!newField)
      return removeItem(state, path);
    const { fieldSeparator, setOpOnChangeField, showErrorMessage } = config2.settings;
    if (Array.isArray(newField))
      newField = newField.join(fieldSeparator);
    const currentType = state.getIn(expandTreePath(path, "type"));
    const currentProperties = state.getIn(expandTreePath(path, "properties"));
    const wasRuleGroup = currentType == "rule_group";
    const newFieldConfig = getFieldConfig(config2, newField);
    const isRuleGroup = newFieldConfig.type == "!group";
    const isRuleGroupExt = isRuleGroup && newFieldConfig.mode == "array";
    const isChangeToAnotherType = wasRuleGroup != isRuleGroup;
    const currentOperator = currentProperties.get("operator");
    const currentOperatorOptions = currentProperties.get("operatorOptions");
    const _currentField = currentProperties.get("field");
    const _currentValue = currentProperties.get("value");
    const _currentValueSrc = currentProperties.get("valueSrc", new import_immutable14.default.List());
    const _currentValueType = currentProperties.get("valueType", new import_immutable14.default.List());
    const lastOp = newFieldConfig && newFieldConfig.operators.indexOf(currentOperator) !== -1 ? currentOperator : null;
    let newOperator = null;
    const availOps = getOperatorsForField(config2, newField);
    if (availOps && availOps.length == 1)
      newOperator = availOps[0];
    else if (availOps && availOps.length > 1) {
      for (let strategy of setOpOnChangeField || []) {
        if (strategy == "keep" && !isChangeToAnotherType)
          newOperator = lastOp;
        else if (strategy == "default")
          newOperator = defaultOperator(config2, newField, false);
        else if (strategy == "first")
          newOperator = getFirstOperator(config2, newField);
        if (newOperator)
          break;
      }
    }
    if (!isRuleGroup && !newFieldConfig.operators) {
      console.warn(`Type ${newFieldConfig.type} is not supported`);
      return state;
    }
    if (wasRuleGroup && !isRuleGroup) {
      state = state.setIn(expandTreePath(path, "type"), "rule");
      state = state.deleteIn(expandTreePath(path, "children1"));
      state = state.setIn(expandTreePath(path, "properties"), new import_immutable14.default.OrderedMap());
    }
    if (isRuleGroup) {
      state = state.setIn(expandTreePath(path, "type"), "rule_group");
      const { canReuseValue, newValue, newValueSrc, newValueType, operatorCardinality } = getNewValueForFieldOp(
        config2,
        config2,
        currentProperties,
        newField,
        newOperator,
        "field",
        true
      );
      let groupProperties = defaultGroupProperties(config2, newFieldConfig).merge({
        field: newField,
        mode: newFieldConfig.mode
      });
      if (isRuleGroupExt) {
        groupProperties = groupProperties.merge({
          operator: newOperator,
          value: newValue,
          valueSrc: newValueSrc,
          valueType: newValueType
        });
      }
      state = state.setIn(expandTreePath(path, "children1"), new import_immutable14.default.OrderedMap());
      state = state.setIn(expandTreePath(path, "properties"), groupProperties);
      if (newFieldConfig.initialEmptyWhere && operatorCardinality == 1) {
      } else {
        state = addItem(state, path, "rule", uuid_default(), defaultRuleProperties(config2, newField), config2);
      }
      state = fixPathsInTree(state);
      return state;
    }
    return state.updateIn(expandTreePath(path, "properties"), (map) => map.withMutations((current) => {
      const { canReuseValue, newValue, newValueSrc, newValueType, newValueError } = getNewValueForFieldOp(
        config2,
        config2,
        current,
        newField,
        newOperator,
        "field",
        true
      );
      if (showErrorMessage) {
        current = current.set("valueError", newValueError);
      }
      const newOperatorOptions = canReuseValue ? currentOperatorOptions : defaultOperatorOptions(config2, newOperator, newField);
      return current.set("field", newField).set("operator", newOperator).set("operatorOptions", newOperatorOptions).set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType).delete("asyncListValues");
    }));
  };
  var setOperator = (state, path, newOperator, config2) => {
    const { showErrorMessage } = config2.settings;
    const properties = state.getIn(expandTreePath(path, "properties"));
    const children = state.getIn(expandTreePath(path, "children1"));
    const currentField = properties.get("field");
    const fieldConfig = getFieldConfig(config2, currentField);
    const isRuleGroup = fieldConfig.type == "!group";
    const operatorConfig = getOperatorConfig(config2, newOperator, currentField);
    const operatorCardinality = operatorConfig ? defaultValue3(operatorConfig.cardinality, 1) : null;
    state = state.updateIn(expandTreePath(path, "properties"), (map) => map.withMutations((current) => {
      const currentField2 = current.get("field");
      const currentOperatorOptions = current.get("operatorOptions");
      const _currentValue = current.get("value", new import_immutable14.default.List());
      const _currentValueSrc = current.get("valueSrc", new import_immutable14.default.List());
      const _currentOperator = current.get("operator");
      const { canReuseValue, newValue, newValueSrc, newValueType, newValueError } = getNewValueForFieldOp(
        config2,
        config2,
        current,
        currentField2,
        newOperator,
        "operator",
        true
      );
      if (showErrorMessage) {
        current = current.set("valueError", newValueError);
      }
      const newOperatorOptions = canReuseValue ? currentOperatorOptions : defaultOperatorOptions(config2, newOperator, currentField2);
      if (!canReuseValue) {
        current = current.delete("asyncListValues");
      }
      return current.set("operator", newOperator).set("operatorOptions", newOperatorOptions).set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType);
    }));
    if (isRuleGroup) {
      if (operatorCardinality == 0 && children.size == 0) {
        state = addItem(state, path, "rule", uuid_default(), defaultRuleProperties(config2, currentField), config2);
      }
    }
    return state;
  };
  var setValue = (state, path, delta, value, valueType, config2, asyncListValues, __isInternal) => {
    const { fieldSeparator, showErrorMessage } = config2.settings;
    let isInternalValueChange;
    const valueSrc = state.getIn(expandTreePath(path, "properties", "valueSrc", delta + "")) || null;
    if (valueSrc === "field" && Array.isArray(value))
      value = value.join(fieldSeparator);
    const field = state.getIn(expandTreePath(path, "properties", "field")) || null;
    const operator = state.getIn(expandTreePath(path, "properties", "operator")) || null;
    const operatorConfig = getOperatorConfig(config2, operator, field);
    const operatorCardinality = operator ? defaultValue3(operatorConfig.cardinality, 1) : null;
    const isEndValue = false;
    const calculatedValueType = valueType || calculateValueType(value, valueSrc, config2);
    const canFix = false;
    const [validateError, fixedValue] = validateValue(
      config2,
      field,
      field,
      operator,
      value,
      calculatedValueType,
      valueSrc,
      asyncListValues,
      canFix,
      isEndValue
    );
    const isValid = !validateError;
    if (fixedValue !== value) {
      value = fixedValue;
    }
    if (showErrorMessage) {
      const w = getWidgetForFieldOp(config2, field, operator, valueSrc);
      const fieldWidgetDefinition = getFieldWidgetConfig(config2, field, operator, w, valueSrc);
      const valueSrcs = Array.from({ length: operatorCardinality }, (_, i) => state.getIn(expandTreePath(path, "properties", "valueSrc", i + "")) || null);
      if (operatorConfig && operatorConfig.validateValues && valueSrcs.filter((vs) => vs == "value" || vs == null).length == operatorCardinality) {
        const values = Array.from({ length: operatorCardinality }, (_, i) => i == delta ? value : state.getIn(expandTreePath(path, "properties", "value", i + "")) || null);
        const jsValues = fieldWidgetDefinition && fieldWidgetDefinition.toJS ? values.map((v) => fieldWidgetDefinition.toJS(v, fieldWidgetDefinition)) : values;
        const rangeValidateError = operatorConfig.validateValues(jsValues);
        state = state.setIn(expandTreePath(path, "properties", "valueError", operatorCardinality), rangeValidateError);
      }
    }
    const lastValueArr = state.getIn(expandTreePath(path, "properties", "value"));
    if (!lastValueArr) {
      state = state.setIn(expandTreePath(path, "properties", "value"), new import_immutable14.default.List(new Array(operatorCardinality))).setIn(expandTreePath(path, "properties", "valueType"), new import_immutable14.default.List(new Array(operatorCardinality))).setIn(expandTreePath(path, "properties", "valueError"), new import_immutable14.default.List(new Array(operatorCardinality)));
    }
    const lastValue = state.getIn(expandTreePath(path, "properties", "value", delta + ""));
    const lastError = state.getIn(expandTreePath(path, "properties", "valueError", delta));
    const isLastEmpty = lastValue == void 0;
    const isLastError = !!lastError;
    if (isValid || showErrorMessage) {
      state = state.deleteIn(expandTreePath(path, "properties", "asyncListValues"));
      if (typeof value === "undefined") {
        state = state.setIn(expandTreePath(path, "properties", "value", delta + ""), void 0);
        state = state.setIn(expandTreePath(path, "properties", "valueType", delta + ""), null);
      } else {
        if (asyncListValues) {
          state = state.setIn(expandTreePath(path, "properties", "asyncListValues"), asyncListValues);
        }
        state = state.setIn(expandTreePath(path, "properties", "value", delta + ""), value);
        state = state.setIn(expandTreePath(path, "properties", "valueType", delta + ""), calculatedValueType);
        isInternalValueChange = __isInternal && !isLastEmpty && !isLastError;
      }
    }
    if (showErrorMessage) {
      state = state.setIn(expandTreePath(path, "properties", "valueError", delta), validateError);
    }
    if (__isInternal && (isValid && isLastError || !isValid && !isLastError)) {
      state = state.setIn(expandTreePath(path, "properties", "valueError", delta), validateError);
      isInternalValueChange = false;
    }
    return { tree: state, isInternalValueChange };
  };
  var setValueSrc = (state, path, delta, srcKey, config2) => {
    const { showErrorMessage } = config2.settings;
    const field = state.getIn(expandTreePath(path, "properties", "field")) || null;
    const operator = state.getIn(expandTreePath(path, "properties", "operator")) || null;
    state = state.setIn(expandTreePath(path, "properties", "value", delta + ""), void 0);
    state = state.setIn(expandTreePath(path, "properties", "valueType", delta + ""), null);
    state = state.deleteIn(expandTreePath(path, "properties", "asyncListValues"));
    if (showErrorMessage) {
      state = state.setIn(expandTreePath(path, "properties", "valueError", delta), null);
      const operatorConfig = getOperatorConfig(config2, operator, field);
      const operatorCardinality = operator ? defaultValue3(operatorConfig.cardinality, 1) : null;
      if (operatorConfig.validateValues) {
        state = state.setIn(expandTreePath(path, "properties", "valueError", operatorCardinality), null);
      }
    }
    if (typeof srcKey === "undefined") {
      state = state.setIn(expandTreePath(path, "properties", "valueSrc", delta + ""), null);
    } else {
      state = state.setIn(expandTreePath(path, "properties", "valueSrc", delta + ""), srcKey);
    }
    if (srcKey) {
      const properties = state.getIn(expandTreePath(path, "properties"));
      const { canReuseValue, newValue, newValueSrc, newValueType, newValueError } = getNewValueForFieldOp(
        config2,
        config2,
        properties,
        field,
        operator,
        "valueSrc",
        true
      );
      if (!canReuseValue && newValueSrc.get(delta) == srcKey) {
        state = state.setIn(expandTreePath(path, "properties", "value", delta + ""), newValue.get(delta));
        state = state.setIn(expandTreePath(path, "properties", "valueType", delta + ""), newValueType.get(delta));
      }
    }
    return state;
  };
  var setOperatorOption = (state, path, name, value) => {
    return state.setIn(expandTreePath(path, "properties", "operatorOptions", name), value);
  };
  var checkEmptyGroups = (state, config2) => {
    const { canLeaveEmptyGroup } = config2.settings;
    if (!canLeaveEmptyGroup) {
      state = fixEmptyGroupsInTree(state);
    }
    return state;
  };
  var calculateValueType = (value, valueSrc, config2) => {
    let calculatedValueType = null;
    if (value) {
      if (valueSrc === "field") {
        const fieldConfig = getFieldConfig(config2, value);
        if (fieldConfig) {
          calculatedValueType = fieldConfig.type;
        }
      } else if (valueSrc === "func") {
        const funcKey = value.get("func");
        if (funcKey) {
          const funcConfig = getFuncConfig(config2, funcKey);
          if (funcConfig) {
            calculatedValueType = funcConfig.returnType;
          }
        }
      }
    }
    return calculatedValueType;
  };
  var getField = (state, path) => {
    const field = state.getIn(expandTreePath(path, "properties", "field")) || null;
    return field;
  };
  var emptyDrag = {
    dragging: {
      id: null,
      x: null,
      y: null,
      w: null,
      h: null
    },
    mousePos: {},
    dragStart: {
      id: null
    }
  };
  var getActionMeta = (action, state) => {
    if (!action || !action.type)
      return null;
    const actionKeysToOmit = [
      "config",
      "asyncListValues",
      "__isInternal"
    ];
    const actionTypesToIgnore = [
      SET_TREE,
      SET_DRAG_START,
      SET_DRAG_PROGRESS,
      SET_DRAG_END
    ];
    let meta = (0, import_mapValues.default)((0, import_omit7.default)(action, actionKeysToOmit), applyToJS);
    let affectedField = action.path && getField(state.tree, action.path) || action.field;
    if (affectedField)
      meta.affectedField = affectedField;
    if (actionTypesToIgnore.includes(action.type) || action.type.indexOf("@@redux") == 0)
      meta = null;
    return meta;
  };
  var tree_default = (config2, tree2, getMemoizedTree) => {
    const emptyTree = defaultRoot(config2);
    const initTree = tree2 || emptyTree;
    const emptyState = {
      tree: initTree,
      ...emptyDrag
    };
    return (state = emptyState, action) => {
      const unset = { __isInternalValueChange: void 0, __lastAction: void 0 };
      let set3 = {};
      let actionMeta = getActionMeta(action, state);
      switch (action?.type) {
        case SET_TREE: {
          const validatedTree = getMemoizedTree(action.config, action.tree);
          set3.tree = validatedTree;
          break;
        }
        case ADD_CASE_GROUP: {
          set3.tree = addNewGroup(state.tree, action.path, "case_group", action.id, action.properties, action.config, action.children, action.meta);
          break;
        }
        case ADD_GROUP: {
          set3.tree = addNewGroup(state.tree, action.path, "group", action.id, action.properties, action.config, action.children, action.meta);
          break;
        }
        case REMOVE_GROUP: {
          set3.tree = removeGroup(state.tree, action.path, action.config);
          break;
        }
        case ADD_RULE: {
          set3.tree = addItem(state.tree, action.path, action.ruleType, action.id, action.properties, action.config, action.children);
          break;
        }
        case REMOVE_RULE: {
          set3.tree = removeRule(state.tree, action.path, action.config);
          break;
        }
        case SET_CONJUNCTION: {
          set3.tree = setConjunction(state.tree, action.path, action.conjunction);
          break;
        }
        case SET_NOT: {
          set3.tree = setNot(state.tree, action.path, action.not);
          break;
        }
        case SET_FIELD: {
          set3.tree = setField(state.tree, action.path, action.field, action.config);
          break;
        }
        case SET_LOCK: {
          set3.tree = setLock(state.tree, action.path, action.lock);
          break;
        }
        case SET_OPERATOR: {
          set3.tree = setOperator(state.tree, action.path, action.operator, action.config);
          break;
        }
        case SET_VALUE: {
          const { tree: tree3, isInternalValueChange } = setValue(
            state.tree,
            action.path,
            action.delta,
            action.value,
            action.valueType,
            action.config,
            action.asyncListValues,
            action.__isInternal
          );
          set3.__isInternalValueChange = isInternalValueChange;
          set3.tree = tree3;
          break;
        }
        case SET_VALUE_SRC: {
          set3.tree = setValueSrc(state.tree, action.path, action.delta, action.srcKey, action.config);
          break;
        }
        case SET_OPERATOR_OPTION: {
          set3.tree = setOperatorOption(state.tree, action.path, action.name, action.value);
          break;
        }
        case MOVE_ITEM: {
          set3.tree = moveItem(state.tree, action.fromPath, action.toPath, action.placement, action.config);
          break;
        }
        case SET_DRAG_START: {
          set3.dragStart = action.dragStart;
          set3.dragging = action.dragging;
          set3.mousePos = action.mousePos;
          break;
        }
        case SET_DRAG_PROGRESS: {
          set3.mousePos = action.mousePos;
          set3.dragging = action.dragging;
          break;
        }
        case SET_DRAG_END: {
          set3.tree = checkEmptyGroups(state.tree, config2);
          set3 = { ...set3, ...emptyDrag };
          break;
        }
        default: {
          break;
        }
      }
      if (actionMeta) {
        set3.__lastAction = actionMeta;
      }
      return { ...state, ...unset, ...set3 };
    };
  };

  // node_modules/@react-awesome-query-builder/core/modules/actions/index.js
  var actions_exports = {};
  __export(actions_exports, {
    group: () => group_exports,
    rule: () => rule_exports,
    tree: () => tree_exports
  });

  // node_modules/@react-awesome-query-builder/core/modules/actions/tree.js
  var tree_exports = {};
  __export(tree_exports, {
    addCaseGroup: () => addCaseGroup,
    addDefaultCaseGroup: () => addDefaultCaseGroup,
    addGroup: () => addGroup,
    addRule: () => addRule,
    moveItem: () => moveItem2,
    removeGroup: () => removeGroup2,
    removeRule: () => removeRule2,
    setTree: () => setTree
  });
  var import_immutable15 = __toESM(require_immutable());
  var setTree = (config2, tree2) => ({
    type: SET_TREE,
    tree: tree2,
    config: config2
  });
  var addRule = (config2, path, properties, ruleType = "rule", children = null) => ({
    type: ADD_RULE,
    ruleType,
    children,
    path: toImmutableList(path),
    id: uuid_default(),
    properties: defaultRuleProperties(config2).merge(properties || {}),
    config: config2
  });
  var removeRule2 = (config2, path) => ({
    type: REMOVE_RULE,
    path: toImmutableList(path),
    config: config2
  });
  var addDefaultCaseGroup = (config2, path, properties, children = null) => ({
    type: ADD_CASE_GROUP,
    path: toImmutableList(path),
    children,
    id: uuid_default(),
    properties: defaultGroupProperties(config2).merge(properties || {}),
    config: config2,
    meta: {
      isDefaultCase: true
    }
  });
  var addCaseGroup = (config2, path, properties, children = null) => ({
    type: ADD_CASE_GROUP,
    path: toImmutableList(path),
    children,
    id: uuid_default(),
    properties: defaultGroupProperties(config2).merge(properties || {}),
    config: config2
  });
  var addGroup = (config2, path, properties, children = null) => ({
    type: ADD_GROUP,
    path: toImmutableList(path),
    children,
    id: uuid_default(),
    properties: defaultGroupProperties(config2).merge(properties || {}),
    config: config2
  });
  var removeGroup2 = (config2, path) => ({
    type: REMOVE_GROUP,
    path: toImmutableList(path),
    config: config2
  });
  var moveItem2 = (config2, fromPath, toPath, placement) => ({
    type: MOVE_ITEM,
    fromPath: toImmutableList(fromPath),
    toPath: toImmutableList(toPath),
    placement,
    config: config2
  });

  // node_modules/@react-awesome-query-builder/core/modules/actions/group.js
  var group_exports = {};
  __export(group_exports, {
    setConjunction: () => setConjunction2,
    setLock: () => setLock2,
    setNot: () => setNot2
  });
  var setConjunction2 = (config2, path, conjunction) => ({
    type: SET_CONJUNCTION,
    path: toImmutableList(path),
    conjunction
  });
  var setNot2 = (config2, path, not) => ({
    type: SET_NOT,
    path: toImmutableList(path),
    not
  });
  var setLock2 = (config2, path, lock) => ({
    type: SET_LOCK,
    path: toImmutableList(path),
    lock
  });

  // node_modules/@react-awesome-query-builder/core/modules/actions/rule.js
  var rule_exports = {};
  __export(rule_exports, {
    setField: () => setField2,
    setOperator: () => setOperator2,
    setOperatorOption: () => setOperatorOption2,
    setValue: () => setValue2,
    setValueSrc: () => setValueSrc2
  });
  var setField2 = (config2, path, field) => ({
    type: SET_FIELD,
    path: toImmutableList(path),
    field,
    config: config2
  });
  var setOperator2 = (config2, path, operator) => ({
    type: SET_OPERATOR,
    path: toImmutableList(path),
    operator,
    config: config2
  });
  var setValue2 = (config2, path, delta, value, valueType, asyncListValues, __isInternal) => ({
    type: SET_VALUE,
    path: toImmutableList(path),
    delta,
    value,
    valueType,
    asyncListValues,
    config: config2,
    __isInternal
  });
  var setValueSrc2 = (config2, path, delta, srcKey) => ({
    type: SET_VALUE_SRC,
    path: toImmutableList(path),
    delta,
    srcKey,
    config: config2
  });
  var setOperatorOption2 = (config2, path, name, value) => ({
    type: SET_OPERATOR_OPTION,
    path: toImmutableList(path),
    name,
    value,
    config: config2
  });

  // node_modules/@react-awesome-query-builder/core/modules/index.js
  var Utils = { ...utils_exports, ...export_exports2, ...import_exports };

  // node_modules/@react-awesome-query-builder/ui/esm/components/QueryContainer.js
  var import_prop_types48 = __toESM(require_prop_types());

  // node_modules/@react-awesome-query-builder/ui/esm/stores/tree.js
  var tree_default2 = tree_default;

  // node_modules/@react-awesome-query-builder/ui/esm/stores/context.js
  var import_react106 = __toESM(require_react());
  var context_default = /* @__PURE__ */ import_react106.default.createContext();

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // node_modules/redux/es/redux.js
  var $$observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
  var randomString = function randomString2() {
    return Math.random().toString(36).substring(7).split("").join(".");
  };
  var ActionTypes = {
    INIT: "@@redux/INIT" + randomString(),
    REPLACE: "@@redux/REPLACE" + randomString(),
    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
      return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
    }
  };
  function isPlainObject(obj) {
    if (typeof obj !== "object" || obj === null)
      return false;
    var proto = obj;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(obj) === proto;
  }
  function miniKindOf(val) {
    if (val === void 0)
      return "undefined";
    if (val === null)
      return "null";
    var type = typeof val;
    switch (type) {
      case "boolean":
      case "string":
      case "number":
      case "symbol":
      case "function": {
        return type;
      }
    }
    if (Array.isArray(val))
      return "array";
    if (isDate(val))
      return "date";
    if (isError(val))
      return "error";
    var constructorName = ctorName(val);
    switch (constructorName) {
      case "Symbol":
      case "Promise":
      case "WeakMap":
      case "WeakSet":
      case "Map":
      case "Set":
        return constructorName;
    }
    return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
  }
  function ctorName(val) {
    return typeof val.constructor === "function" ? val.constructor.name : null;
  }
  function isError(val) {
    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
  }
  function isDate(val) {
    if (val instanceof Date)
      return true;
    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
  }
  function kindOf(val) {
    var typeOfVal = typeof val;
    if (true) {
      typeOfVal = miniKindOf(val);
    }
    return typeOfVal;
  }
  function createStore(reducer, preloadedState, enhancer) {
    var _ref2;
    if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
      throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
    }
    if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
      enhancer = preloadedState;
      preloadedState = void 0;
    }
    if (typeof enhancer !== "undefined") {
      if (typeof enhancer !== "function") {
        throw new Error(false ? formatProdErrorMessage(1) : "Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
      }
      return enhancer(createStore)(reducer, preloadedState);
    }
    if (typeof reducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(2) : "Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer) + "'");
    }
    var currentReducer = reducer;
    var currentState = preloadedState;
    var currentListeners = [];
    var nextListeners = currentListeners;
    var isDispatching = false;
    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }
    function getState() {
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
      }
      return currentState;
    }
    function subscribe(listener) {
      if (typeof listener !== "function") {
        throw new Error(false ? formatProdErrorMessage(4) : "Expected the listener to be a function. Instead, received: '" + kindOf(listener) + "'");
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      var isSubscribed = true;
      ensureCanMutateNextListeners();
      nextListeners.push(listener);
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }
        if (isDispatching) {
          throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        }
        isSubscribed = false;
        ensureCanMutateNextListeners();
        var index = nextListeners.indexOf(listener);
        nextListeners.splice(index, 1);
        currentListeners = null;
      };
    }
    function dispatch2(action) {
      if (!isPlainObject(action)) {
        throw new Error(false ? formatProdErrorMessage(7) : "Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
      }
      if (typeof action.type === "undefined") {
        throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
      }
      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }
      var listeners = currentListeners = nextListeners;
      for (var i = 0; i < listeners.length; i++) {
        var listener = listeners[i];
        listener();
      }
      return action;
    }
    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== "function") {
        throw new Error(false ? formatProdErrorMessage(10) : "Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
      }
      currentReducer = nextReducer;
      dispatch2({
        type: ActionTypes.REPLACE
      });
    }
    function observable() {
      var _ref;
      var outerSubscribe = subscribe;
      return _ref = {
        /**
         * The minimal observable subscription method.
         * @param {Object} observer Any object that can be used as an observer.
         * The observer object should have a `next` method.
         * @returns {subscription} An object with an `unsubscribe` method that can
         * be used to unsubscribe the observable from the store, and prevent further
         * emission of values from the observable.
         */
        subscribe: function subscribe2(observer) {
          if (typeof observer !== "object" || observer === null) {
            throw new Error(false ? formatProdErrorMessage(11) : "Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
          }
          function observeState() {
            if (observer.next) {
              observer.next(getState());
            }
          }
          observeState();
          var unsubscribe = outerSubscribe(observeState);
          return {
            unsubscribe
          };
        }
      }, _ref[$$observable] = function() {
        return this;
      }, _ref;
    }
    dispatch2({
      type: ActionTypes.INIT
    });
    return _ref2 = {
      dispatch: dispatch2,
      subscribe,
      getState,
      replaceReducer
    }, _ref2[$$observable] = observable, _ref2;
  }

  // node_modules/react-redux/es/components/Provider.js
  var import_react109 = __toESM(require_react());
  var import_prop_types46 = __toESM(require_prop_types());

  // node_modules/react-redux/es/components/Context.js
  var import_react107 = __toESM(require_react());
  var ReactReduxContext = /* @__PURE__ */ import_react107.default.createContext(null);
  if (true) {
    ReactReduxContext.displayName = "ReactRedux";
  }

  // node_modules/react-redux/es/utils/batch.js
  function defaultNoopBatch(callback) {
    callback();
  }
  var batch = defaultNoopBatch;
  var setBatch = function setBatch2(newBatch) {
    return batch = newBatch;
  };
  var getBatch = function getBatch2() {
    return batch;
  };

  // node_modules/react-redux/es/utils/Subscription.js
  function createListenerCollection() {
    var batch2 = getBatch();
    var first = null;
    var last5 = null;
    return {
      clear: function clear() {
        first = null;
        last5 = null;
      },
      notify: function notify2() {
        batch2(function() {
          var listener = first;
          while (listener) {
            listener.callback();
            listener = listener.next;
          }
        });
      },
      get: function get2() {
        var listeners = [];
        var listener = first;
        while (listener) {
          listeners.push(listener);
          listener = listener.next;
        }
        return listeners;
      },
      subscribe: function subscribe(callback) {
        var isSubscribed = true;
        var listener = last5 = {
          callback,
          next: null,
          prev: last5
        };
        if (listener.prev) {
          listener.prev.next = listener;
        } else {
          first = listener;
        }
        return function unsubscribe() {
          if (!isSubscribed || first === null)
            return;
          isSubscribed = false;
          if (listener.next) {
            listener.next.prev = listener.prev;
          } else {
            last5 = listener.prev;
          }
          if (listener.prev) {
            listener.prev.next = listener.next;
          } else {
            first = listener.next;
          }
        };
      }
    };
  }
  var nullListeners = {
    notify: function notify() {
    },
    get: function get() {
      return [];
    }
  };
  function createSubscription(store, parentSub) {
    var unsubscribe;
    var listeners = nullListeners;
    function addNestedSub(listener) {
      trySubscribe();
      return listeners.subscribe(listener);
    }
    function notifyNestedSubs() {
      listeners.notify();
    }
    function handleChangeWrapper() {
      if (subscription.onStateChange) {
        subscription.onStateChange();
      }
    }
    function isSubscribed() {
      return Boolean(unsubscribe);
    }
    function trySubscribe() {
      if (!unsubscribe) {
        unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
        listeners = createListenerCollection();
      }
    }
    function tryUnsubscribe() {
      if (unsubscribe) {
        unsubscribe();
        unsubscribe = void 0;
        listeners.clear();
        listeners = nullListeners;
      }
    }
    var subscription = {
      addNestedSub,
      notifyNestedSubs,
      handleChangeWrapper,
      isSubscribed,
      trySubscribe,
      tryUnsubscribe,
      getListeners: function getListeners() {
        return listeners;
      }
    };
    return subscription;
  }

  // node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js
  var import_react108 = __toESM(require_react());
  var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? import_react108.useLayoutEffect : import_react108.useEffect;

  // node_modules/react-redux/es/components/Provider.js
  function Provider(_ref) {
    var store = _ref.store, context = _ref.context, children = _ref.children;
    var contextValue = (0, import_react109.useMemo)(function() {
      var subscription = createSubscription(store);
      return {
        store,
        subscription
      };
    }, [store]);
    var previousState = (0, import_react109.useMemo)(function() {
      return store.getState();
    }, [store]);
    useIsomorphicLayoutEffect(function() {
      var subscription = contextValue.subscription;
      subscription.onStateChange = subscription.notifyNestedSubs;
      subscription.trySubscribe();
      if (previousState !== store.getState()) {
        subscription.notifyNestedSubs();
      }
      return function() {
        subscription.tryUnsubscribe();
        subscription.onStateChange = null;
      };
    }, [contextValue, previousState]);
    var Context2 = context || ReactReduxContext;
    return /* @__PURE__ */ import_react109.default.createElement(Context2.Provider, {
      value: contextValue
    }, children);
  }
  if (true) {
    Provider.propTypes = {
      store: import_prop_types46.default.shape({
        subscribe: import_prop_types46.default.func.isRequired,
        dispatch: import_prop_types46.default.func.isRequired,
        getState: import_prop_types46.default.func.isRequired
      }),
      context: import_prop_types46.default.object,
      children: import_prop_types46.default.any
    };
  }
  var Provider_default = Provider;

  // node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends88() {
    _extends88 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends88.apply(this, arguments);
  }

  // node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
  function _objectWithoutPropertiesLoose55(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }

  // node_modules/react-redux/es/components/connectAdvanced.js
  var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
  var import_react110 = __toESM(require_react());
  var import_react_is = __toESM(require_react_is2());
  var _excluded60 = ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef", "forwardRef", "context"];
  var _excluded212 = ["reactReduxForwardedRef"];
  var EMPTY_ARRAY = [];
  var NO_SUBSCRIPTION_ARRAY = [null, null];
  var stringifyComponent = function stringifyComponent2(Comp) {
    try {
      return JSON.stringify(Comp);
    } catch (err) {
      return String(Comp);
    }
  };
  function storeStateUpdatesReducer(state, action) {
    var updateCount = state[1];
    return [action.payload, updateCount + 1];
  }
  function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
    useIsomorphicLayoutEffect(function() {
      return effectFunc.apply(void 0, effectArgs);
    }, dependencies);
  }
  function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs) {
    lastWrapperProps.current = wrapperProps;
    lastChildProps.current = actualChildProps;
    renderIsScheduled.current = false;
    if (childPropsFromStoreUpdate.current) {
      childPropsFromStoreUpdate.current = null;
      notifyNestedSubs();
    }
  }
  function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch) {
    if (!shouldHandleStateChanges)
      return;
    var didUnsubscribe = false;
    var lastThrownError = null;
    var checkForUpdates = function checkForUpdates2() {
      if (didUnsubscribe) {
        return;
      }
      var latestStoreState = store.getState();
      var newChildProps, error2;
      try {
        newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
      } catch (e) {
        error2 = e;
        lastThrownError = e;
      }
      if (!error2) {
        lastThrownError = null;
      }
      if (newChildProps === lastChildProps.current) {
        if (!renderIsScheduled.current) {
          notifyNestedSubs();
        }
      } else {
        lastChildProps.current = newChildProps;
        childPropsFromStoreUpdate.current = newChildProps;
        renderIsScheduled.current = true;
        forceComponentUpdateDispatch({
          type: "STORE_UPDATED",
          payload: {
            error: error2
          }
        });
      }
    };
    subscription.onStateChange = checkForUpdates;
    subscription.trySubscribe();
    checkForUpdates();
    var unsubscribeWrapper = function unsubscribeWrapper2() {
      didUnsubscribe = true;
      subscription.tryUnsubscribe();
      subscription.onStateChange = null;
      if (lastThrownError) {
        throw lastThrownError;
      }
    };
    return unsubscribeWrapper;
  }
  var initStateUpdates = function initStateUpdates2() {
    return [null, 0];
  };
  function connectAdvanced(selectorFactory, _ref) {
    if (_ref === void 0) {
      _ref = {};
    }
    var _ref2 = _ref, _ref2$getDisplayName = _ref2.getDisplayName, getDisplayName = _ref2$getDisplayName === void 0 ? function(name) {
      return "ConnectAdvanced(" + name + ")";
    } : _ref2$getDisplayName, _ref2$methodName = _ref2.methodName, methodName = _ref2$methodName === void 0 ? "connectAdvanced" : _ref2$methodName, _ref2$renderCountProp = _ref2.renderCountProp, renderCountProp = _ref2$renderCountProp === void 0 ? void 0 : _ref2$renderCountProp, _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges, shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta, _ref2$storeKey = _ref2.storeKey, storeKey = _ref2$storeKey === void 0 ? "store" : _ref2$storeKey, _ref2$withRef = _ref2.withRef, withRef = _ref2$withRef === void 0 ? false : _ref2$withRef, _ref2$forwardRef = _ref2.forwardRef, forwardRef51 = _ref2$forwardRef === void 0 ? false : _ref2$forwardRef, _ref2$context = _ref2.context, context = _ref2$context === void 0 ? ReactReduxContext : _ref2$context, connectOptions = _objectWithoutPropertiesLoose55(_ref2, _excluded60);
    if (true) {
      if (renderCountProp !== void 0) {
        throw new Error("renderCountProp is removed. render counting is built into the latest React Dev Tools profiling extension");
      }
      if (withRef) {
        throw new Error("withRef is removed. To access the wrapped instance, use a ref on the connected component");
      }
      var customStoreWarningMessage = "To use a custom Redux store for specific components, create a custom React context with React.createContext(), and pass the context object to React Redux's Provider and specific components like: <Provider context={MyContext}><ConnectedComponent context={MyContext} /></Provider>. You may also pass a {context : MyContext} option to connect";
      if (storeKey !== "store") {
        throw new Error("storeKey has been removed and does not do anything. " + customStoreWarningMessage);
      }
    }
    var Context2 = context;
    return function wrapWithConnect(WrappedComponent) {
      if (!(0, import_react_is.isValidElementType)(WrappedComponent)) {
        throw new Error("You must pass a component to the function returned by " + (methodName + ". Instead received " + stringifyComponent(WrappedComponent)));
      }
      var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
      var displayName = getDisplayName(wrappedComponentName);
      var selectorFactoryOptions = _extends88({}, connectOptions, {
        getDisplayName,
        methodName,
        renderCountProp,
        shouldHandleStateChanges,
        storeKey,
        displayName,
        wrappedComponentName,
        WrappedComponent
      });
      var pure = connectOptions.pure;
      function createChildSelector(store) {
        return selectorFactory(store.dispatch, selectorFactoryOptions);
      }
      var usePureOnlyMemo = pure ? import_react110.useMemo : function(callback) {
        return callback();
      };
      function ConnectFunction(props) {
        var _useMemo = (0, import_react110.useMemo)(function() {
          var reactReduxForwardedRef2 = props.reactReduxForwardedRef, wrapperProps2 = _objectWithoutPropertiesLoose55(props, _excluded212);
          return [props.context, reactReduxForwardedRef2, wrapperProps2];
        }, [props]), propsContext = _useMemo[0], reactReduxForwardedRef = _useMemo[1], wrapperProps = _useMemo[2];
        var ContextToUse = (0, import_react110.useMemo)(function() {
          return propsContext && propsContext.Consumer && (0, import_react_is.isContextConsumer)(/* @__PURE__ */ import_react110.default.createElement(propsContext.Consumer, null)) ? propsContext : Context2;
        }, [propsContext, Context2]);
        var contextValue = (0, import_react110.useContext)(ContextToUse);
        var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
        var didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
        if (!didStoreComeFromProps && !didStoreComeFromContext) {
          throw new Error('Could not find "store" in the context of ' + ('"' + displayName + '". Either wrap the root component in a <Provider>, ') + "or pass a custom React context provider to <Provider> and the corresponding " + ("React context consumer to " + displayName + " in connect options."));
        }
        var store = didStoreComeFromProps ? props.store : contextValue.store;
        var childPropsSelector = (0, import_react110.useMemo)(function() {
          return createChildSelector(store);
        }, [store]);
        var _useMemo2 = (0, import_react110.useMemo)(function() {
          if (!shouldHandleStateChanges)
            return NO_SUBSCRIPTION_ARRAY;
          var subscription2 = createSubscription(store, didStoreComeFromProps ? null : contextValue.subscription);
          var notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
          return [subscription2, notifyNestedSubs2];
        }, [store, didStoreComeFromProps, contextValue]), subscription = _useMemo2[0], notifyNestedSubs = _useMemo2[1];
        var overriddenContextValue = (0, import_react110.useMemo)(function() {
          if (didStoreComeFromProps) {
            return contextValue;
          }
          return _extends88({}, contextValue, {
            subscription
          });
        }, [didStoreComeFromProps, contextValue, subscription]);
        var _useReducer = (0, import_react110.useReducer)(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates), _useReducer$ = _useReducer[0], previousStateUpdateResult = _useReducer$[0], forceComponentUpdateDispatch = _useReducer[1];
        if (previousStateUpdateResult && previousStateUpdateResult.error) {
          throw previousStateUpdateResult.error;
        }
        var lastChildProps = (0, import_react110.useRef)();
        var lastWrapperProps = (0, import_react110.useRef)(wrapperProps);
        var childPropsFromStoreUpdate = (0, import_react110.useRef)();
        var renderIsScheduled = (0, import_react110.useRef)(false);
        var actualChildProps = usePureOnlyMemo(function() {
          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
            return childPropsFromStoreUpdate.current;
          }
          return childPropsSelector(store.getState(), wrapperProps);
        }, [store, previousStateUpdateResult, wrapperProps]);
        useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs]);
        useIsomorphicLayoutEffectWithArgs(subscribeUpdates, [shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch], [store, subscription, childPropsSelector]);
        var renderedWrappedComponent = (0, import_react110.useMemo)(function() {
          return /* @__PURE__ */ import_react110.default.createElement(WrappedComponent, _extends88({}, actualChildProps, {
            ref: reactReduxForwardedRef
          }));
        }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
        var renderedChild = (0, import_react110.useMemo)(function() {
          if (shouldHandleStateChanges) {
            return /* @__PURE__ */ import_react110.default.createElement(ContextToUse.Provider, {
              value: overriddenContextValue
            }, renderedWrappedComponent);
          }
          return renderedWrappedComponent;
        }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
        return renderedChild;
      }
      var Connect = pure ? import_react110.default.memo(ConnectFunction) : ConnectFunction;
      Connect.WrappedComponent = WrappedComponent;
      Connect.displayName = ConnectFunction.displayName = displayName;
      if (forwardRef51) {
        var forwarded = import_react110.default.forwardRef(function forwardConnectRef(props, ref) {
          return /* @__PURE__ */ import_react110.default.createElement(Connect, _extends88({}, props, {
            reactReduxForwardedRef: ref
          }));
        });
        forwarded.displayName = displayName;
        forwarded.WrappedComponent = WrappedComponent;
        return (0, import_hoist_non_react_statics.default)(forwarded, WrappedComponent);
      }
      return (0, import_hoist_non_react_statics.default)(Connect, WrappedComponent);
    };
  }

  // node_modules/react-redux/es/utils/shallowEqual.js
  function is(x, y) {
    if (x === y) {
      return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }
  function shallowEqual2(objA, objB) {
    if (is(objA, objB))
      return true;
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
      return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length)
      return false;
    for (var i = 0; i < keysA.length; i++) {
      if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }
    return true;
  }

  // node_modules/react-redux/es/utils/bindActionCreators.js
  function bindActionCreators(actionCreators, dispatch2) {
    var boundActionCreators = {};
    var _loop = function _loop2(key2) {
      var actionCreator = actionCreators[key2];
      if (typeof actionCreator === "function") {
        boundActionCreators[key2] = function() {
          return dispatch2(actionCreator.apply(void 0, arguments));
        };
      }
    };
    for (var key in actionCreators) {
      _loop(key);
    }
    return boundActionCreators;
  }

  // node_modules/react-redux/es/utils/isPlainObject.js
  function isPlainObject2(obj) {
    if (typeof obj !== "object" || obj === null)
      return false;
    var proto = Object.getPrototypeOf(obj);
    if (proto === null)
      return true;
    var baseProto = proto;
    while (Object.getPrototypeOf(baseProto) !== null) {
      baseProto = Object.getPrototypeOf(baseProto);
    }
    return proto === baseProto;
  }

  // node_modules/react-redux/es/utils/warning.js
  function warning(message) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
      console.error(message);
    }
    try {
      throw new Error(message);
    } catch (e) {
    }
  }

  // node_modules/react-redux/es/utils/verifyPlainObject.js
  function verifyPlainObject(value, displayName, methodName) {
    if (!isPlainObject2(value)) {
      warning(methodName + "() in " + displayName + " must return a plain object. Instead received " + value + ".");
    }
  }

  // node_modules/react-redux/es/connect/wrapMapToProps.js
  function wrapMapToPropsConstant(getConstant) {
    return function initConstantSelector(dispatch2, options2) {
      var constant = getConstant(dispatch2, options2);
      function constantSelector() {
        return constant;
      }
      constantSelector.dependsOnOwnProps = false;
      return constantSelector;
    };
  }
  function getDependsOnOwnProps(mapToProps) {
    return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== void 0 ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
  }
  function wrapMapToPropsFunc(mapToProps, methodName) {
    return function initProxySelector(dispatch2, _ref) {
      var displayName = _ref.displayName;
      var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
        return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
      };
      proxy.dependsOnOwnProps = true;
      proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
        proxy.mapToProps = mapToProps;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
        var props = proxy(stateOrDispatch, ownProps);
        if (typeof props === "function") {
          proxy.mapToProps = props;
          proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
          props = proxy(stateOrDispatch, ownProps);
        }
        if (true)
          verifyPlainObject(props, displayName, methodName);
        return props;
      };
      return proxy;
    };
  }

  // node_modules/react-redux/es/connect/mapDispatchToProps.js
  function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
    return typeof mapDispatchToProps === "function" ? wrapMapToPropsFunc(mapDispatchToProps, "mapDispatchToProps") : void 0;
  }
  function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
    return !mapDispatchToProps ? wrapMapToPropsConstant(function(dispatch2) {
      return {
        dispatch: dispatch2
      };
    }) : void 0;
  }
  function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
    return mapDispatchToProps && typeof mapDispatchToProps === "object" ? wrapMapToPropsConstant(function(dispatch2) {
      return bindActionCreators(mapDispatchToProps, dispatch2);
    }) : void 0;
  }
  var mapDispatchToProps_default = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];

  // node_modules/react-redux/es/connect/mapStateToProps.js
  function whenMapStateToPropsIsFunction(mapStateToProps) {
    return typeof mapStateToProps === "function" ? wrapMapToPropsFunc(mapStateToProps, "mapStateToProps") : void 0;
  }
  function whenMapStateToPropsIsMissing(mapStateToProps) {
    return !mapStateToProps ? wrapMapToPropsConstant(function() {
      return {};
    }) : void 0;
  }
  var mapStateToProps_default = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];

  // node_modules/react-redux/es/connect/mergeProps.js
  function defaultMergeProps(stateProps, dispatchProps, ownProps) {
    return _extends88({}, ownProps, stateProps, dispatchProps);
  }
  function wrapMergePropsFunc(mergeProps) {
    return function initMergePropsProxy(dispatch2, _ref) {
      var displayName = _ref.displayName, pure = _ref.pure, areMergedPropsEqual = _ref.areMergedPropsEqual;
      var hasRunOnce = false;
      var mergedProps;
      return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
        var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        if (hasRunOnce) {
          if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps))
            mergedProps = nextMergedProps;
        } else {
          hasRunOnce = true;
          mergedProps = nextMergedProps;
          if (true)
            verifyPlainObject(mergedProps, displayName, "mergeProps");
        }
        return mergedProps;
      };
    };
  }
  function whenMergePropsIsFunction(mergeProps) {
    return typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : void 0;
  }
  function whenMergePropsIsOmitted(mergeProps) {
    return !mergeProps ? function() {
      return defaultMergeProps;
    } : void 0;
  }
  var mergeProps_default = [whenMergePropsIsFunction, whenMergePropsIsOmitted];

  // node_modules/react-redux/es/connect/verifySubselectors.js
  function verify(selector, methodName, displayName) {
    if (!selector) {
      throw new Error("Unexpected value for " + methodName + " in " + displayName + ".");
    } else if (methodName === "mapStateToProps" || methodName === "mapDispatchToProps") {
      if (!Object.prototype.hasOwnProperty.call(selector, "dependsOnOwnProps")) {
        warning("The selector for " + methodName + " of " + displayName + " did not specify a value for dependsOnOwnProps.");
      }
    }
  }
  function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
    verify(mapStateToProps, "mapStateToProps", displayName);
    verify(mapDispatchToProps, "mapDispatchToProps", displayName);
    verify(mergeProps, "mergeProps", displayName);
  }

  // node_modules/react-redux/es/connect/selectorFactory.js
  var _excluded61 = ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"];
  function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch2) {
    return function impureFinalPropsSelector(state, ownProps) {
      return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch2, ownProps), ownProps);
    };
  }
  function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch2, _ref) {
    var areStatesEqual = _ref.areStatesEqual, areOwnPropsEqual = _ref.areOwnPropsEqual, areStatePropsEqual = _ref.areStatePropsEqual;
    var hasRunAtLeastOnce = false;
    var state;
    var ownProps;
    var stateProps;
    var dispatchProps;
    var mergedProps;
    function handleFirstCall(firstState, firstOwnProps) {
      state = firstState;
      ownProps = firstOwnProps;
      stateProps = mapStateToProps(state, ownProps);
      dispatchProps = mapDispatchToProps(dispatch2, ownProps);
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      hasRunAtLeastOnce = true;
      return mergedProps;
    }
    function handleNewPropsAndNewState() {
      stateProps = mapStateToProps(state, ownProps);
      if (mapDispatchToProps.dependsOnOwnProps)
        dispatchProps = mapDispatchToProps(dispatch2, ownProps);
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      return mergedProps;
    }
    function handleNewProps() {
      if (mapStateToProps.dependsOnOwnProps)
        stateProps = mapStateToProps(state, ownProps);
      if (mapDispatchToProps.dependsOnOwnProps)
        dispatchProps = mapDispatchToProps(dispatch2, ownProps);
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      return mergedProps;
    }
    function handleNewState() {
      var nextStateProps = mapStateToProps(state, ownProps);
      var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
      stateProps = nextStateProps;
      if (statePropsChanged)
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      return mergedProps;
    }
    function handleSubsequentCalls(nextState, nextOwnProps) {
      var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
      var stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);
      state = nextState;
      ownProps = nextOwnProps;
      if (propsChanged && stateChanged)
        return handleNewPropsAndNewState();
      if (propsChanged)
        return handleNewProps();
      if (stateChanged)
        return handleNewState();
      return mergedProps;
    }
    return function pureFinalPropsSelector(nextState, nextOwnProps) {
      return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
    };
  }
  function finalPropsSelectorFactory(dispatch2, _ref2) {
    var initMapStateToProps = _ref2.initMapStateToProps, initMapDispatchToProps = _ref2.initMapDispatchToProps, initMergeProps = _ref2.initMergeProps, options2 = _objectWithoutPropertiesLoose55(_ref2, _excluded61);
    var mapStateToProps = initMapStateToProps(dispatch2, options2);
    var mapDispatchToProps = initMapDispatchToProps(dispatch2, options2);
    var mergeProps = initMergeProps(dispatch2, options2);
    if (true) {
      verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, options2.displayName);
    }
    var selectorFactory = options2.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
    return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch2, options2);
  }

  // node_modules/react-redux/es/connect/connect.js
  var _excluded62 = ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"];
  function match(arg, factories, name) {
    for (var i = factories.length - 1; i >= 0; i--) {
      var result = factories[i](arg);
      if (result)
        return result;
    }
    return function(dispatch2, options2) {
      throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options2.wrappedComponentName + ".");
    };
  }
  function strictEqual(a, b) {
    return a === b;
  }
  function createConnect(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, _ref$connectHOC = _ref.connectHOC, connectHOC = _ref$connectHOC === void 0 ? connectAdvanced : _ref$connectHOC, _ref$mapStateToPropsF = _ref.mapStateToPropsFactories, mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? mapStateToProps_default : _ref$mapStateToPropsF, _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories, mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? mapDispatchToProps_default : _ref$mapDispatchToPro, _ref$mergePropsFactor = _ref.mergePropsFactories, mergePropsFactories = _ref$mergePropsFactor === void 0 ? mergeProps_default : _ref$mergePropsFactor, _ref$selectorFactory = _ref.selectorFactory, selectorFactory = _ref$selectorFactory === void 0 ? finalPropsSelectorFactory : _ref$selectorFactory;
    return function connect(mapStateToProps, mapDispatchToProps, mergeProps, _ref2) {
      if (_ref2 === void 0) {
        _ref2 = {};
      }
      var _ref3 = _ref2, _ref3$pure = _ref3.pure, pure = _ref3$pure === void 0 ? true : _ref3$pure, _ref3$areStatesEqual = _ref3.areStatesEqual, areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual, _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual, areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? shallowEqual2 : _ref3$areOwnPropsEqua, _ref3$areStatePropsEq = _ref3.areStatePropsEqual, areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? shallowEqual2 : _ref3$areStatePropsEq, _ref3$areMergedPropsE = _ref3.areMergedPropsEqual, areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? shallowEqual2 : _ref3$areMergedPropsE, extraOptions = _objectWithoutPropertiesLoose55(_ref3, _excluded62);
      var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, "mapStateToProps");
      var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, "mapDispatchToProps");
      var initMergeProps = match(mergeProps, mergePropsFactories, "mergeProps");
      return connectHOC(selectorFactory, _extends88({
        // used in error messages
        methodName: "connect",
        // used to compute Connect's displayName from the wrapped component's displayName.
        getDisplayName: function getDisplayName(name) {
          return "Connect(" + name + ")";
        },
        // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
        shouldHandleStateChanges: Boolean(mapStateToProps),
        // passed through to selectorFactory
        initMapStateToProps,
        initMapDispatchToProps,
        initMergeProps,
        pure,
        areStatesEqual,
        areOwnPropsEqual,
        areStatePropsEqual,
        areMergedPropsEqual
      }, extraOptions));
    };
  }
  var connect_default = /* @__PURE__ */ createConnect();

  // node_modules/react-redux/es/hooks/useStore.js
  var import_react112 = __toESM(require_react());

  // node_modules/react-redux/es/hooks/useReduxContext.js
  var import_react111 = __toESM(require_react());

  // node_modules/react-redux/es/hooks/useSelector.js
  var import_react113 = __toESM(require_react());

  // node_modules/react-redux/es/utils/reactBatchedUpdates.js
  var import_react_dom3 = __toESM(require_react_dom());

  // node_modules/react-redux/es/index.js
  setBatch(import_react_dom3.unstable_batchedUpdates);

  // node_modules/@react-awesome-query-builder/ui/esm/actions/drag.js
  var drag_exports = {};
  __export(drag_exports, {
    setDragEnd: () => setDragEnd,
    setDragProgress: () => setDragProgress,
    setDragStart: () => setDragStart
  });

  // node_modules/@react-awesome-query-builder/ui/esm/stores/constants.js
  var PLACEMENT_AFTER2 = "after";
  var PLACEMENT_BEFORE2 = "before";
  var PLACEMENT_APPEND2 = "append";
  var PLACEMENT_PREPEND2 = "prepend";
  var SET_DRAG_PROGRESS2 = "SET_DRAG_PROGRESS";
  var SET_DRAG_START2 = "SET_DRAG_START";
  var SET_DRAG_END2 = "SET_DRAG_END";

  // node_modules/@react-awesome-query-builder/ui/esm/actions/drag.js
  var setDragProgress = function setDragProgress2(mousePos, dragging) {
    return {
      type: SET_DRAG_PROGRESS2,
      mousePos,
      dragging
    };
  };
  var setDragStart = function setDragStart2(dragStart, dragging, mousePos) {
    return {
      type: SET_DRAG_START2,
      dragStart,
      dragging,
      mousePos
    };
  };
  var setDragEnd = function setDragEnd2() {
    return {
      type: SET_DRAG_END2
    };
  };

  // node_modules/@react-awesome-query-builder/ui/esm/actions/index.js
  var tree = actions_exports.tree;
  var group = actions_exports.group;
  var rule = actions_exports.rule;

  // node_modules/@react-awesome-query-builder/ui/esm/utils/configUtils.js
  var import_pick6 = __toESM(require_pick());
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  var extendConfig2 = Utils.ConfigUtils.extendConfig;
  var configKeys = ["conjunctions", "fields", "types", "operators", "widgets", "settings", "funcs"];
  var pickConfig = function pickConfig2(props) {
    return (0, import_pick6.default)(props, configKeys);
  };
  var createConfigMemo = function createConfigMemo2() {
    var configStore = /* @__PURE__ */ new Map();
    var maxSize = 2;
    var configId = 0;
    var extendAndStore = function extendAndStore2(config2) {
      var extendedConfig = extendConfig2(config2, ++configId);
      if (configStore.size + 1 > maxSize) {
        configStore["delete"](configStore.keys()[0]);
      }
      configStore.set(config2, extendedConfig);
      return extendedConfig;
    };
    var findExtended = function findExtended2(findConfig) {
      var _iterator = _createForOfIteratorHelper(configStore.keys()), _step;
      try {
        var _loop = function _loop3() {
          var savedConfig = _step.value;
          var found = configKeys.map(function(k) {
            return savedConfig[k] === findConfig[k];
          }).filter(function(v) {
            return !v;
          }).length === 0;
          if (found) {
            return {
              v: configStore.get(savedConfig)
            };
          }
        };
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _ret = _loop();
          if (_typeof(_ret) === "object")
            return _ret.v;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var _iterator2 = _createForOfIteratorHelper(configStore.values()), _step2;
      try {
        var _loop2 = function _loop22() {
          var extendedConfig = _step2.value;
          var found = configKeys.map(function(k) {
            return extendedConfig[k] === findConfig[k];
          }).filter(function(v) {
            return !v;
          }).length === 0;
          if (found) {
            return {
              v: extendedConfig
            };
          }
        };
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _ret2 = _loop2();
          if (_typeof(_ret2) === "object")
            return _ret2.v;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return null;
    };
    var findOrExtend = function findOrExtend2(config2) {
      return findExtended(config2) || extendAndStore(config2);
    };
    return function(props) {
      return findOrExtend(pickConfig(props));
    };
  };

  // node_modules/@react-awesome-query-builder/ui/esm/utils/stuff.js
  var defaultValue4 = function defaultValue5(value, _default) {
    return typeof value === "undefined" ? _default : value;
  };
  var truncateString = function truncateString2(str, n, useWordBoundary) {
    if (!n || str.length <= n) {
      return str;
    }
    var subString = str.substr(0, n - 1);
    return (useWordBoundary ? subString.substr(0, subString.lastIndexOf(" ")) : subString) + "...";
  };
  var immutableEqual = function immutableEqual2(v1, v2) {
    if (v1 === v2) {
      return true;
    } else {
      return v1.equals(v2);
    }
  };
  var shallowEqual3 = function shallowEqual4(a, b) {
    var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (a === b) {
      return true;
    } else if (Array.isArray(a))
      return shallowEqualArrays2(a, b, deep);
    else if (a && typeof a.equals === "function")
      return a.equals(b);
    else if (_typeof(a) === "object")
      return shallowEqualObjects2(a, b, deep);
    else
      return a === b;
  };
  function shallowEqualArrays2(arrA, arrB) {
    var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (arrA === arrB) {
      return true;
    }
    if (!arrA || !arrB) {
      return false;
    }
    var len = arrA.length;
    if (arrB.length !== len) {
      return false;
    }
    for (var i = 0; i < len; i++) {
      var isEqual = deep ? shallowEqual3(arrA[i], arrB[i], deep) : arrA[i] === arrB[i];
      if (!isEqual) {
        return false;
      }
    }
    return true;
  }
  function shallowEqualObjects2(objA, objB) {
    var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (objA === objB) {
      return true;
    }
    if (!objA || !objB) {
      return false;
    }
    var aKeys = Object.keys(objA);
    var bKeys = Object.keys(objB);
    var len = aKeys.length;
    if (bKeys.length !== len) {
      return false;
    }
    for (var i = 0; i < len; i++) {
      var key = aKeys[i];
      var isEqual = deep ? shallowEqual3(objA[key], objB[key], deep) : objA[key] === objB[key];
      if (!isEqual) {
        return false;
      }
    }
    return true;
  }
  var isDev2 = function isDev3() {
    return typeof process !== "undefined" && process.env && true;
  };
  var getLogger2 = function getLogger3() {
    var devMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var verbose = devMode != void 0 ? devMode : isDev2();
    return verbose ? console : {
      error: function error2() {
      },
      log: function log() {
      },
      warn: function warn() {
      },
      debug: function debug() {
      },
      info: function info() {
      }
    };
  };
  var logger2 = getLogger2();

  // node_modules/@react-awesome-query-builder/ui/esm/utils/validation.js
  var validateAndFixTree2 = Utils.validateAndFixTree;
  var createValidationMemo = function createValidationMemo2() {
    var originalTree;
    var validatedTree;
    var configId;
    return function(config2, tree2, oldConfig) {
      if (!tree2) {
        return null;
      }
      if (config2.__configId === configId && (immutableEqual(tree2, originalTree) || immutableEqual(tree2, validatedTree))) {
        return validatedTree;
      } else {
        configId = config2.__configId;
        originalTree = tree2;
        validatedTree = validateAndFixTree2(tree2, null, config2, oldConfig || config2);
        return validatedTree;
      }
    };
  };

  // node_modules/@react-awesome-query-builder/ui/esm/utils/reactUtils.js
  var import_react114 = __toESM(require_react());
  var import_mapValues2 = __toESM(require_mapValues());
  var getReactContainerType = function getReactContainerType2(el) {
    if (el._reactRootContainer) {
      return "root";
    }
    if (Object.getOwnPropertyNames(el).filter(function(k) {
      return k.startsWith("__reactContainer");
    }).length > 0) {
      return "container";
    }
    return void 0;
  };
  var getReactRootNodeType = function getReactRootNodeType2(node) {
    if (!node) {
      return void 0;
    }
    var type = getReactContainerType(node);
    if (type !== void 0) {
      return type;
    } else {
      return getReactRootNodeType2(node.parentNode);
    }
  };
  var isUsingLegacyReactDomRender = function isUsingLegacyReactDomRender2(node) {
    return getReactRootNodeType(node) === "root";
  };
  var liteShouldComponentUpdate = function liteShouldComponentUpdate2(self2, config2) {
    return function(nextProps, nextState) {
      var prevProps = self2.props;
      var prevState = self2.state;
      var should = nextProps != prevProps || nextState != prevState;
      if (should) {
        if (prevState == nextState && prevProps != nextProps) {
          var chs = [];
          for (var k in nextProps) {
            var changed = nextProps[k] != prevProps[k];
            if (changed) {
              if (config2[k] == "ignore")
                changed = false;
              else if (config2[k] == "shallow_deep")
                changed = !shallowEqual3(nextProps[k], prevProps[k], true);
              else if (config2[k] == "shallow")
                changed = !shallowEqual3(nextProps[k], prevProps[k]);
              else if (typeof config2[k] == "function")
                changed = config2[k](nextProps[k], prevProps[k], nextState);
            }
            if (changed)
              chs.push(k);
          }
          if (!chs.length)
            should = false;
        }
      }
      return should;
    };
  };
  var pureShouldComponentUpdate = function pureShouldComponentUpdate2(self2) {
    return function(nextProps, nextState) {
      return !shallowEqual3(self2.props, nextProps) || !shallowEqual3(self2.state, nextState);
    };
  };
  var canUseUnsafe = function canUseUnsafe2() {
    var v = import_react114.default.version.split(".").map(parseInt.bind(null, 10));
    return v[0] == 16 && v[1] >= 3 || v[0] > 16;
  };
  var useOnPropsChanged = function useOnPropsChanged2(obj) {
    if (canUseUnsafe) {
      obj.UNSAFE_componentWillReceiveProps = function(nextProps) {
        obj.onPropsChanged(nextProps);
      };
    } else {
      obj.componentWillReceiveProps = function(nextProps) {
        obj.onPropsChanged(nextProps);
      };
    }
  };
  var bindActionCreators2 = function bindActionCreators3(actionCreators, config2, dispatch2) {
    return (0, import_mapValues2.default)(actionCreators, function(actionCreator) {
      return function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return dispatch2(actionCreator.apply(void 0, [config2].concat(args)));
      };
    });
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/Query.js
  var import_react115 = __toESM(require_react());
  var import_prop_types47 = __toESM(require_prop_types());
  function ownKeys(object, enumerableOnly) {
    var keys5 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys5.push.apply(keys5, symbols);
    }
    return keys5;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var Query = /* @__PURE__ */ function(_Component) {
    _inherits(Query2, _Component);
    var _super = _createSuper(Query2);
    function Query2(props) {
      var _this;
      _classCallCheck(this, Query2);
      _this = _super.call(this, props);
      _this.shouldComponentUpdate = liteShouldComponentUpdate(_assertThisInitialized(_this), {
        tree: function tree2(nextValue) {
          if (nextValue === _this.oldValidatedTree && _this.oldValidatedTree === _this.validatedTree) {
            return false;
          }
          return true;
        }
      });
      useOnPropsChanged(_assertThisInitialized(_this));
      _this._updateActions(props);
      _this.validatedTree = props.getMemoizedTree(props.config, props.tree);
      _this.oldValidatedTree = _this.validatedTree;
      return _this;
    }
    _createClass(Query2, [{
      key: "_updateActions",
      value: function _updateActions(props) {
        var config2 = props.config, dispatch2 = props.dispatch;
        this.actions = bindActionCreators2(_objectSpread(_objectSpread(_objectSpread({}, tree), group), rule), config2, dispatch2);
      }
    }, {
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        var onChange2 = nextProps.onChange;
        var oldConfig = this.props.config;
        var newTree = nextProps.tree;
        var oldTree = this.props.tree;
        var newConfig = nextProps.config;
        this.oldValidatedTree = this.validatedTree;
        this.validatedTree = newTree;
        if (oldConfig !== newConfig) {
          this._updateActions(nextProps);
          this.validatedTree = nextProps.getMemoizedTree(newConfig, newTree, oldConfig);
        }
        var validatedTreeChanged = !immutableEqual(this.validatedTree, this.oldValidatedTree);
        if (validatedTreeChanged) {
          onChange2 && onChange2(this.validatedTree, newConfig, nextProps.__lastAction);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props, config2 = _this$props.config, renderBuilder2 = _this$props.renderBuilder, dispatch2 = _this$props.dispatch, __isInternalValueChange = _this$props.__isInternalValueChange;
        var builderProps = {
          tree: this.validatedTree,
          actions: this.actions,
          config: config2,
          dispatch: dispatch2,
          __isInternalValueChange
        };
        return renderBuilder2(builderProps);
      }
    }]);
    return Query2;
  }(import_react115.Component);
  Query.propTypes = {
    config: import_prop_types47.default.object.isRequired,
    onChange: import_prop_types47.default.func,
    renderBuilder: import_prop_types47.default.func,
    tree: import_prop_types47.default.any
    //instanceOf(Immutable.Map)
    //dispatch: PropTypes.func.isRequired,
    //__isInternalValueChange
    //__lastAction
    //getMemoizedTree: PropTypes.func.isRequired,
  };
  var ConnectedQuery = connect_default(function(state) {
    return {
      tree: state.tree,
      __isInternalValueChange: state.__isInternalValueChange,
      __lastAction: state.__lastAction
    };
  }, null, null, {
    context: context_default
  })(Query);
  ConnectedQuery.displayName = "ConnectedQuery";
  var Query_default = ConnectedQuery;

  // node_modules/@react-awesome-query-builder/ui/esm/components/QueryContainer.js
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var defaultRoot2 = Utils.DefaultUtils.defaultRoot;
  var QueryContainer = /* @__PURE__ */ function(_Component) {
    _inherits(QueryContainer2, _Component);
    var _super = _createSuper2(QueryContainer2);
    function QueryContainer2(props, context) {
      var _this;
      _classCallCheck(this, QueryContainer2);
      _this = _super.call(this, props, context);
      _this.shouldComponentUpdate = liteShouldComponentUpdate(_assertThisInitialized(_this), {
        value: function value(nextValue, prevValue, state) {
          return false;
        }
      });
      useOnPropsChanged(_assertThisInitialized(_this));
      _this.getMemoizedConfig = createConfigMemo();
      _this.getMemoizedTree = createValidationMemo();
      var config2 = _this.getMemoizedConfig(props);
      var tree2 = props.value;
      var validatedTree = _this.getMemoizedTree(config2, tree2);
      var reducer = tree_default2(config2, validatedTree, _this.getMemoizedTree);
      var store = createStore(reducer);
      _this.state = {
        store,
        config: config2
      };
      return _this;
    }
    _createClass(QueryContainer2, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        var _this2 = this;
        var oldConfig = this.state.config;
        var nextConfig = this.getMemoizedConfig(nextProps);
        var isConfigChanged = oldConfig !== nextConfig;
        var storeValue = this.state.store.getState().tree;
        var isTreeChanged = !immutableEqual(nextProps.value, this.props.value) && !immutableEqual(nextProps.value, storeValue);
        var currentTree = isTreeChanged ? nextProps.value || defaultRoot2(nextProps) : storeValue;
        if (isConfigChanged) {
          this.setState({
            config: nextConfig
          });
        }
        if (isTreeChanged || isConfigChanged) {
          var validatedTree = this.getMemoizedTree(nextConfig, currentTree, oldConfig);
          return Promise.resolve().then(function() {
            _this2.state.store.dispatch(tree.setTree(nextConfig, validatedTree));
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props, renderBuilder2 = _this$props.renderBuilder, get_children = _this$props.get_children, onChange2 = _this$props.onChange, settings4 = _this$props.settings;
        var _this$state = this.state, config2 = _this$state.config, store = _this$state.store;
        var QueryWrapper = settings4.renderProvider;
        return /* @__PURE__ */ import_react116.default.createElement(QueryWrapper, {
          config: config2
        }, /* @__PURE__ */ import_react116.default.createElement(Provider_default, {
          store,
          context: context_default
        }, /* @__PURE__ */ import_react116.default.createElement(Query_default, {
          config: config2,
          getMemoizedTree: this.getMemoizedTree,
          onChange: onChange2,
          renderBuilder: renderBuilder2 || get_children
        })));
      }
    }]);
    return QueryContainer2;
  }(import_react116.Component);
  QueryContainer.propTypes = {
    //config
    conjunctions: import_prop_types48.default.object.isRequired,
    fields: import_prop_types48.default.object.isRequired,
    types: import_prop_types48.default.object.isRequired,
    operators: import_prop_types48.default.object.isRequired,
    widgets: import_prop_types48.default.object.isRequired,
    settings: import_prop_types48.default.object.isRequired,
    onChange: import_prop_types48.default.func,
    renderBuilder: import_prop_types48.default.func,
    value: import_prop_types48.default.any
    //instanceOf(Immutable.Map)
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/Builder.js
  var import_react140 = __toESM(require_react());
  var import_prop_types63 = __toESM(require_prop_types());

  // node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose55(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/Item.js
  var import_react139 = __toESM(require_react());
  var import_prop_types62 = __toESM(require_prop_types());

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/Rule.js
  var import_react128 = __toESM(require_react());
  var import_prop_types56 = __toESM(require_prop_types());

  // node_modules/@react-awesome-query-builder/ui/esm/components/containers/RuleContainer.js
  var import_react117 = __toESM(require_react());
  var import_prop_types49 = __toESM(require_prop_types());
  var import_classnames = __toESM(require_classnames());
  function _createSuper3(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct3();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct3() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var getFieldConfig2 = Utils.ConfigUtils.getFieldConfig;
  var createRuleContainer = function createRuleContainer2(Rule2) {
    var _class;
    return _class = /* @__PURE__ */ function(_Component) {
      _inherits(RuleContainer, _Component);
      var _super = _createSuper3(RuleContainer);
      function RuleContainer(props) {
        var _this;
        _classCallCheck(this, RuleContainer);
        _this = _super.call(this, props);
        _this.dummyFn = function() {
        };
        _this.removeSelf = function() {
          _this.props.actions.removeRule(_this.props.path);
        };
        _this.setLock = function() {
          var lock = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          _this.props.actions.setLock(_this.props.path, lock);
        };
        _this.setField = function(field) {
          _this.props.actions.setField(_this.props.path, field);
        };
        _this.setOperator = function(operator) {
          _this.props.actions.setOperator(_this.props.path, operator);
        };
        _this.setOperatorOption = function(name, value) {
          _this.props.actions.setOperatorOption(_this.props.path, name, value);
        };
        _this.setValue = function(delta, value, type, asyncListValues, __isInternal) {
          _this.props.actions.setValue(_this.props.path, delta, value, type, asyncListValues, __isInternal);
        };
        _this.setValueSrc = function(delta, srcKey) {
          _this.props.actions.setValueSrc(_this.props.path, delta, srcKey);
        };
        _this.dummyFn.isDummyFn = true;
        return _this;
      }
      _createClass(RuleContainer, [{
        key: "shouldComponentUpdate",
        value: function shouldComponentUpdate(nextProps, nextState) {
          var prevProps = this.props;
          var prevState = this.state;
          var should = pureShouldComponentUpdate(this)(nextProps, nextState);
          if (should) {
            if (prevState == nextState && prevProps != nextProps) {
              var draggingId = nextProps.dragging.id || prevProps.dragging.id;
              var isDraggingMe = draggingId == nextProps.id;
              var chs = [];
              for (var k in nextProps) {
                var changed = nextProps[k] != prevProps[k];
                if (k == "dragging" && !isDraggingMe) {
                  changed = false;
                }
                if (changed) {
                  chs.push(k);
                }
              }
              if (!chs.length)
                should = false;
            }
          }
          return should;
        }
      }, {
        key: "render",
        value: function render() {
          var isDraggingMe = this.props.dragging.id == this.props.id;
          var fieldConfig = getFieldConfig2(this.props.config, this.props.field);
          var showErrorMessage = this.props.config.settings.showErrorMessage;
          var _isGroup = fieldConfig && fieldConfig.type == "!struct";
          var isInDraggingTempo = !isDraggingMe && this.props.isDraggingTempo;
          var valueError = this.props.valueError;
          var oneValueError = valueError && valueError.toArray().filter(function(e) {
            return !!e;
          }).shift() || null;
          var hasError = oneValueError != null && showErrorMessage;
          return /* @__PURE__ */ import_react117.default.createElement("div", {
            className: (0, import_classnames.default)("group-or-rule-container", "rule-container", hasError ? "rule-with-error" : null),
            "data-id": this.props.id
          }, [isDraggingMe ? /* @__PURE__ */ import_react117.default.createElement(Rule2, {
            key: "dragging",
            id: this.props.id,
            groupId: this.props.groupId,
            isDraggingMe: true,
            isDraggingTempo: true,
            dragging: this.props.dragging,
            setField: this.dummyFn,
            setOperator: this.dummyFn,
            setOperatorOption: this.dummyFn,
            setLock: this.dummyFn,
            removeSelf: this.dummyFn,
            setValue: this.dummyFn,
            setValueSrc: this.dummyFn,
            selectedField: this.props.field || null,
            parentField: this.props.parentField || null,
            selectedOperator: this.props.operator || null,
            value: this.props.value || null,
            valueSrc: this.props.valueSrc || null,
            valueError: this.props.valueError || null,
            operatorOptions: this.props.operatorOptions,
            config: this.props.config,
            reordableNodesCnt: this.props.reordableNodesCnt,
            totalRulesCnt: this.props.totalRulesCnt,
            asyncListValues: this.props.asyncListValues,
            isLocked: this.props.isLocked,
            isTrueLocked: this.props.isTrueLocked,
            parentReordableNodesCnt: this.props.parentReordableNodesCnt
          }) : null, /* @__PURE__ */ import_react117.default.createElement(Rule2, {
            key: this.props.id,
            id: this.props.id,
            groupId: this.props.groupId,
            isDraggingMe,
            isDraggingTempo: isInDraggingTempo,
            onDragStart: this.props.onDragStart,
            setLock: isInDraggingTempo ? this.dummyFn : this.setLock,
            removeSelf: isInDraggingTempo ? this.dummyFn : this.removeSelf,
            setField: isInDraggingTempo ? this.dummyFn : this.setField,
            setOperator: isInDraggingTempo ? this.dummyFn : this.setOperator,
            setOperatorOption: isInDraggingTempo ? this.dummyFn : this.setOperatorOption,
            setValue: isInDraggingTempo ? this.dummyFn : this.setValue,
            setValueSrc: isInDraggingTempo ? this.dummyFn : this.setValueSrc,
            selectedField: this.props.field || null,
            parentField: this.props.parentField || null,
            selectedOperator: this.props.operator || null,
            value: this.props.value || null,
            valueSrc: this.props.valueSrc || null,
            valueError: this.props.valueError || null,
            operatorOptions: this.props.operatorOptions,
            config: this.props.config,
            reordableNodesCnt: this.props.reordableNodesCnt,
            totalRulesCnt: this.props.totalRulesCnt,
            asyncListValues: this.props.asyncListValues,
            isLocked: this.props.isLocked,
            isTrueLocked: this.props.isTrueLocked,
            parentReordableNodesCnt: this.props.parentReordableNodesCnt
          })]);
        }
      }]);
      return RuleContainer;
    }(import_react117.Component), _class.propTypes = {
      id: import_prop_types49.default.string.isRequired,
      groupId: import_prop_types49.default.string,
      config: import_prop_types49.default.object.isRequired,
      path: import_prop_types49.default.any.isRequired,
      //instanceOf(Immutable.List)
      operator: import_prop_types49.default.string,
      field: import_prop_types49.default.string,
      actions: import_prop_types49.default.object.isRequired,
      //{removeRule: Funciton, setField, setOperator, setOperatorOption, setValue, setValueSrc, ...}
      onDragStart: import_prop_types49.default.func,
      value: import_prop_types49.default.any,
      //depends on widget
      valueSrc: import_prop_types49.default.any,
      asyncListValues: import_prop_types49.default.array,
      valueError: import_prop_types49.default.any,
      operatorOptions: import_prop_types49.default.object,
      reordableNodesCnt: import_prop_types49.default.number,
      parentField: import_prop_types49.default.string,
      //from RuleGroup
      isLocked: import_prop_types49.default.bool,
      isTrueLocked: import_prop_types49.default.bool,
      //connected:
      dragging: import_prop_types49.default.object,
      //{id, x, y, w, h}
      isDraggingTempo: import_prop_types49.default.bool
    }, _class;
  };
  var RuleContainer_default = function(Rule2) {
    var ConnectedRuleContainer = connect_default(function(state) {
      return {
        dragging: state.dragging
      };
    }, null, null, {
      context: context_default
    })(createRuleContainer(Rule2));
    ConnectedRuleContainer.displayName = "ConnectedRuleContainer";
    return ConnectedRuleContainer;
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/containers/Draggable.js
  var import_react119 = __toESM(require_react());
  var import_prop_types51 = __toESM(require_prop_types());

  // node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }

  // node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray2(arr);
  }

  // node_modules/@babel/runtime/helpers/esm/iterableToArray.js
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }

  // node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }

  // node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread();
  }

  // node_modules/@react-awesome-query-builder/ui/esm/components/containers/SortableContainer.js
  var import_react118 = __toESM(require_react());
  var import_prop_types50 = __toESM(require_prop_types());
  function _createSuper4(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct4();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct4() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var clone2 = Utils.clone;
  var getFlatTree2 = Utils.TreeUtils.getFlatTree;
  var _isReorderingTree = false;
  var createSortableContainer = function createSortableContainer2(Builder2) {
    var _class;
    var CanMoveFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return _class = /* @__PURE__ */ function(_Component) {
      _inherits(SortableContainer, _Component);
      var _super = _createSuper4(SortableContainer);
      function SortableContainer(props) {
        var _this;
        _classCallCheck(this, SortableContainer);
        _this = _super.call(this, props);
        _this._getEventTarget = function(e, dragStart) {
          return e && e.__mocked_window || document.body || window;
        };
        _this.onDragStart = function(id, dom, e) {
          var treeEl = dom.closest(".query-builder");
          if (_this._isUsingLegacyReactDomRender === void 0) {
            _this._isUsingLegacyReactDomRender = isUsingLegacyReactDomRender(treeEl);
          }
          document.body.classList.add("qb-dragging");
          treeEl.classList.add("qb-dragging");
          var treeElContainer = treeEl.closest(".query-builder-container") || treeEl;
          treeElContainer = _this._getScrollParent(treeElContainer) || document.body;
          var scrollTop = treeElContainer.scrollTop;
          var _dragEl = _this._getDraggableNodeEl(treeEl);
          var _plhEl = _this._getPlaceholderNodeEl(treeEl);
          var tmpAllGroups = treeEl.querySelectorAll(".group--children");
          var anyGroup = tmpAllGroups.length ? tmpAllGroups[0] : null;
          var groupPadding;
          if (anyGroup) {
            groupPadding = window.getComputedStyle(anyGroup, null).getPropertyValue("padding-left");
            groupPadding = parseInt(groupPadding);
          }
          var dragging = {
            id,
            x: dom.offsetLeft,
            y: dom.offsetTop,
            w: dom.offsetWidth,
            h: dom.offsetHeight,
            itemInfo: _this.tree.items[id],
            paddingLeft: groupPadding
          };
          var dragStart = {
            id,
            x: dom.offsetLeft,
            y: dom.offsetTop,
            scrollTop,
            clientX: e.clientX,
            clientY: e.clientY,
            itemInfo: clone2(_this.tree.items[id]),
            treeEl,
            treeElContainer
          };
          var mousePos = {
            clientX: e.clientX,
            clientY: e.clientY
          };
          var target = _this._getEventTarget(e, dragStart);
          _this.eventTarget = target;
          target.addEventListener("mousemove", _this.onDrag);
          target.addEventListener("mouseup", _this.onDragEnd);
          _this.props.setDragStart(dragStart, dragging, mousePos);
        };
        _this.onDrag = function(e) {
          var doHandleDrag = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var dragging = Object.assign({}, _this.props.dragging);
          var startDragging = _this.props.dragStart;
          var paddingLeft = dragging.paddingLeft;
          var treeElContainer = startDragging.treeElContainer;
          var scrollTop = treeElContainer.scrollTop;
          dragging.itemInfo = _this.tree.items[dragging.id];
          if (!dragging.itemInfo) {
            return;
          }
          var mousePos = {
            clientX: e.clientX,
            clientY: e.clientY
          };
          var startMousePos = {
            clientX: startDragging.clientX,
            clientY: startDragging.clientY
          };
          if (e.__mock_dom) {
            var treeEl = startDragging.treeEl;
            var dragEl = _this._getDraggableNodeEl(treeEl);
            var plhEl = _this._getPlaceholderNodeEl(treeEl);
            e.__mock_dom({
              treeEl,
              dragEl,
              plhEl
            });
          }
          if (!startDragging.plX) {
            var _treeEl = startDragging.treeEl;
            var _plhEl2 = _this._getPlaceholderNodeEl(_treeEl);
            if (_plhEl2) {
              startDragging.plX = _plhEl2.getBoundingClientRect().left + window.scrollX;
              startDragging.plY = _plhEl2.getBoundingClientRect().top + window.scrollY;
            }
          }
          var startX = startDragging.x;
          var startY = startDragging.y;
          var startClientX = startDragging.clientX;
          var startClientY = startDragging.clientY;
          var startScrollTop = startDragging.scrollTop;
          var pos = {
            x: startX + (e.clientX - startClientX),
            y: startY + (e.clientY - startClientY) + (scrollTop - startScrollTop)
          };
          dragging.x = pos.x;
          dragging.y = pos.y;
          dragging.paddingLeft = paddingLeft;
          dragging.mousePos = mousePos;
          dragging.startMousePos = startMousePos;
          _this.props.setDragProgress(mousePos, dragging);
          var moved = doHandleDrag ? _this.handleDrag(dragging, e, CanMoveFn) : false;
          if (!moved) {
            if (e.preventDefault)
              e.preventDefault();
          }
        };
        _this.onDragEnd = function() {
          var treeEl = _this.props.dragStart.treeEl;
          _this.props.setDragEnd();
          treeEl.classList.remove("qb-dragging");
          document.body.classList.remove("qb-dragging");
          _this._cacheEls = {};
          var target = _this.eventTarget || _this._getEventTarget();
          target.removeEventListener("mousemove", _this.onDrag);
          target.removeEventListener("mouseup", _this.onDragEnd);
        };
        useOnPropsChanged(_assertThisInitialized(_this));
        _this.onPropsChanged(props);
        return _this;
      }
      _createClass(SortableContainer, [{
        key: "onPropsChanged",
        value: function onPropsChanged(nextProps) {
          this.tree = getFlatTree2(nextProps.tree);
        }
      }, {
        key: "shouldComponentUpdate",
        value: function shouldComponentUpdate(nextProps, nextState) {
          var prevProps = this.props;
          var prevState = this.state;
          var should = pureShouldComponentUpdate(this)(nextProps, nextState);
          if (should) {
            if (prevState == nextState && prevProps != nextProps) {
              var chs = [];
              for (var k in nextProps) {
                var changed = nextProps[k] != prevProps[k];
                if (changed) {
                  if (k != "dragging" && k != "mousePos")
                    chs.push(k);
                }
              }
              if (!chs.length)
                should = false;
            }
          }
          return should;
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(_prevProps, _prevState) {
          var dragging = this.props.dragging;
          var startDragging = this.props.dragStart;
          _isReorderingTree = false;
          if (startDragging && startDragging.id) {
            dragging.itemInfo = this.tree.items[dragging.id];
            if (dragging.itemInfo) {
              if (dragging.itemInfo.index != startDragging.itemInfo.index || dragging.itemInfo.parent != startDragging.itemInfo.parent) {
                var treeEl = startDragging.treeEl;
                var treeElContainer = startDragging.treeElContainer;
                var plhEl = this._getPlaceholderNodeEl(treeEl, true);
                if (plhEl) {
                  var plX = plhEl.getBoundingClientRect().left + window.scrollX;
                  var plY = plhEl.getBoundingClientRect().top + window.scrollY;
                  var oldPlX = startDragging.plX;
                  var oldPlY = startDragging.plY;
                  var scrollTop = treeElContainer.scrollTop;
                  startDragging.plX = plX;
                  startDragging.plY = plY;
                  startDragging.itemInfo = clone2(dragging.itemInfo);
                  startDragging.y = plhEl.offsetTop;
                  startDragging.x = plhEl.offsetLeft;
                  startDragging.clientY += plY - oldPlY;
                  startDragging.clientX += plX - oldPlX;
                  if (treeElContainer != document.body)
                    startDragging.scrollTop = scrollTop;
                  this.onDrag(this.props.mousePos, false);
                }
              }
            }
          }
        }
      }, {
        key: "_getNodeElById",
        value: function _getNodeElById(treeEl, indexId) {
          var ignoreCache = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (indexId == null)
            return null;
          if (!this._cacheEls)
            this._cacheEls = {};
          var el = this._cacheEls[indexId];
          if (el && document.contains(el) && !ignoreCache)
            return el;
          el = treeEl.querySelector('.group-or-rule-container[data-id="' + indexId + '"]');
          this._cacheEls[indexId] = el;
          return el;
        }
      }, {
        key: "_getDraggableNodeEl",
        value: function _getDraggableNodeEl(treeEl) {
          var ignoreCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          if (!this._cacheEls)
            this._cacheEls = {};
          var el = this._cacheEls["draggable"];
          if (el && document.contains(el) && !ignoreCache)
            return el;
          var els = treeEl.getElementsByClassName("qb-draggable");
          el = els.length ? els[0] : null;
          this._cacheEls["draggable"] = el;
          return el;
        }
      }, {
        key: "_getPlaceholderNodeEl",
        value: function _getPlaceholderNodeEl(treeEl) {
          var ignoreCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          if (!this._cacheEls)
            this._cacheEls = {};
          var el = this._cacheEls["placeholder"];
          if (el && document.contains(el) && !ignoreCache)
            return el;
          var els = treeEl.getElementsByClassName("qb-placeholder");
          el = els.length ? els[0] : null;
          this._cacheEls["placeholder"] = el;
          return el;
        }
      }, {
        key: "_isScrollable",
        value: function _isScrollable(node) {
          var overflowY = window.getComputedStyle(node)["overflow-y"];
          return (overflowY === "scroll" || overflowY === "auto") && node.scrollHeight > node.offsetHeight;
        }
      }, {
        key: "_getScrollParent",
        value: function _getScrollParent(node) {
          if (node == null)
            return null;
          if (node === document.body || this._isScrollable(node)) {
            return node;
          } else {
            return this._getScrollParent(node.parentNode);
          }
        }
      }, {
        key: "handleDrag",
        value: function handleDrag(dragInfo, e, canMoveFn) {
          var _this2 = this;
          var canMoveBeforeAfterGroup = true;
          var itemInfo = dragInfo.itemInfo;
          var paddingLeft = dragInfo.paddingLeft;
          var moveInfo = null;
          var treeEl = this.props.dragStart.treeEl;
          var dragId = dragInfo.id;
          var dragEl = this._getDraggableNodeEl(treeEl);
          var plhEl = this._getPlaceholderNodeEl(treeEl);
          var dragRect, plhRect, hovRect, treeRect;
          if (dragEl && plhEl) {
            dragRect = dragEl.getBoundingClientRect();
            plhRect = plhEl.getBoundingClientRect();
            if (!plhRect.width) {
              return;
            }
            var dragDirs = {
              hrz: 0,
              vrt: 0
            };
            if (dragRect.top < plhRect.top)
              dragDirs.vrt = -1;
            else if (dragRect.bottom > plhRect.bottom)
              dragDirs.vrt = 1;
            if (dragRect.left > plhRect.left)
              dragDirs.hrz = 1;
            else if (dragRect.left < plhRect.left)
              dragDirs.hrz = -1;
            treeRect = treeEl.getBoundingClientRect();
            var trgCoord = {
              x: treeRect.left + (treeRect.right - treeRect.left) / 2,
              y: dragDirs.vrt >= 0 ? dragRect.bottom : dragRect.top
            };
            var hovCNodeEl;
            if (e.__mocked_hov_container) {
              hovCNodeEl = e.__mocked_hov_container;
            } else {
              var hovNodeEl = document.elementFromPoint(trgCoord.x, trgCoord.y - 1);
              hovCNodeEl = hovNodeEl ? hovNodeEl.closest(".group-or-rule-container") : null;
              if (!hovCNodeEl && hovNodeEl && hovNodeEl.classList.contains("query-builder-container")) {
                var _hovNodeEl$firstChild;
                var rootGroupContainer = hovNodeEl === null || hovNodeEl === void 0 ? void 0 : (_hovNodeEl$firstChild = hovNodeEl.firstChild) === null || _hovNodeEl$firstChild === void 0 ? void 0 : _hovNodeEl$firstChild.firstChild;
                if (rootGroupContainer && rootGroupContainer.classList.contains("group-or-rule-container")) {
                  hovCNodeEl = rootGroupContainer;
                }
              }
            }
            if (!hovCNodeEl) {
              logger2.log("out of tree bounds!");
            } else {
              var isGroup = hovCNodeEl.classList.contains("group-container");
              var hovNodeId = hovCNodeEl.getAttribute("data-id");
              var hovEl = hovCNodeEl;
              var doAppend = false;
              var doPrepend = false;
              if (hovEl) {
                hovRect = hovEl.getBoundingClientRect();
                var hovHeight = hovRect.bottom - hovRect.top;
                var hovII = this.tree.items[hovNodeId];
                var trgRect = null, trgEl = null, trgII = null, altII = null;
                if (dragDirs.vrt == 0) {
                  trgII = itemInfo;
                  trgEl = plhEl;
                  if (trgEl)
                    trgRect = trgEl.getBoundingClientRect();
                } else {
                  if (isGroup) {
                    if (dragDirs.vrt > 0) {
                      var hovInnerEl = hovCNodeEl.getElementsByClassName("group--header");
                      var hovEl2 = hovInnerEl.length ? hovInnerEl[0] : null;
                      if (hovEl2) {
                        var hovRect2 = hovEl2.getBoundingClientRect();
                        var hovHeight2 = hovRect2.bottom - hovRect2.top;
                        var isOverHover = dragRect.bottom - hovRect2.top > hovHeight2 * 3 / 4;
                        if (isOverHover && hovII.top > dragInfo.itemInfo.top) {
                          trgII = hovII;
                          trgRect = hovRect2;
                          trgEl = hovEl2;
                          doPrepend = true;
                        }
                      }
                    } else if (dragDirs.vrt < 0) {
                      if (hovII.lev >= itemInfo.lev) {
                        var isClimbToHover = hovRect.bottom - dragRect.top >= 2;
                        if (isClimbToHover && hovII.top < dragInfo.itemInfo.top) {
                          trgII = hovII;
                          trgRect = hovRect;
                          trgEl = hovEl;
                          doAppend = true;
                        }
                      }
                    }
                    if (!doPrepend && !doAppend || canMoveBeforeAfterGroup) {
                      var _isOverHover = dragDirs.vrt < 0 ? hovRect.bottom - dragRect.top > hovHeight - 5 : dragRect.bottom - hovRect.top > hovHeight - 5;
                      if (_isOverHover) {
                        if (!doPrepend && !doAppend) {
                          trgII = hovII;
                          trgRect = hovRect;
                          trgEl = hovEl;
                        }
                        if (canMoveBeforeAfterGroup) {
                          altII = hovII;
                        }
                      }
                    }
                  } else {
                    var _isOverHover2 = dragDirs.vrt < 0 ? hovRect.bottom - dragRect.top > hovHeight / 2 : dragRect.bottom - hovRect.top > hovHeight / 2;
                    if (_isOverHover2) {
                      trgII = hovII;
                      trgRect = hovRect;
                      trgEl = hovEl;
                    }
                  }
                }
                var isSamePos = trgII && trgII.id == dragId;
                if (trgRect) {
                  var dragLeftOffset = dragRect.left - treeRect.left;
                  var trgLeftOffset = trgRect.left - treeRect.left;
                  var _trgLev = trgLeftOffset / paddingLeft;
                  var dragLev = Math.max(0, Math.round(dragLeftOffset / paddingLeft));
                  var availMoves = [];
                  var altMoves = [];
                  if (isSamePos) {
                  } else {
                    if (isGroup) {
                      if (doAppend) {
                        availMoves.push([PLACEMENT_APPEND2, trgII, trgII.lev + 1]);
                      } else if (doPrepend) {
                        availMoves.push([PLACEMENT_PREPEND2, trgII, trgII.lev + 1]);
                      }
                      if (canMoveBeforeAfterGroup && altII) {
                        var isToRoot = altII.lev == 0;
                        var isToCase = altII.type == "case_group" && itemInfo.type != "case_group";
                        var prevCaseId = altII.prev && this.tree.items[altII.prev].caseId;
                        var nextCaseId = altII.next && this.tree.items[altII.next].caseId;
                        if (itemInfo.caseId == prevCaseId)
                          prevCaseId = null;
                        if (itemInfo.caseId == nextCaseId)
                          nextCaseId = null;
                        var prevCase = prevCaseId && this.tree.items[prevCaseId];
                        var nextCase = nextCaseId && this.tree.items[nextCaseId];
                        if (dragDirs.vrt > 0) {
                          if (isToRoot) {
                            altMoves.push([PLACEMENT_APPEND2, altII, altII.lev + 1]);
                          } else if (isToCase && nextCase) {
                            altMoves.push([PLACEMENT_PREPEND2, nextCase, nextCase.lev + 1]);
                          } else {
                            altMoves.push([PLACEMENT_AFTER2, altII, altII.lev]);
                          }
                        } else if (dragDirs.vrt < 0) {
                          if (isToRoot) {
                            altMoves.push([PLACEMENT_PREPEND2, altII, altII.lev + 1]);
                          } else if (isToCase && prevCase) {
                            altMoves.push([PLACEMENT_APPEND2, prevCase, prevCase.lev + 1]);
                          } else {
                            altMoves.push([PLACEMENT_BEFORE2, altII, altII.lev]);
                          }
                        }
                      }
                    }
                    if (!doAppend && !doPrepend) {
                      if (dragDirs.vrt < 0) {
                        availMoves.push([PLACEMENT_BEFORE2, trgII, trgII.lev]);
                      } else if (dragDirs.vrt > 0) {
                        availMoves.push([PLACEMENT_AFTER2, trgII, trgII.lev]);
                      }
                    }
                  }
                  var addCaseII = function addCaseII2(am) {
                    var toII = am[1];
                    var fromCaseII = itemInfo.caseId ? _this2.tree.items[itemInfo.caseId] : null;
                    var toCaseII = toII.caseId ? _this2.tree.items[toII.caseId] : null;
                    return [].concat(_toConsumableArray(am), [fromCaseII, toCaseII]);
                  };
                  availMoves = availMoves.map(addCaseII);
                  altMoves = altMoves.map(addCaseII);
                  availMoves = availMoves.filter(function(am) {
                    var placement = am[0];
                    var trg = am[1];
                    if ((placement == PLACEMENT_BEFORE2 || placement == PLACEMENT_AFTER2) && trg.parent == null)
                      return false;
                    if (trg.collapsed && (placement == PLACEMENT_APPEND2 || placement == PLACEMENT_PREPEND2))
                      return false;
                    var isInside = trg.id == itemInfo.id;
                    if (!isInside) {
                      var tmp = trg;
                      while (tmp.parent) {
                        tmp = _this2.tree.items[tmp.parent];
                        if (tmp.id == itemInfo.id) {
                          isInside = true;
                          break;
                        }
                      }
                    }
                    return !isInside;
                  }).map(function(am) {
                    var placement = am[0], toII = am[1], _lev = am[2], _fromCaseII = am[3], _toCaseII = am[4];
                    var toParentII = null;
                    if (placement == PLACEMENT_APPEND2 || placement == PLACEMENT_PREPEND2)
                      toParentII = toII;
                    else
                      toParentII = _this2.tree.items[toII.parent];
                    if (toParentII && toParentII.parent == null)
                      toParentII = null;
                    am[5] = toParentII;
                    return am;
                  });
                  var bestMode = null;
                  var filteredMoves = availMoves.filter(function(am) {
                    return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);
                  });
                  if (canMoveBeforeAfterGroup && filteredMoves.length == 0 && altMoves.length > 0) {
                    filteredMoves = altMoves.filter(function(am) {
                      return _this2.canMove(itemInfo, am[1], am[0], am[3], am[4], am[5], canMoveFn);
                    });
                  }
                  var levs = filteredMoves.map(function(am) {
                    return am[2];
                  });
                  var curLev = itemInfo.lev;
                  var allLevs = levs.concat(curLev);
                  var closestDragLev = null;
                  if (allLevs.indexOf(dragLev) != -1)
                    closestDragLev = dragLev;
                  else if (dragLev > Math.max.apply(Math, _toConsumableArray(allLevs)))
                    closestDragLev = Math.max.apply(Math, _toConsumableArray(allLevs));
                  else if (dragLev < Math.min.apply(Math, _toConsumableArray(allLevs)))
                    closestDragLev = Math.min.apply(Math, _toConsumableArray(allLevs));
                  bestMode = filteredMoves.find(function(am) {
                    return am[2] == closestDragLev;
                  });
                  if (!isSamePos && !bestMode && filteredMoves.length)
                    bestMode = filteredMoves[0];
                  moveInfo = bestMode;
                }
              }
            }
          }
          if (moveInfo) {
            this.move(itemInfo, moveInfo[1], moveInfo[0], moveInfo[3]);
            return true;
          }
          return false;
        }
      }, {
        key: "canMove",
        value: function canMove(fromII, toII, placement, fromCaseII, toCaseII, toParentII, canMoveFn) {
          if (!fromII || !toII)
            return false;
          if (fromII.id === toII.id)
            return false;
          var _this$props$config$se = this.props.config.settings, canRegroup = _this$props$config$se.canRegroup, canRegroupCases = _this$props$config$se.canRegroupCases, maxNesting = _this$props$config$se.maxNesting, maxNumberOfRules = _this$props$config$se.maxNumberOfRules, canLeaveEmptyCase = _this$props$config$se.canLeaveEmptyCase;
          var newLev = toParentII ? toParentII.lev + 1 : toII.lev;
          var isBeforeAfter = placement == PLACEMENT_BEFORE2 || placement == PLACEMENT_AFTER2;
          var isPend = placement == PLACEMENT_PREPEND2 || placement == PLACEMENT_APPEND2;
          var isLev1 = isBeforeAfter && toII.lev == 1 || isPend && toII.lev == 0;
          var isParentChange = fromII.parent != toII.parent;
          var isStructChange = isPend || isParentChange;
          var isForbiddenStructChange = fromII.type == "case_group" && !isLev1 || fromII.parentType == "rule_group" || toII.type == "rule_group" || toII.parentType == "rule_group" || fromII.type != "case_group" && toII.type == "case_group" && isBeforeAfter || fromII.type != "case_group" && toII.type == "switch_group" || !canRegroupCases && fromII.caseId != toII.caseId;
          var isLockedChange = toII.isLocked || fromII.isLocked || toParentII && toParentII.isLocked;
          if (maxNesting && newLev > maxNesting)
            return false;
          if (isStructChange && (!canRegroup || isForbiddenStructChange || isLockedChange))
            return false;
          if (fromII.type != "case_group" && fromII.caseId != toII.caseId) {
            var isLastFromCase = fromCaseII ? fromCaseII._height == 2 : false;
            var newRulesInTargetCase = toCaseII ? toCaseII.leafsCount + 1 : 0;
            if (maxNumberOfRules && newRulesInTargetCase > maxNumberOfRules)
              return false;
            if (isLastFromCase && !canLeaveEmptyCase)
              return false;
          }
          if (fromII.type == "case_group" && (fromII.isDefaultCase || toII.isDefaultCase || toII.type == "switch_group" && placement == PLACEMENT_APPEND2)) {
            return false;
          }
          var res = true;
          if (canMoveFn) {
            res = canMoveFn(fromII.node.toJS(), toII.node.toJS(), placement, toParentII ? toParentII.node.toJS() : null);
          }
          return res;
        }
      }, {
        key: "move",
        value: function move(fromII, toII, placement, toParentII) {
          if (!this._isUsingLegacyReactDomRender) {
            _isReorderingTree = true;
          }
          this.props.actions.moveItem(fromII.path, toII.path, placement);
        }
      }, {
        key: "render",
        value: function render() {
          return /* @__PURE__ */ import_react118.default.createElement(Builder2, _extends88({}, this.props, {
            onDragStart: this.onDragStart
          }));
        }
      }]);
      return SortableContainer;
    }(import_react118.Component), _class.propTypes = {
      tree: import_prop_types50.default.any.isRequired,
      //instanceOf(Immutable.Map)
      actions: import_prop_types50.default.object.isRequired
      // {moveItem: Function, ..}
      //... see Builder
    }, _class;
  };
  var SortableContainer_default = function(Builder2) {
    var CanMoveFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    var ConnectedSortableContainer = connect_default(function(state) {
      return {
        dragging: state.dragging,
        dragStart: state.dragStart,
        mousePos: state.mousePos
      };
    }, {
      setDragStart: drag_exports.setDragStart,
      setDragProgress: drag_exports.setDragProgress,
      setDragEnd: drag_exports.setDragEnd
    }, null, {
      context: context_default
    })(createSortableContainer(Builder2, CanMoveFn));
    ConnectedSortableContainer.displayName = "ConnectedSortableContainer";
    return ConnectedSortableContainer;
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/containers/Draggable.js
  var import_classnames2 = __toESM(require_classnames());
  var _excluded63 = ["isDraggingTempo", "isDraggingMe", "dragging"];
  function _createSuper5(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct5();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct5() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var Draggable_default = function(className) {
    return function(GroupOrRule) {
      var _class;
      return _class = /* @__PURE__ */ function(_PureComponent) {
        _inherits(Draggable, _PureComponent);
        var _super = _createSuper5(Draggable);
        function Draggable(props) {
          var _this;
          _classCallCheck(this, Draggable);
          _this = _super.call(this, props);
          _this.handleDraggerMouseDown = function(e) {
            var nodeId = _this.props.id;
            var dom = _this.wrapper.current;
            if (_this.props.onDragStart) {
              _this.props.onDragStart(nodeId, dom, e);
            }
          };
          _this.wrapper = /* @__PURE__ */ import_react119.default.createRef();
          return _this;
        }
        _createClass(Draggable, [{
          key: "render",
          value: function render() {
            var _this$props = this.props, isDraggingTempo = _this$props.isDraggingTempo, isDraggingMe = _this$props.isDraggingMe, dragging = _this$props.dragging, otherProps = _objectWithoutProperties(_this$props, _excluded63);
            var isTrueLocked = otherProps.isTrueLocked;
            var styles = {};
            if (isDraggingMe && isDraggingTempo) {
              if (_isReorderingTree) {
              } else {
                styles = {
                  top: dragging.y,
                  left: dragging.x,
                  width: dragging.w
                };
              }
            }
            var cn = (0, import_classnames2.default)(className, "group-or-rule", isDraggingMe && isDraggingTempo ? "qb-draggable" : null, isDraggingMe && !isDraggingTempo ? "qb-placeholder" : null, isTrueLocked ? "locked" : null);
            return /* @__PURE__ */ import_react119.default.createElement("div", {
              className: cn,
              style: styles,
              ref: this.wrapper,
              "data-id": this.props.id
            }, /* @__PURE__ */ import_react119.default.createElement(GroupOrRule, _extends88({
              handleDraggerMouseDown: this.handleDraggerMouseDown,
              isDraggingMe,
              isDraggingTempo
            }, otherProps)));
          }
        }]);
        return Draggable;
      }(import_react119.PureComponent), _class.propTypes = {
        isDraggingTempo: import_prop_types51.default.bool,
        isDraggingMe: import_prop_types51.default.bool,
        onDragStart: import_prop_types51.default.func,
        dragging: import_prop_types51.default.object,
        //{id, x, y, w, h}
        isLocked: import_prop_types51.default.bool,
        isTrueLocked: import_prop_types51.default.bool
      }, _class;
    };
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/rule/OperatorWrapper.js
  var import_react122 = __toESM(require_react());

  // node_modules/@react-awesome-query-builder/ui/esm/components/rule/Operator.js
  var import_react120 = __toESM(require_react());
  var import_prop_types52 = __toESM(require_prop_types());
  var import_keys = __toESM(require_keys());
  var import_pickBy = __toESM(require_pickBy());
  var import_mapValues3 = __toESM(require_mapValues());
  function ownKeys2(object, enumerableOnly) {
    var keys5 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys5.push.apply(keys5, symbols);
    }
    return keys5;
  }
  function _objectSpread3(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _createSuper6(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct6();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct6() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var _Utils$ConfigUtils = Utils.ConfigUtils;
  var getFieldConfig3 = _Utils$ConfigUtils.getFieldConfig;
  var getOperatorConfig2 = _Utils$ConfigUtils.getOperatorConfig;
  var Operator = /* @__PURE__ */ function(_PureComponent) {
    _inherits(Operator2, _PureComponent);
    var _super = _createSuper6(Operator2);
    function Operator2(props) {
      var _this;
      _classCallCheck(this, Operator2);
      _this = _super.call(this, props);
      useOnPropsChanged(_assertThisInitialized(_this));
      _this.onPropsChanged(props);
      return _this;
    }
    _createClass(Operator2, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        var prevProps = this.props;
        var keysForMeta = ["config", "selectedField", "selectedOperator"];
        var needUpdateMeta = !this.meta || keysForMeta.map(function(k) {
          return nextProps[k] !== prevProps[k];
        }).filter(function(ch) {
          return ch;
        }).length > 0;
        if (needUpdateMeta) {
          this.meta = this.getMeta(nextProps);
        }
      }
    }, {
      key: "getMeta",
      value: function getMeta(_ref) {
        var config2 = _ref.config, selectedField = _ref.selectedField, selectedOperator = _ref.selectedOperator;
        var fieldConfig = getFieldConfig3(config2, selectedField);
        var operators3 = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.operators;
        var operatorOptions = (0, import_mapValues3.default)((0, import_pickBy.default)(config2.operators, function(item, key) {
          return (operators3 === null || operators3 === void 0 ? void 0 : operators3.indexOf(key)) !== -1;
        }), function(_opts, op) {
          return getOperatorConfig2(config2, op, selectedField);
        });
        var items = this.buildOptions(config2, operatorOptions, operators3);
        var isOpSelected = !!selectedOperator;
        var currOp = isOpSelected ? operatorOptions[selectedOperator] : null;
        var selectedOpts = currOp || {};
        var placeholder = this.props.config.settings.operatorPlaceholder;
        var selectedKey = selectedOperator;
        var selectedKeys = isOpSelected ? [selectedKey] : null;
        var selectedPath = selectedKeys;
        var selectedLabel = selectedOpts.label;
        return {
          placeholder,
          items,
          selectedKey,
          selectedKeys,
          selectedPath,
          selectedLabel,
          selectedOpts,
          fieldConfig
        };
      }
    }, {
      key: "buildOptions",
      value: function buildOptions(config2, fields, ops) {
        if (!fields || !ops)
          return null;
        return (0, import_keys.default)(fields).sort(function(a, b) {
          return ops.indexOf(a) - ops.indexOf(b);
        }).map(function(fieldKey) {
          var field = fields[fieldKey];
          var label = field.label;
          return {
            key: fieldKey,
            path: fieldKey,
            label
          };
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props, config2 = _this$props.config, customProps = _this$props.customProps, setOperator3 = _this$props.setOperator, readonly = _this$props.readonly, id = _this$props.id, groupId = _this$props.groupId;
        var renderOperator2 = config2.settings.renderOperator;
        var renderProps = _objectSpread3({
          id,
          groupId,
          config: config2,
          customProps,
          readonly,
          setField: setOperator3
        }, this.meta);
        if (!renderProps.items)
          return null;
        return renderOperator2(renderProps);
      }
    }]);
    return Operator2;
  }(import_react120.PureComponent);
  Operator.propTypes = {
    id: import_prop_types52.default.string,
    groupId: import_prop_types52.default.string,
    config: import_prop_types52.default.object.isRequired,
    selectedField: import_prop_types52.default.string,
    selectedOperator: import_prop_types52.default.string,
    readonly: import_prop_types52.default.bool,
    //actions
    setOperator: import_prop_types52.default.func.isRequired
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/utils.js
  var import_react121 = __toESM(require_react());
  var _excluded64 = ["children"];
  var Col = function Col2(_ref) {
    var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded64);
    return /* @__PURE__ */ import_react121.default.createElement("div", props, children);
  };
  var dummyFn = function dummyFn2() {
  };
  var DragIcon = function DragIcon2() {
    return /* @__PURE__ */ import_react121.default.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "gray",
      width: "18px",
      height: "18px"
    }, /* @__PURE__ */ import_react121.default.createElement("path", {
      d: "M0 0h24v24H0V0z",
      fill: "none"
    }), /* @__PURE__ */ import_react121.default.createElement("path", {
      d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"
    }));
  };
  var ConfirmFn = function ConfirmFn2(Cmp) {
    return function(props) {
      var useConfirm = props.config.settings.useConfirm;
      var confirmFn = useConfirm ? useConfirm() : null;
      return /* @__PURE__ */ import_react121.default.createElement(Cmp, _extends88({}, props, {
        confirmFn
      }));
    };
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/rule/OperatorWrapper.js
  function _createSuper7(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct7();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct7() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var OperatorWrapper = /* @__PURE__ */ function(_PureComponent) {
    _inherits(OperatorWrapper2, _PureComponent);
    var _super = _createSuper7(OperatorWrapper2);
    function OperatorWrapper2() {
      _classCallCheck(this, OperatorWrapper2);
      return _super.apply(this, arguments);
    }
    _createClass(OperatorWrapper2, [{
      key: "render",
      value: function render() {
        var _this$props = this.props, config2 = _this$props.config, selectedField = _this$props.selectedField, selectedOperator = _this$props.selectedOperator, setOperator3 = _this$props.setOperator, selectedFieldPartsLabels = _this$props.selectedFieldPartsLabels, showOperator = _this$props.showOperator, showOperatorLabel = _this$props.showOperatorLabel, selectedFieldWidgetConfig = _this$props.selectedFieldWidgetConfig, readonly = _this$props.readonly, id = _this$props.id, groupId = _this$props.groupId;
        var operator = showOperator && /* @__PURE__ */ import_react122.default.createElement(Col, {
          key: "operators-for-" + (selectedFieldPartsLabels || []).join("_"),
          className: "rule--operator"
        }, config2.settings.showLabels && /* @__PURE__ */ import_react122.default.createElement("label", {
          className: "rule--label"
        }, config2.settings.operatorLabel), /* @__PURE__ */ import_react122.default.createElement(Operator, {
          key: "operator",
          config: config2,
          selectedField,
          selectedOperator,
          setOperator: setOperator3,
          readonly,
          id,
          groupId
        }));
        var hiddenOperator = showOperatorLabel && /* @__PURE__ */ import_react122.default.createElement(Col, {
          key: "operators-for-" + (selectedFieldPartsLabels || []).join("_"),
          className: "rule--operator"
        }, /* @__PURE__ */ import_react122.default.createElement("div", {
          className: "rule--operator-wrapper"
        }, config2.settings.showLabels ? /* @__PURE__ */ import_react122.default.createElement("label", {
          className: "rule--label"
        }, "\xA0") : null, /* @__PURE__ */ import_react122.default.createElement("div", {
          className: "rule--operator-text-wrapper"
        }, /* @__PURE__ */ import_react122.default.createElement("span", {
          className: "rule--operator-text"
        }, selectedFieldWidgetConfig.operatorInlineLabel))));
        return [operator, hiddenOperator];
      }
    }]);
    return OperatorWrapper2;
  }(import_react122.PureComponent);

  // node_modules/@react-awesome-query-builder/ui/esm/components/rule/FieldWrapper.js
  var import_react124 = __toESM(require_react());

  // node_modules/@react-awesome-query-builder/ui/esm/components/rule/Field.js
  var import_react123 = __toESM(require_react());
  var import_prop_types53 = __toESM(require_prop_types());
  var import_last2 = __toESM(require_last());
  var import_keys2 = __toESM(require_keys());
  function ownKeys3(object, enumerableOnly) {
    var keys5 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys5.push.apply(keys5, symbols);
    }
    return keys5;
  }
  function _objectSpread4(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _createSuper8(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct8();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct8() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var _Utils$RuleUtils = Utils.RuleUtils;
  var getFieldPath2 = _Utils$RuleUtils.getFieldPath;
  var getFieldPathLabels2 = _Utils$RuleUtils.getFieldPathLabels;
  var getFieldConfig4 = Utils.ConfigUtils.getFieldConfig;
  var Field = /* @__PURE__ */ function(_PureComponent) {
    _inherits(Field2, _PureComponent);
    var _super = _createSuper8(Field2);
    function Field2(props) {
      var _this;
      _classCallCheck(this, Field2);
      _this = _super.call(this, props);
      useOnPropsChanged(_assertThisInitialized(_this));
      _this.onPropsChanged(props);
      return _this;
    }
    _createClass(Field2, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        var prevProps = this.props;
        var keysForMeta = ["selectedField", "config", "parentField"];
        var needUpdateMeta = !this.meta || keysForMeta.map(function(k) {
          return nextProps[k] !== prevProps[k];
        }).filter(function(ch) {
          return ch;
        }).length > 0;
        if (needUpdateMeta) {
          this.meta = this.getMeta(nextProps);
        }
      }
    }, {
      key: "getMeta",
      value: function getMeta(_ref) {
        var selectedField = _ref.selectedField, config2 = _ref.config, parentField = _ref.parentField;
        var selectedKey = selectedField;
        var _config$settings = config2.settings, maxLabelsLength = _config$settings.maxLabelsLength, fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay, fieldPlaceholder = _config$settings.fieldPlaceholder, fieldSeparator = _config$settings.fieldSeparator;
        var isFieldSelected = !!selectedField;
        var placeholder = !isFieldSelected ? truncateString(fieldPlaceholder, maxLabelsLength) : null;
        var currField = isFieldSelected ? getFieldConfig4(config2, selectedKey) : null;
        var selectedOpts = currField || {};
        var selectedKeys = getFieldPath2(selectedKey, config2);
        var selectedPath = getFieldPath2(selectedKey, config2, true);
        var selectedLabel = this.getFieldLabel(currField, selectedKey, config2);
        var partsLabels = getFieldPathLabels2(selectedKey, config2);
        var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
        if (selectedFullLabel == selectedLabel || parentField)
          selectedFullLabel = null;
        var selectedAltLabel = selectedOpts.label2;
        var parentFieldPath = typeof parentField == "string" ? parentField.split(fieldSeparator) : parentField;
        var parentFieldConfig = parentField ? getFieldConfig4(config2, parentField) : null;
        var sourceFields = parentField ? parentFieldConfig && parentFieldConfig.subfields : config2.fields;
        var items = this.buildOptions(parentFieldPath, config2, sourceFields, parentFieldPath);
        return {
          placeholder,
          items,
          parentField,
          selectedKey,
          selectedKeys,
          selectedPath,
          selectedLabel,
          selectedOpts,
          selectedAltLabel,
          selectedFullLabel
        };
      }
    }, {
      key: "getFieldLabel",
      value: function getFieldLabel(fieldOpts, fieldKey, config2) {
        if (!fieldKey)
          return null;
        var fieldSeparator = config2.settings.fieldSeparator;
        var maxLabelsLength = config2.settings.maxLabelsLength;
        var fieldParts = Array.isArray(fieldKey) ? fieldKey : fieldKey.split(fieldSeparator);
        var label = fieldOpts && fieldOpts.label || (0, import_last2.default)(fieldParts);
        label = truncateString(label, maxLabelsLength);
        return label;
      }
    }, {
      key: "buildOptions",
      value: function buildOptions(parentFieldPath, config2, fields) {
        var _this2 = this;
        var path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        var optGroupLabel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
        if (!fields)
          return null;
        var _config$settings2 = config2.settings, fieldSeparator = _config$settings2.fieldSeparator, fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
        var prefix = path ? path.join(fieldSeparator) + fieldSeparator : "";
        return (0, import_keys2.default)(fields).map(function(fieldKey) {
          var field = fields[fieldKey];
          var label = _this2.getFieldLabel(field, fieldKey, config2);
          var partsLabels = getFieldPathLabels2(prefix + fieldKey, config2);
          var fullLabel = partsLabels.join(fieldSeparatorDisplay);
          if (fullLabel == label || parentFieldPath)
            fullLabel = null;
          var altLabel = field.label2;
          var tooltip = field.tooltip;
          var subpath = (path ? path : []).concat(fieldKey);
          var disabled = field.disabled;
          if (field.hideForSelect)
            return void 0;
          if (field.type == "!struct") {
            return {
              disabled,
              key: fieldKey,
              path: prefix + fieldKey,
              label,
              fullLabel,
              altLabel,
              tooltip,
              items: _this2.buildOptions(parentFieldPath, config2, field.subfields, subpath, label)
            };
          } else {
            return {
              disabled,
              key: fieldKey,
              path: prefix + fieldKey,
              label,
              fullLabel,
              altLabel,
              tooltip,
              grouplabel: optGroupLabel
            };
          }
        }).filter(function(o) {
          return !!o;
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props, config2 = _this$props.config, customProps = _this$props.customProps, setField3 = _this$props.setField, readonly = _this$props.readonly, id = _this$props.id, groupId = _this$props.groupId;
        var renderField2 = config2.settings.renderField;
        var renderProps = _objectSpread4({
          id,
          groupId,
          config: config2,
          customProps,
          readonly,
          setField: setField3
        }, this.meta);
        return renderField2(renderProps);
      }
    }]);
    return Field2;
  }(import_react123.PureComponent);
  Field.propTypes = {
    id: import_prop_types53.default.string,
    groupId: import_prop_types53.default.string,
    config: import_prop_types53.default.object.isRequired,
    selectedField: import_prop_types53.default.string,
    parentField: import_prop_types53.default.string,
    customProps: import_prop_types53.default.object,
    readonly: import_prop_types53.default.bool,
    //actions
    setField: import_prop_types53.default.func.isRequired
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/rule/FieldWrapper.js
  function _createSuper9(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct9();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct9() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var FieldWrapper = /* @__PURE__ */ function(_PureComponent) {
    _inherits(FieldWrapper2, _PureComponent);
    var _super = _createSuper9(FieldWrapper2);
    function FieldWrapper2() {
      _classCallCheck(this, FieldWrapper2);
      return _super.apply(this, arguments);
    }
    _createClass(FieldWrapper2, [{
      key: "render",
      value: function render() {
        var _this$props = this.props, config2 = _this$props.config, selectedField = _this$props.selectedField, setField3 = _this$props.setField, parentField = _this$props.parentField, classname = _this$props.classname, readonly = _this$props.readonly, id = _this$props.id, groupId = _this$props.groupId;
        return /* @__PURE__ */ import_react124.default.createElement(Col, {
          className: classname
        }, config2.settings.showLabels && /* @__PURE__ */ import_react124.default.createElement("label", {
          className: "rule--label"
        }, config2.settings.fieldLabel), /* @__PURE__ */ import_react124.default.createElement(Field, {
          config: config2,
          selectedField,
          parentField,
          setField: setField3,
          customProps: config2.settings.customFieldSelectProps,
          readonly,
          id,
          groupId
        }));
      }
    }]);
    return FieldWrapper2;
  }(import_react124.PureComponent);

  // node_modules/@react-awesome-query-builder/ui/esm/components/rule/Widget.js
  var import_react126 = __toESM(require_react());
  var import_prop_types54 = __toESM(require_prop_types());
  var import_range = __toESM(require_range());
  var import_pick7 = __toESM(require_pick());

  // node_modules/@react-awesome-query-builder/ui/esm/components/rule/WidgetFactory.js
  var import_react125 = __toESM(require_react());
  var _excluded65 = ["factory"];
  var getTitleInListValues2 = Utils.ListUtils.getTitleInListValues;
  var WidgetFactory_default = function(_ref) {
    var delta = _ref.delta, isFuncArg = _ref.isFuncArg, valueSrc = _ref.valueSrc, immValue = _ref.value, immValueError = _ref.valueError, asyncListValues = _ref.asyncListValues, isSpecialRange = _ref.isSpecialRange, fieldDefinition = _ref.fieldDefinition, widget = _ref.widget, widgetDefinition = _ref.widgetDefinition, widgetValueLabel = _ref.widgetValueLabel, valueLabels = _ref.valueLabels, textSeparators = _ref.textSeparators, setValueHandler = _ref.setValueHandler, config2 = _ref.config, field = _ref.field, operator = _ref.operator, readonly = _ref.readonly, parentField = _ref.parentField, parentFuncs = _ref.parentFuncs, id = _ref.id, groupId = _ref.groupId;
    var widgetFactory = widgetDefinition.factory, fieldWidgetProps = _objectWithoutProperties(widgetDefinition, _excluded65);
    var isConst = isFuncArg && fieldDefinition.valueSources && fieldDefinition.valueSources.length == 1 && fieldDefinition.valueSources[0] == "const";
    var defaultValue6 = fieldDefinition.defaultValue;
    if (!widgetFactory) {
      return "?";
    }
    var value = isSpecialRange ? [immValue.get(0), immValue.get(1)] : immValue ? immValue.get(delta) : void 0;
    var valueError = immValueError && (isSpecialRange ? [immValueError.get(0), immValueError.get(1)] : immValueError.get(delta)) || null;
    if (isSpecialRange && value[0] === void 0 && value[1] === void 0)
      value = void 0;
    var _ref2 = fieldDefinition || {}, fieldSettings = _ref2.fieldSettings;
    var widgetProps = Object.assign({}, fieldWidgetProps, fieldSettings, {
      config: config2,
      field,
      parentField,
      parentFuncs,
      fieldDefinition,
      operator,
      delta,
      isSpecialRange,
      isFuncArg,
      value,
      valueError,
      label: widgetValueLabel.label,
      placeholder: widgetValueLabel.placeholder,
      placeholders: valueLabels ? valueLabels.placeholder : null,
      textSeparators,
      setValue: setValueHandler,
      readonly,
      asyncListValues,
      id,
      groupId
    });
    if (widget == "field") {
    }
    if (isConst && defaultValue6) {
      if (typeof defaultValue6 == "boolean") {
        return defaultValue6 ? widgetProps.labelYes || "YES" : widgetProps.labelNo || "NO";
      } else if (fieldSettings.listValues) {
        if (Array.isArray(defaultValue6))
          return defaultValue6.map(function(v) {
            return getTitleInListValues2(fieldSettings.listValues, v) || v;
          }).join(", ");
        else
          return getTitleInListValues2(fieldSettings.listValues, defaultValue6) || defaultValue6;
      }
      return "" + defaultValue6;
    }
    return widgetFactory(widgetProps);
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/rule/Widget.js
  function _createSuper10(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct10();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct10() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var _Utils$ConfigUtils2 = Utils.ConfigUtils;
  var getFieldConfig5 = _Utils$ConfigUtils2.getFieldConfig;
  var getOperatorConfig3 = _Utils$ConfigUtils2.getOperatorConfig;
  var getFieldWidgetConfig2 = _Utils$ConfigUtils2.getFieldWidgetConfig;
  var _Utils$RuleUtils2 = Utils.RuleUtils;
  var getValueSourcesForFieldOp2 = _Utils$RuleUtils2.getValueSourcesForFieldOp;
  var getWidgetsForFieldOp2 = _Utils$RuleUtils2.getWidgetsForFieldOp;
  var getWidgetForFieldOp2 = _Utils$RuleUtils2.getWidgetForFieldOp;
  var getValueLabel2 = _Utils$RuleUtils2.getValueLabel;
  var createListFromArray2 = Utils.DefaultUtils.createListFromArray;
  var funcArgDummyOpDef = {
    cardinality: 1
  };
  var Widget = /* @__PURE__ */ function(_PureComponent) {
    _inherits(Widget2, _PureComponent);
    var _super = _createSuper10(Widget2);
    function Widget2(_props) {
      var _this;
      _classCallCheck(this, Widget2);
      _this = _super.call(this, _props);
      _this._setValue = function(isSpecialRange, delta, widgetType, value, asyncListValues, __isInternal) {
        if (isSpecialRange && Array.isArray(value)) {
          var oldRange = [_this.props.value.get(0), _this.props.value.get(1)];
          if (oldRange[0] != value[0])
            _this.props.setValue(0, value[0], widgetType, asyncListValues, __isInternal);
          if (oldRange[1] != value[1])
            _this.props.setValue(1, value[1], widgetType, asyncListValues, __isInternal);
        } else {
          _this.props.setValue(delta, value, widgetType, asyncListValues, __isInternal);
        }
      };
      _this._onChangeValueSrc = function(delta, srcKey) {
        _this.props.setValueSrc(delta, srcKey);
      };
      _this.renderWidget = function(delta, meta, props) {
        var config2 = props.config, isFuncArg = props.isFuncArg, leftField = props.leftField, operator = props.operator, values = props.value, valueError = props.valueError, readonly = props.readonly, parentField = props.parentField, parentFuncs = props.parentFuncs, id = props.id, groupId = props.groupId;
        var settings4 = config2.settings;
        var widgets3 = meta.widgets, iValues = meta.iValues, aField = meta.aField;
        var value = isFuncArg ? iValues : values;
        var field = isFuncArg ? leftField : aField;
        var _widgets$delta = widgets3[delta], valueSrc = _widgets$delta.valueSrc, valueLabel = _widgets$delta.valueLabel;
        var widgetLabel = settings4.showLabels ? /* @__PURE__ */ import_react126.default.createElement("label", {
          className: "rule--label"
        }, valueLabel.label) : null;
        return /* @__PURE__ */ import_react126.default.createElement("div", {
          key: "widget-" + field + "-" + delta,
          className: "widget--widget"
        }, valueSrc == "func" ? null : widgetLabel, /* @__PURE__ */ import_react126.default.createElement(WidgetFactory_default, _extends88({
          id,
          groupId,
          valueSrc,
          delta,
          value,
          valueError,
          isFuncArg
        }, (0, import_pick7.default)(meta, ["isSpecialRange", "fieldDefinition", "asyncListValues"]), (0, import_pick7.default)(widgets3[delta], ["widget", "widgetDefinition", "widgetValueLabel", "valueLabels", "textSeparators", "setValueHandler"]), {
          config: config2,
          field,
          parentField,
          parentFuncs,
          operator,
          readonly
        })));
      };
      _this.renderValueSources = function(delta, meta, props) {
        var config2 = props.config, isFuncArg = props.isFuncArg, leftField = props.leftField, operator = props.operator, readonly = props.readonly;
        var settings4 = config2.settings;
        var valueSources = meta.valueSources, widgets3 = meta.widgets, aField = meta.aField;
        var field = isFuncArg ? leftField : aField;
        var _widgets$delta2 = widgets3[delta], valueSrc = _widgets$delta2.valueSrc, setValueSrcHandler = _widgets$delta2.setValueSrcHandler;
        var valueSourcesInfo = settings4.valueSourcesInfo, ValueSources = settings4.renderValueSources;
        var valueSourcesOptions = valueSources.map(function(srcKey) {
          return [srcKey, {
            label: valueSourcesInfo[srcKey].label
          }];
        });
        var sourceLabel = settings4.showLabels ? /* @__PURE__ */ import_react126.default.createElement("label", {
          className: "rule--label"
        }, "\xA0") : null;
        return valueSources.length > 1 && !readonly && /* @__PURE__ */ import_react126.default.createElement("div", {
          key: "valuesrc-" + field + "-" + delta,
          className: "widget--valuesrc"
        }, sourceLabel, /* @__PURE__ */ import_react126.default.createElement(ValueSources, {
          key: "valuesrc-" + delta,
          delta,
          valueSources: valueSourcesOptions,
          valueSrc,
          config: config2,
          field,
          operator,
          setValueSrc: setValueSrcHandler,
          readonly,
          title: settings4.valueSourcesPopupTitle
        }));
      };
      _this.renderSep = function(delta, meta, props) {
        var config2 = props.config;
        var widgets3 = meta.widgets;
        var settings4 = config2.settings;
        var sepText = widgets3[delta].sepText;
        var sepLabel = settings4.showLabels ? /* @__PURE__ */ import_react126.default.createElement("label", {
          className: "rule--label"
        }, "\xA0") : null;
        return sepText && /* @__PURE__ */ import_react126.default.createElement("div", {
          key: "widget-separators-" + delta,
          className: "widget--sep"
        }, sepLabel, /* @__PURE__ */ import_react126.default.createElement("span", null, sepText));
      };
      _this.renderWidgetDelta = function(delta) {
        var sep = _this.renderSep(delta, _this.meta, _this.props);
        var sources = _this.renderValueSources(delta, _this.meta, _this.props);
        var widgetCmp = _this.renderWidget(delta, _this.meta, _this.props);
        return [sep, sources, widgetCmp];
      };
      useOnPropsChanged(_assertThisInitialized(_this));
      _this.onPropsChanged(_props);
      return _this;
    }
    _createClass(Widget2, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        var prevProps = this.props;
        var keysForMeta = ["config", "field", "fieldFunc", "fieldArg", "leftField", "operator", "valueSrc", "isFuncArg", "asyncListValues"];
        var needUpdateMeta = !this.meta || keysForMeta.map(function(k) {
          return nextProps[k] !== prevProps[k] || k == "isFuncArg" && nextProps["isFuncArg"] && nextProps["value"] !== prevProps["value"];
        }).filter(function(ch) {
          return ch;
        }).length > 0;
        if (needUpdateMeta) {
          this.meta = this.getMeta(nextProps);
        }
      }
    }, {
      key: "getMeta",
      value: function getMeta(_ref) {
        var _this2 = this;
        var config2 = _ref.config, simpleField = _ref.field, fieldFunc = _ref.fieldFunc, fieldArg = _ref.fieldArg, operator = _ref.operator, valueSrcs = _ref.valueSrc, values = _ref.value, isForRuleGruop = _ref.isForRuleGruop, isCaseValue = _ref.isCaseValue, isFuncArg = _ref.isFuncArg, leftField = _ref.leftField, asyncListValues = _ref.asyncListValues;
        var field = isFuncArg ? {
          func: fieldFunc,
          arg: fieldArg
        } : simpleField;
        var iValueSrcs = valueSrcs;
        var iValues = values;
        if (isFuncArg || isForRuleGruop || isCaseValue) {
          iValueSrcs = createListFromArray2([valueSrcs]);
          iValues = createListFromArray2([values]);
        }
        var fieldDefinition = getFieldConfig5(config2, field);
        var defaultWidget = getWidgetForFieldOp2(config2, field, operator);
        var _widgets = getWidgetsForFieldOp2(config2, field, operator);
        var operatorDefinition = isFuncArg ? funcArgDummyOpDef : getOperatorConfig3(config2, operator, field);
        if ((fieldDefinition == null || operatorDefinition == null) && !isCaseValue) {
          return null;
        }
        var isSpecialRange = operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.isSpecialRange;
        var isSpecialRangeForSrcField = isSpecialRange && (iValueSrcs.get(0) == "field" || iValueSrcs.get(1) == "field");
        var isTrueSpecialRange = isSpecialRange && !isSpecialRangeForSrcField;
        var cardinality = isTrueSpecialRange ? 1 : defaultValue4(operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.cardinality, 1);
        if (cardinality === 0) {
          return null;
        }
        var valueSources = getValueSourcesForFieldOp2(config2, field, operator, fieldDefinition, isFuncArg ? leftField : null);
        var widgets3 = (0, import_range.default)(0, cardinality).map(function(delta) {
          var _widgetDefinition;
          var valueSrc = iValueSrcs.get(delta) || null;
          var widget = getWidgetForFieldOp2(config2, field, operator, valueSrc);
          var widgetDefinition = getFieldWidgetConfig2(config2, field, operator, widget, valueSrc);
          if (isSpecialRangeForSrcField) {
            widget = widgetDefinition.singleWidget;
            widgetDefinition = getFieldWidgetConfig2(config2, field, operator, widget, valueSrc);
          }
          var widgetType = (_widgetDefinition = widgetDefinition) === null || _widgetDefinition === void 0 ? void 0 : _widgetDefinition.type;
          var valueLabel = getValueLabel2(config2, field, operator, delta, valueSrc, isTrueSpecialRange);
          var widgetValueLabel = getValueLabel2(config2, field, operator, delta, null, isTrueSpecialRange);
          var sepText = operatorDefinition !== null && operatorDefinition !== void 0 && operatorDefinition.textSeparators ? operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.textSeparators[delta] : null;
          var setValueSrcHandler = _this2._onChangeValueSrc.bind(_this2, delta);
          var valueLabels = null;
          var textSeparators = null;
          if (isSpecialRange) {
            valueLabels = [getValueLabel2(config2, field, operator, 0), getValueLabel2(config2, field, operator, 1)];
            valueLabels = {
              placeholder: [valueLabels[0].placeholder, valueLabels[1].placeholder],
              label: [valueLabels[0].label, valueLabels[1].label]
            };
            textSeparators = operatorDefinition === null || operatorDefinition === void 0 ? void 0 : operatorDefinition.textSeparators;
          }
          var setValueHandler = _this2._setValue.bind(_this2, isSpecialRange, delta, widgetType);
          return {
            valueSrc,
            valueLabel,
            widget,
            sepText,
            setValueSrcHandler,
            widgetDefinition,
            widgetValueLabel,
            valueLabels,
            textSeparators,
            setValueHandler
          };
        });
        return {
          defaultWidget,
          fieldDefinition,
          operatorDefinition,
          isSpecialRange: isTrueSpecialRange,
          cardinality,
          valueSources,
          widgets: widgets3,
          iValues,
          //correct for isFuncArg
          aField: field,
          //correct for isFuncArg
          asyncListValues
        };
      }
    }, {
      key: "render",
      value: function render() {
        if (!this.meta)
          return null;
        var _this$meta = this.meta, defaultWidget = _this$meta.defaultWidget, cardinality = _this$meta.cardinality;
        if (!defaultWidget)
          return null;
        var name = defaultWidget;
        return /* @__PURE__ */ import_react126.default.createElement(Col, {
          className: "rule--widget rule--widget--".concat(name.toUpperCase()),
          key: "widget-col-" + name
        }, (0, import_range.default)(0, cardinality).map(this.renderWidgetDelta));
      }
    }]);
    return Widget2;
  }(import_react126.PureComponent);
  Widget.propTypes = {
    config: import_prop_types54.default.object.isRequired,
    value: import_prop_types54.default.any,
    //instanceOf(Immutable.List)
    valueSrc: import_prop_types54.default.any,
    //instanceOf(Immutable.List)
    valueError: import_prop_types54.default.any,
    field: import_prop_types54.default.string,
    operator: import_prop_types54.default.string,
    readonly: import_prop_types54.default.bool,
    asyncListValues: import_prop_types54.default.array,
    id: import_prop_types54.default.string,
    groupId: import_prop_types54.default.string,
    //actions
    setValue: import_prop_types54.default.func,
    setValueSrc: import_prop_types54.default.func,
    // for isFuncArg
    isFuncArg: import_prop_types54.default.bool,
    fieldFunc: import_prop_types54.default.string,
    fieldArg: import_prop_types54.default.string,
    leftField: import_prop_types54.default.string,
    // for RuleGroupExt
    isForRuleGruop: import_prop_types54.default.bool,
    parentField: import_prop_types54.default.string,
    // for func in func
    parentFuncs: import_prop_types54.default.array,
    // for case_value
    isCaseValue: import_prop_types54.default.bool
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/rule/OperatorOptions.js
  var import_react127 = __toESM(require_react());
  var import_prop_types55 = __toESM(require_prop_types());
  var _excluded66 = ["factory"];
  function _createSuper11(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct11();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct11() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var getOperatorConfig4 = Utils.ConfigUtils.getOperatorConfig;
  var OperatorOptions = /* @__PURE__ */ function(_PureComponent) {
    _inherits(OperatorOptions2, _PureComponent);
    var _super = _createSuper11(OperatorOptions2);
    function OperatorOptions2() {
      _classCallCheck(this, OperatorOptions2);
      return _super.apply(this, arguments);
    }
    _createClass(OperatorOptions2, [{
      key: "render",
      value: function render() {
        if (!this.props.selectedOperator)
          return null;
        var operatorDefinitions = getOperatorConfig4(this.props.config, this.props.selectedOperator, this.props.selectedField);
        if (typeof operatorDefinitions.options === "undefined") {
          return null;
        }
        var _operatorDefinitions$ = operatorDefinitions.options, optionsFactory = _operatorDefinitions$.factory, basicOptionsProps = _objectWithoutProperties(_operatorDefinitions$, _excluded66);
        var optionsProps = Object.assign({}, basicOptionsProps, {
          config: this.props.config,
          field: this.props.selectedField,
          operator: this.props.selectedOperator,
          options: this.props.operatorOptions,
          setOption: this.props.setOperatorOption,
          readonly: this.props.readonly
        });
        var optionsCmp = optionsFactory(optionsProps);
        var name = this.props.selectedOperator;
        return /* @__PURE__ */ import_react127.default.createElement("div", {
          className: "rule--operator rule--operator--".concat(name.toUpperCase())
        }, optionsCmp);
      }
    }]);
    return OperatorOptions2;
  }(import_react127.PureComponent);
  OperatorOptions.propTypes = {
    config: import_prop_types55.default.object.isRequired,
    operatorOptions: import_prop_types55.default.any.isRequired,
    //instanceOf(Immutable.Map)
    selectedField: import_prop_types55.default.string.isRequired,
    selectedOperator: import_prop_types55.default.string.isRequired,
    readonly: import_prop_types55.default.bool,
    //actions
    setOperatorOption: import_prop_types55.default.func.isRequired
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/Rule.js
  var import_classnames3 = __toESM(require_classnames());
  function ownKeys4(object, enumerableOnly) {
    var keys5 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys5.push.apply(keys5, symbols);
    }
    return keys5;
  }
  function _objectSpread5(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _createSuper12(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct12();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct12() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var _Utils$ConfigUtils3 = Utils.ConfigUtils;
  var getFieldConfig6 = _Utils$ConfigUtils3.getFieldConfig;
  var getOperatorConfig5 = _Utils$ConfigUtils3.getOperatorConfig;
  var getFieldWidgetConfig3 = _Utils$ConfigUtils3.getFieldWidgetConfig;
  var getFieldPathLabels3 = Utils.RuleUtils.getFieldPathLabels;
  var Rule = /* @__PURE__ */ function(_PureComponent) {
    _inherits(Rule2, _PureComponent);
    var _super = _createSuper12(Rule2);
    function Rule2(props) {
      var _this;
      _classCallCheck(this, Rule2);
      _this = _super.call(this, props);
      useOnPropsChanged(_assertThisInitialized(_this));
      _this.removeSelf = _this.removeSelf.bind(_assertThisInitialized(_this));
      _this.setLock = _this.setLock.bind(_assertThisInitialized(_this));
      _this.onPropsChanged(props);
      return _this;
    }
    _createClass(Rule2, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        var prevProps = this.props;
        var keysForMeta = ["selectedField", "selectedOperator", "config", "reordableNodesCnt", "isLocked"];
        var needUpdateMeta = !this.meta || keysForMeta.map(function(k) {
          return nextProps[k] !== prevProps[k];
        }).filter(function(ch) {
          return ch;
        }).length > 0;
        if (needUpdateMeta) {
          this.meta = this.getMeta(nextProps);
        }
      }
    }, {
      key: "getMeta",
      value: function getMeta(_ref) {
        var selectedField = _ref.selectedField, selectedOperator = _ref.selectedOperator, config2 = _ref.config, reordableNodesCnt = _ref.reordableNodesCnt, isLocked = _ref.isLocked;
        var selectedFieldPartsLabels = getFieldPathLabels3(selectedField, config2);
        var selectedFieldConfig = getFieldConfig6(config2, selectedField);
        var isSelectedGroup = selectedFieldConfig && selectedFieldConfig.type == "!struct";
        var isFieldAndOpSelected = selectedField && selectedOperator && !isSelectedGroup;
        var selectedOperatorConfig = getOperatorConfig5(config2, selectedOperator, selectedField);
        var selectedOperatorHasOptions = selectedOperatorConfig && selectedOperatorConfig.options != null;
        var selectedFieldWidgetConfig = getFieldWidgetConfig3(config2, selectedField, selectedOperator) || {};
        var hideOperator = selectedFieldWidgetConfig.hideOperator;
        var showDragIcon = config2.settings.canReorder && reordableNodesCnt > 1 && !isLocked;
        var showOperator = selectedField && !hideOperator;
        var showOperatorLabel = selectedField && hideOperator && selectedFieldWidgetConfig.operatorInlineLabel;
        var showWidget = isFieldAndOpSelected;
        var showOperatorOptions = isFieldAndOpSelected && selectedOperatorHasOptions;
        return {
          selectedFieldPartsLabels,
          selectedFieldWidgetConfig,
          showDragIcon,
          showOperator,
          showOperatorLabel,
          showWidget,
          showOperatorOptions
        };
      }
    }, {
      key: "setLock",
      value: function setLock3(lock) {
        this.props.setLock(lock);
      }
    }, {
      key: "removeSelf",
      value: function removeSelf() {
        var _this2 = this;
        var confirmFn = this.props.confirmFn;
        var _this$props$config$se = this.props.config.settings, renderConfirm = _this$props$config$se.renderConfirm, confirmOptions = _this$props$config$se.removeRuleConfirmOptions;
        var doRemove = function doRemove2() {
          _this2.props.removeSelf();
        };
        if (confirmOptions && !this.isEmptyCurrentRule()) {
          renderConfirm(_objectSpread5(_objectSpread5({}, confirmOptions), {}, {
            onOk: doRemove,
            onCancel: null,
            confirmFn
          }));
        } else {
          doRemove();
        }
      }
    }, {
      key: "isEmptyCurrentRule",
      value: function isEmptyCurrentRule() {
        return !(this.props.selectedField !== null && this.props.selectedOperator !== null && this.props.value.filter(function(val) {
          return val !== void 0;
        }).size > 0);
      }
    }, {
      key: "renderField",
      value: function renderField2() {
        var _this$props = this.props, config2 = _this$props.config, isLocked = _this$props.isLocked;
        var immutableFieldsMode = config2.settings.immutableFieldsMode;
        return /* @__PURE__ */ import_react128.default.createElement(FieldWrapper, {
          key: "field",
          classname: "rule--field",
          config: config2,
          selectedField: this.props.selectedField,
          setField: !immutableFieldsMode ? this.props.setField : dummyFn,
          parentField: this.props.parentField,
          readonly: immutableFieldsMode || isLocked,
          id: this.props.id,
          groupId: this.props.groupId
        });
      }
    }, {
      key: "renderOperator",
      value: function renderOperator2() {
        var _this$props2 = this.props, config2 = _this$props2.config, isLocked = _this$props2.isLocked;
        var _this$meta = this.meta, selectedFieldPartsLabels = _this$meta.selectedFieldPartsLabels, selectedFieldWidgetConfig = _this$meta.selectedFieldWidgetConfig, showOperator = _this$meta.showOperator, showOperatorLabel = _this$meta.showOperatorLabel;
        var immutableOpsMode = config2.settings.immutableOpsMode;
        return /* @__PURE__ */ import_react128.default.createElement(OperatorWrapper, {
          key: "operator",
          config: config2,
          selectedField: this.props.selectedField,
          selectedOperator: this.props.selectedOperator,
          setOperator: !immutableOpsMode ? this.props.setOperator : dummyFn,
          selectedFieldPartsLabels,
          showOperator,
          showOperatorLabel,
          selectedFieldWidgetConfig,
          readonly: immutableOpsMode || isLocked,
          id: this.props.id,
          groupId: this.props.groupId
        });
      }
    }, {
      key: "renderWidget",
      value: function renderWidget() {
        var _this$props3 = this.props, config2 = _this$props3.config, valueError = _this$props3.valueError, isLocked = _this$props3.isLocked;
        var showWidget = this.meta.showWidget;
        var immutableValuesMode = config2.settings.immutableValuesMode;
        if (!showWidget)
          return null;
        var widget = /* @__PURE__ */ import_react128.default.createElement(Widget, {
          key: "values",
          field: this.props.selectedField,
          parentField: this.props.parentField,
          operator: this.props.selectedOperator,
          value: this.props.value,
          valueSrc: this.props.valueSrc,
          asyncListValues: this.props.asyncListValues,
          valueError,
          config: config2,
          setValue: !immutableValuesMode ? this.props.setValue : dummyFn,
          setValueSrc: !immutableValuesMode ? this.props.setValueSrc : dummyFn,
          readonly: immutableValuesMode || isLocked,
          id: this.props.id,
          groupId: this.props.groupId
        });
        return /* @__PURE__ */ import_react128.default.createElement(Col, {
          key: "widget-for-" + this.props.selectedOperator,
          className: "rule--value"
        }, widget);
      }
    }, {
      key: "renderOperatorOptions",
      value: function renderOperatorOptions() {
        var config2 = this.props.config;
        var showOperatorOptions = this.meta.showOperatorOptions;
        var _config$settings = config2.settings, immutableOpsMode = _config$settings.immutableOpsMode, immutableValuesMode = _config$settings.immutableValuesMode;
        if (!showOperatorOptions)
          return null;
        var opOpts = /* @__PURE__ */ import_react128.default.createElement(OperatorOptions, {
          key: "operatorOptions",
          selectedField: this.props.selectedField,
          selectedOperator: this.props.selectedOperator,
          operatorOptions: this.props.operatorOptions,
          setOperatorOption: !immutableOpsMode ? this.props.setOperatorOption : dummyFn,
          config: config2,
          readonly: immutableValuesMode
        });
        return /* @__PURE__ */ import_react128.default.createElement(Col, {
          key: "op-options-for-" + this.props.selectedOperator,
          className: "rule--operator-options"
        }, opOpts);
      }
    }, {
      key: "renderBeforeWidget",
      value: function renderBeforeWidget() {
        var config2 = this.props.config;
        var renderBeforeWidget2 = config2.settings.renderBeforeWidget;
        return renderBeforeWidget2 && /* @__PURE__ */ import_react128.default.createElement(Col, {
          key: "before-widget-for-" + this.props.selectedOperator,
          className: "rule--before-widget"
        }, typeof renderBeforeWidget2 === "function" ? renderBeforeWidget2(this.props) : renderBeforeWidget2);
      }
    }, {
      key: "renderAfterWidget",
      value: function renderAfterWidget() {
        var config2 = this.props.config;
        var renderAfterWidget2 = config2.settings.renderAfterWidget;
        return renderAfterWidget2 && /* @__PURE__ */ import_react128.default.createElement(Col, {
          key: "after-widget-for-" + this.props.selectedOperator,
          className: "rule--after-widget"
        }, typeof renderAfterWidget2 === "function" ? renderAfterWidget2(this.props) : renderAfterWidget2);
      }
    }, {
      key: "renderError",
      value: function renderError() {
        var _this$props4 = this.props, config2 = _this$props4.config, valueError = _this$props4.valueError;
        var _config$settings2 = config2.settings, renderRuleError = _config$settings2.renderRuleError, showErrorMessage = _config$settings2.showErrorMessage;
        var oneValueError = valueError && valueError.toArray().filter(function(e) {
          return !!e;
        }).shift() || null;
        return showErrorMessage && oneValueError && /* @__PURE__ */ import_react128.default.createElement("div", {
          className: "rule--error"
        }, renderRuleError ? renderRuleError({
          error: oneValueError
        }) : oneValueError);
      }
    }, {
      key: "renderDrag",
      value: function renderDrag() {
        var showDragIcon = this.meta.showDragIcon;
        return showDragIcon && /* @__PURE__ */ import_react128.default.createElement("span", {
          key: "rule-drag-icon",
          className: "qb-drag-handler rule--drag-handler",
          onMouseDown: this.props.handleDraggerMouseDown
        }, /* @__PURE__ */ import_react128.default.createElement(DragIcon, null), " ");
      }
    }, {
      key: "renderDel",
      value: function renderDel() {
        var _this$props5 = this.props, config2 = _this$props5.config, isLocked = _this$props5.isLocked;
        var _config$settings3 = config2.settings, deleteLabel = _config$settings3.deleteLabel, immutableGroupsMode = _config$settings3.immutableGroupsMode, Btn = _config$settings3.renderButton, canDeleteLocked = _config$settings3.canDeleteLocked;
        return !immutableGroupsMode && (!isLocked || isLocked && canDeleteLocked) && /* @__PURE__ */ import_react128.default.createElement(Btn, {
          type: "delRule",
          onClick: this.removeSelf,
          label: deleteLabel,
          config: config2
        });
      }
    }, {
      key: "renderLock",
      value: function renderLock() {
        var _this$props6 = this.props, config2 = _this$props6.config, isLocked = _this$props6.isLocked, isTrueLocked = _this$props6.isTrueLocked, id = _this$props6.id;
        var _config$settings4 = config2.settings, lockLabel = _config$settings4.lockLabel, lockedLabel = _config$settings4.lockedLabel, showLock = _config$settings4.showLock, Switch = _config$settings4.renderSwitch;
        return showLock && !(isLocked && !isTrueLocked) && /* @__PURE__ */ import_react128.default.createElement(Switch, {
          type: "lock",
          id,
          value: isLocked,
          setValue: this.setLock,
          label: lockLabel,
          checkedLabel: lockedLabel,
          hideLabel: true,
          config: config2
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$meta2 = this.meta, showOperatorOptions = _this$meta2.showOperatorOptions, selectedFieldWidgetConfig = _this$meta2.selectedFieldWidgetConfig;
        var _this$props7 = this.props, valueSrc = _this$props7.valueSrc, value = _this$props7.value, config2 = _this$props7.config;
        var canShrinkValue = valueSrc.first() == "value" && !showOperatorOptions && value.size == 1 && selectedFieldWidgetConfig.fullWidth;
        var BtnGrp = config2.settings.renderButtonGroup;
        var parts2 = [this.renderField(), this.renderOperator(), this.renderBeforeWidget(), this.renderWidget(), this.renderAfterWidget(), this.renderOperatorOptions()];
        var body = /* @__PURE__ */ import_react128.default.createElement("div", {
          key: "rule-body",
          className: (0, import_classnames3.default)("rule--body", canShrinkValue && "can--shrink--value")
        }, parts2);
        var error2 = this.renderError();
        var drag = this.renderDrag();
        var lock = this.renderLock();
        var del2 = this.renderDel();
        return /* @__PURE__ */ import_react128.default.createElement(import_react128.default.Fragment, null, drag, /* @__PURE__ */ import_react128.default.createElement("div", {
          className: "rule--body--wrapper"
        }, body, error2), /* @__PURE__ */ import_react128.default.createElement("div", {
          className: "rule--header"
        }, /* @__PURE__ */ import_react128.default.createElement(BtnGrp, {
          config: config2
        }, lock, del2)));
      }
    }]);
    return Rule2;
  }(import_react128.PureComponent);
  Rule.propTypes = {
    id: import_prop_types56.default.string.isRequired,
    groupId: import_prop_types56.default.string,
    selectedField: import_prop_types56.default.string,
    selectedOperator: import_prop_types56.default.string,
    operatorOptions: import_prop_types56.default.object,
    config: import_prop_types56.default.object.isRequired,
    value: import_prop_types56.default.any,
    //depends on widget
    valueSrc: import_prop_types56.default.any,
    asyncListValues: import_prop_types56.default.array,
    isDraggingMe: import_prop_types56.default.bool,
    isDraggingTempo: import_prop_types56.default.bool,
    parentField: import_prop_types56.default.string,
    //from RuleGroup
    valueError: import_prop_types56.default.any,
    isLocked: import_prop_types56.default.bool,
    isTrueLocked: import_prop_types56.default.bool,
    //path: PropTypes.instanceOf(Immutable.List),
    //actions
    handleDraggerMouseDown: import_prop_types56.default.func,
    setField: import_prop_types56.default.func,
    setOperator: import_prop_types56.default.func,
    setOperatorOption: import_prop_types56.default.func,
    setLock: import_prop_types56.default.func,
    removeSelf: import_prop_types56.default.func,
    setValue: import_prop_types56.default.func,
    setValueSrc: import_prop_types56.default.func,
    reordableNodesCnt: import_prop_types56.default.number
  };
  var Rule_default = RuleContainer_default(Draggable_default("rule")(ConfirmFn(Rule)));

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/Group.js
  var import_react131 = __toESM(require_react());
  var import_prop_types58 = __toESM(require_prop_types());
  var import_startsWith = __toESM(require_startsWith());

  // node_modules/@react-awesome-query-builder/ui/esm/components/containers/GroupContainer.js
  var import_react129 = __toESM(require_react());
  var import_prop_types57 = __toESM(require_prop_types());
  var import_mapValues4 = __toESM(require_mapValues());
  function _createSuper13(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct13();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct13() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var defaultGroupConjunction2 = Utils.DefaultUtils.defaultGroupConjunction;
  var createGroupContainer = function createGroupContainer2(Group) {
    var _class;
    return _class = /* @__PURE__ */ function(_Component) {
      _inherits(GroupContainer, _Component);
      var _super = _createSuper13(GroupContainer);
      function GroupContainer(_props) {
        var _this;
        _classCallCheck(this, GroupContainer);
        _this = _super.call(this, _props);
        _this._selectedConjunction = function(props) {
          props = props || _this.props;
          return props.conjunction || defaultGroupConjunction2(props.config, props.field);
        };
        _this.setConjunction = function() {
          var conj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          _this.props.actions.setConjunction(_this.props.path, conj);
        };
        _this.setNot = function() {
          var not = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          _this.props.actions.setNot(_this.props.path, not);
        };
        _this.setLock = function() {
          var lock = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          _this.props.actions.setLock(_this.props.path, lock);
        };
        _this.dummyFn = function() {
        };
        _this.removeSelf = function() {
          _this.props.actions.removeGroup(_this.props.path);
        };
        _this.addGroup = function() {
          _this.props.actions.addGroup(_this.props.path);
        };
        _this.addCaseGroup = function() {
          _this.props.actions.addCaseGroup(_this.props.path);
        };
        _this.addDefaultCaseGroup = function() {
          _this.props.actions.addDefaultCaseGroup(_this.props.path);
        };
        _this.addRule = function() {
          _this.props.actions.addRule(_this.props.path);
        };
        _this.setField = function(field) {
          _this.props.actions.setField(_this.props.path, field);
        };
        _this.setOperator = function(operator) {
          _this.props.actions.setOperator(_this.props.path, operator);
        };
        _this.setValue = function(delta, value, type) {
          _this.props.actions.setValue(_this.props.path, delta, value, type);
        };
        useOnPropsChanged(_assertThisInitialized(_this));
        _this.selectedConjunction = _this._selectedConjunction(_props);
        _this.conjunctionOptions = _this._getConjunctionOptions(_props);
        _this.dummyFn.isDummyFn = true;
        return _this;
      }
      _createClass(GroupContainer, [{
        key: "shouldComponentUpdate",
        value: function shouldComponentUpdate(nextProps, nextState) {
          var prevProps = this.props;
          var prevState = this.state;
          var should = pureShouldComponentUpdate(this)(nextProps, nextState);
          if (should) {
            if (prevState == nextState && prevProps != nextProps) {
              var draggingId = nextProps.dragging.id || prevProps.dragging.id;
              var isDraggingMe = draggingId == nextProps.id;
              var chs = [];
              for (var k in nextProps) {
                var changed = nextProps[k] != prevProps[k];
                if (k == "dragging" && !isDraggingMe) {
                  changed = false;
                }
                if (changed) {
                  chs.push(k);
                }
              }
              if (!chs.length)
                should = false;
            }
          }
          return should;
        }
      }, {
        key: "onPropsChanged",
        value: function onPropsChanged(nextProps) {
          var config2 = nextProps.config, id = nextProps.id, conjunction = nextProps.conjunction;
          var oldConfig = this.props.config;
          var oldConjunction = this.props.conjunction;
          if (oldConfig != config2 || oldConjunction != conjunction) {
            this.selectedConjunction = this._selectedConjunction(nextProps);
            this.conjunctionOptions = this._getConjunctionOptions(nextProps);
          }
        }
      }, {
        key: "_getConjunctionOptions",
        value: function _getConjunctionOptions(props) {
          var _this2 = this;
          return (0, import_mapValues4.default)(props.config.conjunctions, function(item, index) {
            return {
              id: "conjunction-".concat(props.id, "-").concat(index),
              name: "conjunction[".concat(props.id, "]"),
              key: index,
              label: item.label,
              checked: index === _this2._selectedConjunction(props)
            };
          });
        }
      }, {
        key: "render",
        value: function render() {
          var isDraggingMe = this.props.dragging.id == this.props.id;
          var currentNesting = this.props.path.size;
          var maxNesting = this.props.config.settings.maxNesting;
          var isInDraggingTempo = !isDraggingMe && this.props.isDraggingTempo;
          var allowFurtherNesting = typeof maxNesting === "undefined" || currentNesting < maxNesting;
          var isRoot = currentNesting == 1;
          return /* @__PURE__ */ import_react129.default.createElement("div", {
            className: "group-or-rule-container group-container",
            "data-id": this.props.id
          }, [isDraggingMe ? /* @__PURE__ */ import_react129.default.createElement(Group, {
            key: "dragging",
            id: this.props.id,
            groupId: this.props.groupId,
            isDraggingMe: true,
            isDraggingTempo: true,
            dragging: this.props.dragging,
            isRoot,
            allowFurtherNesting,
            conjunctionOptions: this.conjunctionOptions,
            not: this.props.not,
            selectedConjunction: this.selectedConjunction,
            setConjunction: this.dummyFn,
            setNot: this.dummyFn,
            setLock: this.dummyFn,
            removeSelf: this.dummyFn,
            addGroup: this.dummyFn,
            addCaseGroup: this.dummyFn,
            addDefaultCaseGroup: this.dummyFn,
            addRule: this.dummyFn,
            setField: this.dummyFn,
            setOperator: this.dummyFn,
            setValue: this.dummyFn,
            value: this.props.value || null,
            config: this.props.config,
            children1: this.props.children1,
            actions: this.props.actions,
            reordableNodesCnt: this.props.reordableNodesCnt,
            totalRulesCnt: this.props.totalRulesCnt,
            selectedField: this.props.field || null,
            parentField: this.props.parentField || null,
            selectedOperator: this.props.operator || null,
            isLocked: this.props.isLocked,
            isTrueLocked: this.props.isTrueLocked,
            parentReordableNodesCnt: this.props.parentReordableNodesCnt
          }) : null, /* @__PURE__ */ import_react129.default.createElement(Group, {
            key: this.props.id,
            id: this.props.id,
            groupId: this.props.groupId,
            isDraggingMe,
            isDraggingTempo: isInDraggingTempo,
            onDragStart: this.props.onDragStart,
            isRoot,
            allowFurtherNesting,
            conjunctionOptions: this.conjunctionOptions,
            not: this.props.not,
            selectedConjunction: this.selectedConjunction,
            setConjunction: isInDraggingTempo ? this.dummyFn : this.setConjunction,
            setNot: isInDraggingTempo ? this.dummyFn : this.setNot,
            setLock: isInDraggingTempo ? this.dummyFn : this.setLock,
            removeSelf: isInDraggingTempo ? this.dummyFn : this.removeSelf,
            addGroup: isInDraggingTempo ? this.dummyFn : this.addGroup,
            addCaseGroup: isInDraggingTempo ? this.dummyFn : this.addCaseGroup,
            addDefaultCaseGroup: isInDraggingTempo ? this.dummyFn : this.addDefaultCaseGroup,
            addRule: isInDraggingTempo ? this.dummyFn : this.addRule,
            setField: isInDraggingTempo ? this.dummyFn : this.setField,
            setOperator: isInDraggingTempo ? this.dummyFn : this.setOperator,
            setValue: isInDraggingTempo ? this.dummyFn : this.setValue,
            value: this.props.value || null,
            config: this.props.config,
            children1: this.props.children1,
            actions: this.props.actions,
            reordableNodesCnt: this.props.reordableNodesCnt,
            totalRulesCnt: this.props.totalRulesCnt,
            selectedField: this.props.field || null,
            parentField: this.props.parentField || null,
            selectedOperator: this.props.operator || null,
            isLocked: this.props.isLocked,
            isTrueLocked: this.props.isTrueLocked,
            parentReordableNodesCnt: this.props.parentReordableNodesCnt
          })]);
        }
      }]);
      return GroupContainer;
    }(import_react129.Component), _class.propTypes = {
      //tree: PropTypes.instanceOf(Immutable.Map).isRequired,
      config: import_prop_types57.default.object.isRequired,
      actions: import_prop_types57.default.object.isRequired,
      //{setConjunction: Funciton, removeGroup, addGroup, addRule, ...}
      path: import_prop_types57.default.any.isRequired,
      //instanceOf(Immutable.List)
      id: import_prop_types57.default.string.isRequired,
      groupId: import_prop_types57.default.string,
      not: import_prop_types57.default.bool,
      conjunction: import_prop_types57.default.string,
      children1: import_prop_types57.default.any,
      //instanceOf(Immutable.OrderedMap)
      onDragStart: import_prop_types57.default.func,
      reordableNodesCnt: import_prop_types57.default.number,
      field: import_prop_types57.default.string,
      // for RuleGroup
      parentField: import_prop_types57.default.string,
      //from RuleGroup
      isLocked: import_prop_types57.default.bool,
      isTrueLocked: import_prop_types57.default.bool,
      //connected:
      dragging: import_prop_types57.default.object,
      //{id, x, y, w, h}
      isDraggingTempo: import_prop_types57.default.bool
    }, _class;
  };
  var GroupContainer_default = function(Group) {
    var ConnectedGroupContainer = connect_default(function(state) {
      return {
        dragging: state.dragging
      };
    }, null, null, {
      context: context_default
    })(createGroupContainer(Group));
    ConnectedGroupContainer.displayName = "ConnectedGroupContainer";
    return ConnectedGroupContainer;
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/Group.js
  var import_classnames4 = __toESM(require_classnames());

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/GroupActions.js
  var import_react130 = __toESM(require_react());
  function _createSuper14(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct14();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct14() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var groupActionsPositionList = {
    topLeft: "group--actions--tl",
    topCenter: "group--actions--tc",
    topRight: "group--actions--tr",
    bottomLeft: "group--actions--bl",
    bottomCenter: "group--actions--bc",
    bottomRight: "group--actions--br"
  };
  var defaultPosition = "topRight";
  var GroupActions = /* @__PURE__ */ function(_PureComponent) {
    _inherits(GroupActions2, _PureComponent);
    var _super = _createSuper14(GroupActions2);
    function GroupActions2() {
      _classCallCheck(this, GroupActions2);
      return _super.apply(this, arguments);
    }
    _createClass(GroupActions2, [{
      key: "render",
      value: function render() {
        var _this$props = this.props, config2 = _this$props.config, addRule2 = _this$props.addRule, addGroup2 = _this$props.addGroup, removeSelf = _this$props.removeSelf, setLock3 = _this$props.setLock, isLocked = _this$props.isLocked, isTrueLocked = _this$props.isTrueLocked, id = _this$props.id, canAddGroup = _this$props.canAddGroup, canAddRule = _this$props.canAddRule, canDeleteGroup = _this$props.canDeleteGroup;
        var _config$settings = config2.settings, immutableGroupsMode = _config$settings.immutableGroupsMode, addRuleLabel = _config$settings.addRuleLabel, addGroupLabel = _config$settings.addGroupLabel, delGroupLabel = _config$settings.delGroupLabel, groupActionsPosition = _config$settings.groupActionsPosition, Btn = _config$settings.renderButton, Switch = _config$settings.renderSwitch, BtnGrp = _config$settings.renderButtonGroup, lockLabel = _config$settings.lockLabel, lockedLabel = _config$settings.lockedLabel, showLock = _config$settings.showLock, canDeleteLocked = _config$settings.canDeleteLocked;
        var position = groupActionsPositionList[groupActionsPosition || defaultPosition];
        var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /* @__PURE__ */ import_react130.default.createElement(Switch, {
          type: "lock",
          id,
          value: isLocked,
          setValue: setLock3,
          label: lockLabel,
          checkedLabel: lockedLabel,
          config: config2
        });
        var addRuleBtn = !immutableGroupsMode && canAddRule && !isLocked && /* @__PURE__ */ import_react130.default.createElement(Btn, {
          type: "addRule",
          onClick: addRule2,
          label: addRuleLabel,
          readonly: isLocked,
          config: config2
        });
        var addGroupBtn = !immutableGroupsMode && canAddGroup && !isLocked && /* @__PURE__ */ import_react130.default.createElement(Btn, {
          type: "addGroup",
          onClick: addGroup2,
          label: addGroupLabel,
          readonly: isLocked,
          config: config2
        });
        var delGroupBtn = !immutableGroupsMode && canDeleteGroup && (!isLocked || isLocked && canDeleteLocked) && /* @__PURE__ */ import_react130.default.createElement(Btn, {
          type: "delGroup",
          onClick: removeSelf,
          label: delGroupLabel,
          config: config2
        });
        return /* @__PURE__ */ import_react130.default.createElement("div", {
          className: "group--actions ".concat(position)
        }, /* @__PURE__ */ import_react130.default.createElement(BtnGrp, {
          config: config2
        }, setLockSwitch, addRuleBtn, addGroupBtn, delGroupBtn));
      }
    }]);
    return GroupActions2;
  }(import_react130.PureComponent);

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/Group.js
  function ownKeys5(object, enumerableOnly) {
    var keys5 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys5.push.apply(keys5, symbols);
    }
    return keys5;
  }
  function _objectSpread6(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _createSuper15(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct15();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct15() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var defaultPosition2 = "topRight";
  var BasicGroup = /* @__PURE__ */ function(_PureComponent) {
    _inherits(BasicGroup2, _PureComponent);
    var _super = _createSuper15(BasicGroup2);
    function BasicGroup2(props) {
      var _this;
      _classCallCheck(this, BasicGroup2);
      _this = _super.call(this, props);
      _this.childrenClassName = function() {
        return "";
      };
      _this.renderBeforeActions = function() {
        var BeforeActions = _this.props.config.settings.renderBeforeActions;
        if (BeforeActions == void 0)
          return null;
        return typeof BeforeActions === "function" ? /* @__PURE__ */ import_react131.default.createElement(BeforeActions, _this.props) : BeforeActions;
      };
      _this.renderAfterActions = function() {
        var AfterActions = _this.props.config.settings.renderAfterActions;
        if (AfterActions == void 0)
          return null;
        return typeof AfterActions === "function" ? /* @__PURE__ */ import_react131.default.createElement(AfterActions, _this.props) : AfterActions;
      };
      _this.removeSelf = _this.removeSelf.bind(_assertThisInitialized(_this));
      _this.setLock = _this.setLock.bind(_assertThisInitialized(_this));
      _this.renderItem = _this.renderItem.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(BasicGroup2, [{
      key: "isGroupTopPosition",
      value: function isGroupTopPosition() {
        return (0, import_startsWith.default)(this.props.config.settings.groupActionsPosition || defaultPosition2, "top");
      }
    }, {
      key: "setLock",
      value: function setLock3(lock) {
        this.props.setLock(lock);
      }
    }, {
      key: "removeSelf",
      value: function removeSelf() {
        var _this2 = this;
        var confirmFn = this.props.confirmFn;
        var _this$props$config$se = this.props.config.settings, renderConfirm = _this$props$config$se.renderConfirm, confirmOptions = _this$props$config$se.removeGroupConfirmOptions;
        var doRemove = function doRemove2() {
          _this2.props.removeSelf();
        };
        if (confirmOptions && !this.isEmptyCurrentGroup()) {
          renderConfirm(_objectSpread6(_objectSpread6({}, confirmOptions), {}, {
            onOk: doRemove,
            onCancel: null,
            confirmFn
          }));
        } else {
          doRemove();
        }
      }
    }, {
      key: "isEmptyCurrentGroup",
      value: function isEmptyCurrentGroup() {
        var children = this.props.children1;
        return !children || children.size == 0 || children.size == 1 && this.isEmpty(children.first());
      }
    }, {
      key: "isEmpty",
      value: function isEmpty(item) {
        var isGroup = item.get("type") == "group" || item.get("type") == "rule_group";
        return isGroup ? this.isEmptyGroup(item) : this.isEmptyRule(item);
      }
    }, {
      key: "isEmptyGroup",
      value: function isEmptyGroup(group3) {
        var children = group3.get("children1");
        return !children || children.size == 0 || children.size == 1 && this.isEmpty(children.first());
      }
    }, {
      key: "isEmptyRule",
      value: function isEmptyRule(rule3) {
        var properties = rule3.get("properties");
        return !(properties.get("field") !== null && properties.get("operator") !== null && properties.get("value").filter(function(val) {
          return val !== void 0;
        }).size > 0);
      }
    }, {
      key: "render",
      value: function render() {
        return /* @__PURE__ */ import_react131.default.createElement(import_react131.default.Fragment, null, this.renderHeaderWrapper(), this.renderChildrenWrapper(), this.renderFooterWrapper());
      }
    }, {
      key: "showNot",
      value: function showNot() {
        var config2 = this.props.config;
        return config2.settings.showNot;
      }
      // show conjs for 2+ children?
    }, {
      key: "showConjs",
      value: function showConjs() {
        var _this$props = this.props, conjunctionOptions = _this$props.conjunctionOptions, children1 = _this$props.children1, config2 = _this$props.config;
        var conjunctionCount = Object.keys(conjunctionOptions).length;
        return conjunctionCount > 1 || this.showNot();
      }
    }, {
      key: "isNoChildren",
      value: function isNoChildren() {
        var children1 = this.props.children1;
        return children1 ? children1.size == 0 : true;
      }
    }, {
      key: "isOneChild",
      value: function isOneChild() {
        var children1 = this.props.children1;
        return children1 ? children1.size < 2 : true;
      }
    }, {
      key: "renderChildrenWrapper",
      value: function renderChildrenWrapper() {
        var children1 = this.props.children1;
        return children1 && /* @__PURE__ */ import_react131.default.createElement("div", {
          key: "group-children",
          className: (0, import_classnames4.default)("group--children", !this.showConjs() ? "hide--conjs" : "", this.isOneChild() ? "hide--line" : "", this.isOneChild() ? "one--child" : "", this.childrenClassName())
        }, this.renderChildren());
      }
    }, {
      key: "renderHeaderWrapper",
      value: function renderHeaderWrapper() {
        var isGroupTopPosition = this.isGroupTopPosition();
        return /* @__PURE__ */ import_react131.default.createElement("div", {
          key: "group-header",
          className: (0, import_classnames4.default)("group--header", this.isOneChild() ? "one--child" : "", !this.showConjs() ? "hide--conjs" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "")
        }, this.renderHeader(), isGroupTopPosition && this.renderBeforeActions(), isGroupTopPosition && this.renderActions(), isGroupTopPosition && this.renderAfterActions());
      }
    }, {
      key: "renderFooterWrapper",
      value: function renderFooterWrapper() {
        var isGroupTopPosition = this.isGroupTopPosition();
        return !isGroupTopPosition && /* @__PURE__ */ import_react131.default.createElement("div", {
          key: "group-footer",
          className: "group--footer"
        }, this.renderBeforeActions(), this.renderActions(), this.renderAfterActions());
      }
    }, {
      key: "renderActions",
      value: function renderActions() {
        var _this$props2 = this.props, config2 = _this$props2.config, addRule2 = _this$props2.addRule, addGroup2 = _this$props2.addGroup, isLocked = _this$props2.isLocked, isTrueLocked = _this$props2.isTrueLocked, id = _this$props2.id;
        return /* @__PURE__ */ import_react131.default.createElement(GroupActions, {
          config: config2,
          addRule: addRule2,
          addGroup: addGroup2,
          canAddGroup: this.canAddGroup(),
          canAddRule: this.canAddRule(),
          canDeleteGroup: this.canDeleteGroup(),
          removeSelf: this.removeSelf,
          setLock: this.setLock,
          isLocked,
          isTrueLocked,
          id
        });
      }
    }, {
      key: "canAddGroup",
      value: function canAddGroup() {
        return this.props.allowFurtherNesting;
      }
    }, {
      key: "canAddRule",
      value: function canAddRule() {
        var maxNumberOfRules = this.props.config.settings.maxNumberOfRules;
        var totalRulesCnt = this.props.totalRulesCnt;
        if (maxNumberOfRules) {
          return totalRulesCnt < maxNumberOfRules;
        }
        return true;
      }
    }, {
      key: "canDeleteGroup",
      value: function canDeleteGroup() {
        return !this.props.isRoot;
      }
    }, {
      key: "renderChildren",
      value: function renderChildren() {
        var children1 = this.props.children1;
        return children1 ? children1.map(this.renderItem).toList() : null;
      }
    }, {
      key: "renderItem",
      value: function renderItem(item) {
        var props = this.props;
        var config2 = props.config, actions = props.actions, onDragStart = props.onDragStart, isLocked = props.isLocked;
        var isRuleGroup = item.get("type") == "group" && item.getIn(["properties", "field"]) != null;
        var type = isRuleGroup ? "rule_group" : item.get("type");
        return /* @__PURE__ */ import_react131.default.createElement(Item, _extends88({}, this.extraPropsForItem(item), {
          key: item.get("id"),
          id: item.get("id"),
          groupId: props.id,
          path: item.get("path"),
          type,
          properties: item.get("properties"),
          config: config2,
          actions,
          children1: item.get("children1"),
          reordableNodesCnt: this.reordableNodesCntForItem(item),
          totalRulesCnt: this.totalRulesCntForItem(item),
          parentReordableNodesCnt: this.reordableNodesCnt(),
          onDragStart,
          isDraggingTempo: this.props.isDraggingTempo,
          isParentLocked: isLocked
        }));
      }
    }, {
      key: "extraPropsForItem",
      value: function extraPropsForItem(_item) {
        return {};
      }
    }, {
      key: "reordableNodesCnt",
      value: function reordableNodesCnt() {
        if (this.props.isLocked)
          return 0;
        return this.props.reordableNodesCnt;
      }
    }, {
      key: "totalRulesCntForItem",
      value: function totalRulesCntForItem(_item) {
        return this.props.totalRulesCnt;
      }
    }, {
      key: "reordableNodesCntForItem",
      value: function reordableNodesCntForItem(_item) {
        if (this.props.isLocked)
          return 0;
        return this.reordableNodesCnt();
      }
    }, {
      key: "showDragIcon",
      value: function showDragIcon() {
        var _this$props3 = this.props, config2 = _this$props3.config, isRoot = _this$props3.isRoot, isLocked = _this$props3.isLocked;
        var reordableNodesCnt = this.reordableNodesCnt();
        return config2.settings.canReorder && !isRoot && reordableNodesCnt > 1 && !isLocked;
      }
    }, {
      key: "renderDrag",
      value: function renderDrag() {
        var handleDraggerMouseDown = this.props.handleDraggerMouseDown;
        var drag = this.showDragIcon() && /* @__PURE__ */ import_react131.default.createElement("span", {
          key: "group-drag-icon",
          className: "qb-drag-handler group--drag-handler",
          onMouseDown: handleDraggerMouseDown
        }, /* @__PURE__ */ import_react131.default.createElement(DragIcon, null), " ");
        return drag;
      }
    }, {
      key: "conjunctionOptions",
      value: function conjunctionOptions() {
        var conjunctionOptions2 = this.props.conjunctionOptions;
        return conjunctionOptions2;
      }
    }, {
      key: "renderConjs",
      value: function renderConjs2() {
        var _this$props4 = this.props, config2 = _this$props4.config, children1 = _this$props4.children1, id = _this$props4.id, selectedConjunction = _this$props4.selectedConjunction, setConjunction3 = _this$props4.setConjunction, not = _this$props4.not, setNot3 = _this$props4.setNot, isLocked = _this$props4.isLocked;
        var _config$settings = config2.settings, immutableGroupsMode = _config$settings.immutableGroupsMode, Conjs = _config$settings.renderConjs, _showNot = _config$settings.showNot, notLabel = _config$settings.notLabel;
        var conjunctionOptions = this.conjunctionOptions();
        if (!this.showConjs())
          return null;
        if (!children1 || !children1.size)
          return null;
        var renderProps = {
          disabled: this.isOneChild(),
          readonly: immutableGroupsMode || isLocked,
          selectedConjunction,
          setConjunction: immutableGroupsMode ? dummyFn : setConjunction3,
          conjunctionOptions,
          config: config2,
          not: not || false,
          id,
          setNot: immutableGroupsMode ? dummyFn : setNot3,
          notLabel,
          showNot: this.showNot(),
          isLocked
        };
        return /* @__PURE__ */ import_react131.default.createElement(Conjs, renderProps);
      }
    }, {
      key: "renderHeader",
      value: function renderHeader() {
        return /* @__PURE__ */ import_react131.default.createElement("div", {
          className: "group--conjunctions"
        }, this.renderConjs(), this.renderDrag());
      }
    }]);
    return BasicGroup2;
  }(import_react131.PureComponent);
  BasicGroup.propTypes = {
    //tree: PropTypes.instanceOf(Immutable.Map).isRequired,
    reordableNodesCnt: import_prop_types58.default.number,
    conjunctionOptions: import_prop_types58.default.object.isRequired,
    allowFurtherNesting: import_prop_types58.default.bool.isRequired,
    isRoot: import_prop_types58.default.bool.isRequired,
    not: import_prop_types58.default.bool,
    selectedConjunction: import_prop_types58.default.string,
    config: import_prop_types58.default.object.isRequired,
    id: import_prop_types58.default.string.isRequired,
    groupId: import_prop_types58.default.string,
    path: import_prop_types58.default.any,
    //instanceOf(Immutable.List)
    children1: import_prop_types58.default.any,
    //instanceOf(Immutable.OrderedMap)
    isDraggingMe: import_prop_types58.default.bool,
    isDraggingTempo: import_prop_types58.default.bool,
    isLocked: import_prop_types58.default.bool,
    isTrueLocked: import_prop_types58.default.bool,
    //actions
    handleDraggerMouseDown: import_prop_types58.default.func,
    onDragStart: import_prop_types58.default.func,
    addRule: import_prop_types58.default.func.isRequired,
    addGroup: import_prop_types58.default.func.isRequired,
    removeSelf: import_prop_types58.default.func.isRequired,
    setConjunction: import_prop_types58.default.func.isRequired,
    setNot: import_prop_types58.default.func.isRequired,
    setLock: import_prop_types58.default.func.isRequired,
    actions: import_prop_types58.default.object.isRequired
  };
  var Group_default = GroupContainer_default(Draggable_default("group")(ConfirmFn(BasicGroup)));

  // node_modules/@babel/runtime/helpers/esm/superPropBase.js
  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null)
        break;
    }
    return object;
  }

  // node_modules/@babel/runtime/helpers/esm/get.js
  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get2(target, property, receiver) {
        var base3 = _superPropBase(target, property);
        if (!base3)
          return;
        var desc = Object.getOwnPropertyDescriptor(base3, property);
        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }
        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/RuleGroup.js
  var import_react133 = __toESM(require_react());
  var import_prop_types59 = __toESM(require_prop_types());

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/RuleGroupActions.js
  var import_react132 = __toESM(require_react());
  function _createSuper16(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct16();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct16() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var RuleGroupActions = /* @__PURE__ */ function(_PureComponent) {
    _inherits(RuleGroupActions2, _PureComponent);
    var _super = _createSuper16(RuleGroupActions2);
    function RuleGroupActions2() {
      _classCallCheck(this, RuleGroupActions2);
      return _super.apply(this, arguments);
    }
    _createClass(RuleGroupActions2, [{
      key: "render",
      value: function render() {
        var _this$props = this.props, config2 = _this$props.config, addRule2 = _this$props.addRule, canAddRule = _this$props.canAddRule, canDeleteGroup = _this$props.canDeleteGroup, removeSelf = _this$props.removeSelf, setLock3 = _this$props.setLock, isLocked = _this$props.isLocked, isTrueLocked = _this$props.isTrueLocked, id = _this$props.id;
        var _config$settings = config2.settings, immutableGroupsMode = _config$settings.immutableGroupsMode, addRuleLabel = _config$settings.addRuleLabel, delGroupLabel = _config$settings.delGroupLabel, Btn = _config$settings.renderButton, Switch = _config$settings.renderSwitch, BtnGrp = _config$settings.renderButtonGroup, lockLabel = _config$settings.lockLabel, lockedLabel = _config$settings.lockedLabel, showLock = _config$settings.showLock, canDeleteLocked = _config$settings.canDeleteLocked;
        var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /* @__PURE__ */ import_react132.default.createElement(Switch, {
          type: "lock",
          id,
          value: isLocked,
          setValue: setLock3,
          label: lockLabel,
          checkedLabel: lockedLabel,
          hideLabel: true,
          config: config2
        });
        var addRuleBtn = !immutableGroupsMode && canAddRule && !isLocked && /* @__PURE__ */ import_react132.default.createElement(Btn, {
          type: "addRuleGroup",
          onClick: addRule2,
          label: addRuleLabel,
          readonly: isLocked,
          config: config2
        });
        var delGroupBtn = !immutableGroupsMode && canDeleteGroup && (!isLocked || isLocked && canDeleteLocked) && /* @__PURE__ */ import_react132.default.createElement(Btn, {
          type: "delRuleGroup",
          onClick: removeSelf,
          label: delGroupLabel,
          config: config2
        });
        return /* @__PURE__ */ import_react132.default.createElement("div", {
          className: "group--actions"
        }, /* @__PURE__ */ import_react132.default.createElement(BtnGrp, {
          config: config2
        }, setLockSwitch, addRuleBtn, delGroupBtn));
      }
    }]);
    return RuleGroupActions2;
  }(import_react132.PureComponent);

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/RuleGroup.js
  function ownKeys6(object, enumerableOnly) {
    var keys5 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys5.push.apply(keys5, symbols);
    }
    return keys5;
  }
  function _objectSpread7(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _createSuper17(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct17();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct17() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var RuleGroup = /* @__PURE__ */ function(_BasicGroup) {
    _inherits(RuleGroup2, _BasicGroup);
    var _super = _createSuper17(RuleGroup2);
    function RuleGroup2(props) {
      var _this;
      _classCallCheck(this, RuleGroup2);
      _this = _super.call(this, props);
      _this.childrenClassName = function() {
        return "rule_group--children";
      };
      _this.renderHeaderWrapper = function() {
        return null;
      };
      _this.renderFooterWrapper = function() {
        return null;
      };
      _this.renderConjs = function() {
        return null;
      };
      _this.canAddGroup = function() {
        return false;
      };
      _this.canAddRule = function() {
        return true;
      };
      _this.canDeleteGroup = function() {
        return false;
      };
      useOnPropsChanged(_assertThisInitialized(_this));
      _this.onPropsChanged(props);
      return _this;
    }
    _createClass(RuleGroup2, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
      }
    }, {
      key: "reordableNodesCntForItem",
      value: function reordableNodesCntForItem(_item) {
        if (this.props.isLocked)
          return 0;
        var children1 = this.props.children1;
        return (children1 === null || children1 === void 0 ? void 0 : children1.size) || 0;
      }
    }, {
      key: "renderChildrenWrapper",
      value: function renderChildrenWrapper() {
        return /* @__PURE__ */ import_react133.default.createElement(import_react133.default.Fragment, null, this.renderDrag(), this.renderField(), this.renderActions(), _get(_getPrototypeOf(RuleGroup2.prototype), "renderChildrenWrapper", this).call(this));
      }
    }, {
      key: "renderField",
      value: function renderField2() {
        var _this$props = this.props, config2 = _this$props.config, selectedField = _this$props.selectedField, setField3 = _this$props.setField, parentField = _this$props.parentField, id = _this$props.id, groupId = _this$props.groupId, isLocked = _this$props.isLocked;
        var immutableFieldsMode = config2.settings.immutableFieldsMode;
        return /* @__PURE__ */ import_react133.default.createElement(FieldWrapper, {
          key: "field",
          classname: "group--field",
          config: config2,
          selectedField,
          setField: setField3,
          parentField,
          readonly: immutableFieldsMode || isLocked,
          id,
          groupId
        });
      }
    }, {
      key: "renderActions",
      value: function renderActions() {
        var _this$props2 = this.props, config2 = _this$props2.config, addRule2 = _this$props2.addRule, isLocked = _this$props2.isLocked, isTrueLocked = _this$props2.isTrueLocked, id = _this$props2.id;
        return /* @__PURE__ */ import_react133.default.createElement(RuleGroupActions, {
          config: config2,
          addRule: addRule2,
          canAddRule: this.canAddRule(),
          canDeleteGroup: this.canDeleteGroup(),
          removeSelf: this.removeSelf,
          setLock: this.setLock,
          isLocked,
          isTrueLocked,
          id
        });
      }
    }, {
      key: "extraPropsForItem",
      value: function extraPropsForItem(_item) {
        return {
          parentField: this.props.selectedField
        };
      }
    }]);
    return RuleGroup2;
  }(BasicGroup);
  RuleGroup.propTypes = _objectSpread7(_objectSpread7({}, BasicGroup.propTypes), {}, {
    selectedField: import_prop_types59.default.string,
    parentField: import_prop_types59.default.string,
    setField: import_prop_types59.default.func
  });
  var RuleGroup_default = GroupContainer_default(Draggable_default("group rule_group")(ConfirmFn(RuleGroup)));

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/RuleGroupExt.js
  var import_react135 = __toESM(require_react());
  var import_prop_types60 = __toESM(require_prop_types());

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/RuleGroupExtActions.js
  var import_react134 = __toESM(require_react());
  function _createSuper18(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct18();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct18() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var RuleGroupExtActions = /* @__PURE__ */ function(_PureComponent) {
    _inherits(RuleGroupExtActions2, _PureComponent);
    var _super = _createSuper18(RuleGroupExtActions2);
    function RuleGroupExtActions2() {
      _classCallCheck(this, RuleGroupExtActions2);
      return _super.apply(this, arguments);
    }
    _createClass(RuleGroupExtActions2, [{
      key: "render",
      value: function render() {
        var _this$props = this.props, config2 = _this$props.config, addRule2 = _this$props.addRule, canAddRule = _this$props.canAddRule, canDeleteGroup = _this$props.canDeleteGroup, removeSelf = _this$props.removeSelf, setLock3 = _this$props.setLock, isLocked = _this$props.isLocked, isTrueLocked = _this$props.isTrueLocked, id = _this$props.id;
        var _config$settings = config2.settings, immutableGroupsMode = _config$settings.immutableGroupsMode, addSubRuleLabel = _config$settings.addSubRuleLabel, delGroupLabel = _config$settings.delGroupLabel, Btn = _config$settings.renderButton, Switch = _config$settings.renderSwitch, BtnGrp = _config$settings.renderButtonGroup, lockLabel = _config$settings.lockLabel, lockedLabel = _config$settings.lockedLabel, showLock = _config$settings.showLock, canDeleteLocked = _config$settings.canDeleteLocked;
        var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /* @__PURE__ */ import_react134.default.createElement(Switch, {
          type: "lock",
          id,
          value: isLocked,
          setValue: setLock3,
          label: lockLabel,
          checkedLabel: lockedLabel,
          config: config2
        });
        var addRuleBtn = !immutableGroupsMode && canAddRule && !isLocked && /* @__PURE__ */ import_react134.default.createElement(Btn, {
          type: "addRuleGroupExt",
          onClick: addRule2,
          label: addSubRuleLabel,
          readonly: isLocked,
          config: config2
        });
        var delGroupBtn = !immutableGroupsMode && canDeleteGroup && (!isLocked || isLocked && canDeleteLocked) && /* @__PURE__ */ import_react134.default.createElement(Btn, {
          type: "delRuleGroup",
          onClick: removeSelf,
          label: delGroupLabel,
          config: config2
        });
        return /* @__PURE__ */ import_react134.default.createElement("div", {
          className: "group--actions group--actions--tr"
        }, /* @__PURE__ */ import_react134.default.createElement(BtnGrp, {
          config: config2
        }, setLockSwitch, addRuleBtn, delGroupBtn));
      }
    }]);
    return RuleGroupExtActions2;
  }(import_react134.PureComponent);

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/RuleGroupExt.js
  var import_classnames5 = __toESM(require_classnames());
  function ownKeys7(object, enumerableOnly) {
    var keys5 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys5.push.apply(keys5, symbols);
    }
    return keys5;
  }
  function _objectSpread8(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys7(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray3(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = it.call(o);
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray3(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray3(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray3(o, minLen);
  }
  function _arrayLikeToArray3(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function _createSuper19(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct19();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct19() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var _Utils$ConfigUtils4 = Utils.ConfigUtils;
  var getFieldConfig7 = _Utils$ConfigUtils4.getFieldConfig;
  var getFieldWidgetConfig4 = _Utils$ConfigUtils4.getFieldWidgetConfig;
  var RuleGroupExt = /* @__PURE__ */ function(_BasicGroup) {
    _inherits(RuleGroupExt2, _BasicGroup);
    var _super = _createSuper19(RuleGroupExt2);
    function RuleGroupExt2(props) {
      var _this;
      _classCallCheck(this, RuleGroupExt2);
      _this = _super.call(this, props);
      _this.childrenClassName = function() {
        return "rule_group_ext--children";
      };
      _this.renderFooterWrapper = function() {
        return null;
      };
      _this.canAddGroup = function() {
        return false;
      };
      _this.canAddRule = function() {
        return true;
      };
      _this.canDeleteGroup = function() {
        return true;
      };
      useOnPropsChanged(_assertThisInitialized(_this));
      _this.onPropsChanged(props);
      return _this;
    }
    _createClass(RuleGroupExt2, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
      }
    }, {
      key: "renderHeaderWrapper",
      value: function renderHeaderWrapper() {
        return /* @__PURE__ */ import_react135.default.createElement("div", {
          key: "group-header",
          className: (0, import_classnames5.default)("group--header", this.isOneChild() ? "one--child" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "", this.showDragIcon() ? "with--drag" : "hide--drag", this.showConjs() && (!this.isOneChild() || this.showNot()) ? "with--conjs" : "hide--conjs")
        }, this.renderHeader(), this.renderGroupField(), this.renderActions());
      }
    }, {
      key: "renderHeader",
      value: function renderHeader() {
        return /* @__PURE__ */ import_react135.default.createElement("div", {
          className: "group--conjunctions"
        }, this.renderConjs(), this.renderDrag());
      }
    }, {
      key: "renderGroupField",
      value: function renderGroupField() {
        return /* @__PURE__ */ import_react135.default.createElement("div", {
          className: "group--field--count--rule"
        }, this.renderField(), this.renderOperator(), this.renderWidget());
      }
    }, {
      key: "showNot",
      value: function showNot() {
        var _this$props = this.props, config2 = _this$props.config, selectedField = _this$props.selectedField, selectedOperator = _this$props.selectedOperator;
        var selectedFieldConfig = getFieldConfig7(config2, selectedField) || {};
        return selectedFieldConfig.showNot != void 0 ? selectedFieldConfig.showNot : config2.settings.showNot;
      }
    }, {
      key: "conjunctionOptions",
      value: function conjunctionOptions() {
        var _this$props2 = this.props, config2 = _this$props2.config, selectedField = _this$props2.selectedField, selectedOperator = _this$props2.selectedOperator;
        var selectedFieldConfig = getFieldConfig7(config2, selectedField) || {};
        var conjunctionOptions2 = _get(_getPrototypeOf(RuleGroupExt2.prototype), "conjunctionOptions", this).call(this);
        if (selectedFieldConfig.conjunctions) {
          var filtered = {};
          var _iterator = _createForOfIteratorHelper2(selectedFieldConfig.conjunctions), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var k = _step.value;
              filtered[k] = conjunctionOptions2[k];
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          conjunctionOptions2 = filtered;
        }
        return conjunctionOptions2;
      }
    }, {
      key: "renderField",
      value: function renderField2() {
        var _this$props3 = this.props, config2 = _this$props3.config, selectedField = _this$props3.selectedField, setField3 = _this$props3.setField, parentField = _this$props3.parentField, id = _this$props3.id, groupId = _this$props3.groupId, isLocked = _this$props3.isLocked;
        var immutableFieldsMode = config2.settings.immutableFieldsMode;
        return /* @__PURE__ */ import_react135.default.createElement(FieldWrapper, {
          key: "field",
          classname: "rule--field",
          config: config2,
          selectedField,
          setField: setField3,
          parentField,
          readonly: immutableFieldsMode || isLocked,
          id,
          groupId
        });
      }
    }, {
      key: "renderOperator",
      value: function renderOperator2() {
        var _this$props4 = this.props, config2 = _this$props4.config, selectedField = _this$props4.selectedField, selectedOperator = _this$props4.selectedOperator, setField3 = _this$props4.setField, setOperator3 = _this$props4.setOperator, isLocked = _this$props4.isLocked;
        var immutableFieldsMode = config2.settings.immutableFieldsMode;
        var selectedFieldWidgetConfig = getFieldWidgetConfig4(config2, selectedField, selectedOperator) || {};
        var hideOperator = selectedFieldWidgetConfig.hideOperator;
        var showOperatorLabel = selectedField && hideOperator && selectedFieldWidgetConfig.operatorInlineLabel;
        var showOperator = selectedField && !hideOperator;
        return /* @__PURE__ */ import_react135.default.createElement(OperatorWrapper, {
          key: "operator",
          classname: "group--operator",
          config: config2,
          selectedField,
          selectedOperator,
          setField: setField3,
          setOperator: setOperator3,
          selectedFieldPartsLabels: ["group"],
          showOperator,
          showOperatorLabel,
          selectedFieldWidgetConfig,
          readonly: immutableFieldsMode || isLocked,
          id: this.props.id,
          groupId: this.props.groupId
        });
      }
    }, {
      key: "renderWidget",
      value: function renderWidget() {
        var _this$props5 = this.props, config2 = _this$props5.config, selectedField = _this$props5.selectedField, selectedOperator = _this$props5.selectedOperator, isLocked = _this$props5.isLocked;
        var immutableValuesMode = config2.settings.immutableValuesMode;
        var isFieldAndOpSelected = selectedField && selectedOperator;
        var showWidget = isFieldAndOpSelected;
        if (!showWidget)
          return null;
        var widget = /* @__PURE__ */ import_react135.default.createElement(Widget, {
          key: "values",
          isForRuleGruop: true,
          field: this.props.selectedField,
          operator: this.props.selectedOperator,
          value: this.props.value,
          valueSrc: "value",
          valueError: null,
          config: config2,
          setValue: !immutableValuesMode ? this.props.setValue : dummyFn,
          setValueSrc: dummyFn,
          readonly: immutableValuesMode || isLocked,
          id: this.props.id,
          groupId: this.props.groupId
        });
        return /* @__PURE__ */ import_react135.default.createElement(Col, {
          key: "widget-for-" + this.props.selectedOperator,
          className: "rule--value"
        }, widget);
      }
    }, {
      key: "renderActions",
      value: function renderActions() {
        var _this$props6 = this.props, config2 = _this$props6.config, addRule2 = _this$props6.addRule, isLocked = _this$props6.isLocked, isTrueLocked = _this$props6.isTrueLocked, id = _this$props6.id;
        return /* @__PURE__ */ import_react135.default.createElement(RuleGroupExtActions, {
          config: config2,
          addRule: addRule2,
          canAddRule: this.canAddRule(),
          canDeleteGroup: this.canDeleteGroup(),
          removeSelf: this.removeSelf,
          setLock: this.setLock,
          isLocked,
          isTrueLocked,
          id
        });
      }
    }, {
      key: "reordableNodesCntForItem",
      value: function reordableNodesCntForItem(_item) {
        if (this.props.isLocked)
          return 0;
        var children1 = this.props.children1;
        return (children1 === null || children1 === void 0 ? void 0 : children1.size) || 0;
      }
    }, {
      key: "extraPropsForItem",
      value: function extraPropsForItem(_item) {
        return {
          parentField: this.props.selectedField
        };
      }
    }]);
    return RuleGroupExt2;
  }(BasicGroup);
  RuleGroupExt.propTypes = _objectSpread8(_objectSpread8({}, BasicGroup.propTypes), {}, {
    selectedField: import_prop_types60.default.string,
    selectedOperator: import_prop_types60.default.string,
    value: import_prop_types60.default.any,
    parentField: import_prop_types60.default.string,
    setField: import_prop_types60.default.func,
    setOperator: import_prop_types60.default.func,
    setValue: import_prop_types60.default.func
  });
  var RuleGroupExt_default = GroupContainer_default(Draggable_default("group rule_group_ext")(ConfirmFn(RuleGroupExt)));

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/SwitchGroup.js
  var import_react137 = __toESM(require_react());

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/SwitchGroupActions.js
  var import_react136 = __toESM(require_react());
  function _createSuper20(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct20();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct20() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var groupActionsPositionList2 = {
    topLeft: "group--actions--tl",
    topCenter: "group--actions--tc",
    topRight: "group--actions--tr",
    bottomLeft: "group--actions--bl",
    bottomCenter: "group--actions--bc",
    bottomRight: "group--actions--br"
  };
  var defaultPosition3 = "topRight";
  var SwitchGroupActions = /* @__PURE__ */ function(_PureComponent) {
    _inherits(SwitchGroupActions2, _PureComponent);
    var _super = _createSuper20(SwitchGroupActions2);
    function SwitchGroupActions2() {
      _classCallCheck(this, SwitchGroupActions2);
      return _super.apply(this, arguments);
    }
    _createClass(SwitchGroupActions2, [{
      key: "render",
      value: function render() {
        var _this$props = this.props, config2 = _this$props.config, addCaseGroup2 = _this$props.addCaseGroup, addDefaultCaseGroup2 = _this$props.addDefaultCaseGroup, setLock3 = _this$props.setLock, isLocked = _this$props.isLocked, isTrueLocked = _this$props.isTrueLocked, id = _this$props.id, canAddGroup = _this$props.canAddGroup, canAddDefault = _this$props.canAddDefault;
        var _config$settings = config2.settings, immutableGroupsMode = _config$settings.immutableGroupsMode, addCaseLabel = _config$settings.addCaseLabel, addDefaultCaseLabel = _config$settings.addDefaultCaseLabel, groupActionsPosition = _config$settings.groupActionsPosition, Btn = _config$settings.renderButton, Switch = _config$settings.renderSwitch, BtnGrp = _config$settings.renderButtonGroup, lockLabel = _config$settings.lockLabel, lockedLabel = _config$settings.lockedLabel, showLock = _config$settings.showLock;
        var position = groupActionsPositionList2[groupActionsPosition || defaultPosition3];
        var setLockSwitch = showLock && !(isLocked && !isTrueLocked) && /* @__PURE__ */ import_react136.default.createElement(Switch, {
          type: "lock",
          id,
          value: isLocked,
          setValue: setLock3,
          label: lockLabel,
          checkedLabel: lockedLabel,
          config: config2
        });
        var addCaseGroupBtn = !immutableGroupsMode && canAddGroup && !isLocked && /* @__PURE__ */ import_react136.default.createElement(Btn, {
          type: "addCaseGroup",
          onClick: addCaseGroup2,
          label: addCaseLabel,
          readonly: isLocked,
          config: config2
        });
        var addDefaultCaseGroupBtn = !immutableGroupsMode && canAddDefault && !isLocked && /* @__PURE__ */ import_react136.default.createElement(Btn, {
          type: "addDefaultCaseGroup",
          onClick: addDefaultCaseGroup2,
          label: addDefaultCaseLabel,
          readonly: isLocked,
          config: config2
        });
        return /* @__PURE__ */ import_react136.default.createElement("div", {
          className: "group--actions ".concat(position)
        }, /* @__PURE__ */ import_react136.default.createElement(BtnGrp, {
          config: config2
        }, setLockSwitch, addCaseGroupBtn, addDefaultCaseGroupBtn));
      }
    }]);
    return SwitchGroupActions2;
  }(import_react136.PureComponent);

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/SwitchGroup.js
  var import_classnames6 = __toESM(require_classnames());
  function ownKeys8(object, enumerableOnly) {
    var keys5 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys5.push.apply(keys5, symbols);
    }
    return keys5;
  }
  function _objectSpread9(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys8(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys8(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _createSuper21(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct21();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct21() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var _Utils$TreeUtils = Utils.TreeUtils;
  var getTotalReordableNodesCountInTree2 = _Utils$TreeUtils.getTotalReordableNodesCountInTree;
  var getTotalRulesCountInTree2 = _Utils$TreeUtils.getTotalRulesCountInTree;
  var SwitchGroup = /* @__PURE__ */ function(_BasicGroup) {
    _inherits(SwitchGroup2, _BasicGroup);
    var _super = _createSuper21(SwitchGroup2);
    function SwitchGroup2(props) {
      var _this;
      _classCallCheck(this, SwitchGroup2);
      _this = _super.call(this, props);
      _this.childrenClassName = function() {
        return "switch_group--children";
      };
      _this.renderFooterWrapper = function() {
        return null;
      };
      _this.hasDefaultCase = function() {
        var _this$props$children;
        return ((_this$props$children = _this.props.children1) === null || _this$props$children === void 0 ? void 0 : _this$props$children.size) && _this.props.children1.filter(function(c) {
          return c.get("children1") == null;
        }).size > 0;
      };
      useOnPropsChanged(_assertThisInitialized(_this));
      _this.onPropsChanged(props);
      return _this;
    }
    _createClass(SwitchGroup2, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
      }
    }, {
      key: "canAddGroup",
      value: function canAddGroup() {
        var _this$props$children2;
        var maxNumberOfCases = this.props.config.settings.maxNumberOfCases;
        var totalCasesCnt = ((_this$props$children2 = this.props.children1) === null || _this$props$children2 === void 0 ? void 0 : _this$props$children2.size) || 0;
        if (maxNumberOfCases) {
          return totalCasesCnt < maxNumberOfCases;
        }
        return true;
      }
    }, {
      key: "canAddRule",
      value: function canAddRule() {
        return false;
      }
    }, {
      key: "reordableNodesCnt",
      value: function reordableNodesCnt() {
        var _this$props$children3;
        var totalCasesCnt = ((_this$props$children3 = this.props.children1) === null || _this$props$children3 === void 0 ? void 0 : _this$props$children3.size) || 0;
        var casesToReorder = totalCasesCnt;
        if (this.hasDefaultCase()) {
          casesToReorder--;
        }
        return casesToReorder;
      }
    }, {
      key: "totalRulesCntForItem",
      value: function totalRulesCntForItem(item) {
        return getTotalRulesCountInTree2(item);
      }
    }, {
      key: "reordableNodesCntForItem",
      value: function reordableNodesCntForItem(item) {
        var _this$props$children4;
        if (this.props.isLocked)
          return 0;
        var _this$props$config$se = this.props.config.settings, canLeaveEmptyCase = _this$props$config$se.canLeaveEmptyCase, canRegroupCases = _this$props$config$se.canRegroupCases;
        var totalCasesCnt = ((_this$props$children4 = this.props.children1) === null || _this$props$children4 === void 0 ? void 0 : _this$props$children4.size) || 0;
        var casesToReorder = totalCasesCnt;
        if (this.hasDefaultCase()) {
          casesToReorder--;
        }
        var nodesInCase = getTotalReordableNodesCountInTree2(item);
        var cnt = nodesInCase;
        if (cnt == 1 && canRegroupCases && canLeaveEmptyCase && casesToReorder > 1)
          cnt = 111;
        return cnt;
      }
    }, {
      key: "renderHeaderWrapper",
      value: function renderHeaderWrapper() {
        return /* @__PURE__ */ import_react137.default.createElement("div", {
          key: "group-header",
          className: (0, import_classnames6.default)(
            "group--header",
            this.isOneChild() ? "one--child" : "",
            this.isOneChild() ? "hide--line" : "",
            this.isNoChildren() ? "no--children" : "",
            this.showDragIcon() ? "with--drag" : "hide--drag"
            //this.showConjs() && (!this.isOneChild() || this.showNot()) ? "with--conjs" : "hide--conjs"
          )
        }, this.renderHeader(), this.renderActions());
      }
    }, {
      key: "renderHeader",
      value: function renderHeader() {
        return /* @__PURE__ */ import_react137.default.createElement("div", {
          className: "group--conjunctions"
        }, this.renderConjs(), this.renderDrag());
      }
    }, {
      key: "renderConjs",
      value: function renderConjs2() {
        var renderSwitchPrefix2 = this.props.config.settings.renderSwitchPrefix;
        return renderSwitchPrefix2 ? renderSwitchPrefix2() : null;
      }
    }, {
      key: "showNot",
      value: function showNot() {
        return false;
      }
    }, {
      key: "renderActions",
      value: function renderActions() {
        var _this$props = this.props, config2 = _this$props.config, addCaseGroup2 = _this$props.addCaseGroup, addDefaultCaseGroup2 = _this$props.addDefaultCaseGroup, isLocked = _this$props.isLocked, isTrueLocked = _this$props.isTrueLocked, id = _this$props.id;
        return /* @__PURE__ */ import_react137.default.createElement(SwitchGroupActions, {
          config: config2,
          addCaseGroup: addCaseGroup2,
          addDefaultCaseGroup: addDefaultCaseGroup2,
          canAddDefault: !this.hasDefaultCase(),
          canAddGroup: this.canAddGroup(),
          setLock: this.setLock,
          isLocked,
          isTrueLocked,
          id
        });
      }
    }]);
    return SwitchGroup2;
  }(BasicGroup);
  SwitchGroup.propTypes = _objectSpread9({}, BasicGroup.propTypes);
  var SwitchGroup_default = GroupContainer_default(Draggable_default("group switch_group")(ConfirmFn(SwitchGroup)));

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/CaseGroup.js
  var import_react138 = __toESM(require_react());
  var import_prop_types61 = __toESM(require_prop_types());
  var import_classnames7 = __toESM(require_classnames());
  function ownKeys9(object, enumerableOnly) {
    var keys5 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys5.push.apply(keys5, symbols);
    }
    return keys5;
  }
  function _objectSpread10(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys9(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _createSuper22(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct22();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct22() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var CaseGroup = /* @__PURE__ */ function(_BasicGroup) {
    _inherits(CaseGroup2, _BasicGroup);
    var _super = _createSuper22(CaseGroup2);
    function CaseGroup2(props) {
      var _this;
      _classCallCheck(this, CaseGroup2);
      _this = _super.call(this, props);
      _this.childrenClassName = function() {
        return "case_group--children";
      };
      _this.renderFooterWrapper = function() {
        return null;
      };
      useOnPropsChanged(_assertThisInitialized(_this));
      _this.onPropsChanged(props);
      return _this;
    }
    _createClass(CaseGroup2, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
      }
    }, {
      key: "isDefaultCase",
      value: function isDefaultCase() {
        return this.props.children1 == void 0;
      }
    }, {
      key: "reordableNodesCnt",
      value: function reordableNodesCnt() {
        return this.props.parentReordableNodesCnt;
      }
    }, {
      key: "reordableNodesCntForItem",
      value: function reordableNodesCntForItem(_item) {
        if (this.props.isLocked)
          return 0;
        return this.props.reordableNodesCnt;
      }
    }, {
      key: "totalRulesCntForItem",
      value: function totalRulesCntForItem(_item) {
        return this.props.totalRulesCnt;
      }
    }, {
      key: "showDragIcon",
      value: function showDragIcon() {
        if (this.isDefaultCase())
          return false;
        return _get(_getPrototypeOf(CaseGroup2.prototype), "showDragIcon", this).call(this);
      }
    }, {
      key: "renderHeaderWrapper",
      value: function renderHeaderWrapper() {
        return /* @__PURE__ */ import_react138.default.createElement("div", {
          key: "group-header",
          className: (0, import_classnames7.default)("group--header", this.isOneChild() ? "one--child" : "", this.isOneChild() ? "hide--line" : "", this.isNoChildren() ? "no--children" : "", this.showDragIcon() ? "with--drag" : "hide--drag", this.showConjs() && (!this.isOneChild() || this.showNot()) ? "with--conjs" : "hide--conjs")
        }, this.renderHeaderLeft(), this.renderHeaderCenter(), this.renderActions());
      }
    }, {
      key: "renderChildrenWrapper",
      value: function renderChildrenWrapper() {
        if (this.isDefaultCase())
          return null;
        return /* @__PURE__ */ import_react138.default.createElement("div", {
          className: "case_group--body"
        }, this.renderCondition(), this.renderValue());
      }
    }, {
      key: "renderHeaderLeft",
      value: function renderHeaderLeft() {
        if (this.isDefaultCase()) {
          var defaultCaseLabel = this.props.config.settings.defaultCaseLabel;
          return defaultCaseLabel || "";
        }
        return /* @__PURE__ */ import_react138.default.createElement("div", {
          className: "group--conjunctions"
        }, this.renderConjs(), this.renderDrag());
      }
    }, {
      key: "renderCondition",
      value: function renderCondition() {
        if (this.isDefaultCase())
          return null;
        return _get(_getPrototypeOf(CaseGroup2.prototype), "renderChildrenWrapper", this).call(this);
      }
    }, {
      key: "renderHeaderCenter",
      value: function renderHeaderCenter() {
        if (this.isDefaultCase())
          return this.renderValue();
        else
          return null;
      }
    }, {
      key: "canAddGroup",
      value: function canAddGroup() {
        if (this.isDefaultCase())
          return false;
        return _get(_getPrototypeOf(CaseGroup2.prototype), "canAddGroup", this).call(this);
      }
    }, {
      key: "canAddRule",
      value: function canAddRule() {
        if (this.isDefaultCase())
          return false;
        return _get(_getPrototypeOf(CaseGroup2.prototype), "canAddRule", this).call(this);
      }
    }, {
      key: "renderValue",
      value: function renderValue() {
        var _this$props = this.props, config2 = _this$props.config, isLocked = _this$props.isLocked, value = _this$props.value, setValue3 = _this$props.setValue, id = _this$props.id;
        var immutableValuesMode = config2.settings.immutableValuesMode;
        var widget = /* @__PURE__ */ import_react138.default.createElement(Widget, {
          key: "values",
          isCaseValue: true,
          field: "!case_value",
          operator: null,
          value,
          valueSrc: "value",
          valueError: null,
          config: config2,
          setValue: !immutableValuesMode ? setValue3 : dummyFn,
          setValueSrc: dummyFn,
          readonly: immutableValuesMode || isLocked,
          id,
          groupId: null
        });
        return /* @__PURE__ */ import_react138.default.createElement(Col, {
          className: "case_group--value"
        }, widget);
      }
    }, {
      key: "renderActions",
      value: function renderActions() {
        var _this$props2 = this.props, config2 = _this$props2.config, addGroup2 = _this$props2.addGroup, addRule2 = _this$props2.addRule, isLocked = _this$props2.isLocked, isTrueLocked = _this$props2.isTrueLocked, id = _this$props2.id;
        return /* @__PURE__ */ import_react138.default.createElement(GroupActions, {
          config: config2,
          addGroup: addGroup2,
          addRule: addRule2,
          canAddRule: this.canAddRule(),
          canAddGroup: this.canAddGroup(),
          canDeleteGroup: this.canDeleteGroup(),
          removeSelf: this.removeSelf,
          setLock: this.setLock,
          isLocked,
          isTrueLocked,
          id
        });
      }
    }, {
      key: "isEmptyCurrentGroup",
      value: function isEmptyCurrentGroup() {
        var value = this.props.value;
        var oneValue = value && value.size ? value.get(0) : null;
        var hasValue = oneValue != null && (Array.isArray(oneValue) ? oneValue.length > 0 : true);
        return _get(_getPrototypeOf(CaseGroup2.prototype), "isEmptyCurrentGroup", this).call(this) && !hasValue;
      }
    }]);
    return CaseGroup2;
  }(BasicGroup);
  CaseGroup.propTypes = _objectSpread10(_objectSpread10({}, BasicGroup.propTypes), {}, {
    parentReordableNodesCnt: import_prop_types61.default.number,
    value: import_prop_types61.default.any,
    setValue: import_prop_types61.default.func
  });
  var CaseGroup_default = GroupContainer_default(Draggable_default("group case_group")(ConfirmFn(CaseGroup)));

  // node_modules/@react-awesome-query-builder/ui/esm/components/item/Item.js
  var _excluded67 = ["type"];
  function _createSuper23(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct23();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct23() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function ownKeys10(object, enumerableOnly) {
    var keys5 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys5.push.apply(keys5, symbols);
    }
    return keys5;
  }
  function _objectSpread11(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys10(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys10(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var types2 = ["rule", "group", "rule_group", "switch_group", "case_group"];
  var getProperties = function getProperties2(props) {
    var _props$properties;
    var properties = ((_props$properties = props.properties) === null || _props$properties === void 0 ? void 0 : _props$properties.toObject()) || {};
    var result = _objectSpread11({}, properties);
    if (props.isParentLocked) {
      result.isLocked = true;
    }
    if (properties.isLocked) {
      result.isTrueLocked = true;
    }
    return result;
  };
  var typeMap = {
    rule: function rule2(props) {
      return /* @__PURE__ */ import_react139.default.createElement(Rule_default, _extends88({}, getProperties(props), {
        id: props.id,
        groupId: props.groupId,
        path: props.path,
        actions: props.actions,
        reordableNodesCnt: props.reordableNodesCnt,
        totalRulesCnt: props.totalRulesCnt,
        config: props.config,
        onDragStart: props.onDragStart,
        isDraggingTempo: props.isDraggingTempo,
        parentField: props.parentField,
        parentReordableNodesCnt: props.parentReordableNodesCnt
      }));
    },
    group: function group2(props) {
      return /* @__PURE__ */ import_react139.default.createElement(Group_default, _extends88({}, getProperties(props), {
        id: props.id,
        groupId: props.groupId,
        path: props.path,
        actions: props.actions,
        config: props.config,
        reordableNodesCnt: props.reordableNodesCnt,
        totalRulesCnt: props.totalRulesCnt,
        onDragStart: props.onDragStart,
        isDraggingTempo: props.isDraggingTempo,
        children1: props.children1,
        parentField: null,
        parentReordableNodesCnt: props.parentReordableNodesCnt
      }));
    },
    rule_group: function rule_group(props) {
      return /* @__PURE__ */ import_react139.default.createElement(RuleGroup_default, _extends88({}, getProperties(props), {
        id: props.id,
        groupId: props.groupId,
        path: props.path,
        actions: props.actions,
        config: props.config,
        reordableNodesCnt: props.reordableNodesCnt,
        totalRulesCnt: props.totalRulesCnt,
        onDragStart: props.onDragStart,
        isDraggingTempo: props.isDraggingTempo,
        children1: props.children1,
        parentField: props.parentField,
        parentReordableNodesCnt: props.parentReordableNodesCnt
      }));
    },
    rule_group_ext: function rule_group_ext(props) {
      return /* @__PURE__ */ import_react139.default.createElement(RuleGroupExt_default, _extends88({}, getProperties(props), {
        id: props.id,
        groupId: props.groupId,
        path: props.path,
        actions: props.actions,
        config: props.config,
        reordableNodesCnt: props.reordableNodesCnt,
        totalRulesCnt: props.totalRulesCnt,
        onDragStart: props.onDragStart,
        isDraggingTempo: props.isDraggingTempo,
        children1: props.children1,
        parentField: props.parentField,
        parentReordableNodesCnt: props.parentReordableNodesCnt
      }));
    },
    switch_group: function switch_group(props) {
      return /* @__PURE__ */ import_react139.default.createElement(SwitchGroup_default, _extends88({}, getProperties(props), {
        id: props.id,
        groupId: props.groupId,
        path: props.path,
        actions: props.actions,
        config: props.config,
        reordableNodesCnt: props.reordableNodesCnt,
        totalRulesCnt: props.totalRulesCnt,
        onDragStart: props.onDragStart,
        isDraggingTempo: props.isDraggingTempo,
        children1: props.children1,
        parentField: null,
        parentReordableNodesCnt: props.parentReordableNodesCnt
      }));
    },
    case_group: function case_group(props) {
      return /* @__PURE__ */ import_react139.default.createElement(CaseGroup_default, _extends88({}, getProperties(props), {
        id: props.id,
        groupId: props.groupId,
        path: props.path,
        actions: props.actions,
        config: props.config,
        reordableNodesCnt: props.reordableNodesCnt,
        totalRulesCnt: props.totalRulesCnt,
        onDragStart: props.onDragStart,
        isDraggingTempo: props.isDraggingTempo,
        children1: props.children1,
        parentField: null,
        parentReordableNodesCnt: props.parentReordableNodesCnt
      }));
    }
  };
  var Item = /* @__PURE__ */ function(_PureComponent) {
    _inherits(Item2, _PureComponent);
    var _super = _createSuper23(Item2);
    function Item2() {
      _classCallCheck(this, Item2);
      return _super.apply(this, arguments);
    }
    _createClass(Item2, [{
      key: "render",
      value: function render() {
        var _props$properties2;
        var _this$props = this.props, type = _this$props.type, props = _objectWithoutProperties(_this$props, _excluded67);
        var mode = (_props$properties2 = props.properties) === null || _props$properties2 === void 0 ? void 0 : _props$properties2.get("mode");
        var postfix = mode == "array" ? "_ext" : "";
        var renderItem = props.config.settings.renderItem;
        var Cmp = typeMap[type + postfix];
        if (renderItem) {
          return renderItem(_objectSpread11(_objectSpread11({}, props), {}, {
            type,
            itemComponent: Cmp
          }));
        }
        if (!Cmp)
          return null;
        return Cmp(props);
      }
    }]);
    return Item2;
  }(import_react139.PureComponent);
  Item.propTypes = {
    //tree: PropTypes.instanceOf(Immutable.Map).isRequired,
    config: import_prop_types62.default.object.isRequired,
    id: import_prop_types62.default.string.isRequired,
    groupId: import_prop_types62.default.string,
    type: import_prop_types62.default.oneOf(types2).isRequired,
    path: import_prop_types62.default.any.isRequired,
    //instanceOf(Immutable.List)
    properties: import_prop_types62.default.any.isRequired,
    //instanceOf(Immutable.Map)
    children1: import_prop_types62.default.any,
    //instanceOf(Immutable.OrderedMap)
    actions: import_prop_types62.default.object.isRequired,
    reordableNodesCnt: import_prop_types62.default.number,
    onDragStart: import_prop_types62.default.func,
    parentField: import_prop_types62.default.string,
    //from RuleGroup
    isDraggingTempo: import_prop_types62.default.bool,
    isParentLocked: import_prop_types62.default.bool
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/Builder.js
  function _createSuper24(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct24();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct24() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var _Utils$TreeUtils2 = Utils.TreeUtils;
  var getTotalReordableNodesCountInTree3 = _Utils$TreeUtils2.getTotalReordableNodesCountInTree;
  var getTotalRulesCountInTree3 = _Utils$TreeUtils2.getTotalRulesCountInTree;
  var _Utils$DefaultUtils = Utils.DefaultUtils;
  var createListFromArray3 = _Utils$DefaultUtils.createListFromArray;
  var emptyProperies2 = _Utils$DefaultUtils.emptyProperies;
  var Builder = /* @__PURE__ */ function(_Component) {
    _inherits(Builder2, _Component);
    var _super = _createSuper24(Builder2);
    function Builder2(props) {
      var _this;
      _classCallCheck(this, Builder2);
      _this = _super.call(this, props);
      _this._updPath(props);
      return _this;
    }
    _createClass(Builder2, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        var prevProps = this.props;
        var should = pureShouldComponentUpdate(this)(nextProps, nextState);
        if (should) {
          var chs = [];
          for (var k in nextProps) {
            var changed = nextProps[k] !== prevProps[k];
            if (changed && k != "__isInternalValueChange") {
              chs.push(k);
            }
          }
          if (!chs.length)
            should = false;
          if (chs.length == 1 && chs[0] == "tree" && nextProps.__isInternalValueChange)
            should = false;
        }
        return should;
      }
    }, {
      key: "_updPath",
      value: function _updPath(props) {
        var id = props.tree.get("id");
        this.path = createListFromArray3([id]);
      }
    }, {
      key: "render",
      value: function render() {
        var tree2 = this.props.tree;
        var rootType = tree2.get("type");
        var isTernary = rootType == "switch_group";
        var reordableNodesCnt = isTernary ? null : getTotalReordableNodesCountInTree3(tree2);
        var totalRulesCnt = isTernary ? null : getTotalRulesCountInTree3(tree2);
        var id = tree2.get("id");
        return /* @__PURE__ */ import_react140.default.createElement(Item, {
          key: id,
          id,
          path: this.path,
          type: rootType,
          properties: tree2.get("properties") || emptyProperies2(),
          config: this.props.config,
          actions: this.props.actions,
          children1: tree2.get("children1") || emptyProperies2(),
          reordableNodesCnt,
          totalRulesCnt,
          parentReordableNodesCnt: 0,
          onDragStart: this.props.onDragStart
        });
      }
    }]);
    return Builder2;
  }(import_react140.Component);
  Builder.propTypes = {
    tree: import_prop_types63.default.any.isRequired,
    //instanceOf(Immutable.Map)
    config: import_prop_types63.default.object.isRequired,
    actions: import_prop_types63.default.object.isRequired,
    onDragStart: import_prop_types63.default.func
  };
  var Builder_default = SortableContainer_default(Builder);

  // node_modules/@react-awesome-query-builder/ui/esm/config/index.js
  var import_react162 = __toESM(require_react());

  // node_modules/@react-awesome-query-builder/ui/esm/components/rule/ValueField.js
  var import_react141 = __toESM(require_react());
  var import_prop_types64 = __toESM(require_prop_types());
  var import_last3 = __toESM(require_last());
  var import_keys3 = __toESM(require_keys());
  function ownKeys11(object, enumerableOnly) {
    var keys5 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys5.push.apply(keys5, symbols);
    }
    return keys5;
  }
  function _objectSpread12(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys11(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys11(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _createSuper25(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct25();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct25() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var clone3 = Utils.clone;
  var getFieldConfig8 = Utils.ConfigUtils.getFieldConfig;
  var _Utils$RuleUtils3 = Utils.RuleUtils;
  var getFieldPath3 = _Utils$RuleUtils3.getFieldPath;
  var getFieldPathLabels4 = _Utils$RuleUtils3.getFieldPathLabels;
  var getWidgetForFieldOp3 = _Utils$RuleUtils3.getWidgetForFieldOp;
  var ValueField = /* @__PURE__ */ function(_PureComponent) {
    _inherits(ValueField2, _PureComponent);
    var _super = _createSuper25(ValueField2);
    function ValueField2(props) {
      var _this;
      _classCallCheck(this, ValueField2);
      _this = _super.call(this, props);
      useOnPropsChanged(_assertThisInitialized(_this));
      _this.onPropsChanged(props);
      return _this;
    }
    _createClass(ValueField2, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        var prevProps = this.props;
        var keysForItems = ["config", "field", "operator", "isFuncArg", "parentField"];
        var keysForMeta = ["config", "field", "operator", "value", "placeholder", "isFuncArg", "parentField"];
        var needUpdateItems = !this.items || keysForItems.map(function(k) {
          return nextProps[k] !== prevProps[k];
        }).filter(function(ch) {
          return ch;
        }).length > 0;
        var needUpdateMeta = !this.meta || keysForMeta.map(function(k) {
          return nextProps[k] !== prevProps[k];
        }).filter(function(ch) {
          return ch;
        }).length > 0;
        if (needUpdateItems) {
          this.items = this.getItems(nextProps);
        }
        if (needUpdateMeta) {
          this.meta = this.getMeta(nextProps);
        }
      }
    }, {
      key: "getItems",
      value: function getItems(_ref) {
        var config2 = _ref.config, field = _ref.field, operator = _ref.operator, parentField = _ref.parentField, isFuncArg = _ref.isFuncArg, fieldDefinition = _ref.fieldDefinition;
        var canCompareFieldWithField = config2.settings.canCompareFieldWithField;
        var fieldSeparator = config2.settings.fieldSeparator;
        var parentFieldPath = typeof parentField == "string" ? parentField.split(fieldSeparator) : parentField;
        var parentFieldConfig = parentField ? getFieldConfig8(config2, parentField) : null;
        var sourceFields = parentField ? parentFieldConfig && parentFieldConfig.subfields : config2.fields;
        var filteredFields = this.filterFields(config2, sourceFields, field, parentField, parentFieldPath, operator, canCompareFieldWithField, isFuncArg, fieldDefinition);
        var items = this.buildOptions(parentFieldPath, config2, filteredFields, parentFieldPath);
        return items;
      }
    }, {
      key: "getMeta",
      value: function getMeta(_ref2) {
        var config2 = _ref2.config, field = _ref2.field, operator = _ref2.operator, value = _ref2.value, customPlaceholder = _ref2.placeholder, isFuncArg = _ref2.isFuncArg, parentField = _ref2.parentField;
        var _config$settings = config2.settings, fieldPlaceholder = _config$settings.fieldPlaceholder, fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay;
        var selectedKey = value;
        var isFieldSelected = !!value;
        var leftFieldConfig = getFieldConfig8(config2, field);
        var leftFieldWidgetField = leftFieldConfig.widgets.field;
        var leftFieldWidgetFieldProps = leftFieldWidgetField && leftFieldWidgetField.widgetProps || {};
        var placeholder = isFieldSelected ? null : isFuncArg && customPlaceholder || leftFieldWidgetFieldProps.valuePlaceholder || fieldPlaceholder;
        var currField = isFieldSelected ? getFieldConfig8(config2, selectedKey) : null;
        var selectedOpts = currField || {};
        var selectedKeys = getFieldPath3(selectedKey, config2);
        var selectedPath = getFieldPath3(selectedKey, config2, true);
        var selectedLabel = this.getFieldLabel(currField, selectedKey, config2);
        var partsLabels = getFieldPathLabels4(selectedKey, config2);
        var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
        if (selectedFullLabel == selectedLabel || parentField)
          selectedFullLabel = null;
        var selectedAltLabel = selectedOpts.label2;
        return {
          placeholder,
          selectedKey,
          selectedKeys,
          selectedPath,
          selectedLabel,
          selectedOpts,
          selectedAltLabel,
          selectedFullLabel
        };
      }
    }, {
      key: "filterFields",
      value: function filterFields(config2, fields, leftFieldFullkey, parentField, parentFieldPath, operator, canCompareFieldWithField, isFuncArg, fieldDefinition) {
        fields = clone3(fields);
        var fieldSeparator = config2.settings.fieldSeparator;
        var leftFieldConfig = getFieldConfig8(config2, leftFieldFullkey);
        var _relyOnWidgetType = false;
        var widget = getWidgetForFieldOp3(config2, leftFieldFullkey, operator, "value");
        var widgetConfig = config2.widgets[widget];
        var expectedType;
        if (isFuncArg && fieldDefinition) {
          expectedType = fieldDefinition.type;
        } else if (_relyOnWidgetType && widgetConfig) {
          expectedType = widgetConfig.type;
        } else {
          expectedType = leftFieldConfig.type;
        }
        function _filter(list, path) {
          for (var rightFieldKey in list) {
            var subfields = list[rightFieldKey].subfields;
            var subpath = (path ? path : []).concat(rightFieldKey);
            var rightFieldFullkey = subpath.join(fieldSeparator);
            var rightFieldConfig = getFieldConfig8(config2, rightFieldFullkey);
            if (!rightFieldConfig) {
              delete list[rightFieldKey];
            } else if (rightFieldConfig.type == "!struct" || rightFieldConfig.type == "!group") {
              if (_filter(subfields, subpath) == 0)
                delete list[rightFieldKey];
            } else {
              var canUse = rightFieldConfig.type == expectedType && (isFuncArg ? true : rightFieldFullkey != leftFieldFullkey);
              var fn2 = canCompareFieldWithField || config2.settings.canCompareFieldWithField;
              if (fn2)
                canUse = canUse && fn2(leftFieldFullkey, leftFieldConfig, rightFieldFullkey, rightFieldConfig, operator);
              if (!canUse)
                delete list[rightFieldKey];
            }
          }
          return (0, import_keys3.default)(list).length;
        }
        _filter(fields, parentFieldPath || []);
        return fields;
      }
    }, {
      key: "buildOptions",
      value: function buildOptions(parentFieldPath, config2, fields) {
        var _this2 = this;
        var path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        var optGroupLabel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
        if (!fields)
          return null;
        var _config$settings2 = config2.settings, fieldSeparator = _config$settings2.fieldSeparator, fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
        var prefix = path ? path.join(fieldSeparator) + fieldSeparator : "";
        return (0, import_keys3.default)(fields).map(function(fieldKey) {
          var field = fields[fieldKey];
          var label = _this2.getFieldLabel(field, fieldKey, config2);
          var partsLabels = getFieldPathLabels4(fieldKey, config2);
          var fullLabel = partsLabels.join(fieldSeparatorDisplay);
          if (fullLabel == label || parentFieldPath)
            fullLabel = null;
          var altLabel = field.label2;
          var tooltip = field.tooltip;
          var subpath = (path ? path : []).concat(fieldKey);
          if (field.hideForCompare)
            return void 0;
          if (field.type == "!struct" || field.type == "!group") {
            return {
              key: fieldKey,
              path: prefix + fieldKey,
              label,
              fullLabel,
              altLabel,
              tooltip,
              items: _this2.buildOptions(parentFieldPath, config2, field.subfields, subpath, label)
            };
          } else {
            return {
              key: fieldKey,
              path: prefix + fieldKey,
              label,
              fullLabel,
              altLabel,
              tooltip,
              grouplabel: optGroupLabel
            };
          }
        }).filter(function(o) {
          return !!o;
        });
      }
    }, {
      key: "getFieldLabel",
      value: function getFieldLabel(fieldOpts, fieldKey, config2) {
        if (!fieldKey)
          return null;
        var fieldSeparator = config2.settings.fieldSeparator;
        var maxLabelsLength = config2.settings.maxLabelsLength;
        var fieldParts = Array.isArray(fieldKey) ? fieldKey : fieldKey.split(fieldSeparator);
        var label = fieldOpts.label || (0, import_last3.default)(fieldParts);
        label = truncateString(label, maxLabelsLength);
        return label;
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props, config2 = _this$props.config, customProps = _this$props.customProps, setValue3 = _this$props.setValue, readonly = _this$props.readonly, id = _this$props.id, groupId = _this$props.groupId;
        var renderField2 = config2.settings.renderField;
        var renderProps = _objectSpread12({
          config: config2,
          customProps,
          setField: setValue3,
          readonly,
          items: this.items,
          id,
          groupId
        }, this.meta);
        return renderField2(renderProps);
      }
    }]);
    return ValueField2;
  }(import_react141.PureComponent);
  ValueField.propTypes = {
    id: import_prop_types64.default.string,
    groupId: import_prop_types64.default.string,
    setValue: import_prop_types64.default.func.isRequired,
    config: import_prop_types64.default.object.isRequired,
    field: import_prop_types64.default.string.isRequired,
    value: import_prop_types64.default.string,
    operator: import_prop_types64.default.string,
    customProps: import_prop_types64.default.object,
    readonly: import_prop_types64.default.bool,
    parentField: import_prop_types64.default.string,
    fieldDefinition: import_prop_types64.default.object,
    isFuncArg: import_prop_types64.default.bool
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/rule/FuncWidget.js
  var import_react143 = __toESM(require_react());
  var import_prop_types66 = __toESM(require_prop_types());

  // node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }

  // node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
  function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
      var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
      try {
        if (_x = (_i = _i.call(arr)).next, 0 === i) {
          if (Object(_i) !== _i)
            return;
          _n = false;
        } else
          for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
            ;
      } catch (err) {
        _d = true, _e = err;
      } finally {
        try {
          if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
            return;
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
  }

  // node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // node_modules/@babel/runtime/helpers/esm/slicedToArray.js
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest();
  }

  // node_modules/@react-awesome-query-builder/ui/esm/components/rule/FuncSelect.js
  var import_react142 = __toESM(require_react());
  var import_prop_types65 = __toESM(require_prop_types());
  var import_last4 = __toESM(require_last());
  var import_keys4 = __toESM(require_keys());
  function ownKeys12(object, enumerableOnly) {
    var keys5 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys5.push.apply(keys5, symbols);
    }
    return keys5;
  }
  function _objectSpread13(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys12(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys12(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _createSuper26(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct26();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct26() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var clone4 = Utils.clone;
  var _Utils$ConfigUtils5 = Utils.ConfigUtils;
  var getFieldConfig9 = _Utils$ConfigUtils5.getFieldConfig;
  var getFuncConfig2 = _Utils$ConfigUtils5.getFuncConfig;
  var _Utils$RuleUtils4 = Utils.RuleUtils;
  var getFieldPath4 = _Utils$RuleUtils4.getFieldPath;
  var getFuncPathLabels2 = _Utils$RuleUtils4.getFuncPathLabels;
  var getWidgetForFieldOp4 = _Utils$RuleUtils4.getWidgetForFieldOp;
  var FuncSelect = /* @__PURE__ */ function(_PureComponent) {
    _inherits(FuncSelect2, _PureComponent);
    var _super = _createSuper26(FuncSelect2);
    function FuncSelect2(props) {
      var _this;
      _classCallCheck(this, FuncSelect2);
      _this = _super.call(this, props);
      useOnPropsChanged(_assertThisInitialized(_this));
      _this.onPropsChanged(props);
      return _this;
    }
    _createClass(FuncSelect2, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        var prevProps = this.props;
        var keysForItems = ["config", "field", "operator", "isFuncArg"];
        var keysForMeta = ["config", "field", "value"];
        var needUpdateItems = !this.items || keysForItems.map(function(k) {
          return nextProps[k] !== prevProps[k];
        }).filter(function(ch) {
          return ch;
        }).length > 0;
        var needUpdateMeta = !this.meta || keysForMeta.map(function(k) {
          return nextProps[k] !== prevProps[k];
        }).filter(function(ch) {
          return ch;
        }).length > 0;
        if (needUpdateMeta) {
          this.meta = this.getMeta(nextProps);
        }
        if (needUpdateItems) {
          this.items = this.getItems(nextProps);
        }
      }
    }, {
      key: "getItems",
      value: function getItems(_ref) {
        var config2 = _ref.config, field = _ref.field, operator = _ref.operator, parentFuncs = _ref.parentFuncs, fieldDefinition = _ref.fieldDefinition, isFuncArg = _ref.isFuncArg;
        var canUseFuncForField = config2.settings.canUseFuncForField;
        var filteredFuncs = this.filterFuncs(config2, config2.funcs, field, operator, canUseFuncForField, parentFuncs, isFuncArg, fieldDefinition);
        var items = this.buildOptions(config2, filteredFuncs);
        return items;
      }
    }, {
      key: "getMeta",
      value: function getMeta(_ref2) {
        var config2 = _ref2.config, field = _ref2.field, value = _ref2.value;
        var _config$settings = config2.settings, funcPlaceholder = _config$settings.funcPlaceholder, fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay;
        var selectedFuncKey = value;
        var isFuncSelected = !!value;
        var leftFieldConfig = getFieldConfig9(config2, field);
        var leftFieldWidgetField = leftFieldConfig.widgets.field;
        var leftFieldWidgetFieldProps = leftFieldWidgetField && leftFieldWidgetField.widgetProps || {};
        var placeholder = !isFuncSelected ? funcPlaceholder : null;
        var currFunc = isFuncSelected ? getFuncConfig2(config2, selectedFuncKey) : null;
        var selectedOpts = currFunc || {};
        var selectedKeys = getFieldPath4(selectedFuncKey, config2);
        var selectedPath = getFieldPath4(selectedFuncKey, config2, true);
        var selectedLabel = this.getFuncLabel(currFunc, selectedFuncKey, config2);
        var partsLabels = getFuncPathLabels2(selectedFuncKey, config2);
        var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
        if (selectedFullLabel == selectedLabel)
          selectedFullLabel = null;
        return {
          placeholder,
          selectedKey: selectedFuncKey,
          selectedKeys,
          selectedPath,
          selectedLabel,
          selectedOpts,
          selectedFullLabel
        };
      }
    }, {
      key: "filterFuncs",
      value: function filterFuncs(config2, funcs, leftFieldFullkey, operator, canUseFuncForField, parentFuncs, isFuncArg, fieldDefinition) {
        funcs = clone4(funcs);
        var fieldSeparator = config2.settings.fieldSeparator;
        var leftFieldConfig = getFieldConfig9(config2, leftFieldFullkey);
        var expectedType;
        var targetDefinition = leftFieldConfig;
        var widget = getWidgetForFieldOp4(config2, leftFieldFullkey, operator, "value");
        if (isFuncArg && fieldDefinition) {
          targetDefinition = fieldDefinition;
          expectedType = fieldDefinition.type;
        } else if (widget) {
          var widgetConfig = config2.widgets[widget];
          var widgetType = widgetConfig.type;
          expectedType = widgetType;
        } else {
          expectedType = leftFieldConfig.type;
        }
        function _filter(list, path) {
          for (var funcKey in list) {
            var subfields = list[funcKey].subfields;
            var subpath = (path ? path : []).concat(funcKey);
            var funcFullkey = subpath.join(fieldSeparator);
            var funcConfig = getFuncConfig2(config2, funcFullkey);
            if (funcConfig.type == "!struct") {
              if (_filter(subfields, subpath) == 0)
                delete list[funcKey];
            } else {
              var canUse = funcConfig.returnType == expectedType;
              if (targetDefinition.funcs)
                canUse = canUse && targetDefinition.funcs.includes(funcFullkey);
              if (canUseFuncForField)
                canUse = canUse && canUseFuncForField(leftFieldFullkey, leftFieldConfig, funcFullkey, funcConfig, operator);
              if (!funcConfig.allowSelfNesting && parentFuncs && parentFuncs.map(function(_ref3) {
                var _ref4 = _slicedToArray(_ref3, 2), func = _ref4[0], _arg = _ref4[1];
                return func;
              }).includes(funcFullkey))
                canUse = false;
              if (!canUse)
                delete list[funcKey];
            }
          }
          return (0, import_keys4.default)(list).length;
        }
        _filter(funcs, []);
        return funcs;
      }
    }, {
      key: "buildOptions",
      value: function buildOptions(config2, funcs) {
        var _this2 = this;
        var path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        var optGroupLabel = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        if (!funcs)
          return null;
        var _config$settings2 = config2.settings, fieldSeparator = _config$settings2.fieldSeparator, fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
        var prefix = path ? path.join(fieldSeparator) + fieldSeparator : "";
        return (0, import_keys4.default)(funcs).map(function(funcKey) {
          var func = funcs[funcKey];
          var label = _this2.getFuncLabel(func, funcKey, config2);
          var partsLabels = getFuncPathLabels2(funcKey, config2);
          var fullLabel = partsLabels.join(fieldSeparatorDisplay);
          if (fullLabel == label)
            fullLabel = null;
          var tooltip = func.tooltip;
          var subpath = (path ? path : []).concat(funcKey);
          if (func.type == "!struct") {
            return {
              key: funcKey,
              path: prefix + funcKey,
              label,
              fullLabel,
              tooltip,
              items: _this2.buildOptions(config2, func.subfields, subpath, label)
            };
          } else {
            return {
              key: funcKey,
              path: prefix + funcKey,
              label,
              fullLabel,
              tooltip,
              grouplabel: optGroupLabel
            };
          }
        });
      }
    }, {
      key: "getFuncLabel",
      value: function getFuncLabel(funcOpts, funcKey, config2) {
        if (!funcKey)
          return null;
        var fieldSeparator = config2.settings.fieldSeparator;
        var maxLabelsLength = config2.settings.maxLabelsLength;
        var funcParts = Array.isArray(funcKey) ? funcKey : funcKey.split(fieldSeparator);
        var label = funcOpts.label || (0, import_last4.default)(funcParts);
        label = truncateString(label, maxLabelsLength);
        return label;
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props, config2 = _this$props.config, customProps = _this$props.customProps, setValue3 = _this$props.setValue, readonly = _this$props.readonly, id = _this$props.id, groupId = _this$props.groupId;
        var renderFunc2 = config2.settings.renderFunc;
        var renderProps = _objectSpread13({
          config: config2,
          customProps,
          readonly,
          setField: setValue3,
          items: this.items,
          id,
          groupId
        }, this.meta);
        return renderFunc2(renderProps);
      }
    }]);
    return FuncSelect2;
  }(import_react142.PureComponent);
  FuncSelect.propTypes = {
    id: import_prop_types65.default.string,
    groupId: import_prop_types65.default.string,
    config: import_prop_types65.default.object.isRequired,
    field: import_prop_types65.default.string.isRequired,
    operator: import_prop_types65.default.string,
    customProps: import_prop_types65.default.object,
    value: import_prop_types65.default.string,
    setValue: import_prop_types65.default.func.isRequired,
    readonly: import_prop_types65.default.bool,
    parentFuncs: import_prop_types65.default.array,
    fieldDefinition: import_prop_types65.default.object,
    isFuncArg: import_prop_types65.default.bool
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/rule/FuncWidget.js
  function _createSuper27(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct27();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct27() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var getFuncConfig3 = Utils.ConfigUtils.getFuncConfig;
  var _Utils$FuncUtils = Utils.FuncUtils;
  var setFunc2 = _Utils$FuncUtils.setFunc;
  var setArgValue2 = _Utils$FuncUtils.setArgValue;
  var setArgValueSrc2 = _Utils$FuncUtils.setArgValueSrc;
  var FuncWidget = /* @__PURE__ */ function(_PureComponent) {
    _inherits(FuncWidget3, _PureComponent);
    var _super = _createSuper27(FuncWidget3);
    function FuncWidget3(props) {
      var _this;
      _classCallCheck(this, FuncWidget3);
      _this = _super.call(this, props);
      _this.setFunc = function(funcKey) {
        _this.props.setValue(setFunc2(_this.props.value, funcKey, _this.props.config));
      };
      _this.setArgValue = function(argKey, argVal) {
        var config2 = _this.props.config;
        var funcDefinition = _this.meta.funcDefinition;
        var args = funcDefinition.args;
        var argDefinition = args[argKey];
        _this.props.setValue(setArgValue2(_this.props.value, argKey, argVal, argDefinition, config2));
      };
      _this.setArgValueSrc = function(argKey, argValSrc) {
        var config2 = _this.props.config;
        var funcDefinition = _this.meta.funcDefinition;
        var args = funcDefinition.args;
        var argDefinition = args[argKey];
        _this.props.setValue(setArgValueSrc2(_this.props.value, argKey, argValSrc, argDefinition, config2));
      };
      _this.renderFuncSelect = function() {
        var _this$props = _this.props, config2 = _this$props.config, field = _this$props.field, operator = _this$props.operator, customProps = _this$props.customProps, value = _this$props.value, readonly = _this$props.readonly, parentFuncs = _this$props.parentFuncs, id = _this$props.id, groupId = _this$props.groupId, isFuncArg = _this$props.isFuncArg, fieldDefinition = _this$props.fieldDefinition;
        var funcKey = value ? value.get("func") : null;
        var selectProps = {
          value: funcKey,
          setValue: _this.setFunc,
          config: config2,
          field,
          operator,
          customProps,
          readonly,
          parentFuncs,
          isFuncArg,
          fieldDefinition,
          id,
          groupId
        };
        var _config$settings = config2.settings, showLabels = _config$settings.showLabels, funcLabel = _config$settings.funcLabel;
        var widgetLabel = showLabels ? /* @__PURE__ */ import_react143.default.createElement("label", {
          className: "rule--label"
        }, funcLabel) : null;
        return /* @__PURE__ */ import_react143.default.createElement(Col, {
          key: "func",
          className: "rule--func"
        }, widgetLabel, /* @__PURE__ */ import_react143.default.createElement(FuncSelect, selectProps));
      };
      _this.renderArgLabel = function(argKey, argDefinition) {
        var valueSources = argDefinition.valueSources, type = argDefinition.type, showPrefix = argDefinition.showPrefix, label = argDefinition.label;
        var config2 = _this.props.config;
        var isConst = valueSources && valueSources.length == 1 && valueSources[0] == "const";
        var forceShow = !config2.settings.showLabels && (type == "boolean" || isConst) && showPrefix;
        if (!forceShow)
          return null;
        return /* @__PURE__ */ import_react143.default.createElement(Col, {
          className: "rule--func--arg-label"
        }, label || argKey);
      };
      _this.renderArgLabelSep = function(argKey, argDefinition) {
        var valueSources = argDefinition.valueSources, type = argDefinition.type, showPrefix = argDefinition.showPrefix;
        var config2 = _this.props.config;
        var isConst = valueSources && valueSources.length == 1 && valueSources[0] == "const";
        var forceShow = !config2.settings.showLabels && (type == "boolean" || isConst) && showPrefix;
        if (!forceShow)
          return null;
        return /* @__PURE__ */ import_react143.default.createElement(Col, {
          className: "rule--func--arg-label-sep"
        }, ":");
      };
      _this.renderArgVal = function(funcKey, argKey, argDefinition) {
        var _this$props2 = _this.props, config2 = _this$props2.config, field = _this$props2.field, operator = _this$props2.operator, value = _this$props2.value, readonly = _this$props2.readonly, parentFuncs = _this$props2.parentFuncs, id = _this$props2.id, groupId = _this$props2.groupId;
        var arg = value ? value.getIn(["args", argKey]) : null;
        var argVal = arg ? arg.get("value") : void 0;
        var defaultValueSource = argDefinition.valueSources.length == 1 ? argDefinition.valueSources[0] : void 0;
        var argValSrc = arg ? arg.get("valueSrc") || defaultValueSource || "value" : defaultValueSource;
        var widgetProps = {
          config: config2,
          fieldFunc: funcKey,
          fieldArg: argKey,
          leftField: field,
          operator: null,
          value: argVal,
          valueSrc: argValSrc,
          setValue: _this.setArgValue,
          setValueSrc: _this.setArgValueSrc,
          funcKey,
          argKey,
          argDefinition,
          readonly,
          parentFuncs,
          id,
          groupId
        };
        return /* @__PURE__ */ import_react143.default.createElement(Col, {
          className: "rule--func--arg-value"
        }, /* @__PURE__ */ import_react143.default.createElement(ArgWidget, widgetProps));
      };
      _this.renderArgSep = function(argKey, argDefinition, argIndex, _ref) {
        var renderSeps = _ref.renderSeps;
        if (!argIndex)
          return null;
        return /* @__PURE__ */ import_react143.default.createElement(Col, {
          className: "rule--func--arg-sep"
        }, renderSeps ? renderSeps[argIndex - 1] : ", ");
      };
      _this.renderBracketBefore = function(_ref2) {
        var renderBrackets = _ref2.renderBrackets;
        return /* @__PURE__ */ import_react143.default.createElement(Col, {
          key: "before_args",
          className: "rule--func--bracket-before"
        }, renderBrackets ? renderBrackets[0] : "(");
      };
      _this.renderBracketAfter = function(_ref3) {
        var renderBrackets = _ref3.renderBrackets;
        return /* @__PURE__ */ import_react143.default.createElement(Col, {
          key: "after_args",
          className: "rule--func--bracket-after"
        }, renderBrackets ? renderBrackets[1] : ")");
      };
      _this.renderFuncArgs = function() {
        var _this$meta = _this.meta, funcDefinition = _this$meta.funcDefinition, funcKey = _this$meta.funcKey;
        if (!funcKey)
          return null;
        var args = funcDefinition.args;
        if (!args)
          return null;
        return /* @__PURE__ */ import_react143.default.createElement(import_react143.default.Fragment, null, _this.renderBracketBefore(funcDefinition), /* @__PURE__ */ import_react143.default.createElement(Col, {
          key: "args",
          className: "rule--func--args"
        }, Object.keys(args).map(function(argKey, argIndex) {
          return /* @__PURE__ */ import_react143.default.createElement(Col, {
            key: "arg-".concat(argKey, "-").concat(argIndex),
            className: "rule--func--arg"
          }, _this.renderArgSep(argKey, args[argKey], argIndex, funcDefinition), _this.renderArgLabel(argKey, args[argKey]), _this.renderArgLabelSep(argKey, args[argKey]), _this.renderArgVal(funcKey, argKey, args[argKey]));
        })), _this.renderBracketAfter(funcDefinition));
      };
      useOnPropsChanged(_assertThisInitialized(_this));
      _this.onPropsChanged(props);
      return _this;
    }
    _createClass(FuncWidget3, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        var prevProps = this.props;
        var keysForMeta = ["config", "field", "operator", "value"];
        var needUpdateMeta = !this.meta || keysForMeta.map(function(k) {
          return nextProps[k] !== prevProps[k];
        }).filter(function(ch) {
          return ch;
        }).length > 0;
        if (needUpdateMeta) {
          this.meta = this.getMeta(nextProps);
        }
      }
    }, {
      key: "getMeta",
      value: function getMeta(_ref4) {
        var config2 = _ref4.config, field = _ref4.field, operator = _ref4.operator, value = _ref4.value;
        var funcKey = value ? value.get("func") : null;
        var funcDefinition = funcKey ? getFuncConfig3(config2, funcKey) : null;
        return {
          funcDefinition,
          funcKey
        };
      }
    }, {
      key: "render",
      value: function render() {
        return /* @__PURE__ */ import_react143.default.createElement(Col, {
          className: "rule--func--wrapper"
        }, this.renderFuncSelect(), this.renderFuncArgs());
      }
    }]);
    return FuncWidget3;
  }(import_react143.PureComponent);
  FuncWidget.propTypes = {
    id: import_prop_types66.default.string,
    groupId: import_prop_types66.default.string,
    config: import_prop_types66.default.object.isRequired,
    field: import_prop_types66.default.string.isRequired,
    operator: import_prop_types66.default.string,
    customProps: import_prop_types66.default.object,
    value: import_prop_types66.default.object,
    //instanceOf(Immutable.Map) //with keys 'func' and `args`
    setValue: import_prop_types66.default.func.isRequired,
    readonly: import_prop_types66.default.bool,
    parentFuncs: import_prop_types66.default.array,
    fieldDefinition: import_prop_types66.default.object,
    isFuncArg: import_prop_types66.default.bool
  };
  var ArgWidget = /* @__PURE__ */ function(_PureComponent2) {
    _inherits(ArgWidget2, _PureComponent2);
    var _super2 = _createSuper27(ArgWidget2);
    function ArgWidget2() {
      var _this2;
      _classCallCheck(this, ArgWidget2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _super2.call.apply(_super2, [this].concat(args));
      _this2.setValue = function(_delta, value, _widgetType) {
        var _this2$props = _this2.props, setValue3 = _this2$props.setValue, argKey = _this2$props.argKey;
        setValue3(argKey, value);
      };
      _this2.setValueSrc = function(_delta, valueSrc, _widgetType) {
        var _this2$props2 = _this2.props, setValueSrc3 = _this2$props2.setValueSrc, argKey = _this2$props2.argKey;
        setValueSrc3(argKey, valueSrc);
      };
      return _this2;
    }
    _createClass(ArgWidget2, [{
      key: "render",
      value: function render() {
        var _this$props3 = this.props, funcKey = _this$props3.funcKey, argKey = _this$props3.argKey, parentFuncs = _this$props3.parentFuncs;
        return /* @__PURE__ */ import_react143.default.createElement(Widget, _extends88({}, this.props, {
          setValue: this.setValue,
          setValueSrc: this.setValueSrc,
          isFuncArg: true,
          parentFuncs: [].concat(_toConsumableArray(parentFuncs || []), [[funcKey, argKey]])
        }));
      }
    }]);
    return ArgWidget2;
  }(import_react143.PureComponent);
  ArgWidget.propTypes = {
    funcKey: import_prop_types66.default.string.isRequired,
    argKey: import_prop_types66.default.string.isRequired,
    setValue: import_prop_types66.default.func.isRequired,
    setValueSrc: import_prop_types66.default.func.isRequired,
    readonly: import_prop_types66.default.bool,
    parentFuncs: import_prop_types66.default.array,
    id: import_prop_types66.default.string,
    groupId: import_prop_types66.default.string
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/index.js
  var import_react160 = __toESM(require_react());

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/value/VanillaBoolean.js
  var import_react144 = __toESM(require_react());
  var uuid2 = Utils.uuid;
  var VanillaBoolean_default = function(props) {
    var value = props.value, setValue3 = props.setValue, config2 = props.config, labelYes = props.labelYes, labelNo = props.labelNo, readonly = props.readonly, _props$customProps = props.customProps, customProps = _props$customProps === void 0 ? {} : _props$customProps;
    var customRadioYesProps = customProps.radioYes || {};
    var customRadioNoProps = customProps.radioNo || {};
    var onCheckboxChange = function onCheckboxChange2(e) {
      return setValue3(e.target.checked);
    };
    var onRadioChange = function onRadioChange2(e) {
      return setValue3(e.target.value == "true");
    };
    var id = uuid2(), id2 = uuid2();
    return /* @__PURE__ */ import_react144.default.createElement(import_react144.default.Fragment, null, /* @__PURE__ */ import_react144.default.createElement("input", _extends88({
      key: id,
      type: "radio",
      id,
      value: true,
      checked: !!value,
      disabled: readonly,
      onChange: onRadioChange
    }, customRadioYesProps)), /* @__PURE__ */ import_react144.default.createElement("label", {
      style: {
        display: "inline"
      },
      key: id + "label",
      htmlFor: id
    }, labelYes), /* @__PURE__ */ import_react144.default.createElement("input", _extends88({
      key: id2,
      type: "radio",
      id: id2,
      value: false,
      checked: !value,
      disabled: readonly,
      onChange: onRadioChange
    }, customRadioNoProps)), /* @__PURE__ */ import_react144.default.createElement("label", {
      style: {
        display: "inline"
      },
      key: id2 + "label",
      htmlFor: id2
    }, labelNo));
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/value/VanillaText.js
  var import_react145 = __toESM(require_react());
  var VanillaText_default = function(props) {
    var value = props.value, setValue3 = props.setValue, config2 = props.config, readonly = props.readonly, placeholder = props.placeholder, maxLength = props.maxLength, customProps = props.customProps;
    var onChange2 = function onChange3(e) {
      var val = e.target.value;
      if (val === "")
        val = void 0;
      setValue3(val);
    };
    var textValue = value || "";
    return /* @__PURE__ */ import_react145.default.createElement("input", _extends88({
      type: "text",
      value: textValue,
      placeholder,
      disabled: readonly,
      onChange: onChange2,
      maxLength
    }, customProps));
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/value/VanillaTextArea.js
  var import_react146 = __toESM(require_react());
  var VanillaTextArea_default = function(props) {
    var value = props.value, setValue3 = props.setValue, config2 = props.config, readonly = props.readonly, placeholder = props.placeholder, maxLength = props.maxLength, maxRows = props.maxRows, fullWidth = props.fullWidth, customProps = props.customProps;
    var onChange2 = function onChange3(e) {
      var val = e.target.value;
      if (val === "")
        val = void 0;
      setValue3(val);
    };
    var textValue = value || "";
    return /* @__PURE__ */ import_react146.default.createElement("textarea", _extends88({
      value: textValue,
      placeholder,
      disabled: readonly,
      onChange: onChange2,
      maxLength,
      style: {
        width: fullWidth ? "100%" : void 0
      }
    }, customProps));
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/value/VanillaDate.js
  var import_react147 = __toESM(require_react());
  var moment6 = Utils.moment;
  var VanillaDate_default = function(props) {
    var value = props.value, setValue3 = props.setValue, config2 = props.config, valueFormat = props.valueFormat, readonly = props.readonly, customProps = props.customProps;
    var onChange2 = function onChange3(e) {
      var value2 = e.target.value;
      if (value2 == "")
        value2 = void 0;
      setValue3(value2);
    };
    return /* @__PURE__ */ import_react147.default.createElement("input", _extends88({
      type: "date",
      value: value || "",
      disabled: readonly,
      onChange: onChange2
    }, customProps));
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/value/VanillaTime.js
  var import_react148 = __toESM(require_react());
  var VanillaTime_default = function(props) {
    var value = props.value, setValue3 = props.setValue, config2 = props.config, valueFormat = props.valueFormat, use12Hours = props.use12Hours, readonly = props.readonly, customProps = props.customProps;
    var onChange2 = function onChange3(e) {
      var value2 = e.target.value;
      if (value2 == "")
        value2 = void 0;
      setValue3(value2);
    };
    return /* @__PURE__ */ import_react148.default.createElement("input", _extends88({
      type: "time",
      value: value || "",
      disabled: readonly,
      onChange: onChange2
    }, customProps));
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/value/VanillaDateTime.js
  var import_react149 = __toESM(require_react());
  var moment7 = Utils.moment;
  var VanillaDateTime_default = function(props) {
    var value = props.value, setValue3 = props.setValue, config2 = props.config, valueFormat = props.valueFormat, use12Hours = props.use12Hours, readonly = props.readonly, customProps = props.customProps;
    var onChange2 = function onChange3(e) {
      var value2 = e.target.value;
      if (value2 == "")
        value2 = void 0;
      else
        value2 = moment7(new Date(value2)).format(valueFormat);
      setValue3(value2);
    };
    var dtValue = value;
    if (!value)
      dtValue = "";
    else
      dtValue = moment7(value).format("YYYY-MM-DDTHH:mm");
    return /* @__PURE__ */ import_react149.default.createElement("input", _extends88({
      type: "datetime-local",
      value: dtValue,
      disabled: readonly,
      onChange: onChange2
    }, customProps));
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/value/VanillaMultiSelect.js
  var import_react150 = __toESM(require_react());
  var import_omit8 = __toESM(require_omit());
  var mapListValues2 = Utils.ListUtils.mapListValues;
  var VanillaMultiSelect_default = function(_ref) {
    var listValues = _ref.listValues, value = _ref.value, setValue3 = _ref.setValue, allowCustomValues = _ref.allowCustomValues, readonly = _ref.readonly, customProps = _ref.customProps;
    var renderOptions = function renderOptions2() {
      return mapListValues2(listValues, function(_ref2) {
        var title = _ref2.title, value2 = _ref2.value;
        return /* @__PURE__ */ import_react150.default.createElement("option", {
          key: value2,
          value: value2
        }, title);
      });
    };
    var getMultiSelectValues = function getMultiSelectValues2(multiselect) {
      var values = [];
      var options2 = multiselect.options;
      for (var i = 0; i < options2.length; i++) {
        var opt = options2[i];
        if (opt.selected) {
          values.push(opt.value);
        }
      }
      if (!values.length)
        values = void 0;
      return values;
    };
    var onChange2 = function onChange3(e) {
      return setValue3(getMultiSelectValues(e.target));
    };
    return /* @__PURE__ */ import_react150.default.createElement("select", _extends88({
      multiple: true,
      onChange: onChange2,
      value,
      disabled: readonly
    }, (0, import_omit8.default)(customProps, ["showSearch", "input", "showCheckboxes"])), renderOptions());
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/value/VanillaSelect.js
  var import_react151 = __toESM(require_react());
  var import_omit9 = __toESM(require_omit());
  var mapListValues3 = Utils.ListUtils.mapListValues;
  var VanillaSelect_default = function(_ref) {
    var listValues = _ref.listValues, value = _ref.value, setValue3 = _ref.setValue, allowCustomValues = _ref.allowCustomValues, readonly = _ref.readonly, customProps = _ref.customProps;
    var renderOptions = function renderOptions2() {
      return mapListValues3(listValues, function(_ref2) {
        var title = _ref2.title, value2 = _ref2.value;
        return /* @__PURE__ */ import_react151.default.createElement("option", {
          key: value2,
          value: value2
        }, title);
      });
    };
    var onChange2 = function onChange3(e) {
      return setValue3(e.target.value);
    };
    var hasValue = value != null;
    return /* @__PURE__ */ import_react151.default.createElement("select", _extends88({
      onChange: onChange2,
      value: hasValue ? value : "",
      disabled: readonly
    }, (0, import_omit9.default)(customProps, ["showSearch", "input"])), !hasValue && /* @__PURE__ */ import_react151.default.createElement("option", {
      disabled: true,
      value: ""
    }), renderOptions());
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/value/VanillaNumber.js
  var import_react152 = __toESM(require_react());
  var VanillaNumber_default = function(props) {
    var value = props.value, setValue3 = props.setValue, config2 = props.config, readonly = props.readonly, min2 = props.min, max2 = props.max, step = props.step, placeholder = props.placeholder, customProps = props.customProps;
    var onChange2 = function onChange3(e) {
      var val = e.target.value;
      if (val === "" || val === null)
        val = void 0;
      else
        val = Number(val);
      setValue3(val);
    };
    var numberValue = value == void 0 ? "" : value;
    return /* @__PURE__ */ import_react152.default.createElement("input", _extends88({
      type: "number",
      value: numberValue,
      placeholder,
      disabled: readonly,
      min: min2,
      max: max2,
      step,
      onChange: onChange2
    }, customProps));
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/value/VanillaSlider.js
  var import_react153 = __toESM(require_react());
  var VanillaSlider_default = function(props) {
    var value = props.value, setValue3 = props.setValue, config2 = props.config, readonly = props.readonly, min2 = props.min, max2 = props.max, step = props.step, placeholder = props.placeholder, _props$customProps = props.customProps, customProps = _props$customProps === void 0 ? {} : _props$customProps;
    var customInputProps = customProps.input || {};
    var customSliderProps = customProps.slider || customProps;
    var onChange2 = function onChange3(e) {
      var val = e.target.value;
      if (val === "" || val === null)
        val = void 0;
      else
        val = Number(val);
      setValue3(val);
    };
    var numberValue = value == void 0 ? "" : value;
    return /* @__PURE__ */ import_react153.default.createElement("div", {
      style: {
        display: "inline-flex"
      }
    }, /* @__PURE__ */ import_react153.default.createElement("input", _extends88({
      key: "number",
      type: "number",
      value: numberValue,
      placeholder,
      disabled: readonly,
      min: min2,
      max: max2,
      step,
      onChange: onChange2
    }, customInputProps)), /* @__PURE__ */ import_react153.default.createElement("input", _extends88({
      key: "range",
      type: "range",
      value: numberValue,
      disabled: readonly,
      min: min2,
      max: max2,
      step,
      onChange: onChange2
    }, customSliderProps)));
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/core/VanillaFieldSelect.js
  var import_react154 = __toESM(require_react());
  var VanillaFieldSelect_default = function(_ref) {
    var items = _ref.items, setField3 = _ref.setField, selectedKey = _ref.selectedKey, readonly = _ref.readonly;
    var renderOptions = function renderOptions2(fields) {
      return fields.map(function(field) {
        var items2 = field.items, path = field.path, label = field.label, disabled = field.disabled;
        if (items2) {
          return /* @__PURE__ */ import_react154.default.createElement("optgroup", {
            disabled,
            key: path,
            label
          }, renderOptions2(items2));
        } else {
          return /* @__PURE__ */ import_react154.default.createElement("option", {
            disabled,
            key: path,
            value: path
          }, label);
        }
      });
    };
    var onChange2 = function onChange3(e) {
      return setField3(e.target.value);
    };
    var hasValue = selectedKey != null;
    return /* @__PURE__ */ import_react154.default.createElement("select", {
      onChange: onChange2,
      value: hasValue ? selectedKey : "",
      disabled: readonly
    }, !hasValue && /* @__PURE__ */ import_react154.default.createElement("option", {
      disabled: true,
      value: ""
    }), renderOptions(items));
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/core/VanillaConjs.js
  var import_react155 = __toESM(require_react());
  var VanillaConjs_default = function(_ref) {
    var id = _ref.id, not = _ref.not, setNot3 = _ref.setNot, conjunctionOptions = _ref.conjunctionOptions, setConjunction3 = _ref.setConjunction, disabled = _ref.disabled, readonly = _ref.readonly, config2 = _ref.config, showNot = _ref.showNot, notLabel = _ref.notLabel;
    var conjsCount = Object.keys(conjunctionOptions).length;
    var lessThenTwo = disabled;
    var forceShowConj = config2.settings.forceShowConj;
    var showConj = forceShowConj || conjsCount > 1 && !lessThenTwo;
    var renderOptions = function renderOptions2() {
      return Object.keys(conjunctionOptions).map(function(key) {
        var _conjunctionOptions$k = conjunctionOptions[key], id2 = _conjunctionOptions$k.id, name = _conjunctionOptions$k.name, label = _conjunctionOptions$k.label, checked = _conjunctionOptions$k.checked;
        var postfix = setConjunction3.isDummyFn ? "__dummy" : "";
        if ((readonly || disabled) && !checked)
          return null;
        return [/* @__PURE__ */ import_react155.default.createElement("input", {
          key: id2 + postfix,
          type: "radio",
          id: id2 + postfix,
          name: name + postfix,
          checked,
          disabled: readonly || disabled,
          value: key,
          onChange: onChange2
        }), /* @__PURE__ */ import_react155.default.createElement("label", {
          key: id2 + postfix + "label",
          htmlFor: id2 + postfix
        }, label)];
      });
    };
    var renderNot = function renderNot2() {
      var postfix = "not";
      return [/* @__PURE__ */ import_react155.default.createElement("input", {
        key: id + postfix,
        type: "checkbox",
        id: id + postfix,
        checked: not,
        disabled: readonly,
        onChange: onNotChange
      }), /* @__PURE__ */ import_react155.default.createElement("label", {
        key: id + postfix + "label",
        htmlFor: id + postfix
      }, notLabel || "NOT")];
    };
    var onChange2 = function onChange3(e) {
      return setConjunction3(e.target.value);
    };
    var onNotChange = function onNotChange2(e) {
      return setNot3(e.target.checked);
    };
    return [showNot && renderNot(), showConj && renderOptions()];
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/core/VanillaButton.js
  var import_react156 = __toESM(require_react());
  var VanillaButton_default = function(_ref) {
    var type = _ref.type, label = _ref.label, onClick = _ref.onClick, readonly = _ref.readonly, config2 = _ref.config;
    var typeToLabel = {
      "addRuleGroup": "+",
      "addRuleGroupExt": "+",
      "delGroup": "x",
      "delRuleGroup": "x",
      "delRule": "x"
    };
    var btnLabel = label || typeToLabel[type];
    return /* @__PURE__ */ import_react156.default.createElement("button", {
      onClick,
      type: "button",
      disabled: readonly
    }, btnLabel);
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/core/VanillaButtonGroup.js
  var import_react157 = __toESM(require_react());
  var VanillaButtonGroup_default = function(_ref) {
    var children = _ref.children, config2 = _ref.config;
    return /* @__PURE__ */ import_react157.default.createElement(import_react157.default.Fragment, null, children);
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/core/VanillaValueSources.js
  var import_react158 = __toESM(require_react());
  var VanillaValueSources_default = function(_ref) {
    var config2 = _ref.config, valueSources = _ref.valueSources, valueSrc = _ref.valueSrc, title = _ref.title, setValueSrc3 = _ref.setValueSrc, readonly = _ref.readonly;
    var renderOptions = function renderOptions2(valueSources2) {
      return valueSources2.map(function(_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2), srcKey = _ref3[0], info = _ref3[1];
        return /* @__PURE__ */ import_react158.default.createElement("option", {
          key: srcKey,
          value: srcKey
        }, info.label);
      });
    };
    var onChange2 = function onChange3(e) {
      return setValueSrc3(e.target.value);
    };
    return /* @__PURE__ */ import_react158.default.createElement("select", {
      onChange: onChange2,
      value: valueSrc,
      disabled: readonly
    }, renderOptions(valueSources));
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/core/VanillaSwitch.js
  var import_react159 = __toESM(require_react());
  var VanillaSwitch_default = function(_ref) {
    var value = _ref.value, setValue3 = _ref.setValue, label = _ref.label, id = _ref.id, config2 = _ref.config, type = _ref.type;
    var onChange2 = function onChange3(e) {
      return setValue3(e.target.checked);
    };
    var postfix = type;
    return [/* @__PURE__ */ import_react159.default.createElement("input", {
      key: id + postfix,
      type: "checkbox",
      id: id + postfix,
      checked: !!value,
      onChange: onChange2
    }), /* @__PURE__ */ import_react159.default.createElement("label", {
      key: id + postfix + "label",
      htmlFor: id + postfix
    }, label)];
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/core/vanillaConfirm.js
  var vanillaConfirm_default = function(_ref) {
    var onOk = _ref.onOk, okText = _ref.okText, cancelText = _ref.cancelText, title = _ref.title;
    if (confirm(title)) {
      onOk();
    }
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/widgets/vanilla/index.js
  var VanillaProvider = function VanillaProvider2(_ref) {
    var config2 = _ref.config, children = _ref.children;
    return children;
  };

  // node_modules/@react-awesome-query-builder/ui/esm/components/operators/Proximity.js
  var import_react161 = __toESM(require_react());
  var import_prop_types67 = __toESM(require_prop_types());
  var import_range2 = __toESM(require_range());
  function _createSuper28(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct28();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct28() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var Proximity = /* @__PURE__ */ function(_PureComponent) {
    _inherits(Proximity2, _PureComponent);
    var _super = _createSuper28(Proximity2);
    function Proximity2() {
      var _this;
      _classCallCheck(this, Proximity2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _this.handleChange = function(value) {
        _this.props.setOption("proximity", parseInt(value));
      };
      return _this;
    }
    _createClass(Proximity2, [{
      key: "render",
      value: function render() {
        var _this$props = this.props, defaults = _this$props.defaults, options2 = _this$props.options, config2 = _this$props.config, optionLabel = _this$props.optionLabel, optionPlaceholder = _this$props.optionPlaceholder, customProps = _this$props.customProps, minProximity = _this$props.minProximity, maxProximity = _this$props.maxProximity, optionTextBefore = _this$props.optionTextBefore, readonly = _this$props.readonly;
        var settings4 = config2.settings, widgets3 = config2.widgets;
        var defaultProximity = defaults ? defaults.proximity : void 0;
        var showLabels = settings4.showLabels;
        var selectedProximity = options2.get("proximity", defaultProximity);
        var proxValues = (0, import_range2.default)(minProximity, maxProximity + 1).map(function(item) {
          return {
            title: item,
            value: item
          };
        });
        var Select2 = widgets3.select.factory;
        return /* @__PURE__ */ import_react161.default.createElement("div", {
          className: "operator--PROXIMITY"
        }, /* @__PURE__ */ import_react161.default.createElement("div", {
          className: "operator--options"
        }, showLabels && /* @__PURE__ */ import_react161.default.createElement("label", {
          className: "rule--label"
        }, optionLabel), !showLabels && optionTextBefore && /* @__PURE__ */ import_react161.default.createElement("div", {
          className: "operator--options--sep"
        }, /* @__PURE__ */ import_react161.default.createElement("span", null, optionTextBefore)), /* @__PURE__ */ import_react161.default.createElement(Select2, _extends88({
          config: config2,
          value: selectedProximity,
          listValues: proxValues,
          setValue: this.handleChange,
          readonly,
          placeholder: optionPlaceholder
        }, customProps))), /* @__PURE__ */ import_react161.default.createElement("div", {
          className: "operator--widgets"
        }, this.props.children));
      }
    }]);
    return Proximity2;
  }(import_react161.PureComponent);
  Proximity.propTypes = {
    config: import_prop_types67.default.object.isRequired,
    setOption: import_prop_types67.default.func.isRequired,
    options: import_prop_types67.default.any.isRequired,
    //instanceOf(Immutable.Map)
    minProximity: import_prop_types67.default.number,
    maxProximity: import_prop_types67.default.number,
    optionPlaceholder: import_prop_types67.default.string,
    optionTextBefore: import_prop_types67.default.string,
    optionLabel: import_prop_types67.default.string,
    customProps: import_prop_types67.default.object,
    readonly: import_prop_types67.default.bool
    //children
  };
  Proximity.defaultProps = {
    customProps: {},
    minProximity: 2,
    maxProximity: 10,
    optionPlaceholder: "Select words between",
    optionLabel: "Words between",
    optionTextBefore: null
  };

  // node_modules/@react-awesome-query-builder/ui/esm/config/index.js
  function ownKeys13(object, enumerableOnly) {
    var keys5 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys5.push.apply(keys5, symbols);
    }
    return keys5;
  }
  function _objectSpread14(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys13(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys13(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var VanillaBooleanWidget = VanillaBoolean_default;
  var VanillaTextWidget = VanillaText_default;
  var VanillaTextAreaWidget = VanillaTextArea_default;
  var VanillaDateWidget = VanillaDate_default;
  var VanillaTimeWidget = VanillaTime_default;
  var VanillaDateTimeWidget = VanillaDateTime_default;
  var VanillaMultiSelectWidget = VanillaMultiSelect_default;
  var VanillaSelectWidget = VanillaSelect_default;
  var VanillaNumberWidget = VanillaNumber_default;
  var VanillaSliderWidget = VanillaSlider_default;
  var VanillaFieldSelect = VanillaFieldSelect_default;
  var VanillaConjs = VanillaConjs_default;
  var VanillaButton = VanillaButton_default;
  var VanillaButtonGroup = VanillaButtonGroup_default;
  var VanillaProvider3 = VanillaProvider;
  var VanillaValueSources = VanillaValueSources_default;
  var vanillaConfirm = vanillaConfirm_default;
  var VanillaSwitch = VanillaSwitch_default;
  var ValueFieldWidget = ValueField;
  var FuncWidget2 = FuncWidget;
  var ProximityOperator = Proximity;
  var conjunctions2 = _objectSpread14({}, config_default.conjunctions);
  var operators2 = _objectSpread14(_objectSpread14({}, config_default.operators), {}, {
    proximity: _objectSpread14(_objectSpread14({}, config_default.operators.proximity), {}, {
      options: _objectSpread14(_objectSpread14({}, config_default.operators.proximity.options), {}, {
        factory: function factory(props) {
          return /* @__PURE__ */ import_react162.default.createElement(ProximityOperator, props);
        }
      })
    })
  });
  var widgets2 = {
    text: _objectSpread14(_objectSpread14({}, config_default.widgets.text), {}, {
      factory: function factory2(props) {
        return /* @__PURE__ */ import_react162.default.createElement(VanillaTextWidget, props);
      }
    }),
    textarea: _objectSpread14(_objectSpread14({}, config_default.widgets.textarea), {}, {
      factory: function factory3(props) {
        return /* @__PURE__ */ import_react162.default.createElement(VanillaTextAreaWidget, props);
      }
    }),
    number: _objectSpread14(_objectSpread14({}, config_default.widgets.number), {}, {
      factory: function factory4(props) {
        return /* @__PURE__ */ import_react162.default.createElement(VanillaNumberWidget, props);
      }
    }),
    slider: _objectSpread14(_objectSpread14({}, config_default.widgets.slider), {}, {
      factory: function factory5(props) {
        return /* @__PURE__ */ import_react162.default.createElement(VanillaSliderWidget, props);
      }
    }),
    select: _objectSpread14(_objectSpread14({}, config_default.widgets.select), {}, {
      factory: function factory6(props) {
        return /* @__PURE__ */ import_react162.default.createElement(VanillaSelectWidget, props);
      }
    }),
    multiselect: _objectSpread14(_objectSpread14({}, config_default.widgets.multiselect), {}, {
      factory: function factory7(props) {
        return /* @__PURE__ */ import_react162.default.createElement(VanillaMultiSelectWidget, props);
      }
    }),
    date: _objectSpread14(_objectSpread14({}, config_default.widgets.date), {}, {
      factory: function factory8(props) {
        return /* @__PURE__ */ import_react162.default.createElement(VanillaDateWidget, props);
      }
    }),
    time: _objectSpread14(_objectSpread14({}, config_default.widgets.time), {}, {
      factory: function factory9(props) {
        return /* @__PURE__ */ import_react162.default.createElement(VanillaTimeWidget, props);
      }
    }),
    datetime: _objectSpread14(_objectSpread14({}, config_default.widgets.datetime), {}, {
      factory: function factory10(props) {
        return /* @__PURE__ */ import_react162.default.createElement(VanillaDateTimeWidget, props);
      }
    }),
    "boolean": _objectSpread14(_objectSpread14({}, config_default.widgets["boolean"]), {}, {
      factory: function factory11(props) {
        return /* @__PURE__ */ import_react162.default.createElement(VanillaBooleanWidget, props);
      }
    }),
    field: _objectSpread14(_objectSpread14({}, config_default.widgets.field), {}, {
      factory: function factory12(props) {
        return /* @__PURE__ */ import_react162.default.createElement(ValueFieldWidget, props);
      },
      customProps: {
        showSearch: true
      }
    }),
    func: _objectSpread14(_objectSpread14({}, config_default.widgets.func), {}, {
      factory: function factory13(props) {
        return /* @__PURE__ */ import_react162.default.createElement(FuncWidget2, props);
      },
      customProps: {
        //showSearch: true
      }
    }),
    case_value: _objectSpread14(_objectSpread14({}, config_default.widgets.case_value), {}, {
      factory: function factory14(_ref) {
        var value = _ref.value, setValue3 = _ref.setValue;
        return /* @__PURE__ */ import_react162.default.createElement("input", {
          type: "text",
          value: value || "",
          onChange: function onChange2(e) {
            return setValue3(e.target.value);
          }
        });
      }
    })
  };
  var types3 = _objectSpread14(_objectSpread14({}, config_default.types), {}, {
    select: _objectSpread14(_objectSpread14({}, config_default.types.select), {}, {
      widgets: _objectSpread14(_objectSpread14({}, config_default.types.select.widgets), {}, {
        select: _objectSpread14(_objectSpread14({}, config_default.types.select.widgets.select), {}, {
          widgetProps: {
            customProps: {
              showSearch: true
            }
          }
        })
      })
    })
  });
  var settings3 = _objectSpread14(_objectSpread14({}, config_default.settings), {}, {
    renderField: function renderField(props) {
      return /* @__PURE__ */ import_react162.default.createElement(VanillaFieldSelect, props);
    },
    renderOperator: function renderOperator(props) {
      return /* @__PURE__ */ import_react162.default.createElement(VanillaFieldSelect, props);
    },
    renderFunc: function renderFunc(props) {
      return /* @__PURE__ */ import_react162.default.createElement(VanillaFieldSelect, props);
    },
    renderConjs: function renderConjs(props) {
      return /* @__PURE__ */ import_react162.default.createElement(VanillaConjs, props);
    },
    renderSwitch: function renderSwitch(props) {
      return /* @__PURE__ */ import_react162.default.createElement(VanillaSwitch, props);
    },
    renderButton: function renderButton(props) {
      return /* @__PURE__ */ import_react162.default.createElement(VanillaButton, props);
    },
    renderButtonGroup: function renderButtonGroup(props) {
      return /* @__PURE__ */ import_react162.default.createElement(VanillaButtonGroup, props);
    },
    renderProvider: function renderProvider(props) {
      return /* @__PURE__ */ import_react162.default.createElement(VanillaProvider3, props);
    },
    renderValueSources: function renderValueSources(props) {
      return /* @__PURE__ */ import_react162.default.createElement(VanillaValueSources, props);
    },
    renderConfirm: vanillaConfirm,
    renderSwitchPrefix: function renderSwitchPrefix() {
      return /* @__PURE__ */ import_react162.default.createElement(import_react162.default.Fragment, null, "Conditions");
    },
    customFieldSelectProps: {
      showSearch: true
    },
    defaultSliderWidth: "200px",
    defaultSelectWidth: "200px",
    defaultSearchWidth: "100px",
    defaultMaxRows: 5,
    renderSize: "small",
    maxLabelsLength: 100,
    showLock: false,
    showNot: true,
    forceShowConj: false,
    groupActionsPosition: "topRight"
    // oneOf [topLeft, topCenter, topRight, bottomLeft, bottomCenter, bottomRight]
  });
  var config_default2 = {
    conjunctions: conjunctions2,
    operators: operators2,
    widgets: widgets2,
    types: types3,
    settings: settings3
  };

  // node_modules/@react-awesome-query-builder/ui/esm/hooks/useListValuesAutocomplete.js
  var import_regenerator = __toESM(require_regenerator());
  var import_react163 = __toESM(require_react());
  var import_debounce2 = __toESM(require_debounce());
  var _Utils$Autocomplete = Utils.Autocomplete;
  var mergeListValues2 = _Utils$Autocomplete.mergeListValues;
  var listValueToOption2 = _Utils$Autocomplete.listValueToOption;
  var getListValue2 = _Utils$Autocomplete.getListValue;
  var _Utils$ListUtils = Utils.ListUtils;
  var mapListValues4 = _Utils$ListUtils.mapListValues;
  var listValuesToArray2 = _Utils$ListUtils.listValuesToArray;

  // app/javascript/components/module/QueryBuilder.jsx
  var InitialConfig = config_default2;
  var config = {
    ...InitialConfig,
    fields: {
      // qty: {
      //   label: 'Qty',
      //   type: 'number',
      //   fieldSettings: {
      //     min: 0,
      //   },
      //   valueSources: ['value'],
      //   preferWidgets: ['number'],
      // },
      // price: {
      //   label: 'Price',
      //   type: 'number',
      //   valueSources: ['value'],
      //   fieldSettings: {
      //     min: 10,
      //     max: 100,
      //   },
      //   preferWidgets: ['slider', 'rangeslider'],
      // },
      log: {
        label: "Log",
        type: "text"
      }
      // color: {
      //   label: 'Color',
      //   type: 'select',
      //   valueSources: ['value'],
      //   fieldSettings: {
      //     listValues: [
      //       { value: 'yellow', title: 'Yellow' },
      //       { value: 'green', title: 'Green' },
      //       { value: 'orange', title: 'Orange' }
      //     ],
      //   }
      // },
      // is_promotion: {
      //   label: 'Promo?',
      //   type: 'boolean',
      //   operators: ['equal'],
      //   valueSources: ['value'],
      // },
    }
  };
  var queryValue = { "id": Utils.uuid(), "type": "group" };
  var QueryBuilder = (props) => {
    const newQueryValue = props.build_query ? JSON.parse(props.build_query) : queryValue;
    const [state, setState] = (0, import_react164.useState)({ tree: Utils.checkTree(Utils.loadTree(newQueryValue), config), config });
    renderBuilder = (props2) => /* @__PURE__ */ import_react164.default.createElement("div", { className: "col-md-12" }, /* @__PURE__ */ import_react164.default.createElement("label", null, "Rule Builder"), /* @__PURE__ */ import_react164.default.createElement(Builder_default, { ...props2 }));
    renderResult = ({ tree: immutableTree, config: config2 }) => /* @__PURE__ */ import_react164.default.createElement("div", { className: "query-builder-result" }, /* @__PURE__ */ import_react164.default.createElement("div", null, "Query string: ", /* @__PURE__ */ import_react164.default.createElement("pre", null, JSON.stringify(Utils.queryString(immutableTree, config2)))));
    onChange = (immutableTree, config2) => {
      setState({ tree: immutableTree, config: config2 });
      const jsonTree = Utils.getTree(immutableTree);
      props.setbuild_query(JSON.stringify(jsonTree));
      const mongo_qry = JSON.stringify(Utils.mongodbFormat(immutableTree, config2));
      if (mongo_qry) {
        props.setmongo_query(mongo_qry);
      }
    };
    return /* @__PURE__ */ import_react164.default.createElement("div", null, /* @__PURE__ */ import_react164.default.createElement(
      QueryContainer,
      {
        ...config,
        value: state.tree,
        onChange,
        renderBuilder
      }
    ), renderResult(state));
  };
  var QueryBuilder_default = QueryBuilder;

  // app/javascript/components/module/EditRule.jsx
  var LayerForm2 = (props) => {
    const setData = props.setData;
    const [loading, setLoading] = (0, import_react165.useState)(false);
    const [form_errors, setform_errors] = (0, import_react165.useState)("");
    const [rule_data, setruleData] = (0, import_react165.useState)(props.rule_detail);
    const [mongo_query, setmongo_query] = (0, import_react165.useState)();
    const [build_query, setbuild_query] = (0, import_react165.useState)();
    (0, import_react165.useEffect)(() => {
    }, []);
    const onSubmit = ({ value, touched }) => {
      if (value.name && value.query_string && value.mongo_query) {
        setform_errors("");
        let csrf = document.querySelector("meta[name='csrf-token']").getAttribute("content");
        const post_set = {
          method: "POST",
          headers: { "Content-Type": "application/json", "X-CSRF-Token": csrf },
          body: JSON.stringify(value)
        };
        updateData = () => {
          setLoading(true);
          fetch("api/update_rule", post_set).then((response) => response.json()).then((data) => {
            setData(data);
            setmongo_query(data.mongo_query);
            setbuild_query(data.build_query);
            props.setOpen(false);
            setLoading(false);
          }).catch((error2) => {
            setLoading(false);
          });
        };
        updateData();
      } else if (!value.name) {
        setform_errors("Please provide rule name");
      } else if (!value.query_string) {
        setform_errors("Please provide query string");
      } else {
        setform_errors("Please provide some inputs");
      }
    };
    const updateText = (e) => {
      const { value, name } = e.target;
      setruleData((prevState) => ({ ...prevState, [name]: value }));
    };
    return /* @__PURE__ */ import_react165.default.createElement(Box, { gap: "medium" }, /* @__PURE__ */ import_react165.default.createElement(Button2, { alignSelf: "end", icon: /* @__PURE__ */ import_react165.default.createElement(Close, null), onClick: () => props.setOpen(false) }), /* @__PURE__ */ import_react165.default.createElement(Header, { alignSelf: "center", pad: { horizontal: "xxsmall" } }, /* @__PURE__ */ import_react165.default.createElement(Box, null, /* @__PURE__ */ import_react165.default.createElement(Heading, { level: 4, margin: "none", id: "layer-title" }, "New Rule"))), /* @__PURE__ */ import_react165.default.createElement("div", { direction: "row" }, /* @__PURE__ */ import_react165.default.createElement(Form, { validate: "blur", method: "post", onSubmit: ({ value, touched }) => onSubmit({ value, touched }) }, /* @__PURE__ */ import_react165.default.createElement(TextInput, { id: "rule_id", type: "hidden", name: "rule_id", value: rule_data.id }), /* @__PURE__ */ import_react165.default.createElement("div", { direction: "row", style: { marginTop: "10px" } }, /* @__PURE__ */ import_react165.default.createElement("div", { className: "col-md-12" }, /* @__PURE__ */ import_react165.default.createElement(FormField, { label: "Rule Name", htmlFor: "rule_name" }, /* @__PURE__ */ import_react165.default.createElement(TextInput, { id: "name", name: "name", value: rule_data.name, onChange: (e) => updateText(e) }))), /* @__PURE__ */ import_react165.default.createElement("div", { className: "col-md-12" }, /* @__PURE__ */ import_react165.default.createElement(FormField, { label: "Query String", htmlFor: "query_string" }, /* @__PURE__ */ import_react165.default.createElement(TextInput, { id: "query_string", name: "query_string", value: rule_data.query_string, onChange: (e) => updateText(e) }))), /* @__PURE__ */ import_react165.default.createElement(TextInput, { id: "mongo_query", type: "hidden", name: "mongo_query", value: mongo_query }), /* @__PURE__ */ import_react165.default.createElement(TextInput, { id: "build_query", type: "hidden", name: "build_query", value: build_query }), /* @__PURE__ */ import_react165.default.createElement(QueryBuilder_default, { setmongo_query, setbuild_query, build_query: rule_data.build_query }), /* @__PURE__ */ import_react165.default.createElement("div", { className: "col-md-12" }, /* @__PURE__ */ import_react165.default.createElement(Box, { direction: "row", gap: "small", margin: "medium", className: "" }, /* @__PURE__ */ import_react165.default.createElement(Button2, { label: "Update", secondary: true, type: "submit" }))), form_errors && /* @__PURE__ */ import_react165.default.createElement("div", { className: "col-md-12" }, /* @__PURE__ */ import_react165.default.createElement(Box, { direction: "row", align: "center", gap: "medium", margin: "medium", className: "mt-3 pt-3" }, /* @__PURE__ */ import_react165.default.createElement("span", { style: { margin: "auto", color: "#F00" } }, form_errors)))))));
  };
  LayerForm2.propTypes = {
    setOpen: import_prop_types68.default.func.isRequired
  };
  var EditRule = (props) => {
    user = props.user;
    var roleids = [];
    if (user) {
      roles = user.roles;
      if (roles) {
        roleids = roles.map(function(rl) {
          return rl["id"];
        });
      }
    }
    const [open, setOpen] = (0, import_react165.useState)(false);
    const size = (0, import_react165.useContext)(ResponsiveContext);
    const onOpen = () => setOpen(true);
    const onClose = () => setOpen(void 0);
    const rule_detail = props.rule_detail;
    const setData = props.setData;
    return /* @__PURE__ */ import_react165.default.createElement(import_react165.default.Fragment, null, roleids.includes(1) || roleids.includes(3) || rule_detail.created_by == user.id ? /* @__PURE__ */ import_react165.default.createElement(Button2, { alignSelf: "center", icon: /* @__PURE__ */ import_react165.default.createElement(Edit, null), onClick: onOpen, secondary: true }) : /* @__PURE__ */ import_react165.default.createElement(Button2, { alignSelf: "center", icon: /* @__PURE__ */ import_react165.default.createElement(Edit, null), secondary: true, disabled: true }), open && /* @__PURE__ */ import_react165.default.createElement(Layer, { position: "right", full: !["xsmall", "small"].includes(size) ? "vertical" : true, onEsc: onClose }, /* @__PURE__ */ import_react165.default.createElement(Box, { fill: "vertical", overflow: "auto", width: !["xsmall", "small"].includes(size) ? "large" : void 0, pad: "medium" }, /* @__PURE__ */ import_react165.default.createElement(LayerForm2, { rule_detail, setData, user, setOpen: (value) => setOpen(value) }))));
  };
  var EditRule_default = EditRule;

  // app/javascript/components/module/NewRule.jsx
  var import_react166 = __toESM(require_react());
  var import_prop_types69 = __toESM(require_prop_types());
  var LayerForm3 = (props) => {
    const setData = props.setData;
    const [loading, setLoading] = (0, import_react166.useState)(false);
    const [form_errors, setform_errors] = (0, import_react166.useState)("");
    const [mongo_query, setmongo_query] = (0, import_react166.useState)("");
    const static_qry = JSON.stringify({ "id": "8a8aabb9-0123-4456-b89a-b186c5ad2c95", "type": "group" });
    const [build_query, setbuild_query] = (0, import_react166.useState)(static_qry);
    (0, import_react166.useEffect)(() => {
    }, []);
    const onSubmit = ({ value, touched }) => {
      if (value.rule_name && value.query_string && value.mongo_query) {
        setform_errors("");
        let csrf = document.querySelector("meta[name='csrf-token']").getAttribute("content");
        const post_set = {
          method: "POST",
          headers: { "Content-Type": "application/json", "X-CSRF-Token": csrf },
          body: JSON.stringify(value)
        };
        updateData = () => {
          setLoading(true);
          fetch("api/create_rule", post_set).then((response) => response.json()).then((data) => {
            setData(data);
            props.setOpen(false);
            setLoading(false);
          }).catch((error2) => {
            setLoading(false);
          });
        };
        updateData();
      } else if (!value.rule_name) {
        setform_errors("Please provide rule name");
      } else if (!value.query_string) {
        setform_errors("Please provide query string");
      } else if (!value.mongo_query) {
        setform_errors("Please Create some rule");
      } else {
        setform_errors("Please provide some inputs");
      }
    };
    return /* @__PURE__ */ import_react166.default.createElement(Box, { gap: "medium" }, /* @__PURE__ */ import_react166.default.createElement(Button2, { alignSelf: "end", icon: /* @__PURE__ */ import_react166.default.createElement(Close, null), onClick: () => props.setOpen(false) }), /* @__PURE__ */ import_react166.default.createElement(Header, { alignSelf: "center", pad: { horizontal: "xxsmall" } }, /* @__PURE__ */ import_react166.default.createElement(Box, null, /* @__PURE__ */ import_react166.default.createElement(Heading, { level: 4, margin: "none", id: "layer-title" }, "New Rule"))), /* @__PURE__ */ import_react166.default.createElement("div", { direction: "row" }, /* @__PURE__ */ import_react166.default.createElement(Form, { validate: "blur", method: "post", onSubmit: ({ value, touched }) => onSubmit({ value, touched }) }, /* @__PURE__ */ import_react166.default.createElement("div", { direction: "row", style: { marginTop: "10px" } }, /* @__PURE__ */ import_react166.default.createElement("div", { className: "col-md-12" }, /* @__PURE__ */ import_react166.default.createElement(FormField, { label: "Rule Name", htmlFor: "rule_name" }, /* @__PURE__ */ import_react166.default.createElement(TextInput, { id: "rule_name", name: "rule_name" }))), /* @__PURE__ */ import_react166.default.createElement("div", { className: "col-md-12" }, /* @__PURE__ */ import_react166.default.createElement(FormField, { label: "Query String", htmlFor: "query_string" }, /* @__PURE__ */ import_react166.default.createElement(TextInput, { id: "query_string", name: "query_string" }))), /* @__PURE__ */ import_react166.default.createElement(TextInput, { id: "mongo_query", type: "hidden", name: "mongo_query", value: mongo_query }), /* @__PURE__ */ import_react166.default.createElement(TextInput, { id: "build_query", type: "hidden", name: "build_query", value: build_query }), /* @__PURE__ */ import_react166.default.createElement(QueryBuilder_default, { setmongo_query, setbuild_query }), /* @__PURE__ */ import_react166.default.createElement("div", { className: "col-md-12" }, /* @__PURE__ */ import_react166.default.createElement(Box, { direction: "row", gap: "small", margin: "medium", className: "" }, /* @__PURE__ */ import_react166.default.createElement(Button2, { label: "Create", secondary: true, type: "submit" }))), form_errors && /* @__PURE__ */ import_react166.default.createElement("div", { className: "col-md-12" }, /* @__PURE__ */ import_react166.default.createElement(Box, { direction: "row", align: "center", gap: "medium", margin: "medium", className: "mt-3 pt-3" }, /* @__PURE__ */ import_react166.default.createElement("span", { style: { margin: "auto", color: "#F00" } }, form_errors)))))));
  };
  LayerForm3.propTypes = {
    setOpen: import_prop_types69.default.func.isRequired
  };
  var NewRule = (props) => {
    const [open, setOpen] = (0, import_react166.useState)(false);
    const size = (0, import_react166.useContext)(ResponsiveContext);
    const onOpen = () => setOpen(true);
    const onClose = () => setOpen(void 0);
    const user2 = props.user;
    const setData = props.setData;
    return /* @__PURE__ */ import_react166.default.createElement(import_react166.default.Fragment, null, /* @__PURE__ */ import_react166.default.createElement(Button2, { alignSelf: "end", label: "Create New Rule", onClick: onOpen, secondary: true }), open && /* @__PURE__ */ import_react166.default.createElement(Layer, { position: "right", full: !["xsmall", "small"].includes(size) ? "vertical" : true, onEsc: onClose }, /* @__PURE__ */ import_react166.default.createElement(Box, { fill: "vertical", overflow: "auto", width: !["xsmall", "small"].includes(size) ? "large" : void 0, pad: "medium" }, /* @__PURE__ */ import_react166.default.createElement(LayerForm3, { user: user2, setData, setOpen: (value) => setOpen(value) }))));
  };
  var NewRule_default = NewRule;

  // app/javascript/components/module/RulesList.jsx
  var RulesList = (props) => {
    user = props.user;
    var roleids = [];
    if (user) {
      roles = user.roles;
      if (roles) {
        roleids = roles.map(function(rl) {
          return rl["id"];
        });
      }
    }
    const [allData, setData] = (0, import_react167.useState)([]);
    const [select, setSelect] = (0, import_react167.useState)([]);
    const [loading, setLoading] = (0, import_react167.useState)(false);
    const COLUMNS = [
      { property: "id", header: "ID", render: (datum) => /* @__PURE__ */ import_react167.default.createElement("span", null, "RL000", datum.id, " ") },
      { property: "name", header: "Name" },
      { property: "query_string", header: "Query String" },
      { property: "mongo_query", header: "Rule Query" },
      { property: "is_active", header: "Status", render: (datum) => roleids.includes(1) || roleids.includes(3) ? /* @__PURE__ */ import_react167.default.createElement(CheckBox, { checked: datum.is_active, toggle: true, label: datum.is_active == true ? "Active" : "Inactive", onChange: (event) => setChecked(event.target.checked, datum.id) }) : datum.is_active == true ? "Active" : "Inactive" },
      { property: "mdfy_btn", header: "Modify", render: (datum) => /* @__PURE__ */ import_react167.default.createElement(EditRule_default, { user, rule_detail: datum, setData }) },
      { property: "action_btn", header: "Action", render: (datum) => /* @__PURE__ */ import_react167.default.createElement(Button2, { label: "Action", secondary: true }) },
      { property: "notification_btn", header: "Notification", render: (datum) => /* @__PURE__ */ import_react167.default.createElement(Button2, { label: "Notification", secondary: true }) }
    ];
    const options2 = COLUMNS.map(({ header, property }) => ({
      property,
      label: header
    }));
    (0, import_react167.useEffect)(() => {
      fetchData();
    }, []);
    const fetchData = () => {
      let csrf = document.querySelector("meta[name='csrf-token']").getAttribute("content");
      const post_set = {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-CSRF-Token": csrf }
      };
      setLoading(true);
      fetch("api/get_rules_list", post_set).then((response) => response.json()).then((data) => {
        setData(data);
        setLoading(false);
      }).catch((error2) => {
        console.log(error2);
        setLoading(false);
      });
    };
    const setChecked = (status, rid) => {
      let csrf = document.querySelector("meta[name='csrf-token']").getAttribute("content");
      const post_set = {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-CSRF-Token": csrf },
        body: JSON.stringify({ rule_id: rid, status })
      };
      setLoading(true);
      fetch("api/update_rulestatus", post_set).then((response) => response.json()).then((data) => {
        setData(data);
        setLoading(false);
      }).catch((error2) => {
        console.log(error2);
        setLoading(false);
      });
    };
    return /* @__PURE__ */ import_react167.default.createElement(import_react167.default.Fragment, null, (roleids.includes(1) || roleids.includes(3)) && /* @__PURE__ */ import_react167.default.createElement(NewRule_default, { setData }), /* @__PURE__ */ import_react167.default.createElement(Data2, { data: allData, flex: true }, /* @__PURE__ */ import_react167.default.createElement(Box, { overflow: "auto", flex: true }, /* @__PURE__ */ import_react167.default.createElement(DataTable, { columns: COLUMNS }))));
  };

  // app/javascript/components/Home.jsx
  var Home_default = (props) => {
    user = props.user;
    const [index, setIndex] = (0, import_react168.useState)();
    const onActive = (nextIndex) => setIndex(nextIndex);
    const [loading, setLoading] = (0, import_react168.useState)(false);
    const [details, setDetails] = (0, import_react168.useState)([]);
    return /* @__PURE__ */ import_react168.default.createElement("div", { className: "content-list-body p-3" }, /* @__PURE__ */ import_react168.default.createElement("div", { className: "card-list" }, /* @__PURE__ */ import_react168.default.createElement("div", { className: "card-list-head" }, /* @__PURE__ */ import_react168.default.createElement(Tabs, { activeIndex: index, onActive, justify: "start" }, /* @__PURE__ */ import_react168.default.createElement(Tab2, { title: "Rules" }, /* @__PURE__ */ import_react168.default.createElement(Box, { pad: "medium" }, /* @__PURE__ */ import_react168.default.createElement(RulesList, { user }))), /* @__PURE__ */ import_react168.default.createElement(Tab2, { title: "Reports" }, /* @__PURE__ */ import_react168.default.createElement(Box, { pad: "medium" }, /* @__PURE__ */ import_react168.default.createElement("span", null, " Reports ")))))));
  };

  // app/javascript/components/App.jsx
  var App = () => {
    const [user2, setUser] = (0, import_react169.useState)({});
    const [loading, setLoading] = (0, import_react169.useState)(false);
    const url = window.location.href;
    (0, import_react169.useEffect)(() => {
      fetchData();
    }, []);
    const fetchData = () => {
      setLoading(true);
      fetch("api/user_current").then((response) => response.json()).then((data) => {
        setUser(data);
        setLoading(false);
      }).catch((error2) => {
        console.log(error2);
        setLoading(false);
      });
    };
    const size = (0, import_react169.useContext)(ResponsiveContext);
    return /* @__PURE__ */ import_react169.default.createElement(AppContainer, { background: "background-back" }, /* @__PURE__ */ import_react169.default.createElement(ContentArea, null, " ", /* @__PURE__ */ import_react169.default.createElement(Header_default, { app_name: "Rocket", user: user2 })), /* @__PURE__ */ import_react169.default.createElement(Page, null, /* @__PURE__ */ import_react169.default.createElement(PageContent, { className: "card mb-4", style: { height: "860px" }, gap: "large" }, /* @__PURE__ */ import_react169.default.createElement(Home_default, { user: user2 }))), /* @__PURE__ */ import_react169.default.createElement(ContentArea, { className: "footer fixed-bottom" }, /* @__PURE__ */ import_react169.default.createElement(Footer_default, { user: user2 })));
  };

  // app/javascript/components/index.jsx
  document.addEventListener("turbo:load", () => {
    const root = (0, import_client.createRoot)(
      document.body.appendChild(document.createElement("div"))
    );
    root.render(
      /* @__PURE__ */ import_react170.default.createElement(import_react170.default.Fragment, null, /* @__PURE__ */ import_react170.default.createElement(Grommet, { theme: hpe, full: true }, /* @__PURE__ */ import_react170.default.createElement(App, null)))
    );
  });
})();
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

jquery/dist/jquery.js:
  (*!
   * jQuery JavaScript Library v3.6.4
   * https://jquery.com/
   *
   * Includes Sizzle.js
   * https://sizzlejs.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-03-08T15:28Z
   *)

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

react-is/cjs/react-is.development.js:
  (** @license React v17.0.2
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

bootstrap/dist/js/bootstrap.esm.js:
  (*!
    * Bootstrap v5.2.3 (https://getbootstrap.com/)
    * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
    * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
    *)
*/
//# sourceMappingURL=assets/application.js.map
