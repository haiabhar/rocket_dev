import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["width", "showCheckboxes"];
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
import React from "react";
import omit from "lodash/omit";
import TextField from "@mui/material/TextField";
import FormControl from "@mui/material/FormControl";
import Autocomplete, { createFilterOptions } from "@mui/material/Autocomplete";
import CircularProgress from "@mui/material/CircularProgress";
import Chip from "@mui/material/Chip";
import Checkbox from "@mui/material/Checkbox";
import CheckBoxOutlineBlankIcon from "@mui/icons-material/CheckBoxOutlineBlank";
import CheckBoxIcon from "@mui/icons-material/CheckBox";
import { Hooks } from "@react-awesome-query-builder/ui";
var useListValuesAutocomplete = Hooks.useListValuesAutocomplete;
var nonCheckedIcon = /*#__PURE__*/React.createElement(CheckBoxOutlineBlankIcon, {
  fontSize: "small"
});
var checkedIcon = /*#__PURE__*/React.createElement(CheckBoxIcon, {
  fontSize: "small"
});
var defaultFilterOptions = createFilterOptions();
var emptyArray = [];
export default (function (props) {
  var allowCustomValues = props.allowCustomValues,
    multiple = props.multiple,
    selectedValue = props.value,
    customProps = props.customProps,
    readonly = props.readonly,
    config = props.config,
    groupBy = props.groupBy,
    filterOptionsConfig = props.filterOptionsConfig;
  var filterOptionsFn = filterOptionsConfig ? createFilterOptions(filterOptionsConfig) : defaultFilterOptions;

  // hook
  var _useListValuesAutocom = useListValuesAutocomplete(props, {
      debounceTimeout: 100,
      multiple: multiple
    }),
    open = _useListValuesAutocom.open,
    onOpen = _useListValuesAutocom.onOpen,
    onClose = _useListValuesAutocom.onClose,
    onChange = _useListValuesAutocom.onChange,
    onInputChange = _useListValuesAutocom.onInputChange,
    inputValue = _useListValuesAutocom.inputValue,
    options = _useListValuesAutocom.options,
    isInitialLoading = _useListValuesAutocom.isInitialLoading,
    isLoading = _useListValuesAutocom.isLoading,
    aPlaceholder = _useListValuesAutocom.aPlaceholder,
    extendOptions = _useListValuesAutocom.extendOptions,
    getOptionSelected = _useListValuesAutocom.getOptionSelected,
    getOptionDisabled = _useListValuesAutocom.getOptionDisabled,
    getOptionLabel = _useListValuesAutocom.getOptionLabel;

  // setings
  var _config$settings = config.settings,
    defaultSelectWidth = _config$settings.defaultSelectWidth,
    defaultSearchWidth = _config$settings.defaultSearchWidth;
  var _ref = customProps || {},
    width = _ref.width,
    showCheckboxes = _ref.showCheckboxes,
    rest = _objectWithoutProperties(_ref, _excluded);
  var customInputProps = rest.input || {};
  var inputWidth = customInputProps.width || defaultSearchWidth; // todo: use as min-width for Autocomplete comp
  customInputProps = omit(customInputProps, ["width"]);
  var customAutocompleteProps = omit(rest, ["showSearch", "showCheckboxes"]);
  var fullWidth = true;
  var minWidth = width || defaultSelectWidth;
  var style = {
    width: multiple ? undefined : minWidth,
    minWidth: minWidth
  };
  var placeholder = !readonly ? aPlaceholder : "";
  var hasValue = selectedValue != null;
  // should be simple value to prevent re-render!s
  var value = hasValue ? selectedValue : multiple ? emptyArray : null;
  var filterOptions = function filterOptions(options, params) {
    var filtered = filterOptionsFn(options, params);
    var extended = extendOptions(filtered);
    return extended;
  };

  // render
  var renderInput = function renderInput(params) {
    return /*#__PURE__*/React.createElement(TextField, _extends({
      variant: "standard"
    }, params, {
      InputProps: _objectSpread(_objectSpread({}, params.InputProps), {}, {
        readOnly: readonly,
        endAdornment: /*#__PURE__*/React.createElement(React.Fragment, null, isLoading ? /*#__PURE__*/React.createElement(CircularProgress, {
          color: "inherit",
          size: 20
        }) : null, params.InputProps.endAdornment)
      }),
      disabled: readonly,
      placeholder: placeholder
      //onChange={onInputChange}
    }, customInputProps));
  };
  var renderTags = function renderTags(value, getTagProps) {
    return value.map(function (option, index) {
      return /*#__PURE__*/React.createElement(Chip, _extends({
        key: index,
        label: getOptionLabel(option)
      }, getTagProps({
        index: index
      })));
    });
  };
  var isOptionEqualToValue = function isOptionEqualToValue(option, value) {
    return (option === null || option === void 0 ? void 0 : option.value) == value;
  };
  var renderOption = function renderOption(props, option) {
    var title = option.title,
      renderTitle = option.renderTitle,
      value = option.value;
    var selected = (selectedValue || []).includes(value);
    if (option.specialValue) {
      return /*#__PURE__*/React.createElement("div", props, renderTitle || title);
    } else if (multiple && showCheckboxes != false) {
      return /*#__PURE__*/React.createElement("div", props, /*#__PURE__*/React.createElement(Checkbox, {
        icon: nonCheckedIcon,
        checkedIcon: checkedIcon,
        style: {
          marginRight: 8
        },
        checked: selected
      }), title);
    } else {
      return /*#__PURE__*/React.createElement("div", props, renderTitle || title);
    }
  };
  return /*#__PURE__*/React.createElement(FormControl, {
    fullWidth: fullWidth
  }, /*#__PURE__*/React.createElement(Autocomplete, _extends({
    disableCloseOnSelect: multiple,
    fullWidth: fullWidth,
    multiple: multiple,
    style: style,
    freeSolo: allowCustomValues,
    loading: isInitialLoading,
    open: open,
    onOpen: onOpen,
    onClose: onClose,
    inputValue: inputValue,
    onInputChange: onInputChange,
    label: placeholder,
    onChange: onChange,
    value: value,
    disabled: readonly,
    readOnly: readonly,
    options: options,
    groupBy: groupBy,
    getOptionLabel: getOptionLabel,
    getOptionDisabled: getOptionDisabled,
    renderInput: renderInput
    //renderTags={renderTags}
    ,
    renderOption: renderOption,
    filterOptions: filterOptions,
    isOptionEqualToValue: isOptionEqualToValue,
    size: "small"
  }, customAutocompleteProps)));
});